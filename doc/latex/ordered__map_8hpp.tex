\hypertarget{ordered__map_8hpp}{}\doxysection{seq/ordered\+\_\+map.hpp File Reference}
\label{ordered__map_8hpp}\index{seq/ordered\_map.hpp@{seq/ordered\_map.hpp}}
{\ttfamily \#include \char`\"{}sequence.\+hpp\char`\"{}}\newline
{\ttfamily \#include \char`\"{}utils.\+hpp\char`\"{}}\newline
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_sequence_node}{seq\+::detail\+::\+Sequence\+Node$<$ T, Extract $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_hash_equal}{seq\+::detail\+::\+Hash\+Equal$<$ Hash, Equal, Empty\+Hash, Empty\+Equal $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_hash_equal_3_01_hash_00_01_equal_00_01true_00_01true_01_4}{seq\+::detail\+::\+Hash\+Equal$<$ Hash, Equal, true, true $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_hash_equal_3_01_hash_00_01_equal_00_01true_00_01false_01_4}{seq\+::detail\+::\+Hash\+Equal$<$ Hash, Equal, true, false $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_hash_equal_3_01_hash_00_01_equal_00_01false_00_01true_01_4}{seq\+::detail\+::\+Hash\+Equal$<$ Hash, Equal, false, true $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter}{seq\+::detail\+::\+Inserter$<$ Sequence, Loc, Value $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter_3_01_sequence_00_01_back_00_01const_01_value_01_6_01_4}{seq\+::detail\+::\+Inserter$<$ Sequence, Back, const Value \& $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter_3_01_sequence_00_01_front_00_01const_01_value_01_6_01_4}{seq\+::detail\+::\+Inserter$<$ Sequence, Front, const Value \& $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter_3_01_sequence_00_01_anywhere_00_01const_01_value_01_6_01_4}{seq\+::detail\+::\+Inserter$<$ Sequence, Anywhere, const Value \& $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter_3_01_sequence_00_01_back_00_01_value_01_4}{seq\+::detail\+::\+Inserter$<$ Sequence, Back, Value $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter_3_01_sequence_00_01_front_00_01_value_01_4}{seq\+::detail\+::\+Inserter$<$ Sequence, Front, Value $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter_3_01_sequence_00_01_anywhere_00_01_value_01_4}{seq\+::detail\+::\+Inserter$<$ Sequence, Anywhere, Value $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter_3_01_sequence_00_01_back_00_01_value_01_6_6_01_4}{seq\+::detail\+::\+Inserter$<$ Sequence, Back, Value \&\& $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter_3_01_sequence_00_01_front_00_01_value_01_6_6_01_4}{seq\+::detail\+::\+Inserter$<$ Sequence, Front, Value \&\& $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_inserter_3_01_sequence_00_01_anywhere_00_01_value_01_6_6_01_4}{seq\+::detail\+::\+Inserter$<$ Sequence, Anywhere, Value \&\& $>$}}
\item 
struct \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table}{seq\+::detail\+::\+Sparse\+Flat\+Node\+Hash\+Table$<$ Key, Value, Hash, Equal, Allocator, layout $>$}}
\item 
class \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$}}
\begin{DoxyCompactList}\small\item\em Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-\/time complexity. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{seq\+::ordered\+\_\+set$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::const\+\_\+iterator}}
\item 
class \mbox{\hyperlink{classseq_1_1ordered__map}{seq\+::ordered\+\_\+map$<$ Key, T, Hash, Key\+Equal, Allocator, Layout $>$}}
\begin{DoxyCompactList}\small\item\em Associative container that contains key-\/value pairs with unique keys. Search, insertion, and removal of elements have average constant-\/time complexity. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structseq_1_1ordered__map_1_1const__iterator}{seq\+::ordered\+\_\+map$<$ Key, T, Hash, Key\+Equal, Allocator, Layout $>$\+::const\+\_\+iterator}}
\item 
struct \mbox{\hyperlink{structseq_1_1ordered__map_1_1iterator}{seq\+::ordered\+\_\+map$<$ Key, T, Hash, Key\+Equal, Allocator, Layout $>$\+::iterator}}
\end{DoxyCompactItemize}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespaceseq}{seq}}
\item 
 \mbox{\hyperlink{namespaceseq_1_1detail}{seq\+::detail}}
\begin{DoxyCompactList}\small\item\em Returns the number of set bits in {\itshape value}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{namespaceseq_1_1detail_ab30aadadbca04f03a4fbfafab2b975af}{seq\+::detail\+::\+Location}} \{ \mbox{\hyperlink{namespaceseq_1_1detail_ab30aadadbca04f03a4fbfafab2b975afa6ae50c1c523c4d9f711fc5309543056e}{seq\+::detail\+::\+Back}}, 
\mbox{\hyperlink{namespaceseq_1_1detail_ab30aadadbca04f03a4fbfafab2b975afa9ee85222ef4be71557a04ca6e1d9462a}{seq\+::detail\+::\+Front}}, 
\mbox{\hyperlink{namespaceseq_1_1detail_ab30aadadbca04f03a4fbfafab2b975afaf0e0359e700bf7b06a32567d0da335ed}{seq\+::detail\+::\+Anywhere}}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Key , class Hash1 , class Hash2 , class Key\+Equal , class Allocator1 , class Allocator2 , Layout\+Management Layout1, Layout\+Management Layout2$>$ }\\auto \mbox{\hyperlink{namespaceseq_a4308e82af69325da59bf1abe2e9b30d1}{seq\+::operator==}} (const ordered\+\_\+set$<$ Key, Hash1, Key\+Equal, Allocator1, Layout1 $>$ \&lhs, const ordered\+\_\+set$<$ Key, Hash2, Key\+Equal, Allocator2, Layout2 $>$ \&rhs) -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Compare two \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} for equality. Two \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} are considered equal if they contain the same keys. Key ordering is not considered. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Key , class Hash1 , class Hash2 , class Key\+Equal , class Allocator1 , class Allocator2 , Layout\+Management Layout1, Layout\+Management Layout2$>$ }\\auto \mbox{\hyperlink{namespaceseq_a12a8e4ca5bdbbf2cd53645c2733449d0}{seq\+::operator!=}} (const ordered\+\_\+set$<$ Key, Hash1, Key\+Equal, Allocator1, Layout1 $>$ \&lhs, const ordered\+\_\+set$<$ Key, Hash2, Key\+Equal, Allocator2, Layout2 $>$ \&rhs) -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Compare two \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} for inequality, synthesized from operator==. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Key , class Hash1 , class Key\+Equal , class Allocator1 , Layout\+Management Layout1, class Pred $>$ }\\auto \mbox{\hyperlink{namespaceseq_ac8c9030a8049270841c9d1ceb949ed16}{seq\+::erase\+\_\+if}} (ordered\+\_\+set$<$ Key, Hash1, Key\+Equal, Allocator1, Layout1 $>$ \&set, Pred p) -\/$>$ size\+\_\+t
\begin{DoxyCompactList}\small\item\em Erases all elements that satisfy the predicate p from the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Key , class T , class Hash1 , class Hash2 , class Key\+Equal , class Allocator1 , class Allocator2 , Layout\+Management Layout1, Layout\+Management Layout2$>$ }\\auto \mbox{\hyperlink{namespaceseq_a3debed99e1f30055ff02d9d0ee009727}{seq\+::operator==}} (const ordered\+\_\+map$<$ Key, T, Hash1, Key\+Equal, Allocator1, Layout1 $>$ \&lhs, const ordered\+\_\+map$<$ Key, T, Hash2, Key\+Equal, Allocator2, Layout2 $>$ \&rhs) -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Compare two \mbox{\hyperlink{classseq_1_1ordered__map}{ordered\+\_\+map}} for equality. Two \mbox{\hyperlink{classseq_1_1ordered__map}{ordered\+\_\+map}} are considered equal if they contain the same pairs key-\/$>$value. Key ordering is not considered. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Key , class T , class Hash1 , class Hash2 , class Key\+Equal , class Allocator1 , class Allocator2 , Layout\+Management Layout1, Layout\+Management Layout2$>$ }\\auto \mbox{\hyperlink{namespaceseq_ac8a77517d376eeb44fc2615040f226b3}{seq\+::operator!=}} (const ordered\+\_\+map$<$ Key, T, Hash1, Key\+Equal, Allocator1, Layout1 $>$ \&lhs, const ordered\+\_\+map$<$ Key, T, Hash2, Key\+Equal, Allocator2, Layout2 $>$ \&rhs) -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Compare two \mbox{\hyperlink{classseq_1_1ordered__map}{ordered\+\_\+map}} for inequality, synthesized from operator==. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Key , class T , class Hash1 , class Key\+Equal , class Allocator1 , Layout\+Management Layout1, class Pred $>$ }\\auto \mbox{\hyperlink{namespaceseq_a345460864d8e607d34f3547e6d1e01fd}{seq\+::erase\+\_\+if}} (ordered\+\_\+map$<$ Key, T, Hash1, Key\+Equal, Allocator1, Layout1 $>$ \&set, Pred p) -\/$>$ size\+\_\+t
\begin{DoxyCompactList}\small\item\em Erases all elements that satisfy the predicate p from the container. \end{DoxyCompactList}\end{DoxyCompactItemize}
