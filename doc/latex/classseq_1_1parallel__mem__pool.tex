\hypertarget{classseq_1_1parallel__mem__pool}{}\doxysection{seq\+::parallel\+\_\+mem\+\_\+pool$<$ T, Allocator, Align, Lock $>$ Class Template Reference}
\label{classseq_1_1parallel__mem__pool}\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_af41a1fcfa90c32a294676a40fea6c6af}\label{classseq_1_1parallel__mem__pool_af41a1fcfa90c32a294676a40fea6c6af}} 
using {\bfseries value\+\_\+type} = T
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a530188291b401abe6fa368ea31e19dff}\label{classseq_1_1parallel__mem__pool_a530188291b401abe6fa368ea31e19dff}} 
using {\bfseries pointer} = T $\ast$
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_aa4c33454820b03dd6803f33eb9069f77}\label{classseq_1_1parallel__mem__pool_aa4c33454820b03dd6803f33eb9069f77}} 
using {\bfseries const\+\_\+pointer} = const T $\ast$
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_ab2c934082753a1da7fe3a7069752b875}\label{classseq_1_1parallel__mem__pool_ab2c934082753a1da7fe3a7069752b875}} 
using {\bfseries allocator\+\_\+type} = Allocator
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classseq_1_1parallel__mem__pool_ac054e8aafaa1cb40b3e8b8767ef68576}{parallel\+\_\+mem\+\_\+pool}} (const Allocator \&alloc=Allocator()) noexcept
\item 
\mbox{\hyperlink{classseq_1_1parallel__mem__pool_a79a7692243d2d6cc989bd0ed8ed883d3}{$\sim$parallel\+\_\+mem\+\_\+pool}} ()
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_aa4b0886c09ac9dfafc3e329e48f3b5ba}\label{classseq_1_1parallel__mem__pool_aa4b0886c09ac9dfafc3e329e48f3b5ba}} 
{\bfseries parallel\+\_\+mem\+\_\+pool} (const \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{parallel\+\_\+mem\+\_\+pool}} \&)=delete
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a10b9fdf48cdee59e0ffb17f2e059661d}\label{classseq_1_1parallel__mem__pool_a10b9fdf48cdee59e0ffb17f2e059661d}} 
\mbox{\hyperlink{classseq_1_1parallel__mem__pool}{parallel\+\_\+mem\+\_\+pool}} \& {\bfseries operator=} (const \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{parallel\+\_\+mem\+\_\+pool}} \&)=delete
\item 
Allocator \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a5897506fbac2877a0d7831b8a2db81cd}{get\+\_\+allocator}} () const noexcept
\item 
Allocator \& \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a6d0c1077987fd4ec3105b004b9d77f65}{get\+\_\+allocator}} () noexcept
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_ab3e9dad3e0a599fed0a106244f53ecb8}\label{classseq_1_1parallel__mem__pool_ab3e9dad3e0a599fed0a106244f53ecb8}} 
bool {\bfseries reclaim\+\_\+memory} () const
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a42e0da73bcc4776268b8556867866565}\label{classseq_1_1parallel__mem__pool_a42e0da73bcc4776268b8556867866565}} 
bool {\bfseries reclaim\+\_\+memory} (std\+::thread\+::id id) const
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a3b9278a96e69689302a7f98e48fff795}\label{classseq_1_1parallel__mem__pool_a3b9278a96e69689302a7f98e48fff795}} 
bool {\bfseries reclaim\+\_\+memory\+\_\+all} () const noexcept
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_acbf3004c3f7dbabb5eb6143ec9db8ad8}\label{classseq_1_1parallel__mem__pool_acbf3004c3f7dbabb5eb6143ec9db8ad8}} 
void {\bfseries set\+\_\+reclaim\+\_\+memory} (bool reclaim)
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a76ef9f461d63f1b546bb8e632ca61591}\label{classseq_1_1parallel__mem__pool_a76ef9f461d63f1b546bb8e632ca61591}} 
void {\bfseries set\+\_\+reclaim\+\_\+memory} (std\+::thread\+::id id, bool reclaim)
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_ada33875cfe763bbd79fb66f0b746fb1f}\label{classseq_1_1parallel__mem__pool_ada33875cfe763bbd79fb66f0b746fb1f}} 
void {\bfseries set\+\_\+reclaim\+\_\+memory\+\_\+all} (bool reclaim)
\item 
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a9f6462311344c1f8e5c21f1501870c92}{release\+\_\+unused\+\_\+memory}} ()
\item 
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a22902b6938f3d5211de300588fd89e8e}{release\+\_\+unused\+\_\+memory}} (std\+::thread\+::id id)
\item 
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_ae2348c8a4ed0bac93f1089c3d88f540d}{release\+\_\+unused\+\_\+memory\+\_\+all}} ()
\item 
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a59e7108b95a8c18f50386a1daea0f2bc}{clear}} ()
\item 
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_aeea066025942b67b6c7d78a730a724bf}{clear}} (std\+::thread\+::id id)
\item 
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_af1503145dce551f0b7a71dc81831b5de}{clear\+\_\+all}} ()
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_aca54cb063488d8566881334211fcf89c}{capacity}} () const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_ad8d8ccdaba69bec7ed83f480041fc78c}{capacity}} (std\+::thread\+::id id) const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_af52257a65256fe89b732f1bc07a98946}{capacity\+\_\+all}} () const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a0305227505253c15e96bbe725e5ffa72}{objects}} () const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_aa0d83eecd65477d4983930e5ddd4a7ec}{objects}} (std\+::thread\+::id id) const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a95f6ade1fb1bb74857ec8d463567d89a}{objects\+\_\+all}} () const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a7e00fcfb3116603f6237838bf1436f9a}{free\+\_\+count}} () const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a126641a6cbc6c8e16cc60be9eb3429c1}{free\+\_\+count}} (std\+::thread\+::id id) const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a445b0e31342349b479e3690362a8267c}{free\+\_\+count\+\_\+all}} () const
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_afcb87c14ce2797256b652e0183dcc8ba}\label{classseq_1_1parallel__mem__pool_afcb87c14ce2797256b652e0183dcc8ba}} 
void {\bfseries reset\+\_\+statistics} ()
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a830bdbcc696dbcbc69b74d8df40bdaec}\label{classseq_1_1parallel__mem__pool_a830bdbcc696dbcbc69b74d8df40bdaec}} 
void {\bfseries reset\+\_\+statistics} (std\+::thread\+::id id)
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_aa545ea499d33ca4729fc97b4c1978f31}\label{classseq_1_1parallel__mem__pool_aa545ea499d33ca4729fc97b4c1978f31}} 
void {\bfseries reset\+\_\+statistics\+\_\+all} ()
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a0f4d7f08b8bf862e243b56c64e2d9ef4}\label{classseq_1_1parallel__mem__pool_a0f4d7f08b8bf862e243b56c64e2d9ef4}} 
void {\bfseries dump\+\_\+statistics} (\mbox{\hyperlink{structseq_1_1mem__pool__statistics}{mem\+\_\+pool\+\_\+statistics}} \&stats)
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a57d60a74f90dc1799c6cdd09d9cd5ec6}\label{classseq_1_1parallel__mem__pool_a57d60a74f90dc1799c6cdd09d9cd5ec6}} 
void {\bfseries dump\+\_\+statistics} (std\+::thread\+::id id, \mbox{\hyperlink{structseq_1_1mem__pool__statistics}{mem\+\_\+pool\+\_\+statistics}} \&stats)
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a5c1734364c1f81b05439cb331d82c7a5}\label{classseq_1_1parallel__mem__pool_a5c1734364c1f81b05439cb331d82c7a5}} 
void {\bfseries dump\+\_\+statistics\+\_\+all} (\mbox{\hyperlink{structseq_1_1mem__pool__statistics}{mem\+\_\+pool\+\_\+statistics}} \&stats)
\item 
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_ae9f21afe6d0a90c9a3a72cd26033d7e5}{reserve}} (size\+\_\+t count)
\item 
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a08085eb5d2797d7dfa365ef10515de07}{reserve}} (std\+::thread\+::id id, size\+\_\+t count)
\item 
T $\ast$ \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a33dc6a8a1be4bb2615e4e2766be8de01}{allocate}} (size\+\_\+t=1)
\item 
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a2931c917c3ddadd56c82acdb82c3ff4a}{deallocate}} (T $\ast$ptr, size\+\_\+t=1)
\item 
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_af30146618908b94a79c79864d8a97f19}\label{classseq_1_1parallel__mem__pool_af30146618908b94a79c79864d8a97f19}} 
size\+\_\+t {\bfseries memory\+\_\+footprint} () const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_aca8c67ce41c064226271621e810f7538}{memory\+\_\+footprint\+\_\+all}} () const
\item 
virtual size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a98fcaa8b0238973aff1f4c816115319d}{key}} () const noexcept
\item 
virtual void $\ast$ \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a91d4f261692a3a944b35b80d27f75e6b}{allocate\+\_\+one}} (void $\ast$)
\item 
virtual void \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a8360c9fdca62adaf3baf6d0a99f9a29e}{deallocate\+\_\+one}} (void $\ast$ptr)
\end{DoxyCompactItemize}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_ac054e8aafaa1cb40b3e8b8767ef68576}\label{classseq_1_1parallel__mem__pool_ac054e8aafaa1cb40b3e8b8767ef68576}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!parallel\_mem\_pool@{parallel\_mem\_pool}}
\index{parallel\_mem\_pool@{parallel\_mem\_pool}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{parallel\_mem\_pool()}{parallel\_mem\_pool()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
\mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::\mbox{\hyperlink{classseq_1_1parallel__mem__pool}{parallel\+\_\+mem\+\_\+pool}} (\begin{DoxyParamCaption}\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Constructor the \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{parallel\+\_\+mem\+\_\+pool}} using an Allocator object \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a79a7692243d2d6cc989bd0ed8ed883d3}\label{classseq_1_1parallel__mem__pool_a79a7692243d2d6cc989bd0ed8ed883d3}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!````~parallel\_mem\_pool@{$\sim$parallel\_mem\_pool}}
\index{````~parallel\_mem\_pool@{$\sim$parallel\_mem\_pool}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$parallel\_mem\_pool()}{~parallel\_mem\_pool()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
\mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::$\sim$\mbox{\hyperlink{classseq_1_1parallel__mem__pool}{parallel\+\_\+mem\+\_\+pool}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Destructor, free all previously allocated memory. This will invalidate all previously allocated objects. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a33dc6a8a1be4bb2615e4e2766be8de01}\label{classseq_1_1parallel__mem__pool_a33dc6a8a1be4bb2615e4e2766be8de01}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!allocate@{allocate}}
\index{allocate@{allocate}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
T$\ast$ \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::allocate (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{ = {\ttfamily 1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Allocate an uninitialized T object. This operation performs in amortized O(1).

Throws a std\+::bad\+\_\+alloc exception on failure. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a91d4f261692a3a944b35b80d27f75e6b}\label{classseq_1_1parallel__mem__pool_a91d4f261692a3a944b35b80d27f75e6b}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!allocate\_one@{allocate\_one}}
\index{allocate\_one@{allocate\_one}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{allocate\_one()}{allocate\_one()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
virtual void$\ast$ \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::allocate\+\_\+one (\begin{DoxyParamCaption}\item[{void $\ast$}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

internal use only \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_aca54cb063488d8566881334211fcf89c}\label{classseq_1_1parallel__mem__pool_aca54cb063488d8566881334211fcf89c}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!capacity@{capacity}}
\index{capacity@{capacity}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{capacity()}{capacity()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::capacity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the capacity for the calling thread \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_ad8d8ccdaba69bec7ed83f480041fc78c}\label{classseq_1_1parallel__mem__pool_ad8d8ccdaba69bec7ed83f480041fc78c}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!capacity@{capacity}}
\index{capacity@{capacity}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{capacity()}{capacity()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::capacity (\begin{DoxyParamCaption}\item[{std\+::thread\+::id}]{id }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the capacity for given thread id \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_af52257a65256fe89b732f1bc07a98946}\label{classseq_1_1parallel__mem__pool_af52257a65256fe89b732f1bc07a98946}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!capacity\_all@{capacity\_all}}
\index{capacity\_all@{capacity\_all}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{capacity\_all()}{capacity\_all()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::capacity\+\_\+all (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the cumulated capacity for all threads \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a59e7108b95a8c18f50386a1daea0f2bc}\label{classseq_1_1parallel__mem__pool_a59e7108b95a8c18f50386a1daea0f2bc}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!clear@{clear}}
\index{clear@{clear}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Free allocated memory for the calling thread. This will invalidate all allocated objects for this thread. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_aeea066025942b67b6c7d78a730a724bf}\label{classseq_1_1parallel__mem__pool_aeea066025942b67b6c7d78a730a724bf}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!clear@{clear}}
\index{clear@{clear}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::clear (\begin{DoxyParamCaption}\item[{std\+::thread\+::id}]{id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Free allocated memory for given thread id. This will invalidate all allocated objects for this thread. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_af1503145dce551f0b7a71dc81831b5de}\label{classseq_1_1parallel__mem__pool_af1503145dce551f0b7a71dc81831b5de}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!clear\_all@{clear\_all}}
\index{clear\_all@{clear\_all}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{clear\_all()}{clear\_all()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::clear\+\_\+all (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Free allocated memory for all threads. This will invalidate all allocated objects with this \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{parallel\+\_\+mem\+\_\+pool}}. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a2931c917c3ddadd56c82acdb82c3ff4a}\label{classseq_1_1parallel__mem__pool_a2931c917c3ddadd56c82acdb82c3ff4a}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{deallocate()}{deallocate()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::deallocate (\begin{DoxyParamCaption}\item[{T $\ast$}]{ptr,  }\item[{size\+\_\+t}]{ = {\ttfamily 1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Deallocate a single object. The object destructor must be called before calling \mbox{\hyperlink{classseq_1_1parallel__mem__pool_a2931c917c3ddadd56c82acdb82c3ff4a}{parallel\+\_\+mem\+\_\+pool\+::deallocate}}. {\itshape ptr} must have been allocated with this \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{parallel\+\_\+mem\+\_\+pool}}. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a8360c9fdca62adaf3baf6d0a99f9a29e}\label{classseq_1_1parallel__mem__pool_a8360c9fdca62adaf3baf6d0a99f9a29e}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!deallocate\_one@{deallocate\_one}}
\index{deallocate\_one@{deallocate\_one}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{deallocate\_one()}{deallocate\_one()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
virtual void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::deallocate\+\_\+one (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

internal use only \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a7e00fcfb3116603f6237838bf1436f9a}\label{classseq_1_1parallel__mem__pool_a7e00fcfb3116603f6237838bf1436f9a}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!free\_count@{free\_count}}
\index{free\_count@{free\_count}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{free\_count()}{free\_count()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::free\+\_\+count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the number of available free slots for the calling thread \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a126641a6cbc6c8e16cc60be9eb3429c1}\label{classseq_1_1parallel__mem__pool_a126641a6cbc6c8e16cc60be9eb3429c1}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!free\_count@{free\_count}}
\index{free\_count@{free\_count}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{free\_count()}{free\_count()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::free\+\_\+count (\begin{DoxyParamCaption}\item[{std\+::thread\+::id}]{id }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the number of available free slots for given thread id \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a445b0e31342349b479e3690362a8267c}\label{classseq_1_1parallel__mem__pool_a445b0e31342349b479e3690362a8267c}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!free\_count\_all@{free\_count\_all}}
\index{free\_count\_all@{free\_count\_all}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{free\_count\_all()}{free\_count\_all()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::free\+\_\+count\+\_\+all (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the cumulated number of available free slots for all threads \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a5897506fbac2877a0d7831b8a2db81cd}\label{classseq_1_1parallel__mem__pool_a5897506fbac2877a0d7831b8a2db81cd}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
Allocator \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns the underlying allocator \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a6d0c1077987fd4ec3105b004b9d77f65}\label{classseq_1_1parallel__mem__pool_a6d0c1077987fd4ec3105b004b9d77f65}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
Allocator\& \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns the underlying allocator. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a98fcaa8b0238973aff1f4c816115319d}\label{classseq_1_1parallel__mem__pool_a98fcaa8b0238973aff1f4c816115319d}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!key@{key}}
\index{key@{key}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{key()}{key()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
virtual size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::key (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

internal use only \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_aca8c67ce41c064226271621e810f7538}\label{classseq_1_1parallel__mem__pool_aca8c67ce41c064226271621e810f7538}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!memory\_footprint\_all@{memory\_footprint\_all}}
\index{memory\_footprint\_all@{memory\_footprint\_all}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{memory\_footprint\_all()}{memory\_footprint\_all()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::memory\+\_\+footprint\+\_\+all (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the object memory footprint in bytes excluding sizeof($\ast$this). \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a0305227505253c15e96bbe725e5ffa72}\label{classseq_1_1parallel__mem__pool_a0305227505253c15e96bbe725e5ffa72}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!objects@{objects}}
\index{objects@{objects}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{objects()}{objects()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::objects (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the number of allocated objects for the calling thread \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_aa0d83eecd65477d4983930e5ddd4a7ec}\label{classseq_1_1parallel__mem__pool_aa0d83eecd65477d4983930e5ddd4a7ec}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!objects@{objects}}
\index{objects@{objects}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{objects()}{objects()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::objects (\begin{DoxyParamCaption}\item[{std\+::thread\+::id}]{id }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the number of allocated objects for given thread id \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a95f6ade1fb1bb74857ec8d463567d89a}\label{classseq_1_1parallel__mem__pool_a95f6ade1fb1bb74857ec8d463567d89a}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!objects\_all@{objects\_all}}
\index{objects\_all@{objects\_all}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{objects\_all()}{objects\_all()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::objects\+\_\+all (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the cumulated number of allocated objects for all threads \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a9f6462311344c1f8e5c21f1501870c92}\label{classseq_1_1parallel__mem__pool_a9f6462311344c1f8e5c21f1501870c92}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!release\_unused\_memory@{release\_unused\_memory}}
\index{release\_unused\_memory@{release\_unused\_memory}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{release\_unused\_memory()}{release\_unused\_memory()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::release\+\_\+unused\+\_\+memory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Free all unused memory for the calling thread. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a22902b6938f3d5211de300588fd89e8e}\label{classseq_1_1parallel__mem__pool_a22902b6938f3d5211de300588fd89e8e}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!release\_unused\_memory@{release\_unused\_memory}}
\index{release\_unused\_memory@{release\_unused\_memory}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{release\_unused\_memory()}{release\_unused\_memory()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::release\+\_\+unused\+\_\+memory (\begin{DoxyParamCaption}\item[{std\+::thread\+::id}]{id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Free all unused memory for given thread id. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_ae2348c8a4ed0bac93f1089c3d88f540d}\label{classseq_1_1parallel__mem__pool_ae2348c8a4ed0bac93f1089c3d88f540d}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!release\_unused\_memory\_all@{release\_unused\_memory\_all}}
\index{release\_unused\_memory\_all@{release\_unused\_memory\_all}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{release\_unused\_memory\_all()}{release\_unused\_memory\_all()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::release\+\_\+unused\+\_\+memory\+\_\+all (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Free all unused memory for all threads. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_ae9f21afe6d0a90c9a3a72cd26033d7e5}\label{classseq_1_1parallel__mem__pool_ae9f21afe6d0a90c9a3a72cd26033d7e5}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!reserve@{reserve}}
\index{reserve@{reserve}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::reserve (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Extend the \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} object for the calling thread. Does nothing if count $<$= \mbox{\hyperlink{classseq_1_1parallel__mem__pool_aca54cb063488d8566881334211fcf89c}{capacity()}} for the calling thread.

Throws a std\+::bad\+\_\+alloc exception on failure. \mbox{\Hypertarget{classseq_1_1parallel__mem__pool_a08085eb5d2797d7dfa365ef10515de07}\label{classseq_1_1parallel__mem__pool_a08085eb5d2797d7dfa365ef10515de07}} 
\index{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}!reserve@{reserve}}
\index{reserve@{reserve}!seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::parallel\_mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = spinlock$>$ \\
void \mbox{\hyperlink{classseq_1_1parallel__mem__pool}{seq\+::parallel\+\_\+mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::reserve (\begin{DoxyParamCaption}\item[{std\+::thread\+::id}]{id,  }\item[{size\+\_\+t}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Extend the \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} object for the calling thread. Does nothing if count $<$= \mbox{\hyperlink{classseq_1_1parallel__mem__pool_aca54cb063488d8566881334211fcf89c}{capacity()}} for the calling thread.

Throws a std\+::bad\+\_\+alloc exception on failure. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
mem\+\_\+pool.\+hpp\end{DoxyCompactItemize}
