\hypertarget{group__charconv}{}\doxysection{Charconv\+: arithmetic value convertion from/to string}
\label{group__charconv}\index{Charconv: arithmetic value convertion from/to string@{Charconv: arithmetic value convertion from/to string}}


The charconv module provides fast routines to convert numerical values from/to string. This module was initially developped for very fast containers dump in files or strings.  


\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespaceseq}{seq}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The charconv module provides fast routines to convert numerical values from/to string. This module was initially developped for very fast containers dump in files or strings. 

\hypertarget{group__charconv_autotoc_md9}{}\doxysubsubsection{Low level functions}\label{group__charconv_autotoc_md9}
The main functions of charconv module are \mbox{\hyperlink{namespaceseq_a9e1cfb2de75c85497d57702430705b1c}{seq\+::to\+\_\+chars}} and \mbox{\hyperlink{namespaceseq_ac422fc75d3e6f011374ffeed3683da55}{seq\+::from\+\_\+chars}} which provide a similar interface to C++17 functions std\+::from\+\_\+chars and std\+::to\+\_\+chars. They aim to provide a faster alternative to C++ streams for converting floating point and integer types from/to string. Note that they were developped to accomodate my needs, and might not be used in all circumstances.

\mbox{\hyperlink{namespaceseq_ac422fc75d3e6f011374ffeed3683da55}{seq\+::from\+\_\+chars()}} is similar to std\+::from\+\_\+chars with the following differences\+:
\begin{DoxyItemize}
\item Leading spaces are consumed.
\item For integral types, a leading \textquotesingle{}0x\textquotesingle{} prefix is considered valid.
\item For floating point values\+: if the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-\/)inf or (+-\/)0, and the full pattern will be consumed. Therefore, std\+::errc\+::result\+\_\+out\+\_\+of\+\_\+range is never returned.
\item Leading \textquotesingle{}+\textquotesingle{} sign is considered valid.
\item Custom \textquotesingle{}dot\textquotesingle{} character can be passed as argument.
\item For floating point values\+: this function IS N\+OT AN E\+X\+A\+CT P\+A\+R\+S\+ER. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100\% perfect exactitude.
\end{DoxyItemize}

\mbox{\hyperlink{namespaceseq_a9e1cfb2de75c85497d57702430705b1c}{seq\+::to\+\_\+chars}} is similar to std\+::to\+\_\+chars with the following differences
\begin{DoxyItemize}
\item For integral types, additional options on the form of a \mbox{\hyperlink{structseq_1_1integral__chars__format}{seq\+::integral\+\_\+chars\+\_\+format}} object can be passed. They add the possibility to output a leading \textquotesingle{}0x\textquotesingle{} for hexadecimal formatting, a minimum width (with zeros padding), upper case outputs for hexadecimal formatting.
\item For floating point values, the \textquotesingle{}dot\textquotesingle{} character can be specified.
\item For floating point values, this function is N\+OT AN E\+X\+A\+CT F\+O\+R\+M\+A\+T\+T\+ER. There are currently a lot of different algorithms to provide fast convertion of floating point values to strings with round-\/trip guarantees\+: ryu, grisu-\/exact, dragonbox... This function tries to provide a faster and lighter alternative when perfect round-\/trip is not a requirement (which is my case). When converting double values, obtained strings are similar to the result of printf in 100\% of the cases when the required precision is below 12. After that, the ratio decreases to 86\% of exactitude for a precision of 17. Converting a very high (or very small) value with the \textquotesingle{}f\textquotesingle{} specifier will usually produce slightly different output, especially in the \char`\"{}garbage\char`\"{} digits.
\end{DoxyItemize}\hypertarget{group__charconv_autotoc_md10}{}\doxysubsubsection{Working with C++ streams}\label{group__charconv_autotoc_md10}
To write numerical values to C++ std\+::ostream objects, see the \mbox{\hyperlink{group__format}{format}} module.

To read numerical values from std\+::istream object, the charconv module provides the stream adapter \mbox{\hyperlink{classseq_1_1std__input__stream}{seq\+::std\+\_\+input\+\_\+stream}}. It was developped to read huge tables or matrices from ascii files or strings.

Basic usage\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::ifstream fin(\textcolor{stringliteral}{"my\_huge\_file.txt"});}
\DoxyCodeLine{\mbox{\hyperlink{classseq_1_1std__input__stream}{seq::std\_input\_stream<>}} istream(fin);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Read trailing lines}}
\DoxyCodeLine{std::string trailer;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceseq_add85486f09f54fba24d5f3cc4737474c}{seq::read\_line\_from\_stream}}(istream, trailer);}
\DoxyCodeLine{\textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Read words}}
\DoxyCodeLine{std::string word;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceseq_ade167dcc6d29b420964a6be1498889ac}{seq::from\_stream}}(istream, word);}
\DoxyCodeLine{\textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Read all numeric values into a vector}}
\DoxyCodeLine{std::vector<double> vec;}
\DoxyCodeLine{\textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{}
\DoxyCodeLine{    \textcolor{keywordtype}{double} v;}
\DoxyCodeLine{    \mbox{\hyperlink{namespaceseq_ade167dcc6d29b420964a6be1498889ac}{seq::from\_stream}}(istream, v);}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (istream)}
\DoxyCodeLine{        vec.push\_back(v);}
\DoxyCodeLine{    \textcolor{keywordflow}{else}}
\DoxyCodeLine{        \textcolor{keywordflow}{break};}
\DoxyCodeLine{\}}
\end{DoxyCode}


Internal benchmarks show that using \mbox{\hyperlink{namespaceseq_ac2d0cf3592690ba5924d6eb3f5cf48a8}{from\+\_\+stream()}} is around 20 faster (or more) than using \mbox{\hyperlink{namespaceseq_a7083aa58832400e4ec4cd4baaf5b39d0}{std\+::istream\+::operator$>$$>$()}} when reading floating point values from a huge string.

In additional to \mbox{\hyperlink{classseq_1_1std__input__stream}{seq\+::std\+\_\+input\+\_\+stream}}, charconv module provides the similar \mbox{\hyperlink{classseq_1_1buffer__input__stream}{seq\+::buffer\+\_\+input\+\_\+stream}} and \mbox{\hyperlink{classseq_1_1file__input__stream}{seq\+::file\+\_\+input\+\_\+stream}}. 