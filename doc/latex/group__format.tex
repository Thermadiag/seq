\hypertarget{group__format}{}\doxysection{Format\+: Type safe formatting module}
\label{group__format}\index{Format: Type safe formatting module@{Format: Type safe formatting module}}


The format module provides fast routines for object formatting to string/streams. It is strongly typed and does not rely on string parsing to find the output format. Therefore, almost all possible formatting errors are detected at compilation instead of runtime.  


\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespaceseq}{seq}}
\item 
 \mbox{\hyperlink{namespacestd}{std}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The format module provides fast routines for object formatting to string/streams. It is strongly typed and does not rely on string parsing to find the output format. Therefore, almost all possible formatting errors are detected at compilation instead of runtime. 

There are already several great C++ formatting libraries available in \href{https://abseil.io/}{\texttt{ Abseil}}, \href{https://github.com/facebook/folly}{\texttt{ Folly}} or the \href{https://fmt.dev/latest/index.html}{\texttt{ fmt}} library. Furtheremore, C++20 will provide a new text formatting library similar to the \{fmt\} one. The format module is an attempt to provide (yet) another formatting library which does not rely on string parsing, is compatible with c++ streams and is {\bfseries{fast}}.

It was designed first to output huge matrices or tables to files and strings. Format module is based on the \mbox{\hyperlink{group__charconv}{charconv}} module to format numerical values.\hypertarget{group__format_autotoc_md18}{}\doxysubsubsection{Formatting single values}\label{group__format_autotoc_md18}
Format module heavily relies on the \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq\+::fmt}} function to format single or several values.

When formatting a single value, \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq\+::fmt}} returns a \mbox{\hyperlink{classseq_1_1ostream__format}{seq\+::ostream\+\_\+format}} object providing several members to modify the formatting options\+:
\begin{DoxyItemize}
\item {\bfseries{base(int)}}\+: specify the base for integral types, similar to b(int)
\item {\bfseries{format(char)}}\+: specify the format (\textquotesingle{}e\textquotesingle{}, \textquotesingle{}E\textquotesingle{}, \textquotesingle{}g\textquotesingle{}, \textquotesingle{}G\textquotesingle{}, \textquotesingle{}f\textquotesingle{}) for floating point types, similar to t(char)
\item {\bfseries{precision(int)}}\+: specify the maximum precision for floating point types, similar to p(int)
\item {\bfseries{dot(char)}}\+: specify the dot character for floating point types, similar to d(char)
\item {\bfseries{hex\+\_\+prefix()}}\+: add trailing \textquotesingle{}0x\textquotesingle{} for hexadecimal format, similar to h()
\item {\bfseries{upper()}}\+: output hexadecimal value in upper case, similar to u()
\item {\bfseries{as\+\_\+char()}}\+: output integral value as an ascii character, similar to c()
\item {\bfseries{left(int)}}\+: align output to the left for given width, similar to l(int)
\item {\bfseries{right(int)}}\+: align output to the right for given width, similar to r(int)
\item {\bfseries{center(int)}}\+: center output for given width, similar to c(int)
\item {\bfseries{fill(char)}}\+: specify the filling character used for aligned output (default to space character), similar to f(char)
\end{DoxyItemize}

Usage\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Usage for formatting one value}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespaceseq}{seq}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265358979323846;}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(PI) << std::endl;                                      \textcolor{comment}{//default double formatting}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(PI,\textcolor{charliteral}{'E'}) << std::endl;                                  \textcolor{comment}{//scientific notation, equivalent to fmt(PI).format('E') or fmt(PI).t('E')}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(PI,\textcolor{charliteral}{'E'}).precision(12) << std::endl;                    \textcolor{comment}{//scientific notation with maximum precision, equivalent to fmt(PI).t('E').precision(12) or fmt(PI).t('E').p(12)}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(PI).dot(\textcolor{charliteral}{','}) << std::endl;                             \textcolor{comment}{//change dot, equivalent to fmt(PI).d(',')}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(PI).right(10).fill(\textcolor{charliteral}{'-\/'}) << std::endl;                  \textcolor{comment}{//align to the right and pad with '-\/', equivalent to fmt(PI).r(10).f('-\/')}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(PI).left(10).fill(\textcolor{charliteral}{'-\/'}) << std::endl;                   \textcolor{comment}{//align to the left and pad with '-\/', equivalent to fmt(PI).l(10).f('-\/')}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(PI).center(10).fill(\textcolor{charliteral}{'-\/'}) << std::endl;                 \textcolor{comment}{//align to the center and pad with '-\/', equivalent to fmt(PI).c(10).f('-\/')}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(123456).base(16).hex\_prefix().upper() << std::endl;    \textcolor{comment}{//hexadecimal upper case with '0x' prefix. equivalent to fmt(123456).b(16).h().u() or hex(123456).h().u()}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\textcolor{stringliteral}{"hello"}).c(10).f(\textcolor{charliteral}{'*'}) << std::endl;                    \textcolor{comment}{//center string and pad with '*', equivalent to fmt("hello").center(10).fill('*')}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\textcolor{stringliteral}{"hello"}).c(3) << std::endl;                            \textcolor{comment}{//center and truncate string}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Direct string conversion}}
\DoxyCodeLine{std::string \mbox{\hyperlink{namespaceseq_1_1detail_a84d714603751dddb280584583ccdd7e3}{str}} = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(PI);}
\DoxyCodeLine{\textcolor{comment}{// Direct string conversion using .str()}}
\DoxyCodeLine{std::string str2 = \textcolor{stringliteral}{"PI value is "} + \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(PI).str();}
\DoxyCodeLine{std::cout << str2 << std::endl;}
\end{DoxyCode}


The format module provides additional convenient functions to shorten the syntax even more\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespaceseq}{seq}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Convenient shortcut functions}}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << ch(\textcolor{charliteral}{'u'}) << std::endl;  \textcolor{comment}{//equivalent to fmt('u').as\_char() or fmt('u').c()}}
\DoxyCodeLine{std::cout << e(1.2) << std::endl;   \textcolor{comment}{//equivalent to fmt(1.2,'e') or fmt(1.2).format('e') or fmt(1.2).t('e')}}
\DoxyCodeLine{std::cout << E(1.2) << std::endl;   \textcolor{comment}{//equivalent to fmt(1.2,'E') or fmt(1.2).format('E') or fmt(1.2).t('E')}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}}(1.2) << std::endl;   \textcolor{comment}{//equivalent to fmt(1.2,'f') or fmt(1.2).format('f') or fmt(1.2).t('f')}}
\DoxyCodeLine{std::cout << F(1.2) << std::endl;   \textcolor{comment}{//equivalent to fmt(1.2,'F') or fmt(1.2).format('F') or fmt(1.2).t('F')}}
\DoxyCodeLine{std::cout << g(1.2) << std::endl;   \textcolor{comment}{//equivalent to fmt(1.2,'g') or fmt(1.2).format('g') or fmt(1.2).t('g')}}
\DoxyCodeLine{std::cout << G(1.2) << std::endl;   \textcolor{comment}{//equivalent to fmt(1.2,'G') or fmt(1.2).format('G') or fmt(1.2).t('G')}}
\DoxyCodeLine{std::cout << hex(100) << std::endl; \textcolor{comment}{//equivalent to fmt(100).base(16) or fmt(100).b(16)}}
\DoxyCodeLine{std::cout << oct(100) << std::endl; \textcolor{comment}{//equivalent to fmt(100).base(8) or fmt(100).b(8)}}
\DoxyCodeLine{std::cout << bin(100) << std::endl; \textcolor{comment}{//equivalent to fmt(100).base(2) or fmt(100).b(2)}}
\end{DoxyCode}


\mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq\+::fmt}} calls can also be nested\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespaceseq}{seq}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Nested formatting}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\textcolor{stringliteral}{"surrounded text"})).c(20).\mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}}(\textcolor{charliteral}{'*'})).c(30).\mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}}(\textcolor{charliteral}{'\#'})).c(40).f(\textcolor{charliteral}{'-\/'}) << std::endl;}
\end{DoxyCode}
\hypertarget{group__format_autotoc_md19}{}\doxysubsubsection{Formatting several values}\label{group__format_autotoc_md19}
The \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq\+::fmt}} function can be used to format any number of values at once\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Formatting multiple values}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Direct stream}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\textcolor{stringliteral}{"The answer is "}, 43,\textcolor{stringliteral}{" ..."}) << std::endl;}
\DoxyCodeLine{\textcolor{comment}{// Direct stream with nested formatting}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\textcolor{stringliteral}{"...Or it could be"}, \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(43.3,\textcolor{charliteral}{'e'}).c(10) ) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Reuse a formatting object built without arguments}}
\DoxyCodeLine{\textcolor{keyword}{auto} \mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}} = fmt<int, tstring\_view, double, tstring\_view, double>();}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}}(1, \textcolor{stringliteral}{" + "}, 2.2, \textcolor{stringliteral}{" = "}, 3.2) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Reuse a formatting object and use seq::null to only update some arguments}}
\DoxyCodeLine{\textcolor{keyword}{auto} f2 = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\textcolor{keywordtype}{int}(), \textcolor{stringliteral}{" + "}, fmt<double>().format(\textcolor{charliteral}{'g'}), \textcolor{stringliteral}{" = "}, fmt<double>().format(\textcolor{charliteral}{'e'}));}
\DoxyCodeLine{std::cout << f2(1, \textcolor{keyword}{null}, 2.2, \textcolor{keyword}{null}, 3.2) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Convert to string or tstring}}
\DoxyCodeLine{std::string s1 = f2(1, \textcolor{keyword}{null}, 2.2, \textcolor{keyword}{null}, 3.2);   \textcolor{comment}{//equivalent to s1 = f2(1, null, 2.2, null, 3.2).str();}}
\DoxyCodeLine{\mbox{\hyperlink{namespaceseq_a8d9a01a2c5a12df6d4baac1d1520d4b5}{tstring}} s2 = f2(1, \textcolor{keyword}{null}, 2.2, \textcolor{keyword}{null}, 3.2);       \textcolor{comment}{//equivalent to s2 = f2(1, null, 2.2, null, 3.2).str<tstring>();}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Append to string}}
\DoxyCodeLine{s2 += \textcolor{stringliteral}{", repeat-\/> "};}
\DoxyCodeLine{f2(1, \textcolor{keyword}{null}, 2.2, \textcolor{keyword}{null}, 3.2).append(s2);         \textcolor{comment}{// append formatted result to s2}}
\DoxyCodeLine{std::cout << s2 <<std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Modify formatting object using get() and/or set()}}
\DoxyCodeLine{f2.set<0>(fmt<int>().base(16).h().u()); \textcolor{comment}{// reset the formatting object at position 0}}
\DoxyCodeLine{f2.get<2>().format(\textcolor{charliteral}{'e'});                \textcolor{comment}{// modifiy the formatting object at position 2}}
\DoxyCodeLine{std::cout << f2(1, \textcolor{keyword}{null}, 2.2, \textcolor{keyword}{null}, 3.2) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Use positional argument}}
\DoxyCodeLine{std::cout << f2(pos<0, 2, 4>(), 1, 2.2, 3.2) << std::endl; \textcolor{comment}{// provided arguments are used for positions 0, 2 and 4}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Positional directly in the fmt call}}
\DoxyCodeLine{\textcolor{keyword}{auto} f3 = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(pos<0, 2, 4>(), \textcolor{keywordtype}{int}(), \textcolor{stringliteral}{" + "}, seq::g<double>(), \textcolor{stringliteral}{" = "}, seq::e<double>());}
\DoxyCodeLine{std::cout << f3(1, 2.2, 3.2) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Building tables}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// header/trailer format, 2 columns of width 20 centered, separated by a '|'}}
\DoxyCodeLine{\textcolor{keyword}{auto} header = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(pos<1, 3>(),\textcolor{stringliteral}{"|"}, seq::str().c(20), \textcolor{stringliteral}{"|"}, seq::str().c(20), \textcolor{stringliteral}{"|"});}
\DoxyCodeLine{\textcolor{comment}{//line format, 2 columns of width 20 centered, separated by a '|'}}
\DoxyCodeLine{\textcolor{keyword}{auto} line = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(pos<1, 3>(),\textcolor{stringliteral}{"|"}, seq::fmt<double>().c(20), \textcolor{stringliteral}{"|"}, seq::fmt<double>().c(20), \textcolor{stringliteral}{"|"});}
\DoxyCodeLine{\textcolor{comment}{// write table}}
\DoxyCodeLine{std::cout << header( \textcolor{stringliteral}{"Header 1"}, \textcolor{stringliteral}{"Header 2"}) << std::endl;}
\DoxyCodeLine{std::cout << line( 1.1, 2.2) << std::endl;}
\DoxyCodeLine{std::cout << line( 3.3, 4.4) << std::endl;}
\DoxyCodeLine{std::cout << header( \textcolor{stringliteral}{"Trailer 1"}, \textcolor{stringliteral}{"Trailer 2"}) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << std::endl;}
\end{DoxyCode}
\hypertarget{group__format_autotoc_md20}{}\doxysubsubsection{Formatting to string or buffer}\label{group__format_autotoc_md20}
A formatting object can be\+:
\begin{DoxyItemize}
\item Printed to a std\+::ostream object
\item Converted to a string object
\item Added to an existing string object
\item Writed to a buffer
\end{DoxyItemize}

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Print to std::cout}}
\DoxyCodeLine{std::cout<< \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(1.123456789,\textcolor{charliteral}{'g'}) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Convert to string}}
\DoxyCodeLine{std::string \mbox{\hyperlink{namespaceseq_1_1detail_a84d714603751dddb280584583ccdd7e3}{str}} = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(1.123456789,\textcolor{charliteral}{'g'}).str<std::string>();}
\DoxyCodeLine{std::cout<< \mbox{\hyperlink{namespaceseq_1_1detail_a84d714603751dddb280584583ccdd7e3}{str}} << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Append to an existing string}}
\DoxyCodeLine{std::string str2;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(1.123456789,\textcolor{charliteral}{'g'}).append(str2);}
\DoxyCodeLine{std::cout<< str2 << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// write to buffer (to\_chars(char*) returns past-\/the-\/end pointer)}}
\DoxyCodeLine{\textcolor{keywordtype}{char} dst[100];}
\DoxyCodeLine{*\mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(1.123456789,\textcolor{charliteral}{'g'}).to\_chars(dst) = 0;}
\DoxyCodeLine{std::cout<< dst << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// write to buffer with maximum size (to\_chars(char*,size\_t) returns a pair of past-\/the-\/end pointer and size without truncation)}}
\DoxyCodeLine{\textcolor{keywordtype}{char} dst2[100];}
\DoxyCodeLine{*\mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(1.123456789,\textcolor{charliteral}{'g'}).to\_chars(dst2, \textcolor{keyword}{sizeof}(dst2)).first = 0;}
\DoxyCodeLine{std::cout<< dst2 << std::endl;}
\end{DoxyCode}
\hypertarget{group__format_autotoc_md21}{}\doxysubsubsection{Using std\+::to\+\_\+chars}\label{group__format_autotoc_md21}
It is possible to use std\+::to\+\_\+chars instead of \mbox{\hyperlink{namespaceseq_a9e1cfb2de75c85497d57702430705b1c}{seq\+::to\+\_\+chars}} within the format module, mostly when exact round-\/trip guarantee is mandatory. For that, you must define S\+E\+Q\+\_\+\+F\+O\+R\+M\+A\+T\+\_\+\+U\+S\+E\+\_\+\+S\+T\+D\+\_\+\+T\+O\+\_\+\+C\+H\+A\+RS and enable C++17. If C++17 is not supported by the compiler, the format module will always fallback to \mbox{\hyperlink{namespaceseq_a9e1cfb2de75c85497d57702430705b1c}{seq\+::to\+\_\+chars}}.\hypertarget{group__format_autotoc_md22}{}\doxysubsubsection{Working with custom types}\label{group__format_autotoc_md22}
By default, the format library supports arithmetic types and string types. Not that std\+::string, \mbox{\hyperlink{namespaceseq_a8d9a01a2c5a12df6d4baac1d1520d4b5}{seq\+::tstring}} or const char$\ast$ arguments are represented internally as string views (tstring\+\_\+view class). The format module is extendible to custom types by 2 means\+:
\begin{DoxyItemize}
\item If the type is streamable to std\+::ostream, it will directly work with \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq\+::fmt}} using internally a (slow) std\+::ostringstream.
\item Otherwise, you need to specialize \mbox{\hyperlink{classseq_1_1ostream__format}{seq\+::ostream\+\_\+format}} for your type.
\end{DoxyItemize}

Example of custom type formatting\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{format_8hpp}{format.hpp}}"}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceseq}{seq}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{comment}{// Specialization of ostream\_format for std::pair<T,T>}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{    \textcolor{keyword}{class }ostream\_format<\mbox{\hyperlink{namespacestd}{std}}::pair<T, T> >: \textcolor{keyword}{public} base\_ostream\_format<std::pair<T, T> , ostream\_format<std::pair<T, T> > >}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keyword}{using} base\_type = base\_ostream\_format<std::pair<T, T>, ostream\_format<std::pair<T, T> > >;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{public}:}
\DoxyCodeLine{}
\DoxyCodeLine{        \mbox{\hyperlink{classseq_1_1ostream__format_a3eb7536572cddbefdbb8844bb64cafe4}{ostream\_format}}() : base\_type() \{\}}
\DoxyCodeLine{        \mbox{\hyperlink{classseq_1_1ostream__format_a3eb7536572cddbefdbb8844bb64cafe4}{ostream\_format}}(\textcolor{keyword}{const} std::pair<T, T>\& v) : base\_type(v) \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// The specialization must provide this member:}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{classseq_1_1ostream__format_a3c30d958ce8fb82d6509acc7e23f2648}{to\_string}}(std::string \& out)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{        }\{}
\DoxyCodeLine{            \textcolor{keywordtype}{size\_t} prev = out.size();}
\DoxyCodeLine{}
\DoxyCodeLine{            out.append(\textcolor{stringliteral}{"("});}
\DoxyCodeLine{            \textcolor{comment}{// Format the first member of the pair using the internal numeric format}}
\DoxyCodeLine{            ostream\_format<T>(this-\/>\mbox{\hyperlink{structseq_1_1base__ostream__format_ad75f4918a30f9643a0b66c0100d00293}{value}}().\mbox{\hyperlink{namespaceseq_1_1detail_a4abc955e0a77f9f1a5d4b9fa147745e1}{first}}, this-\/>\mbox{\hyperlink{structseq_1_1base__ostream__format_a05fa37e912fb5660b236f31689935ad5}{numeric\_fmt}}()).append(out);}
\DoxyCodeLine{            out.append(\textcolor{stringliteral}{", "});}
\DoxyCodeLine{            \textcolor{comment}{// Format the second member of the pair using the internal numeric format}}
\DoxyCodeLine{            ostream\_format<T>(this-\/>\mbox{\hyperlink{structseq_1_1base__ostream__format_ad75f4918a30f9643a0b66c0100d00293}{value}}().second, this-\/>\mbox{\hyperlink{structseq_1_1base__ostream__format_a05fa37e912fb5660b236f31689935ad5}{numeric\_fmt}}()).append(out);}
\DoxyCodeLine{            out.append(\textcolor{stringliteral}{")"});}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordflow}{return} out.size() -\/ prev;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} ** argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{using namespace }\mbox{\hyperlink{namespaceseq}{seq}};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Formatting custom types}}
\DoxyCodeLine{    std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\textcolor{stringliteral}{"Print a pair of float: "}, std::make\_pair(1.2f, 3.4f)) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Formatting custom types with custom format}}
\DoxyCodeLine{    std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\textcolor{stringliteral}{"Print a pair of double: "}, \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(std::make\_pair(1.2, 3.4)).format(\textcolor{charliteral}{'e'})) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Formatting custom types with custom format and alignment}}
\DoxyCodeLine{    std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(\textcolor{stringliteral}{"Print a pair of double centered: "}, \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(std::make\_pair(1.2, 3.4)).t(\textcolor{charliteral}{'e'}).c(30).\mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}}(\textcolor{charliteral}{'*'})) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


For arithmetic types, a \mbox{\hyperlink{classseq_1_1ostream__format}{seq\+::ostream\+\_\+format}} internally stores a copy of the value passed as argument of \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq\+::fmt}}. Therefore, the ostream\+\_\+format object can be stored and formatted afterward. However, for custom types as well as strings, it is unsafe to store a ostream\+\_\+format object and format it afterward as it internally stores a {\itshape pointer} to the actual data.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Format arithmetic type}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} \mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}} = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(1.2);}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}} << std::endl;        \textcolor{comment}{// Safe: the ostream\_format stores a plain double value}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Format string type}}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(\textcolor{stringliteral}{"format a string"})<< std::endl;                   \textcolor{comment}{// Safe: lifetime of string literals is the lifetime of the program}}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(std::string(\textcolor{stringliteral}{"format a string"})) << std::endl;     \textcolor{comment}{// Safe: the temporay string is valid when the actual formatting occurs}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} f2 = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(std::string(\textcolor{stringliteral}{"format a string"}));}
\DoxyCodeLine{std::cout << f2(std::string(\textcolor{stringliteral}{"another string"})) <<std::endl;     \textcolor{comment}{//Safe: the first string is replace by a new temporary one}}
\DoxyCodeLine{std::cout << f2 << std::endl;                                   \textcolor{comment}{//UNSAFE: attempt to format the temporay std::string holding "another string" which was already destroyed}}
\end{DoxyCode}
\hypertarget{group__format_autotoc_md23}{}\doxysubsubsection{Thread safety}\label{group__format_autotoc_md23}
The format module is thread safe\+: formatting objects in different threads is allowed, as the format module only uses (few) global variables with the {\itshape thread\+\_\+local} specifier. However, a formatting object returned by \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq\+::fmt}} is not thread safe and you must pass copies of this object to other threads.\hypertarget{group__format_autotoc_md24}{}\doxysubsubsection{Performances}\label{group__format_autotoc_md24}
The format module is relatively fast compared to C++ streams, mainly thanks to the \mbox{\hyperlink{group__charconv}{charconv}} module. Usually, using \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq\+::fmt}} to output arithmetic values to streams should be around 8 times faster than directly writing the values to a std\+::ostream object. This will, of course, vary greatly depending on the considered scenario.

The following code is a simple benchmark on writing a 4 $\ast$ 1000000 table of double values to a std\+::ostream object.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{testing_8hpp}{testing.hpp}}"}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{format_8hpp}{format.hpp}}"}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} ** argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{using namespace }\mbox{\hyperlink{namespaceseq}{seq}};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Generate 4M double values}}
\DoxyCodeLine{    \textcolor{keyword}{using} float\_type = double;}
\DoxyCodeLine{    \mbox{\hyperlink{classseq_1_1random__float__genertor}{random\_float\_genertor<float\_type>}} rgn;}
\DoxyCodeLine{    std::vector<float\_type> vec\_d;}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4000000; ++i)}
\DoxyCodeLine{        vec\_d.push\_back(rgn());}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Null ostream object}}
\DoxyCodeLine{    \mbox{\hyperlink{structseq_1_1basic__nullbuf}{nullbuf}} \mbox{\hyperlink{namespaceseq_1_1detail_a12c9a7db6862be66b508b7cc80e12a2d}{n}};}
\DoxyCodeLine{    std::ostream oss(\&\mbox{\hyperlink{namespaceseq_1_1detail_a12c9a7db6862be66b508b7cc80e12a2d}{n}});}
\DoxyCodeLine{    oss.sync\_with\_stdio(\textcolor{keyword}{false});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Build a table of 4 * 1000000 double values separated by a '|'. All values are centered on a 20 characters space}}
\DoxyCodeLine{    \mbox{\hyperlink{namespaceseq_ad863fcfc143b646f5a2f2362a1327575}{tick}}();}
\DoxyCodeLine{    oss << std::setprecision(6);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < vec\_d.size()/4; ++i)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        oss << std::left << std::setw(20) << vec\_d[i * 4] << \textcolor{stringliteral}{"|"};}
\DoxyCodeLine{        oss << std::left << std::setw(20) << vec\_d[i * 4+1] << \textcolor{stringliteral}{"|"};}
\DoxyCodeLine{        oss << std::left << std::setw(20) << vec\_d[i * 4+2] << \textcolor{stringliteral}{"|"};}
\DoxyCodeLine{        oss << std::left << std::setw(20) << vec\_d[i * 4+3] << \textcolor{stringliteral}{"|"};}
\DoxyCodeLine{        oss << std::endl;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordtype}{int} el = \mbox{\hyperlink{namespaceseq_a576ae74a514ded550299e48e4c32cc64}{tock\_ms}}();}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Write table with streams: "} <<el<<\textcolor{stringliteral}{" ms"}<< std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Build the same table with format module}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Create the format object}}
\DoxyCodeLine{    \textcolor{keyword}{auto} \mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}} = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{fmt}}(pos<0, 2, 4, 6>(), g<float\_type>().p(6).c(20), \textcolor{stringliteral}{"|"}, g<float\_type>().p(6).c(20), \textcolor{stringliteral}{"|"}, g<float\_type>().p(6).c(20), \textcolor{stringliteral}{"|"}, g<float\_type>().p(6).c(20), \textcolor{stringliteral}{"|"});}
\DoxyCodeLine{    \mbox{\hyperlink{namespaceseq_ad863fcfc143b646f5a2f2362a1327575}{tick}}();}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < vec\_d.size() / 4; ++i)}
\DoxyCodeLine{        oss << \mbox{\hyperlink{namespaceseq_1_1detail_a76fa776653402382e316c7b6715856af}{f}}(vec\_d[i * 4], vec\_d[i * 4+1], vec\_d[i * 4+2], vec\_d[i * 4+3]) << std::endl;}
\DoxyCodeLine{    el = \mbox{\hyperlink{namespaceseq_a576ae74a514ded550299e48e4c32cc64}{tock\_ms}}();}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Write table with seq formatting module: "} << el << \textcolor{stringliteral}{" ms"} << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Use std::format}}
\DoxyCodeLine{    \textcolor{comment}{// tick();}}
\DoxyCodeLine{    \textcolor{comment}{// for (size\_t i = 0; i < vec\_d.size() / 4; ++i)}}
\DoxyCodeLine{    \textcolor{comment}{//  std::format\_to(std::ostreambuf\_iterator<char>(oss), "\{:\string^20.6g\} | \{:\string^20.6g\} | \{:\string^20.6g\} | \{:\string^20.6g\}\(\backslash\)n", vec\_d[i * 4], vec\_d[i * 4 + 1], vec\_d[i * 4 + 2], vec\_d[i * 4 + 3]);}}
\DoxyCodeLine{    \textcolor{comment}{// el = tock\_ms();}}
\DoxyCodeLine{    \textcolor{comment}{// std::cout << "Write table with std::format : " << el << " ms" << std::endl;}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Just for comparison, directly dump the double values without the '|' character (but keeping centering)}}
\DoxyCodeLine{}
\DoxyCodeLine{    \mbox{\hyperlink{namespaceseq_ad863fcfc143b646f5a2f2362a1327575}{tick}}();}
\DoxyCodeLine{    \textcolor{keyword}{auto} f2 = \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq::fmt}}(float\_type(), \textcolor{charliteral}{'g'}).c(20);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < vec\_d.size(); ++i)}
\DoxyCodeLine{        oss << f2(vec\_d[i]);}
\DoxyCodeLine{    el = \mbox{\hyperlink{namespaceseq_a576ae74a514ded550299e48e4c32cc64}{tock\_ms}}();}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Write centered double with seq::fmt: "} << el << \textcolor{stringliteral}{" ms"} << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{// use std::ostream::bad() to make sure the above tests are not simply ignored by the compiler}}
\DoxyCodeLine{    \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int})oss.bad())}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"error"} << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


Above example compiled with gcc 10.\+1.\+0 (-\/O3) for msys2 on Windows 10 on a Intel(\+R) Core(\+T\+M) i7-\/10850H at 2.\+70\+G\+Hz gives the following output\+:

\begin{quote}
Write table with streams\+: 3469 ms

Write table with seq formatting module\+: 413 ms

Write centered double with \mbox{\hyperlink{namespaceseq_a21b27d9d28ab49b4e36657f9e95013c7}{seq\+::fmt}}\+: 366 ms \end{quote}
