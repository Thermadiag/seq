\hypertarget{group___charconv}{}\doxysection{Arithmetic value convertion from/to string}
\label{group___charconv}\index{Arithmetic value convertion from/to string@{Arithmetic value convertion from/to string}}


The Charconv module provides fast routines to convert numerical values from/to string.  




\doxysubsection{Detailed Description}
The Charconv module provides fast routines to convert numerical values from/to string. 

\hypertarget{group___charconv_autotoc_md0}{}\doxysubsubsection{Low level functions}\label{group___charconv_autotoc_md0}
The main functions of \textbackslash{}\+Charconv are seq\+::to\+\_\+chars and seq\+::from\+\_\+chars which provide a similar interface to C++17 functions std\+::from\+\_\+chars and std\+::to\+\_\+chars. They aim to provide a faster alternative to C++ streams for converting floating point and integer types from/to string.

seq\+::from\+\_\+chars() is similar to std\+::from\+\_\+chars with the following differences\+:
\begin{DoxyItemize}
\item Leading spaces are consumed.
\item For integral types, a leading \textquotesingle{}0x\textquotesingle{} prefix is considered valid.
\item For floating point values\+: if the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-\/)inf or (+-\/)0, and the full pattern will be consumed. Therefore, std\+::errc\+::result\+\_\+out\+\_\+of\+\_\+range is never returned.
\item Leading \textquotesingle{}+\textquotesingle{} sign is considered valid.
\item Custom \textquotesingle{}dot\textquotesingle{} character can be passed as argument.
\item For floating point values\+: this function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100\% perfect exactitude.
\end{DoxyItemize}

seq\+::to\+\_\+chars is similar to std\+::to\+\_\+chars with the following differences \begin{DoxyVerb}-   For integral type, additional options on the form of a seq::integral_chars_format object can be passed. They add the possibility to output a leading '0x' for hexadecimal
    formatting, a minimum width (with zeros padding), upper case outputs for hexadecimal formatting.
-   For floating point values, the 'dot' character can be specified.
-   For floating point values, this function is NOT AN EXACT formatter. There are currently a lot of different algorithms to provide fast and exact convertion of floating point 
    values to strings: ryu, grisu-exact, dragonbox... This function tries to provide a faster and lighter alternative when exact precision is not a requirement (which is my case).
    Internal benchmarks show that convertiing double values to string using this function is around 2 times faster than with ryu library for scientific or general formatting, 
    and 3 times faster with fixed formatting. When converting double values, obtained strings are similar to the result of printf in 100% of the cases when the required precision 
    is below 12. After that, the ratio decreases to 86% of exactitude for a precision of 17. Converting a very high (or very small) value with the 'f' specifier will usually produce 
    slightly different output, especially in the "garbade" digits.
\end{DoxyVerb}
\hypertarget{group___charconv_autotoc_md1}{}\doxysubsubsection{Working with C++ streams}\label{group___charconv_autotoc_md1}
To write numerical values to C++ std\+::ostream objects, see the \textbackslash{}\+Format module.

To read numerical values from std\+::istream object, the \textbackslash{}\+Charconv module provides the stream adapter \mbox{\hyperlink{classseq_1_1std__input__stream}{seq\+::std\+\_\+input\+\_\+stream}}. It was developped to read huge tables or matrices from ascii files or string.

Basic usage\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::ifstream fin(\textcolor{stringliteral}{"my\_huge\_file.txt"});}
\DoxyCodeLine{\mbox{\hyperlink{classseq_1_1std__input__stream}{seq::std\_input\_stream<>}} istream(fin);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Read trailing lines}}
\DoxyCodeLine{std::string trailer;}
\DoxyCodeLine{seq::read\_line\_from\_stream(istream, trailer);}
\DoxyCodeLine{\textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Read words}}
\DoxyCodeLine{std::string word;}
\DoxyCodeLine{seq::from\_stream(istream, word);}
\DoxyCodeLine{\textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Read all numeric values into a vector}}
\DoxyCodeLine{std::vector<double> vec;}
\DoxyCodeLine{\textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{}
\DoxyCodeLine{    \textcolor{keywordtype}{double} v;}
\DoxyCodeLine{    seq::from\_stream(istream, v);}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (istream)}
\DoxyCodeLine{        vec.push\_back(v);}
\DoxyCodeLine{    \textcolor{keywordflow}{else}}
\DoxyCodeLine{        \textcolor{keywordflow}{break};}
\DoxyCodeLine{\}}
\end{DoxyCode}


Internal benchmarks show that using from\+\_\+stream() is around 20 faster (or more) than using std\+::istream\+::operator$>$$>$() when reading floating point values from a huge string.

In additional to \mbox{\hyperlink{classseq_1_1std__input__stream}{seq\+::std\+\_\+input\+\_\+stream}}, \textbackslash{}\+Charconv module provides the similar \mbox{\hyperlink{classseq_1_1buffer__input__stream}{seq\+::buffer\+\_\+input\+\_\+stream}} and \mbox{\hyperlink{classseq_1_1file__input__stream}{seq\+::file\+\_\+input\+\_\+stream}}. 