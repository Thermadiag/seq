\hypertarget{classseq_1_1deque}{}\doxysection{seq\+::deque$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$ Class Template Reference}
\label{classseq_1_1deque}\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}


\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} is a std\+::deque like container implemented as a tiered-\/vector.  




{\ttfamily \#include $<$deque.\+hpp$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \{ \mbox{\hyperlink{classseq_1_1deque_a3ba6c8bebfda616a22386fe197aa8cb3a7cc35ae60e861ea7a2b359dca0116152}{min\+\_\+block\+\_\+size}} = Min\+B\+Size
 \}
\item 
using \mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}} = \mbox{\hyperlink{structseq_1_1detail_1_1_bucket_manager}{detail\+::\+Bucket\+Manager}}$<$ T, Allocator, \mbox{\hyperlink{classseq_1_1deque_a3ba6c8bebfda616a22386fe197aa8cb3a7cc35ae60e861ea7a2b359dca0116152}{min\+\_\+block\+\_\+size}}, max\+\_\+block\+\_\+size, Store\+Back\+Values, Value\+Compare, layout $>$
\item 
using \mbox{\hyperlink{classseq_1_1deque_a9d874479b6486d2e8f6b8b461650288b}{alloc\+\_\+traits}} = std\+::allocator\+\_\+traits$<$ Allocator $>$
\item 
using \mbox{\hyperlink{classseq_1_1deque_abc46688716d27484ca03d21abae18db7}{this\+\_\+type}} = \mbox{\hyperlink{classseq_1_1deque}{deque}}$<$ T, Allocator, layout, \mbox{\hyperlink{classseq_1_1deque_a3ba6c8bebfda616a22386fe197aa8cb3a7cc35ae60e861ea7a2b359dca0116152}{min\+\_\+block\+\_\+size}}, max\+\_\+block\+\_\+size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$
\item 
using \mbox{\hyperlink{classseq_1_1deque_a853961011a8be3c95faabf1cfccc3182}{find\+\_\+bsize\+\_\+type}} = Find\+B\+Size
\item 
using \mbox{\hyperlink{classseq_1_1deque_a28bbad2236c90a80dba90c568c5654fb}{value\+\_\+type}} = T
\item 
using \mbox{\hyperlink{classseq_1_1deque_a4239436838d076ad345b9bb785dc54dd}{allocator\+\_\+type}} = Allocator
\item 
using \mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} = typename alloc\+\_\+traits\+::size\+\_\+type
\item 
using \mbox{\hyperlink{classseq_1_1deque_ae2f18cc6989d106d650aa488415252e8}{difference\+\_\+type}} = typename alloc\+\_\+traits\+::difference\+\_\+type
\item 
using \mbox{\hyperlink{classseq_1_1deque_a228407dd384845d6167c684f7701d4ee}{pointer}} = typename alloc\+\_\+traits\+::pointer
\item 
using \mbox{\hyperlink{classseq_1_1deque_aca2b481d97075fd7894cff4612763199}{const\+\_\+pointer}} = typename alloc\+\_\+traits\+::const\+\_\+pointer
\item 
using \mbox{\hyperlink{classseq_1_1deque_a90ae3172fa0f0ac4ed3dd33bec2a02f5}{reference}} = \mbox{\hyperlink{classseq_1_1deque_a28bbad2236c90a80dba90c568c5654fb}{value\+\_\+type}} \&
\item 
using \mbox{\hyperlink{classseq_1_1deque_a151de06ed07bd72accfb8a12745326a8}{const\+\_\+reference}} = const \mbox{\hyperlink{classseq_1_1deque_a28bbad2236c90a80dba90c568c5654fb}{value\+\_\+type}} \&
\item 
using \mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} = \mbox{\hyperlink{structseq_1_1detail_1_1deque__iterator}{detail\+::deque\+\_\+iterator}}$<$ \mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}} $>$
\item 
using \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} = \mbox{\hyperlink{structseq_1_1detail_1_1deque__const__iterator}{detail\+::deque\+\_\+const\+\_\+iterator}}$<$ \mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}} $>$
\item 
using \mbox{\hyperlink{classseq_1_1deque_a14115e561acf8848747c6e7661c4800d}{reverse\+\_\+iterator}} = std\+::reverse\+\_\+iterator$<$ \mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} $>$
\item 
using \mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} = std\+::reverse\+\_\+iterator$<$ \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} $>$
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classseq_1_1deque_a7aae7b987099770b63f3147335f7dcce}{deque}} ()
\begin{DoxyCompactList}\small\item\em Default constructor, initialize the internal bucket manager. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a96cc44c9b81e4d5862f04424aac90acd}{deque}} (const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Constructs an empty container with the given allocator alloc. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a58de8c7b9e96974fd934627704a31340}{deque}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} count, const T \&value, const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Constructs the container with {\itshape count} copies of elements with value {\itshape value}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a9c5ddb926dea1831571ee1d6263849e4}{deque}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} count, const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Constructs the container with count default-\/inserted instances of T. No copies are made. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_ab513b58b214e0135920a7d21987f4564}{deque}} (const \mbox{\hyperlink{classseq_1_1deque}{deque}} \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor. Constructs the container with the copy of the contents of other. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a519290bc20631f450370ab0d8da1a439}{deque}} (const \mbox{\hyperlink{classseq_1_1deque}{deque}} \&other, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Constructs the container with the copy of the contents of other, using alloc as the allocator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_aaeb297c94534c431b03380df3dd255a5}{deque}} (\mbox{\hyperlink{classseq_1_1deque}{deque}} \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-\/construction from the allocator belonging to other. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a1dc218068b589d84525e7b6da2deab4e}{deque}} (\mbox{\hyperlink{classseq_1_1deque}{deque}} \&\&other, const Allocator \&alloc) noexcept(std\+::is\+\_\+nothrow\+\_\+move\+\_\+assignable$<$ T $>$\+::value)
\begin{DoxyCompactList}\small\item\em Allocator-\/extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.\+get\+\_\+allocator(), this results in an element-\/wise move. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a424d57d5a2b9a303ba914c4e922b930f}{deque}} (const std\+::initializer\+\_\+list$<$ T $>$ \&lst, const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Constructs the container with the contents of the initializer list {\itshape init}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Iter $>$ }\\\mbox{\hyperlink{classseq_1_1deque_a60e0e8b7d8deb773b6f1f83cb0d7f2dc}{deque}} (Iter first, Iter last, const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Constructs the container with the contents of the range \mbox{[}first, last). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a42f80d8e9124bccfc341b38fcc0aaa07}{$\sim$deque}} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque}{deque}} \& \mbox{\hyperlink{classseq_1_1deque_af909cbb794747e1eabe9a1beb474d2bf}{operator=}} (\mbox{\hyperlink{classseq_1_1deque}{deque}} \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em Move assignment operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque}{deque}} \& \mbox{\hyperlink{classseq_1_1deque_a1f03b2bd65988d8fdac77a8e80cbdf36}{operator=}} (const \mbox{\hyperlink{classseq_1_1deque}{deque}} \&other)
\begin{DoxyCompactList}\small\item\em Copy assignment operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}} $\ast$ \mbox{\hyperlink{classseq_1_1deque_a79daf1947e65162d94d50a60cd4761c4}{manager}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns the internal bucket manager object. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}} $\ast$ \mbox{\hyperlink{classseq_1_1deque_afecc70047ddfb65d9b0d37501a1db9cd}{manager}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the internal bucket manager object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1deque_a71556fb0d3f4c3b265893c55928b493a}{size}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the container size. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1deque_a3221e376dd28de949efe7d8d20c3e8fb}{max\+\_\+size}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the container maximum size. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1deque_aed129f8130d68197107538d0ca2e67eb}{bucket\+\_\+count}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the number of buckets within deque. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1deque_ac2995ba209354769563f2732e0eb7904}{bucket\+\_\+size}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the size of a bucket within deque. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classseq_1_1deque_a40abeefb98cf25015d6ab3ed2dec3ddd}{empty}} () const noexcept
\begin{DoxyCompactList}\small\item\em Retruns true if the container is empty, false otherwise. \end{DoxyCompactList}\item 
const Allocator \& \mbox{\hyperlink{classseq_1_1deque_a341110a6075e758aec7c369958434059}{get\+\_\+allocator}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the allocator associated with the container. \end{DoxyCompactList}\item 
Allocator \& \mbox{\hyperlink{classseq_1_1deque_a77406df7887444866057c00b9f9d1b84}{get\+\_\+allocator}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns the allocator associated with the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a874f1f1b57d0334da07ed3bd14377d7e}{swap}} (\mbox{\hyperlink{classseq_1_1deque}{deque}} \&other) noexcept
\begin{DoxyCompactList}\small\item\em Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a77c84fc9fed752a27ced1e18d0f606a3}{shrink\+\_\+to\+\_\+fit}} ()
\begin{DoxyCompactList}\small\item\em Release all unused memory, and move the deque content to the smallest possible storage. This function only makes sense for {\itshape Optimize\+For\+Speed} flag. Invalidate all iterators and references. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_afb7676de11f1c09c7b8cea6ddb960a5c}{resize}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} count)
\begin{DoxyCompactList}\small\item\em Resizes the container to contain count elements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a1771d81b89d110c367d2348755d5b34c}{resize}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} count, const T \&value)
\begin{DoxyCompactList}\small\item\em Resizes the container to contain count elements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_af9ec5ae83e62226daed9376a36c7441b}{resize\+\_\+front}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} count)
\begin{DoxyCompactList}\small\item\em Resizes the container to contain count elements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a9ff00f12899037caada678a1a219bbb9}{resize\+\_\+front}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} count, const T \&value)
\begin{DoxyCompactList}\small\item\em Resizes the container to contain count elements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a26a0fb8b42a6be979f132618fbd3c9cf}{clear}} ()
\begin{DoxyCompactList}\small\item\em Clear the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a414633a9f528db23bce8e1567b894719}{push\+\_\+back}} (const T \&value)
\begin{DoxyCompactList}\small\item\em Appends the given element value to the end of the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a0cdae82b8bbb44d8bc55c7e3c45c540d}{push\+\_\+back}} (T \&\&value)
\begin{DoxyCompactList}\small\item\em Appends the given element value to the end of the container using move semantic. \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\T \& \mbox{\hyperlink{classseq_1_1deque_a74c07d8a83b577b3be81d25b0399e3bd}{emplace\+\_\+back}} (Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Appends a new element to the end of the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a43cf34c3e8a456b45ad4a6914d05c269}{push\+\_\+front}} (const T \&value)
\begin{DoxyCompactList}\small\item\em Appends the given element value to the beginning of the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a463357d654a8e621c2d668f4be762999}{push\+\_\+front}} (T \&\&value)
\begin{DoxyCompactList}\small\item\em Appends the given element value to the beginning of the container using move semantic. \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\T \& \mbox{\hyperlink{classseq_1_1deque_ab3962bae2d03e7cecde2428f18285640}{emplace\+\_\+front}} (Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Appends a new element to the beginning of the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a2f41761b1626d06ac2616f9f84f4c133}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}, const T \&value)
\begin{DoxyCompactList}\small\item\em Insert {\itshape value} before {\itshape pos}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_ab3f8fbcf9b33523e8a4be313fe56ce0c}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}, T \&\&value)
\begin{DoxyCompactList}\small\item\em Insert {\itshape value} before {\itshape pos} using move semantic. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_ad967349f51c9d609c39ac4a605e816ae}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} it, const T \&value)
\begin{DoxyCompactList}\small\item\em Insert {\itshape value} before {\itshape it}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_acfe8b48223f0dfc13c3a91abfbe31b6b}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} it, T \&\&value)
\begin{DoxyCompactList}\small\item\em Insert {\itshape value} before {\itshape it} using move semantic. \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\T \& \mbox{\hyperlink{classseq_1_1deque_a07e2b5bd39ebf6335560a4f441806673}{emplace}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Inserts a new element into the container directly before {\itshape pos}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\T \& \mbox{\hyperlink{classseq_1_1deque_a7925f463edc78229e32b08cbd7a6dafd}{emplace}} (\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Inserts a new element into the container directly before {\itshape pos}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Iter $>$ }\\void \mbox{\hyperlink{classseq_1_1deque_a58ac8b3765950bb1a42f0203e392f313}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}, Iter first, Iter last)
\begin{DoxyCompactList}\small\item\em Inserts elements from range \mbox{[}first, last) before pos. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Iter $>$ }\\\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_aaa28cfd55c0dc7e96d4d06d9cf6b89a2}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} it, Iter first, Iter last)
\begin{DoxyCompactList}\small\item\em Inserts elements from range \mbox{[}first, last) before it. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_ac2c78f7740fb0a7437df74139546e837}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}, std\+::initializer\+\_\+list$<$ T $>$ ilist)
\begin{DoxyCompactList}\small\item\em Inserts elements from initializer list ilist before pos. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_a2202a3b1249440c7f6a031a9d8b955f0}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}, std\+::initializer\+\_\+list$<$ T $>$ ilist)
\begin{DoxyCompactList}\small\item\em Inserts elements from initializer list ilist before pos. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a66d1a767786c2f2e1cec17baa32c28a4}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}, \mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} count, const T \&value)
\begin{DoxyCompactList}\small\item\em Inserts count copies of the value before pos Basic exception guarantee. ~\newline
 \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_a30fdb06c5a4f4a7892630716ccd5400a}{insert}} (\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}, \mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} count, const T \&value)
\begin{DoxyCompactList}\small\item\em Inserts count copies of the value before pos. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a45c749a8706927412d28d950bfa3e206}{pop\+\_\+back}} ()
\begin{DoxyCompactList}\small\item\em Removes the last element of the container. Calling pop\+\_\+back on an empty container results in undefined behavior. Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a377cf60662942fa5d286871934e280dd}{pop\+\_\+front}} ()
\begin{DoxyCompactList}\small\item\em Removes the first element of the container. Calling pop\+\_\+front on an empty container results in undefined behavior. Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_ad972f18dac66aea6d0a3748ffc06979f}{erase}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}})
\begin{DoxyCompactList}\small\item\em Erase element at given position. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_a470a94fb88af238e6d61a48ef507be12}{erase}} (\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} it)
\begin{DoxyCompactList}\small\item\em Erase element at given position. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a722457938d178ab2f99f2dac1b685945}{erase}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} first, \mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} last)
\begin{DoxyCompactList}\small\item\em Removes the elements in the range \mbox{[}first, last). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_a6356d51874581e77564b790d3070ed0c}{erase}} (\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} first, \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} last)
\begin{DoxyCompactList}\small\item\em Removes the elements in the range \mbox{[}first, last). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_a601bef3e23cc2c342c66a8fb49687216}{assign}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} count, const T \&value)
\begin{DoxyCompactList}\small\item\em Replaces the contents with {\itshape count} copies of value {\itshape value} Basic exception guarantee. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Iter $>$ }\\void \mbox{\hyperlink{classseq_1_1deque_a2f298ee8f4b33b979d61060f59a5ea0c}{assign}} (Iter first, Iter last)
\begin{DoxyCompactList}\small\item\em Replaces the contents with copies of those in the range \mbox{[}first, last). The behavior is undefined if either argument is an iterator into $\ast$this. Basic exception guarantee. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1deque_ad918b95290d266ec34adafd8e667d491}{assign}} (std\+::initializer\+\_\+list$<$ T $>$ ilist)
\begin{DoxyCompactList}\small\item\em Replaces the contents with the elements from the initializer list ilist. Basic exception guarantee. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Fun $>$ }\\Fun \mbox{\hyperlink{classseq_1_1deque_a301b9415b79b787de33e29f15f0ceb7c}{for\+\_\+each}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} first, \mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} last, Fun fun)
\begin{DoxyCompactList}\small\item\em Apply unary function {\itshape fun} to all elements within the range \mbox{[}first,last). \end{DoxyCompactList}\item 
{\footnotesize template$<$class Fun $>$ }\\Fun \mbox{\hyperlink{classseq_1_1deque_a0c4ff3ed240b474c92ee870addfd02fc}{for\+\_\+each}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} first, \mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} last, Fun fun) const
\begin{DoxyCompactList}\small\item\em Apply unary function {\itshape fun} to all elements within the range \mbox{[}first,last). \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T \& \mbox{\hyperlink{classseq_1_1deque_a1c4648cb5f1a4159aeebc800c0ff574a}{at}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}) const
\begin{DoxyCompactList}\small\item\em Returns a reference to the element at specified location pos, with bounds checking. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T \& \mbox{\hyperlink{classseq_1_1deque_a194f893c5172c08e6cf18195783d2b82}{at}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}})
\begin{DoxyCompactList}\small\item\em Returns a reference to the element at specified location pos, with bounds checking. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T \& \mbox{\hyperlink{classseq_1_1deque_a1da93d7f24768a8f3b881efb2a2ad162}{operator\mbox{[}$\,$\mbox{]}}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}) const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reference to the element at specified location pos, without bounds checking. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T \& \mbox{\hyperlink{classseq_1_1deque_a77b2976e01941baa9400c1111c1cc3bf}{operator\mbox{[}$\,$\mbox{]}}} (\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}) noexcept
\begin{DoxyCompactList}\small\item\em Returns a reference to the element at specified location pos, without bounds checking. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T \& \mbox{\hyperlink{classseq_1_1deque_a99199cfa3c7e85ca221f5b89daa7c37b}{back}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns a reference to the last element in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T \& \mbox{\hyperlink{classseq_1_1deque_a522dbb0be4b6af94155e980b4e0f78c6}{back}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reference to the last element in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T \& \mbox{\hyperlink{classseq_1_1deque_a6a0e9f55bdfb07b3a83bb29bfe175814}{front}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns a reference to the first element in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T \& \mbox{\hyperlink{classseq_1_1deque_af223de620baf1912e6b68bed7ffecfbd}{front}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reference to the first element in the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_aa772708cf45c10f3db5c3d046e707148}{begin}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the deque. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the deque. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_ace22814e8935b68260d2df2b0e9a69ee}{end}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the deque. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_a3009be4be5c7c3df7138ce2828284d10}{end}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the deque. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a14115e561acf8848747c6e7661c4800d}{reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_a189a81122365b6e1ee0fc47d2688d19c}{rbegin}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_a490292dd996a977094eafcd4652e11a9}{rbegin}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a14115e561acf8848747c6e7661c4800d}{reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_a3e80a5e705d79bd934a5fe24e258db95}{rend}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_a9b56c4660ca7cbfa295ac13af609db12}{rend}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_a9c59aa1ed1eb3d9bce6496e4557fb332}{cbegin}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the deque. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_af82d0f9a5a7245857029e823e45e2e26}{cend}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the deque. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_aebed7061983f44f09c92da3d2f7c0002}{crbegin}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_a46365fdba452451d245fbb196dc691dd}{crend}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque_a8ada35adcc56bcc7921ca4c7df077ded}{iterator\+\_\+at}} (size\+\_\+t \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}) noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to given absolute position. This is slightly faster than \mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}}+pos. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque_a07c742f00582a04ebde4500c182f7d30}{iterator\+\_\+at}} (size\+\_\+t \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}}) const noexcept
\begin{DoxyCompactList}\small\item\em Returns a const\+\_\+iterator to given absolute position. This is slightly faster than \mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}}+pos. \end{DoxyCompactList}\item 
{\footnotesize template$<$class U , class Less  = std\+::less$<$\+T$>$$>$ }\\size\+\_\+t \mbox{\hyperlink{classseq_1_1deque_ad12577b9a91e319e17d437478358c2dc}{binary\+\_\+search}} (const U \&value, const Less \&le=Less()) const noexcept
\begin{DoxyCompactList}\small\item\em Optimized version of std\+::binary\+\_\+search(\mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}},\mbox{\hyperlink{classseq_1_1deque_a3009be4be5c7c3df7138ce2828284d10}{end()}},value,le); Only works for sorted deque. \end{DoxyCompactList}\item 
{\footnotesize template$<$class U , class Less  = std\+::less$<$\+T$>$$>$ }\\size\+\_\+t \mbox{\hyperlink{classseq_1_1deque_a37f347ccd00402dbcebaa9d9f3e97126}{lower\+\_\+bound}} (const U \&value, const Less \&le=Less()) const noexcept
\begin{DoxyCompactList}\small\item\em Optimized version of std\+::lower\+\_\+bound(\mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}},\mbox{\hyperlink{classseq_1_1deque_a3009be4be5c7c3df7138ce2828284d10}{end()}},value,le); Only works for sorted deque. \end{DoxyCompactList}\item 
{\footnotesize template$<$class U , class Less  = std\+::less$<$\+T$>$$>$ }\\size\+\_\+t \mbox{\hyperlink{classseq_1_1deque_a59cc73e8bf0ba9a691e80e3a8a34690a}{upper\+\_\+bound}} (const U \&value, const Less \&le=Less()) const noexcept
\begin{DoxyCompactList}\small\item\em Optimized version of std\+::upper\+\_\+bound(\mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}},\mbox{\hyperlink{classseq_1_1deque_a3009be4be5c7c3df7138ce2828284d10}{end()}},value,le); Only works for sorted deque. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class T, class Allocator = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$\newline
class seq\+::deque$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$}

\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} is a std\+::deque like container implemented as a tiered-\/vector. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & value type \\
\hline
{\em Allocator} & allocator type \\
\hline
{\em layout} & memory layout \\
\hline
{\em Min\+B\+Size} & minimum bucket size, depends on the value\+\_\+type size \\
\hline
{\em Max\+B\+Size} & maximum bucket size \\
\hline
{\em Find\+B\+Size} & struct used to find the bucket size for a given deque size \\
\hline
{\em Value\+Compare} & internal use only\\
\hline
\end{DoxyTemplParams}
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} is a random-\/access, bucket based container providing a similar interface to std\+::deque. Its internals are however very different as it is implemented as a \href{http://cs.brown.edu/cgc/jdsl/papers/tiered-vector.pdf}{\texttt{ tiered vector}}. Instead of maintaining a vector of fixed size buckets, \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} uses a bucket size close to sqrt(size()). The bucket size is always a power of 2 for fast division and modulo. Furtheremore, the bucket is not a linear buffer but is instead implemented as a circular buffer. This allows a complexity of O(sqrt(\+N)) for insertion and deletion in the middle of the deque instead of O(\+N) for std\+::deque. Inserting and deleting elements at both ends is still O(1).

\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} internally uses \mbox{\hyperlink{classseq_1_1devector}{seq\+::devector}} to store the buckets. \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} is used as the backend container for \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}, \mbox{\hyperlink{classseq_1_1flat__map}{seq\+::flat\+\_\+map}}, \mbox{\hyperlink{classseq_1_1flat__multiset}{seq\+::flat\+\_\+multiset}} and \mbox{\hyperlink{classseq_1_1flat__multimap}{seq\+::flat\+\_\+multimap}}.\hypertarget{classseq_1_1deque_autotoc_md11}{}\doxysubsubsection{Interface}\label{classseq_1_1deque_autotoc_md11}
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} interface is the same as std\+::deque, with the additional members\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{classseq_1_1deque_a301b9415b79b787de33e29f15f0ceb7c}{for\+\_\+each()}} providing a faster way to walk through the deque than iterators,
\item \mbox{\hyperlink{classseq_1_1deque_af9ec5ae83e62226daed9376a36c7441b}{resize\+\_\+front()}} to resize the deque from the front instead of the back of the container,
\end{DoxyItemize}\hypertarget{classseq_1_1deque_autotoc_md12}{}\doxysubsubsection{Bucket managment}\label{classseq_1_1deque_autotoc_md12}
The \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} maintains internally an array of circular buffers (or buckets). At any moment, all buckets have the same size which is a power of 2. At container initialization, the bucket size is given by template parameter {\itshape Min\+B\+Size} which is, by default, between 64 and 8 depending on value\+\_\+type size. Whenever \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} grows (through \mbox{\hyperlink{classseq_1_1deque_a414633a9f528db23bce8e1567b894719}{push\+\_\+back()}}, \mbox{\hyperlink{classseq_1_1deque_a43cf34c3e8a456b45ad4a6914d05c269}{push\+\_\+front()}}, \mbox{\hyperlink{classseq_1_1deque_a2f41761b1626d06ac2616f9f84f4c133}{insert()}}, \mbox{\hyperlink{classseq_1_1deque_afb7676de11f1c09c7b8cea6ddb960a5c}{resize()}} ...), the new bucket size is computed using the template parameter {\itshape Find\+B\+Size}. {\itshape Find\+B\+Size} must provide the member 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned}  FindBSize::operator() (\textcolor{keywordtype}{size\_t} \mbox{\hyperlink{classseq_1_1deque_a71556fb0d3f4c3b265893c55928b493a}{size}}, \textcolor{keywordtype}{unsigned} MinBSize, \textcolor{keywordtype}{unsigned} MaxBSize) \textcolor{keyword}{const} noexcept ;}
\end{DoxyCode}
 returning the new bucket size based on the container size, the minimum and maximum bucket size. Default implementation returns a value close to sqrt(size()) rounded up to the next power of 2.

If the new bucket size is different than the current one, new buckets are created and elements from the old buckets are moved to the new ones. This has the practical consequence to {\bfseries{ invalidate all iterators and references on growing or shrinking }}, as opposed to std\+::deque which maintains references when inserting/deleting at both ends.\hypertarget{classseq_1_1deque_autotoc_md13}{}\doxysubsubsection{Inserting and deleting elements}\label{classseq_1_1deque_autotoc_md13}
Inserting or deleting elements at the back or the front behaves the same way as for std\+::deque, except if the bucket size is updated (as explained above).

Inerting an element in the middle of \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} follows these steps\+:
\begin{DoxyItemize}
\item The bucket index and the element position within the bucket are first computed
\item The back element of the bucket is extracted and removed from the bucket
\item The new element is inserted at the right position. Since the bucket is implemented as a dense circular buffer, at most half of the bucket elements must be moved (toward the left or the right, whichever is the shortest path)
\item The back value that was previously removed is inserted at the front of the next bucket
\item The next bucket back value is extracted and inserted at the front of the following bucket
\item ....
\item And so forth until we reach the last bucket.
\end{DoxyItemize}

This operation of {\itshape insert front/pop back} is very fast on a circular buffer as it involves only two element moves and shifting the begin index of the buffer. If the bucket size is exactly sqrt(size()), inserting an element in the middle performs in O(sqrt(\+N)) as it involves as many element moves within a single bucket than between buckets.

In practice the buckets size should be greater than sqrt(size()) as moving elements within a bucket is much faster than between buckets due to cache locality.

Note that, depending on the insertion location, elements can be shifted toward the front bucket instead of the back one if this is the shortest path. This practically divides by 2 (on average) the number of moved elements.

Erasing an element in the middle follows the exact same logic.

Note that inserting/removing relocatable types (where \mbox{\hyperlink{structseq_1_1is__relocatable_a9bc3104d310961a601c2185957f846ad}{seq\+::is\+\_\+relocatable$<$\+T$>$\+::value}} is true) is faster than for other types.\hypertarget{classseq_1_1deque_autotoc_md14}{}\doxysubsubsection{Exception guarantee}\label{classseq_1_1deque_autotoc_md14}
All insertion/deletion operations on a \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} are much more complex than for a std\+::deque. Especially, each operation might change the bucket size, and therefore trigger the allocation of new buckets plus moving all elements within the new buckets.

Although possible, providing strong exception guarantee on \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} operations would have added a very complex layer hurting its performances. Therefore, all \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} operations only provide {\bfseries{basic exception guarantee}}.\hypertarget{classseq_1_1deque_autotoc_md15}{}\doxysubsubsection{Iterators and references invalidation}\label{classseq_1_1deque_autotoc_md15}
As explained above, all \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} operations invalidate iterators and references, except for swapping two \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}.

The only exception is when providing a minimum bucket size ({\itshape Min\+B\+Size}) equals to the maximum bucket size ({\itshape Max\+B\+Size}). In this case, inserting/deleting elements will {\itshape never} change the bucket size and move all elements within new buckets. This affects the members \mbox{\hyperlink{classseq_1_1deque_a74c07d8a83b577b3be81d25b0399e3bd}{emplace\+\_\+back()}}, \mbox{\hyperlink{classseq_1_1deque_a414633a9f528db23bce8e1567b894719}{push\+\_\+back()}}, \mbox{\hyperlink{classseq_1_1deque_ab3962bae2d03e7cecde2428f18285640}{emplace\+\_\+front()}} and \mbox{\hyperlink{classseq_1_1deque_a43cf34c3e8a456b45ad4a6914d05c269}{push\+\_\+front()}} that provide the same invalidation rules as for std\+::deque.\hypertarget{classseq_1_1deque_autotoc_md16}{}\doxysubsubsection{Memory layout}\label{classseq_1_1deque_autotoc_md16}
If the {\itshape layout} template parameter is {\itshape Optimize\+For\+Memory}, each bucket is independantly allocated using the provided allocator, and the buckets are automatically deallocated when empty.

When using the {\itshape Optimize\+For\+Speed} flag, the \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} will use a memory pool to allocate several buckets at once, still using the provided allocator. The memory pool uses a growing strategy to allocate more and more buckets based on a growth factor (S\+E\+Q\+\_\+\+G\+R\+O\+W\+\_\+\+F\+A\+C\+T\+OR define, defaulting to 1.\+6). Whenever the bucket size changes, memory chunks used to store the previous buckets are kept as long as they are big enough to hold buckets of the new size. This avoid a lot of unnecessary allocations when continuously extending the \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}. The memory pool makes insertion tipically 50\% faster (depending on value\+\_\+type size) than the default allocation strategy, but will consume slightly more memory.

With {\itshape Optimize\+For\+Speed} flag, the deque will almost never release memory, except on calls to \mbox{\hyperlink{classseq_1_1deque_a77c84fc9fed752a27ced1e18d0f606a3}{shrink\+\_\+to\+\_\+fit()}}.\hypertarget{classseq_1_1deque_autotoc_md17}{}\doxysubsubsection{Performances}\label{classseq_1_1deque_autotoc_md17}
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} was optimized to match libc++ std\+::deque performances as close as possible. My benchmarhs shows that all members are actually faster than libc++ std\+::deque, except for \mbox{\hyperlink{classseq_1_1deque_a414633a9f528db23bce8e1567b894719}{push\+\_\+back()}}, \mbox{\hyperlink{classseq_1_1deque_a43cf34c3e8a456b45ad4a6914d05c269}{push\+\_\+front()}}, \mbox{\hyperlink{classseq_1_1deque_a45c749a8706927412d28d950bfa3e206}{pop\+\_\+back()}} and \mbox{\hyperlink{classseq_1_1deque_a377cf60662942fa5d286871934e280dd}{pop\+\_\+front()}} which are slightly slower due to the need to move all elements when the bucket size changes. This can be alievated by the {\itshape Optimize\+For\+Speed} flag that makes both operations faster than their std\+::deque counterparts.

Usually, iterating through a \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} is faster than through a std\+::deque. The random-\/access \#operator\mbox{[}$\,$\mbox{]}(size\+\_\+t) is also faster. Making a lot of random access based on iterators can be slightly slower with \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} depending on the use case. For instance, sorting a \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} is slower than sorting a std\+::deque.

Inserting/deleting single elements on a \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}} is several order of magnitudes faster than std\+::deque due to the tiered-\/vector implementation.

The standard conlusion is\+: you should always benchmark with your own use cases. 

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{classseq_1_1deque_a9d874479b6486d2e8f6b8b461650288b}\label{classseq_1_1deque_a9d874479b6486d2e8f6b8b461650288b}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!alloc\_traits@{alloc\_traits}}
\index{alloc\_traits@{alloc\_traits}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{alloc\_traits}{alloc\_traits}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a9d874479b6486d2e8f6b8b461650288b}{alloc\+\_\+traits}} =  std\+::allocator\+\_\+traits$<$Allocator$>$}

\mbox{\Hypertarget{classseq_1_1deque_a4239436838d076ad345b9bb785dc54dd}\label{classseq_1_1deque_a4239436838d076ad345b9bb785dc54dd}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a4239436838d076ad345b9bb785dc54dd}{allocator\+\_\+type}} =  Allocator}

\mbox{\Hypertarget{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}\label{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!bucket\_manager@{bucket\_manager}}
\index{bucket\_manager@{bucket\_manager}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{bucket\_manager}{bucket\_manager}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}} =  \mbox{\hyperlink{structseq_1_1detail_1_1_bucket_manager}{detail\+::\+Bucket\+Manager}}$<$T, Allocator, \mbox{\hyperlink{classseq_1_1deque_a3ba6c8bebfda616a22386fe197aa8cb3a7cc35ae60e861ea7a2b359dca0116152}{min\+\_\+block\+\_\+size}}, max\+\_\+block\+\_\+size, Store\+Back\+Values, Value\+Compare, layout$>$}

\mbox{\Hypertarget{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}\label{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!const\_iterator@{const\_iterator}}
\index{const\_iterator@{const\_iterator}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{const\_iterator}{const\_iterator}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} =  \mbox{\hyperlink{structseq_1_1detail_1_1deque__const__iterator}{detail\+::deque\+\_\+const\+\_\+iterator}}$<$\mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}}$>$}

\mbox{\Hypertarget{classseq_1_1deque_aca2b481d97075fd7894cff4612763199}\label{classseq_1_1deque_aca2b481d97075fd7894cff4612763199}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!const\_pointer@{const\_pointer}}
\index{const\_pointer@{const\_pointer}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{const\_pointer}{const\_pointer}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_aca2b481d97075fd7894cff4612763199}{const\+\_\+pointer}} =  typename alloc\+\_\+traits\+::const\+\_\+pointer}

\mbox{\Hypertarget{classseq_1_1deque_a151de06ed07bd72accfb8a12745326a8}\label{classseq_1_1deque_a151de06ed07bd72accfb8a12745326a8}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!const\_reference@{const\_reference}}
\index{const\_reference@{const\_reference}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{const\_reference}{const\_reference}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a151de06ed07bd72accfb8a12745326a8}{const\+\_\+reference}} =  const \mbox{\hyperlink{classseq_1_1deque_a28bbad2236c90a80dba90c568c5654fb}{value\+\_\+type}}\&}

\mbox{\Hypertarget{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}\label{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!const\_reverse\_iterator@{const\_reverse\_iterator}}
\index{const\_reverse\_iterator@{const\_reverse\_iterator}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{const\_reverse\_iterator}{const\_reverse\_iterator}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} =  std\+::reverse\+\_\+iterator$<$\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}$>$}

\mbox{\Hypertarget{classseq_1_1deque_ae2f18cc6989d106d650aa488415252e8}\label{classseq_1_1deque_ae2f18cc6989d106d650aa488415252e8}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!difference\_type@{difference\_type}}
\index{difference\_type@{difference\_type}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{difference\_type}{difference\_type}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_ae2f18cc6989d106d650aa488415252e8}{difference\+\_\+type}} =  typename alloc\+\_\+traits\+::difference\+\_\+type}

\mbox{\Hypertarget{classseq_1_1deque_a853961011a8be3c95faabf1cfccc3182}\label{classseq_1_1deque_a853961011a8be3c95faabf1cfccc3182}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!find\_bsize\_type@{find\_bsize\_type}}
\index{find\_bsize\_type@{find\_bsize\_type}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{find\_bsize\_type}{find\_bsize\_type}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a853961011a8be3c95faabf1cfccc3182}{find\+\_\+bsize\+\_\+type}} =  Find\+B\+Size}

\mbox{\Hypertarget{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}\label{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!iterator@{iterator}}
\index{iterator@{iterator}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{iterator}{iterator}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} =  \mbox{\hyperlink{structseq_1_1detail_1_1deque__iterator}{detail\+::deque\+\_\+iterator}}$<$\mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}}$>$}

\mbox{\Hypertarget{classseq_1_1deque_a228407dd384845d6167c684f7701d4ee}\label{classseq_1_1deque_a228407dd384845d6167c684f7701d4ee}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!pointer@{pointer}}
\index{pointer@{pointer}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{pointer}{pointer}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a228407dd384845d6167c684f7701d4ee}{pointer}} =  typename alloc\+\_\+traits\+::pointer}

\mbox{\Hypertarget{classseq_1_1deque_a90ae3172fa0f0ac4ed3dd33bec2a02f5}\label{classseq_1_1deque_a90ae3172fa0f0ac4ed3dd33bec2a02f5}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!reference@{reference}}
\index{reference@{reference}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{reference}{reference}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a90ae3172fa0f0ac4ed3dd33bec2a02f5}{reference}} =  \mbox{\hyperlink{classseq_1_1deque_a28bbad2236c90a80dba90c568c5654fb}{value\+\_\+type}}\&}

\mbox{\Hypertarget{classseq_1_1deque_a14115e561acf8848747c6e7661c4800d}\label{classseq_1_1deque_a14115e561acf8848747c6e7661c4800d}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!reverse\_iterator@{reverse\_iterator}}
\index{reverse\_iterator@{reverse\_iterator}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{reverse\_iterator}{reverse\_iterator}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a14115e561acf8848747c6e7661c4800d}{reverse\+\_\+iterator}} =  std\+::reverse\+\_\+iterator$<$\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}}$>$}

\mbox{\Hypertarget{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}\label{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!size\_type@{size\_type}}
\index{size\_type@{size\_type}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{size\_type}{size\_type}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} =  typename alloc\+\_\+traits\+::size\+\_\+type}

\mbox{\Hypertarget{classseq_1_1deque_abc46688716d27484ca03d21abae18db7}\label{classseq_1_1deque_abc46688716d27484ca03d21abae18db7}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!this\_type@{this\_type}}
\index{this\_type@{this\_type}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{this\_type}{this\_type}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_abc46688716d27484ca03d21abae18db7}{this\+\_\+type}} =  \mbox{\hyperlink{classseq_1_1deque}{deque}}$<$T, Allocator, layout, \mbox{\hyperlink{classseq_1_1deque_a3ba6c8bebfda616a22386fe197aa8cb3a7cc35ae60e861ea7a2b359dca0116152}{min\+\_\+block\+\_\+size}}, max\+\_\+block\+\_\+size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare$>$}

\mbox{\Hypertarget{classseq_1_1deque_a28bbad2236c90a80dba90c568c5654fb}\label{classseq_1_1deque_a28bbad2236c90a80dba90c568c5654fb}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
using \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque_a28bbad2236c90a80dba90c568c5654fb}{value\+\_\+type}} =  T}



\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{classseq_1_1deque_a3ba6c8bebfda616a22386fe197aa8cb3}\label{classseq_1_1deque_a3ba6c8bebfda616a22386fe197aa8cb3}} 
\doxysubsubsection{\texorpdfstring{anonymous enum}{anonymous enum}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
anonymous enum}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{min\_block\_size@{min\_block\_size}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!min\_block\_size@{min\_block\_size}}}\mbox{\Hypertarget{classseq_1_1deque_a3ba6c8bebfda616a22386fe197aa8cb3a7cc35ae60e861ea7a2b359dca0116152}\label{classseq_1_1deque_a3ba6c8bebfda616a22386fe197aa8cb3a7cc35ae60e861ea7a2b359dca0116152}} 
min\+\_\+block\+\_\+size&\\
\hline

\end{DoxyEnumFields}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classseq_1_1deque_a7aae7b987099770b63f3147335f7dcce}\label{classseq_1_1deque_a7aae7b987099770b63f3147335f7dcce}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [1/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Default constructor, initialize the internal bucket manager. 

\mbox{\Hypertarget{classseq_1_1deque_a96cc44c9b81e4d5862f04424aac90acd}\label{classseq_1_1deque_a96cc44c9b81e4d5862f04424aac90acd}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [2/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructs an empty container with the given allocator alloc. 


\begin{DoxyParams}{Parameters}
{\em alloc} & allocator object \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a58de8c7b9e96974fd934627704a31340}\label{classseq_1_1deque_a58de8c7b9e96974fd934627704a31340}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [3/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{count,  }\item[{const T \&}]{value,  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructs the container with {\itshape count} copies of elements with value {\itshape value}. 


\begin{DoxyParams}{Parameters}
{\em count} & new deque size \\
\hline
{\em value} & the value to initialize elements of the container with \\
\hline
{\em alloc} & allocator object ~\newline
 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a9c5ddb926dea1831571ee1d6263849e4}\label{classseq_1_1deque_a9c5ddb926dea1831571ee1d6263849e4}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [4/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{count,  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructs the container with count default-\/inserted instances of T. No copies are made. 


\begin{DoxyParams}{Parameters}
{\em count} & new deque size \\
\hline
{\em alloc} & allocator object \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_ab513b58b214e0135920a7d21987f4564}\label{classseq_1_1deque_ab513b58b214e0135920a7d21987f4564}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [5/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1deque}{deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy constructor. Constructs the container with the copy of the contents of other. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a519290bc20631f450370ab0d8da1a439}\label{classseq_1_1deque_a519290bc20631f450370ab0d8da1a439}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [6/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1deque}{deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$ \&}]{other,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs the container with the copy of the contents of other, using alloc as the allocator. 


\begin{DoxyParams}{Parameters}
{\em other} & other another container to be used as source to initialize the elements of the container with \\
\hline
{\em alloc} & allcoator object \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_aaeb297c94534c431b03380df3dd255a5}\label{classseq_1_1deque_aaeb297c94534c431b03380df3dd255a5}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [7/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque}{deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-\/construction from the allocator belonging to other. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a1dc218068b589d84525e7b6da2deab4e}\label{classseq_1_1deque_a1dc218068b589d84525e7b6da2deab4e}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [8/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque}{deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$ \&\&}]{other,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Allocator-\/extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.\+get\+\_\+allocator(), this results in an element-\/wise move. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
{\em alloc} & allocator object \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a424d57d5a2b9a303ba914c4e922b930f}\label{classseq_1_1deque_a424d57d5a2b9a303ba914c4e922b930f}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [9/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}\item[{const std\+::initializer\+\_\+list$<$ T $>$ \&}]{lst,  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs the container with the contents of the initializer list {\itshape init}. 


\begin{DoxyParams}{Parameters}
{\em lst} & initializer list \\
\hline
{\em alloc} & allocator object \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a60e0e8b7d8deb773b6f1f83cb0d7f2dc}\label{classseq_1_1deque_a60e0e8b7d8deb773b6f1f83cb0d7f2dc}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!deque@{deque}}
\index{deque@{deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{deque()}{deque()}\hspace{0.1cm}{\footnotesize\ttfamily [10/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class Iter $>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}\item[{Iter}]{first,  }\item[{Iter}]{last,  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs the container with the contents of the range \mbox{[}first, last). 


\begin{DoxyTemplParams}{Template Parameters}
{\em Iter} & iterator type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em first} & first iterator of the range \\
\hline
{\em last} & last iterator of the range \\
\hline
{\em alloc} & allocator object \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a42f80d8e9124bccfc341b38fcc0aaa07}\label{classseq_1_1deque_a42f80d8e9124bccfc341b38fcc0aaa07}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!````~deque@{$\sim$deque}}
\index{````~deque@{$\sim$deque}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$deque()}{~deque()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::$\sim$\mbox{\hyperlink{classseq_1_1deque}{deque}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Destructor. 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classseq_1_1deque_a2f298ee8f4b33b979d61060f59a5ea0c}\label{classseq_1_1deque_a2f298ee8f4b33b979d61060f59a5ea0c}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!assign@{assign}}
\index{assign@{assign}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{assign()}{assign()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class Iter $>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::assign (\begin{DoxyParamCaption}\item[{Iter}]{first,  }\item[{Iter}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the contents with copies of those in the range \mbox{[}first, last). The behavior is undefined if either argument is an iterator into $\ast$this. Basic exception guarantee. 

\mbox{\Hypertarget{classseq_1_1deque_a601bef3e23cc2c342c66a8fb49687216}\label{classseq_1_1deque_a601bef3e23cc2c342c66a8fb49687216}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!assign@{assign}}
\index{assign@{assign}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{assign()}{assign()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::assign (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{count,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the contents with {\itshape count} copies of value {\itshape value} Basic exception guarantee. 

\mbox{\Hypertarget{classseq_1_1deque_ad918b95290d266ec34adafd8e667d491}\label{classseq_1_1deque_ad918b95290d266ec34adafd8e667d491}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!assign@{assign}}
\index{assign@{assign}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{assign()}{assign()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::assign (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ T $>$}]{ilist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replaces the contents with the elements from the initializer list ilist. Basic exception guarantee. 

\mbox{\Hypertarget{classseq_1_1deque_a194f893c5172c08e6cf18195783d2b82}\label{classseq_1_1deque_a194f893c5172c08e6cf18195783d2b82}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!at@{at}}
\index{at@{at}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{at()}{at()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::at (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reference to the element at specified location pos, with bounds checking. 

\mbox{\Hypertarget{classseq_1_1deque_a1c4648cb5f1a4159aeebc800c0ff574a}\label{classseq_1_1deque_a1c4648cb5f1a4159aeebc800c0ff574a}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!at@{at}}
\index{at@{at}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{at()}{at()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::at (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a reference to the element at specified location pos, with bounds checking. 

\mbox{\Hypertarget{classseq_1_1deque_a522dbb0be4b6af94155e980b4e0f78c6}\label{classseq_1_1deque_a522dbb0be4b6af94155e980b4e0f78c6}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!back@{back}}
\index{back@{back}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{back()}{back()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reference to the last element in the container. 

\mbox{\Hypertarget{classseq_1_1deque_a99199cfa3c7e85ca221f5b89daa7c37b}\label{classseq_1_1deque_a99199cfa3c7e85ca221f5b89daa7c37b}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!back@{back}}
\index{back@{back}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{back()}{back()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reference to the last element in the container. 

\mbox{\Hypertarget{classseq_1_1deque_aa772708cf45c10f3db5c3d046e707148}\label{classseq_1_1deque_aa772708cf45c10f3db5c3d046e707148}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!begin@{begin}}
\index{begin@{begin}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the first element of the deque. 

\mbox{\Hypertarget{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}\label{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!begin@{begin}}
\index{begin@{begin}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the first element of the deque. 

\mbox{\Hypertarget{classseq_1_1deque_ad12577b9a91e319e17d437478358c2dc}\label{classseq_1_1deque_ad12577b9a91e319e17d437478358c2dc}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!binary\_search@{binary\_search}}
\index{binary\_search@{binary\_search}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{binary\_search()}{binary\_search()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class U , class Less  = std\+::less$<$\+T$>$$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::binary\+\_\+search (\begin{DoxyParamCaption}\item[{const U \&}]{value,  }\item[{const Less \&}]{le = {\ttfamily Less()} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Optimized version of std\+::binary\+\_\+search(\mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}},\mbox{\hyperlink{classseq_1_1deque_a3009be4be5c7c3df7138ce2828284d10}{end()}},value,le); Only works for sorted deque. 

\mbox{\Hypertarget{classseq_1_1deque_aed129f8130d68197107538d0ca2e67eb}\label{classseq_1_1deque_aed129f8130d68197107538d0ca2e67eb}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!bucket\_count@{bucket\_count}}
\index{bucket\_count@{bucket\_count}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{bucket\_count()}{bucket\_count()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::bucket\+\_\+count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the number of buckets within deque. 

\mbox{\Hypertarget{classseq_1_1deque_ac2995ba209354769563f2732e0eb7904}\label{classseq_1_1deque_ac2995ba209354769563f2732e0eb7904}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!bucket\_size@{bucket\_size}}
\index{bucket\_size@{bucket\_size}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{bucket\_size()}{bucket\_size()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::bucket\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the size of a bucket within deque. 

\mbox{\Hypertarget{classseq_1_1deque_a9c59aa1ed1eb3d9bce6496e4557fb332}\label{classseq_1_1deque_a9c59aa1ed1eb3d9bce6496e4557fb332}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!cbegin@{cbegin}}
\index{cbegin@{cbegin}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{cbegin()}{cbegin()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::cbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the first element of the deque. 

\mbox{\Hypertarget{classseq_1_1deque_af82d0f9a5a7245857029e823e45e2e26}\label{classseq_1_1deque_af82d0f9a5a7245857029e823e45e2e26}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!cend@{cend}}
\index{cend@{cend}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{cend()}{cend()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::cend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the element following the last element of the deque. 

\mbox{\Hypertarget{classseq_1_1deque_a26a0fb8b42a6be979f132618fbd3c9cf}\label{classseq_1_1deque_a26a0fb8b42a6be979f132618fbd3c9cf}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!clear@{clear}}
\index{clear@{clear}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Clear the container. 

\mbox{\Hypertarget{classseq_1_1deque_aebed7061983f44f09c92da3d2f7c0002}\label{classseq_1_1deque_aebed7061983f44f09c92da3d2f7c0002}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!crbegin@{crbegin}}
\index{crbegin@{crbegin}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{crbegin()}{crbegin()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::crbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the first element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1deque_a46365fdba452451d245fbb196dc691dd}\label{classseq_1_1deque_a46365fdba452451d245fbb196dc691dd}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!crend@{crend}}
\index{crend@{crend}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{crend()}{crend()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::crend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the element following the last element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1deque_a7925f463edc78229e32b08cbd7a6dafd}\label{classseq_1_1deque_a7925f463edc78229e32b08cbd7a6dafd}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!emplace@{emplace}}
\index{emplace@{emplace}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{emplace()}{emplace()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class... Args$>$ \\
T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::emplace (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}}]{pos,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts a new element into the container directly before {\itshape pos}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em ...\+Args} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pos} & iterator within the deque \\
\hline
{\em ...\+args} & T constructor arguments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to inserted element Basic exception guarantee. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_a07e2b5bd39ebf6335560a4f441806673}\label{classseq_1_1deque_a07e2b5bd39ebf6335560a4f441806673}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!emplace@{emplace}}
\index{emplace@{emplace}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{emplace()}{emplace()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class... Args$>$ \\
T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::emplace (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts a new element into the container directly before {\itshape pos}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em ...\+Args} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pos} & absolute position within the deque \\
\hline
{\em ...\+args} & T constructor arguments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to inserted element Basic exception guarantee. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_a74c07d8a83b577b3be81d25b0399e3bd}\label{classseq_1_1deque_a74c07d8a83b577b3be81d25b0399e3bd}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!emplace\_back@{emplace\_back}}
\index{emplace\_back@{emplace\_back}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_back()}{emplace\_back()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class... Args$>$ \\
T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::emplace\+\_\+back (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends a new element to the end of the container. 


\begin{DoxyTemplParams}{Template Parameters}
{\em ...\+Args} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em ...\+args} & T constructor arguments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to inserted element Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_ab3962bae2d03e7cecde2428f18285640}\label{classseq_1_1deque_ab3962bae2d03e7cecde2428f18285640}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!emplace\_front@{emplace\_front}}
\index{emplace\_front@{emplace\_front}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_front()}{emplace\_front()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class... Args$>$ \\
T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::emplace\+\_\+front (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends a new element to the beginning of the container. 


\begin{DoxyTemplParams}{Template Parameters}
{\em ...\+Args} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em ...\+args} & T constructor arguments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to inserted element Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_a40abeefb98cf25015d6ab3ed2dec3ddd}\label{classseq_1_1deque_a40abeefb98cf25015d6ab3ed2dec3ddd}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!empty@{empty}}
\index{empty@{empty}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
bool \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Retruns true if the container is empty, false otherwise. 

\mbox{\Hypertarget{classseq_1_1deque_ace22814e8935b68260d2df2b0e9a69ee}\label{classseq_1_1deque_ace22814e8935b68260d2df2b0e9a69ee}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!end@{end}}
\index{end@{end}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{end()}{end()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the element following the last element of the deque. 

\mbox{\Hypertarget{classseq_1_1deque_a3009be4be5c7c3df7138ce2828284d10}\label{classseq_1_1deque_a3009be4be5c7c3df7138ce2828284d10}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!end@{end}}
\index{end@{end}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{end()}{end()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the element following the last element of the deque. 

\mbox{\Hypertarget{classseq_1_1deque_a6356d51874581e77564b790d3070ed0c}\label{classseq_1_1deque_a6356d51874581e77564b790d3070ed0c}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!erase@{erase}}
\index{erase@{erase}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}}]{first,  }\item[{\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes the elements in the range \mbox{[}first, last). 


\begin{DoxyParams}{Parameters}
{\em first} & iterator to the first element to erase \\
\hline
{\em last} & iterator to the last (excluded) element to erase \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Iterator following the last removed element. Basic exception guarantee. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_a470a94fb88af238e6d61a48ef507be12}\label{classseq_1_1deque_a470a94fb88af238e6d61a48ef507be12}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!erase@{erase}}
\index{erase@{erase}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}}]{it }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Erase element at given position. 


\begin{DoxyParams}{Parameters}
{\em it} & iterator to the element to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator following the last removed element Basic exception guarantee. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_a722457938d178ab2f99f2dac1b685945}\label{classseq_1_1deque_a722457938d178ab2f99f2dac1b685945}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!erase@{erase}}
\index{erase@{erase}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{first,  }\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes the elements in the range \mbox{[}first, last). 


\begin{DoxyParams}{Parameters}
{\em first} & absolute position of the first element to erase \\
\hline
{\em last} & absolute position of the last (excluded) element to erase Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_ad972f18dac66aea6d0a3748ffc06979f}\label{classseq_1_1deque_ad972f18dac66aea6d0a3748ffc06979f}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!erase@{erase}}
\index{erase@{erase}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Erase element at given position. 


\begin{DoxyParams}{Parameters}
{\em pos} & absolute position of the element to erase Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a301b9415b79b787de33e29f15f0ceb7c}\label{classseq_1_1deque_a301b9415b79b787de33e29f15f0ceb7c}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!for\_each@{for\_each}}
\index{for\_each@{for\_each}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{for\_each()}{for\_each()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class Fun $>$ \\
Fun \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::for\+\_\+each (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{first,  }\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{last,  }\item[{Fun}]{fun }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Apply unary function {\itshape fun} to all elements within the range \mbox{[}first,last). 


\begin{DoxyTemplParams}{Template Parameters}
{\em Fun} & unary functor type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em first} & first element of the range to apply the functor {\itshape fun} \\
\hline
{\em last} & end of range \\
\hline
{\em fun} & unary functor of lambda function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the unary functor (usefull for statefull functors). Using for\+\_\+each is faster than walking through iterators as it uses the internal knowledge on bucket layout to fasten step increments. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_a0c4ff3ed240b474c92ee870addfd02fc}\label{classseq_1_1deque_a0c4ff3ed240b474c92ee870addfd02fc}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!for\_each@{for\_each}}
\index{for\_each@{for\_each}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{for\_each()}{for\_each()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class Fun $>$ \\
Fun \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::for\+\_\+each (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{first,  }\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{last,  }\item[{Fun}]{fun }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Apply unary function {\itshape fun} to all elements within the range \mbox{[}first,last). 


\begin{DoxyTemplParams}{Template Parameters}
{\em Fun} & unary functor type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em first} & first element of the range to apply the functor {\itshape fun} \\
\hline
{\em last} & end of range \\
\hline
{\em fun} & unary functor of lambda function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the unary functor (usefull for statefull functors). Using for\+\_\+each is faster than walking through iterators as it uses the internal knowledge on bucket layout to fasten step increments. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_af223de620baf1912e6b68bed7ffecfbd}\label{classseq_1_1deque_af223de620baf1912e6b68bed7ffecfbd}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!front@{front}}
\index{front@{front}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{front()}{front()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::front (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reference to the first element in the container. 

\mbox{\Hypertarget{classseq_1_1deque_a6a0e9f55bdfb07b3a83bb29bfe175814}\label{classseq_1_1deque_a6a0e9f55bdfb07b3a83bb29bfe175814}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!front@{front}}
\index{front@{front}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{front()}{front()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::front (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reference to the first element in the container. 

\mbox{\Hypertarget{classseq_1_1deque_a341110a6075e758aec7c369958434059}\label{classseq_1_1deque_a341110a6075e758aec7c369958434059}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
const Allocator\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the allocator associated with the container. 

\mbox{\Hypertarget{classseq_1_1deque_a77406df7887444866057c00b9f9d1b84}\label{classseq_1_1deque_a77406df7887444866057c00b9f9d1b84}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
Allocator\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the allocator associated with the container. 

\mbox{\Hypertarget{classseq_1_1deque_ad967349f51c9d609c39ac4a605e816ae}\label{classseq_1_1deque_ad967349f51c9d609c39ac4a605e816ae}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}}]{it,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Insert {\itshape value} before {\itshape it}. 


\begin{DoxyParams}{Parameters}
{\em it} & iterator within the deque \\
\hline
{\em value} & element to insert Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_aaa28cfd55c0dc7e96d4d06d9cf6b89a2}\label{classseq_1_1deque_aaa28cfd55c0dc7e96d4d06d9cf6b89a2}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class Iter $>$ \\
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}}]{it,  }\item[{Iter}]{first,  }\item[{Iter}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements from range \mbox{[}first, last) before it. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Iter} & iterator type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em it} & iterator within the deque \\
\hline
{\em first} & first iterator of the range \\
\hline
{\em last} & last iterator of the range \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Iterator pointing to the first element inserted, or it if first==last Basic exception guarantee. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_acfe8b48223f0dfc13c3a91abfbe31b6b}\label{classseq_1_1deque_acfe8b48223f0dfc13c3a91abfbe31b6b}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [3/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}}]{it,  }\item[{T \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Insert {\itshape value} before {\itshape it} using move semantic. 


\begin{DoxyParams}{Parameters}
{\em it} & iterator within the deque \\
\hline
{\em value} & element to insert Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a30fdb06c5a4f4a7892630716ccd5400a}\label{classseq_1_1deque_a30fdb06c5a4f4a7892630716ccd5400a}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [4/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}}]{pos,  }\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{count,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts count copies of the value before pos. 

\begin{DoxyReturn}{Returns}
Iterator pointing to the first element inserted, or it if count==0 Basic exception guarantee. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_a2202a3b1249440c7f6a031a9d8b955f0}\label{classseq_1_1deque_a2202a3b1249440c7f6a031a9d8b955f0}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [5/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}}}]{pos,  }\item[{std\+::initializer\+\_\+list$<$ T $>$}]{ilist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements from initializer list ilist before pos. 

\begin{DoxyReturn}{Returns}
Iterator pointing to the first element inserted, or it if first==last. Basic exception guarantee. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_a2f41761b1626d06ac2616f9f84f4c133}\label{classseq_1_1deque_a2f41761b1626d06ac2616f9f84f4c133}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [6/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Insert {\itshape value} before {\itshape pos}. 


\begin{DoxyParams}{Parameters}
{\em pos} & absolute position within the deque \\
\hline
{\em value} & element to insert Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a58ac8b3765950bb1a42f0203e392f313}\label{classseq_1_1deque_a58ac8b3765950bb1a42f0203e392f313}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [7/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class Iter $>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos,  }\item[{Iter}]{first,  }\item[{Iter}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements from range \mbox{[}first, last) before pos. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Iter} & iterator type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pos} & absolute position within the deque \\
\hline
{\em first} & first iterator of the range \\
\hline
{\em last} & last iterator of the range Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a66d1a767786c2f2e1cec17baa32c28a4}\label{classseq_1_1deque_a66d1a767786c2f2e1cec17baa32c28a4}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [8/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos,  }\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{count,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts count copies of the value before pos Basic exception guarantee. ~\newline
 

\mbox{\Hypertarget{classseq_1_1deque_ac2c78f7740fb0a7437df74139546e837}\label{classseq_1_1deque_ac2c78f7740fb0a7437df74139546e837}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [9/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos,  }\item[{std\+::initializer\+\_\+list$<$ T $>$}]{ilist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements from initializer list ilist before pos. 

\begin{DoxyReturn}{Returns}
Iterator pointing to the first element inserted, or it if first==last. Basic exception guarantee. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_ab3f8fbcf9b33523e8a4be313fe56ce0c}\label{classseq_1_1deque_ab3f8fbcf9b33523e8a4be313fe56ce0c}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!insert@{insert}}
\index{insert@{insert}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [10/10]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos,  }\item[{T \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Insert {\itshape value} before {\itshape pos} using move semantic. 


\begin{DoxyParams}{Parameters}
{\em pos} & absolute position within the deque \\
\hline
{\em value} & element to insert Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a07c742f00582a04ebde4500c182f7d30}\label{classseq_1_1deque_a07c742f00582a04ebde4500c182f7d30}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!iterator\_at@{iterator\_at}}
\index{iterator\_at@{iterator\_at}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{iterator\_at()}{iterator\_at()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a33aa4d29ac3235a3e39c4e4ba4b7e8aa}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::iterator\+\_\+at (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a const\+\_\+iterator to given absolute position. This is slightly faster than \mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}}+pos. 

\mbox{\Hypertarget{classseq_1_1deque_a8ada35adcc56bcc7921ca4c7df077ded}\label{classseq_1_1deque_a8ada35adcc56bcc7921ca4c7df077ded}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!iterator\_at@{iterator\_at}}
\index{iterator\_at@{iterator\_at}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{iterator\_at()}{iterator\_at()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a26cf9da97c50a252516996ae1f7f2acc}{iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::iterator\+\_\+at (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to given absolute position. This is slightly faster than \mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}}+pos. 

\mbox{\Hypertarget{classseq_1_1deque_a37f347ccd00402dbcebaa9d9f3e97126}\label{classseq_1_1deque_a37f347ccd00402dbcebaa9d9f3e97126}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!lower\_bound@{lower\_bound}}
\index{lower\_bound@{lower\_bound}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{lower\_bound()}{lower\_bound()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class U , class Less  = std\+::less$<$\+T$>$$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::lower\+\_\+bound (\begin{DoxyParamCaption}\item[{const U \&}]{value,  }\item[{const Less \&}]{le = {\ttfamily Less()} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Optimized version of std\+::lower\+\_\+bound(\mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}},\mbox{\hyperlink{classseq_1_1deque_a3009be4be5c7c3df7138ce2828284d10}{end()}},value,le); Only works for sorted deque. 

\mbox{\Hypertarget{classseq_1_1deque_afecc70047ddfb65d9b0d37501a1db9cd}\label{classseq_1_1deque_afecc70047ddfb65d9b0d37501a1db9cd}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!manager@{manager}}
\index{manager@{manager}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{manager()}{manager()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
const \mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}}$\ast$ \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::manager (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the internal bucket manager object. 

\mbox{\Hypertarget{classseq_1_1deque_a79daf1947e65162d94d50a60cd4761c4}\label{classseq_1_1deque_a79daf1947e65162d94d50a60cd4761c4}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!manager@{manager}}
\index{manager@{manager}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{manager()}{manager()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_ab7d8ba27147a4e824b0714d584bc2555}{bucket\+\_\+manager}}$\ast$ \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::manager (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the internal bucket manager object. 

\mbox{\Hypertarget{classseq_1_1deque_a3221e376dd28de949efe7d8d20c3e8fb}\label{classseq_1_1deque_a3221e376dd28de949efe7d8d20c3e8fb}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!max\_size@{max\_size}}
\index{max\_size@{max\_size}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{max\_size()}{max\_size()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::max\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the container maximum size. 

\mbox{\Hypertarget{classseq_1_1deque_a1f03b2bd65988d8fdac77a8e80cbdf36}\label{classseq_1_1deque_a1f03b2bd65988d8fdac77a8e80cbdf36}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!operator=@{operator=}}
\index{operator=@{operator=}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{deque}}\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1deque}{deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy assignment operator. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to use as data source \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to this 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_af909cbb794747e1eabe9a1beb474d2bf}\label{classseq_1_1deque_af909cbb794747e1eabe9a1beb474d2bf}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!operator=@{operator=}}
\index{operator=@{operator=}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque}{deque}}\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque}{deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Move assignment operator. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to use as data source \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to this 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1deque_a1da93d7f24768a8f3b881efb2a2ad162}\label{classseq_1_1deque_a1da93d7f24768a8f3b881efb2a2ad162}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reference to the element at specified location pos, without bounds checking. 

\mbox{\Hypertarget{classseq_1_1deque_a77b2976e01941baa9400c1111c1cc3bf}\label{classseq_1_1deque_a77b2976e01941baa9400c1111c1cc3bf}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T\& \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reference to the element at specified location pos, without bounds checking. 

\mbox{\Hypertarget{classseq_1_1deque_a45c749a8706927412d28d950bfa3e206}\label{classseq_1_1deque_a45c749a8706927412d28d950bfa3e206}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!pop\_back@{pop\_back}}
\index{pop\_back@{pop\_back}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{pop\_back()}{pop\_back()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::pop\+\_\+back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes the last element of the container. Calling pop\+\_\+back on an empty container results in undefined behavior. Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). 

\mbox{\Hypertarget{classseq_1_1deque_a377cf60662942fa5d286871934e280dd}\label{classseq_1_1deque_a377cf60662942fa5d286871934e280dd}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!pop\_front@{pop\_front}}
\index{pop\_front@{pop\_front}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{pop\_front()}{pop\_front()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::pop\+\_\+front (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes the first element of the container. Calling pop\+\_\+front on an empty container results in undefined behavior. Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). 

\mbox{\Hypertarget{classseq_1_1deque_a414633a9f528db23bce8e1567b894719}\label{classseq_1_1deque_a414633a9f528db23bce8e1567b894719}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends the given element value to the end of the container. 


\begin{DoxyParams}{Parameters}
{\em value} & the value of the element to append Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a0cdae82b8bbb44d8bc55c7e3c45c540d}\label{classseq_1_1deque_a0cdae82b8bbb44d8bc55c7e3c45c540d}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{T \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends the given element value to the end of the container using move semantic. 


\begin{DoxyParams}{Parameters}
{\em value} & the value of the element to append Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a43cf34c3e8a456b45ad4a6914d05c269}\label{classseq_1_1deque_a43cf34c3e8a456b45ad4a6914d05c269}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!push\_front@{push\_front}}
\index{push\_front@{push\_front}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{push\_front()}{push\_front()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::push\+\_\+front (\begin{DoxyParamCaption}\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends the given element value to the beginning of the container. 


\begin{DoxyParams}{Parameters}
{\em value} & the value of the element to append Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a463357d654a8e621c2d668f4be762999}\label{classseq_1_1deque_a463357d654a8e621c2d668f4be762999}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!push\_front@{push\_front}}
\index{push\_front@{push\_front}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{push\_front()}{push\_front()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::push\+\_\+front (\begin{DoxyParamCaption}\item[{T \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Appends the given element value to the beginning of the container using move semantic. 


\begin{DoxyParams}{Parameters}
{\em value} & the value of the element to append Basic exception guarantee, except if {\itshape Min\+B\+Size == Max\+B\+Size} (strong guarantee in this case). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a490292dd996a977094eafcd4652e11a9}\label{classseq_1_1deque_a490292dd996a977094eafcd4652e11a9}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{rbegin()}{rbegin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the first element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1deque_a189a81122365b6e1ee0fc47d2688d19c}\label{classseq_1_1deque_a189a81122365b6e1ee0fc47d2688d19c}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{rbegin()}{rbegin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a14115e561acf8848747c6e7661c4800d}{reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the first element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1deque_a9b56c4660ca7cbfa295ac13af609db12}\label{classseq_1_1deque_a9b56c4660ca7cbfa295ac13af609db12}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!rend@{rend}}
\index{rend@{rend}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{rend()}{rend()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a4bb9e145b4cc3ab0203afb6b5dfffa1e}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the element following the last element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1deque_a3e80a5e705d79bd934a5fe24e258db95}\label{classseq_1_1deque_a3e80a5e705d79bd934a5fe24e258db95}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!rend@{rend}}
\index{rend@{rend}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{rend()}{rend()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1deque_a14115e561acf8848747c6e7661c4800d}{reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the element following the last element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1deque_afb7676de11f1c09c7b8cea6ddb960a5c}\label{classseq_1_1deque_afb7676de11f1c09c7b8cea6ddb960a5c}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!resize@{resize}}
\index{resize@{resize}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Resizes the container to contain count elements. 


\begin{DoxyParams}{Parameters}
{\em count} & new size of the container If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-\/inserted elements are appended. Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a1771d81b89d110c367d2348755d5b34c}\label{classseq_1_1deque_a1771d81b89d110c367d2348755d5b34c}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!resize@{resize}}
\index{resize@{resize}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{count,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Resizes the container to contain count elements. 


\begin{DoxyParams}{Parameters}
{\em count} & new size of the container \\
\hline
{\em value} & the value to initialize the new elements with If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of value are appended. Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_af9ec5ae83e62226daed9376a36c7441b}\label{classseq_1_1deque_af9ec5ae83e62226daed9376a36c7441b}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!resize\_front@{resize\_front}}
\index{resize\_front@{resize\_front}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{resize\_front()}{resize\_front()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::resize\+\_\+front (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Resizes the container to contain count elements. 


\begin{DoxyParams}{Parameters}
{\em count} & new size of the container If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional default-\/inserted elements are prepended. Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a9ff00f12899037caada678a1a219bbb9}\label{classseq_1_1deque_a9ff00f12899037caada678a1a219bbb9}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!resize\_front@{resize\_front}}
\index{resize\_front@{resize\_front}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{resize\_front()}{resize\_front()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::resize\+\_\+front (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}}}]{count,  }\item[{const T \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Resizes the container to contain count elements. 


\begin{DoxyParams}{Parameters}
{\em count} & new size of the container \\
\hline
{\em value} & the value to initialize the new elements with If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional copies of value are prepended. Basic exception guarantee. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a77c84fc9fed752a27ced1e18d0f606a3}\label{classseq_1_1deque_a77c84fc9fed752a27ced1e18d0f606a3}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!shrink\_to\_fit@{shrink\_to\_fit}}
\index{shrink\_to\_fit@{shrink\_to\_fit}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{shrink\_to\_fit()}{shrink\_to\_fit()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::shrink\+\_\+to\+\_\+fit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Release all unused memory, and move the deque content to the smallest possible storage. This function only makes sense for {\itshape Optimize\+For\+Speed} flag. Invalidate all iterators and references. 

\mbox{\Hypertarget{classseq_1_1deque_a71556fb0d3f4c3b265893c55928b493a}\label{classseq_1_1deque_a71556fb0d3f4c3b265893c55928b493a}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!size@{size}}
\index{size@{size}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
\mbox{\hyperlink{classseq_1_1deque_a480ffd160d8d2e3c32b241fa0eb3cefc}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the container size. 

\mbox{\Hypertarget{classseq_1_1deque_a874f1f1b57d0334da07ed3bd14377d7e}\label{classseq_1_1deque_a874f1f1b57d0334da07ed3bd14377d7e}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!swap@{swap}}
\index{swap@{swap}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
void \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1deque}{deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. 


\begin{DoxyParams}{Parameters}
{\em other} & other sequence to swap with All iterators and references remain valid. An iterator holding the past-\/the-\/end value in this container will refer to the other container after the operation. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1deque_a59cc73e8bf0ba9a691e80e3a8a34690a}\label{classseq_1_1deque_a59cc73e8bf0ba9a691e80e3a8a34690a}} 
\index{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}!upper\_bound@{upper\_bound}}
\index{upper\_bound@{upper\_bound}!seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$@{seq::deque$<$ T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare $>$}}
\doxysubsubsection{\texorpdfstring{upper\_bound()}{upper\_bound()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, Layout\+Management layout = Optimize\+For\+Speed, unsigned Min\+B\+Size = S\+E\+Q\+\_\+\+M\+I\+N\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+Z\+E(\+T), unsigned Max\+B\+Size = S\+E\+Q\+\_\+\+M\+A\+X\+\_\+\+B\+U\+C\+K\+E\+T\+\_\+\+S\+I\+ZE, class Find\+B\+Size  = detail\+::\+Find\+Bucket\+Size$<$\+T$>$, bool Store\+Back\+Values = false, class Value\+Compare  = detail\+::\+Null\+Value\+Compare$<$\+T$>$$>$ \\
template$<$class U , class Less  = std\+::less$<$\+T$>$$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1deque}{seq\+::deque}}$<$ T, Allocator, layout, Min\+B\+Size, Max\+B\+Size, Find\+B\+Size, Store\+Back\+Values, Value\+Compare $>$\+::upper\+\_\+bound (\begin{DoxyParamCaption}\item[{const U \&}]{value,  }\item[{const Less \&}]{le = {\ttfamily Less()} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Optimized version of std\+::upper\+\_\+bound(\mbox{\hyperlink{classseq_1_1deque_ac3ffce89982e8060bbc5f20011c6a7ba}{begin()}},\mbox{\hyperlink{classseq_1_1deque_a3009be4be5c7c3df7138ce2828284d10}{end()}},value,le); Only works for sorted deque. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
seq/\mbox{\hyperlink{deque_8hpp}{deque.\+hpp}}\end{DoxyCompactItemize}
