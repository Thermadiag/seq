\hypertarget{classseq_1_1flat__set}{}\doxysection{seq\+::flat\+\_\+set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$ Class Template Reference}
\label{classseq_1_1flat__set}\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}


flat sorted container similar to boost\+::flat\+\_\+set with faster insertion/deletion of single values  




{\ttfamily \#include $<$flat\+\_\+map.\+hpp$>$}

\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Random access const iterator class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}{deque\+\_\+type}} = typename \mbox{\hyperlink{structseq_1_1detail_1_1flat__tree_a206db35a1c2d1065d811172700f3518d}{flat\+\_\+tree\+\_\+type\+::deque\+\_\+type}}
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} = \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a95c948977310c47866584a268790a6f0}{key\+\_\+type}} = Key
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} = Key
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a9d8481828c9f2f74c4e061acfdc1e02a}{difference\+\_\+type}} = typename std\+::allocator\+\_\+traits$<$ Allocator $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a9d8481828c9f2f74c4e061acfdc1e02a}{difference\+\_\+type}}
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}} = typename std\+::allocator\+\_\+traits$<$ Allocator $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a0a1d4b80fd721e98fd252d5f2dbc674d}{key\+\_\+compare}} = Compare
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a45e750bb1eb6ece2521d164c022287d7}{allocator\+\_\+type}} = Allocator
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a3dac755c1568229cf24798257217d0b3}{reference}} = Key \&
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_ac3aa14284b49ee04935c41c6e8c01a55}{const\+\_\+reference}} = const Key \&
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a32c4082dfe9ef37b2894e9a785830887}{pointer}} = typename std\+::allocator\+\_\+traits$<$ Allocator $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a32c4082dfe9ef37b2894e9a785830887}{pointer}}
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_ac56ed1e8f1b1fee2c4f8a26f16969210}{const\+\_\+pointer}} = typename std\+::allocator\+\_\+traits$<$ Allocator $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_ac56ed1e8f1b1fee2c4f8a26f16969210}{const\+\_\+pointer}}
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_aa005e31dc3f4c6de57c78c08579c0350}{reverse\+\_\+iterator}} = std\+::reverse\+\_\+iterator$<$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} $>$
\item 
using \mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}} = std\+::reverse\+\_\+iterator$<$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} $>$
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classseq_1_1flat__set_af28779bd30528cfb05dbdd6738a5e230}{flat\+\_\+set}} ()
\begin{DoxyCompactList}\small\item\em Default constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1flat__set_a43495f719ac2a6337b70580292767eab}{flat\+\_\+set}} (const Compare \&comp, const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Construct from comparator function and optional allocator object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1flat__set_a96ca0e8e62ba5e2400f60678eb8e038f}{flat\+\_\+set}} (const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Construct from allocator object. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+It $>$ }\\\mbox{\hyperlink{classseq_1_1flat__set_ab3e6b15d9f9e06b35f91e61f35f73862}{flat\+\_\+set}} (Input\+It first, Input\+It last, const Compare \&comp=Compare(), const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Range constructor. Constructs the container with the contents of the range \mbox{[}first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+It $>$ }\\\mbox{\hyperlink{classseq_1_1flat__set_a5e37d39789987ad2558c9c44ed3d0785}{flat\+\_\+set}} (Input\+It first, Input\+It last, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Range constructor. Constructs the container with the contents of the range \mbox{[}first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1flat__set_a55ba984f81b0db26a01612988d610318}{flat\+\_\+set}} (const \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1flat__set_a6ebb1cbcd91fd9baf92dd692511796b0}{flat\+\_\+set}} (const \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&other, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1flat__set_a0a5ef5410087dbbfac294b6c3863838f}{flat\+\_\+set}} (\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-\/construction from the allocator belonging to other. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1flat__set_ab7a6058962930dd09aa6f7f1579d266e}{flat\+\_\+set}} (\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&\&other, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-\/construction from the allocator belonging to other. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1flat__set_a834fe917b40b91a984b0b6e6a873fb77}{flat\+\_\+set}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} $>$ init, const Compare \&comp=Compare(), const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em Initializer-\/list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1flat__set_ad129f6187e0badecbcf74e653813b751}{flat\+\_\+set}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} $>$ init, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Initializer-\/list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classseq_1_1flat__set_a38730475abb8a0a31dcc8674ec8712a3}{operator=}} (\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&\&other) noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&
\begin{DoxyCompactList}\small\item\em Move assignment operator. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classseq_1_1flat__set_a85c5d9440fe54481bdd8db47a0c4256a}{operator=}} (const \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&other) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&
\begin{DoxyCompactList}\small\item\em Copy operator. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classseq_1_1flat__set_aad22c9c9dad8a9720aa3c1f6dee76430}{operator=}} (const std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} $>$ \&init) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&
\begin{DoxyCompactList}\small\item\em Assign initializer-\/list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a050ce6bc5285419473b22f7aade304ae}{get\+\_\+allocator}} () const noexcept -\/$>$ Allocator
\begin{DoxyCompactList}\small\item\em Returns container\textquotesingle{}s allocator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_ab2096ed6a791d86016655b8ea6806405}{empty}} () const noexcept -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Returns true if container is empty, false otherwise. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}{size}} () const noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Returns the container size. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_aa85b0206e6306dc533f30c34dd55a065}{max\+\_\+size}} () const noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Returns the container maximum size. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set_af48d76f5df8ae9b333e7d947e7132505}{clear}} () noexcept
\begin{DoxyCompactList}\small\item\em Clears the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set_a145a8c0071d070fc5f1f4ceb03bb595e}{swap}} (\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} \&other) noexcept
\begin{DoxyCompactList}\small\item\em Swap this container\textquotesingle{}s content with another. Iterators to both containers remain valid, including end iterators. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a62f600b3a19bfeb5bb3515a915f184f7}{tvector}} () noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}{deque\+\_\+type}} \&
\begin{DoxyCompactList}\small\item\em Returns the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}. Calling this function will mark the container as dirty. Any further attempts to call members like \mbox{\hyperlink{classseq_1_1flat__set_ab57074210e38022bdea1e1d34eaea124}{find()}}, lower\+\_\+bound, upper\+\_\+bound... will raise a std\+::logic\+\_\+error. To mark the container as non dirty anymore, the user must call \mbox{\hyperlink{classseq_1_1flat__set_aed2aa28ae90743b550fd6543126d6138}{flat\+\_\+set\+::sort()}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_af71e0e9ba96e3cb66048659fa6af5dd2}{tvector}} () const noexcept -\/$>$ const \mbox{\hyperlink{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}{deque\+\_\+type}} \&
\begin{DoxyCompactList}\small\item\em Returns a const reference to the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}. The container will N\+OT be marked as dirty. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a5d89147ce2a02f2054ee1441f827b329}{ctvector}} () const noexcept -\/$>$ const \mbox{\hyperlink{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}{deque\+\_\+type}} \&
\begin{DoxyCompactList}\small\item\em Returns a const reference to the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}. The container will N\+OT be marked as dirty. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a1d303585e85156afba2c58aafab309a4}{insert}} (const \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&value) -\/$>$ std\+::pair$<$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, bool $>$
\begin{DoxyCompactList}\small\item\em See std\+::set\+::insert. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_ab40f91951dc0cffa782856434f3d98e3}{insert}} (\mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&\&value) -\/$>$ std\+::pair$<$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, bool $>$
\begin{DoxyCompactList}\small\item\em See std\+::set\+::insert. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_abcb5126c808ca716db9fd0e3d4e306b7}{insert\+\_\+pos}} (const \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&value) -\/$>$ std\+::pair$<$ size\+\_\+t, bool $>$
\begin{DoxyCompactList}\small\item\em Same as \mbox{\hyperlink{classseq_1_1flat__set_a1d303585e85156afba2c58aafab309a4}{insert()}}, but returns the inserted object position instead of iterator (or \mbox{\hyperlink{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}{size()}} if no element was inserted). \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a9a413bfa23fb123841f4c0b7c3e045cd}{insert\+\_\+pos}} (\mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&\&value) -\/$>$ std\+::pair$<$ size\+\_\+t, bool $>$
\begin{DoxyCompactList}\small\item\em Same as \mbox{\hyperlink{classseq_1_1flat__set_a1d303585e85156afba2c58aafab309a4}{insert()}}, but returns the inserted object position instead of iterator (or \mbox{\hyperlink{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}{size()}} if no element was inserted). \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a7e7400d10c6be9c84e4302950a039a48}{emplace}} (Args \&\&... args) -\/$>$ std\+::pair$<$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, bool $>$
\begin{DoxyCompactList}\small\item\em See std\+::set\+::emplace(). \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a6758b8d25da755df20ab3f5cfa56bc30}{emplace\+\_\+pos}} (Args \&\&... args) -\/$>$ std\+::pair$<$ size\+\_\+t, bool $>$
\begin{DoxyCompactList}\small\item\em Same as \mbox{\hyperlink{classseq_1_1flat__set_a7e7400d10c6be9c84e4302950a039a48}{emplace()}}, but returns the inserted object position instead of iterator (or \mbox{\hyperlink{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}{size()}} if no element was inserted). \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a58d3bc87ac76060a64df3cff86de25c1}{emplace\+\_\+hint}} (\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} hint, Args \&\&... args) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Same as std\+::set\+::emplace\+\_\+hint. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_ae026ff05db15ce89a04df42942a73505}{insert}} (\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} hint, const \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&value) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Same as std\+::set\+::insert() \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a71768fa11e840ccf87e601102e4355ce}{insert}} (\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} hint, \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&\&value) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Same as std\+::set\+::insert() \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+It $>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set_a370336c5106645ee45fec8a2a26eadc4}{insert}} (Input\+It first, Input\+It last)
\begin{DoxyCompactList}\small\item\em Inserts elements from range \mbox{[}first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range \mbox{[}first, last) is roughly equal or greater than the container\textquotesingle{}s size, this function is much faster than inserting elements one by one. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set_ace98a525dfd46ea113f9f151c63f2411}{insert}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} $>$ ilist)
\begin{DoxyCompactList}\small\item\em Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Iter $>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set_ae51062a09feb26117423c5e2637cdd91}{assign}} (Iter first, Iter last)
\begin{DoxyCompactList}\small\item\em Assign the content of the range \mbox{[}first, last) to this container, discarding previous values. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set_aa211185e183f54d722afea2e38769f6b}{erase\+\_\+pos}} (\mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1flat__set_a0c36b1aaec8f9d12343152213a4789ad}{pos}})
\begin{DoxyCompactList}\small\item\em Erase element at given position in the container. This is slightly faster than calling \mbox{\hyperlink{classseq_1_1flat__set_a5bb1e814df180dd44a0032b877e823df}{erase(iterator)}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a5bb1e814df180dd44a0032b877e823df}{erase}} (\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1flat__set_a0c36b1aaec8f9d12343152213a4789ad}{pos}}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Erase element at given location. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a9fb8322374785d7c6dc51938a16e13ce}{erase}} (\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} first, \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} last) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Erase elements in the range \mbox{[}first, last) \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set_aaf5bf6cec1d8e7106f6c34a5cae2850e}{erase}} (size\+\_\+t first, size\+\_\+t last)
\begin{DoxyCompactList}\small\item\em Erase elements in the range \mbox{[}first, last) \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a81b66ef1a67458556d4a8573cc2d7862}{erase}} (const K \&key) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Removes the element (if one exists) with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type, and neither iterator nor \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} is implicitly convertible from K. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a769ae39fe7a3aabb03bc9eba700081eb}{erase}} (const Key \&key) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Removes the element (if one exists) with the key equivalent to key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_ab57074210e38022bdea1e1d34eaea124}{find}} (const K \&key) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a9edc18a9b502e44daf57d8343e249994}{find}} (const Key \&key) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Finds an element with key equivalent to key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a6c519766a4d8b7c1e16a91e9347fa6d6}{find}} (const K \&key) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_ae8e1aeb2634304ff1c1bf26a0107d918}{find}} (const Key \&x) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Finds an element with key equivalent to key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_ab9949c1ca56b3124db9bffd2581bdbce}{find\+\_\+pos}} (const K \&key) const -\/$>$ size\+\_\+t
\begin{DoxyCompactList}\small\item\em Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_ae3b92a2a8e8a39936d16846c2f12dcf8}{find\+\_\+pos}} (const Key \&x) const -\/$>$ size\+\_\+t
\begin{DoxyCompactList}\small\item\em Finds an element with key equivalent to key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a0c36b1aaec8f9d12343152213a4789ad}{pos}} (size\+\_\+t i) const noexcept -\/$>$ const \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&
\begin{DoxyCompactList}\small\item\em Returns value at given flat position. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{lower\+\_\+bound}} (const K \&key) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator pointing to the first element that compares not less (i.\+e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a629a2e5125b9141860aed25f26ea9a53}{lower\+\_\+bound}} (const Key \&key) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator pointing to the first element that is not less than (i.\+e. greater or equal to) key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_af8ac90f96ae7a84fba51fbe80fec29b8}{lower\+\_\+bound}} (const K \&key) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator pointing to the first element that compares not less (i.\+e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a23b604bc495608e02a17696fed13493d}{lower\+\_\+bound}} (const Key \&key) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator pointing to the first element that is not less than (i.\+e. greater or equal to) key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_abaab3b186746f31c608223d263a337d3}{lower\+\_\+bound\+\_\+pos}} (const K \&key) const -\/$>$ size\+\_\+t
\begin{DoxyCompactList}\small\item\em Returns the position of the first element that compares not less (i.\+e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_af6077925167e63133dccb4590e93d2df}{lower\+\_\+bound\+\_\+pos}} (const Key \&key) const -\/$>$ size\+\_\+t
\begin{DoxyCompactList}\small\item\em Returns the position of the first element that is not less than (i.\+e. greater or equal to) key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}{upper\+\_\+bound}} (const K \&key) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a2bee27bd128f6aefc76bd804a083aa55}{upper\+\_\+bound}} (const Key \&key) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator pointing to the first element that is greater than key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_ac41bad49d5d46802758f61ec0e1b74ae}{upper\+\_\+bound}} (const K \&key) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a8a85ecad5fd863135883a958f5e02f52}{upper\+\_\+bound}} (const Key \&key) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator pointing to the first element that is greater than key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a157af0b66ff9eb5a8892a052b5437039}{upper\+\_\+bound\+\_\+pos}} (const K \&key) const -\/$>$ size\+\_\+t
\begin{DoxyCompactList}\small\item\em Returns the position of the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a9032ec73505dff2edef68f48b8867e5c}{upper\+\_\+bound\+\_\+pos}} (const Key \&key) const -\/$>$ size\+\_\+t
\begin{DoxyCompactList}\small\item\em Returns the position of the first element that is greater than key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a9f918ac2c34f0fc4ad9bad3cd6ea8020}{contains}} (const K \&key) const -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Checks if there is an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a322fde5fca97a0c3da93f391d2809d11}{contains}} (const Key \&key) const -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Checks if there is an element with key equivalent to key in the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_aed5760dc699ac86f0faf0900ab6d1cc1}{count}} (const K \&key) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Returns the number of elements with key key (either 1 or 0 for \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} and \mbox{\hyperlink{classseq_1_1flat__map}{flat\+\_\+map}}). This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a0108b61136b039802e0a5d630b528ba7}{count}} (const Key \&key) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Returns the number of elements with key key (either 1 or 0 for \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} and \mbox{\hyperlink{classseq_1_1flat__map}{flat\+\_\+map}}). \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a335c56f73beb14db8a2533352f53ad9d}{equal\+\_\+range}} (const K \&key) -\/$>$ std\+::pair$<$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} $>$
\begin{DoxyCompactList}\small\item\em Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{lower\+\_\+bound()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}{upper\+\_\+bound()}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_abf33465b2705df1b6b8063bd89822610}{equal\+\_\+range}} (const Key \&key) -\/$>$ std\+::pair$<$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} $>$
\begin{DoxyCompactList}\small\item\em Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{lower\+\_\+bound()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}{upper\+\_\+bound()}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a1e81e0e8b7082f46c5dd53a189ed6a04}{equal\+\_\+range}} (const K \&key) const -\/$>$ std\+::pair$<$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}, \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} $>$
\begin{DoxyCompactList}\small\item\em Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{lower\+\_\+bound()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}{upper\+\_\+bound()}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a1873a004bfa957a6454704e2f8ab91cc}{equal\+\_\+range}} (const Key \&key) const -\/$>$ std\+::pair$<$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}, \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} $>$
\begin{DoxyCompactList}\small\item\em Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{lower\+\_\+bound()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}{upper\+\_\+bound()}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a43a4cceb7d0c71e85df8f532ba8eaf6f}{equal\+\_\+range\+\_\+pos}} (const K \&key) const -\/$>$ std\+::pair$<$ size\+\_\+t, size\+\_\+t $>$
\begin{DoxyCompactList}\small\item\em Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_abaab3b186746f31c608223d263a337d3}{lower\+\_\+bound\+\_\+pos()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a157af0b66ff9eb5a8892a052b5437039}{upper\+\_\+bound\+\_\+pos()}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a3dc1702bfbf2b5fb80fde4a68c604564}{equal\+\_\+range\+\_\+pos}} (const Key \&key) const -\/$>$ std\+::pair$<$ size\+\_\+t, size\+\_\+t $>$
\begin{DoxyCompactList}\small\item\em Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_abaab3b186746f31c608223d263a337d3}{lower\+\_\+bound\+\_\+pos()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a157af0b66ff9eb5a8892a052b5437039}{upper\+\_\+bound\+\_\+pos()}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class C2 , Layout\+Management layout2$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set_ad53ba988a2774436198f857105de9969}{merge}} (\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}$<$ Key, C2, Allocator, layout2 $>$ \&source)
\begin{DoxyCompactList}\small\item\em Attempts to extract each element in source and insert it into this using the comparison object of this. If there is an element in this with key equivalent to the key of an element from source, then that element is not extracted from source. Note that elements from source are moved to this. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a2e0ae68bbfdd65d872ced19448211dc6}{begin}} () noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a6fce030fb400220bed09cc61e5481660}{begin}} () const noexcept -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_aa31bc4f93192298eae80d450128f19fe}{cbegin}} () const noexcept -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a24c05caf75cab36a9867f327b36a0e1a}{end}} () noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a6ac3bfe3b3689202b76363abab0c2b22}{end}} () const noexcept -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a45a2f7b8e1111e564d7a697fcc636ae4}{cend}} () const noexcept -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a08f8f14f5d3939b85d73bfd33ff18b6b}{rbegin}} () noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_aa005e31dc3f4c6de57c78c08579c0350}{reverse\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a6ca9925da3e6ac9e5892a29dc9ac49b2}{rbegin}} () const noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a888df9ed8978abe58fd4d244177caf91}{crbegin}} () const noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a05da8c9d8495c529c8487b3f4a8cc724}{rend}} () noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_aa005e31dc3f4c6de57c78c08579c0350}{reverse\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a3e186cc2c502d5dfd123e6ca38cdf6c5}{rend}} () const noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_a2a9923cc9ecdcc5c25c96dd5508b72c7}{crend}} () const noexcept -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}}
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set_aab8c0e7201020733f0240a4d0036148a}{key\+\_\+comp}} () const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a0a1d4b80fd721e98fd252d5f2dbc674d}{key\+\_\+compare}}
\begin{DoxyCompactList}\small\item\em Returns the comparison object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set_aed2aa28ae90743b550fd6543126d6138}{sort}} ()
\begin{DoxyCompactList}\small\item\em Sort the container. This function sort again the container only if\+: \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class Key, class Compare = std\+::less$<$\+Key$>$, class Allocator = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$\newline
class seq\+::flat\+\_\+set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}

flat sorted container similar to boost\+::flat\+\_\+set with faster insertion/deletion of single values 


\begin{DoxyTemplParams}{Template Parameters}
{\em Key} & key type \\
\hline
{\em Compare} & comparison function \\
\hline
{\em Allocator} & allocator \\
\hline
{\em layout} & memory layout of the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{seq\+::tiered\+\_\+vector}} \\
\hline
{\em Stable} & insertion order stability\\
\hline
\end{DoxyTemplParams}
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}} is a sorted associative container similar to \href{https://www.boost.org/doc/libs/1_64_0/doc/html/boost/container/flat_set.html}{\texttt{ boost\+::flat\+\_\+set}}, but relying on a \mbox{\hyperlink{classseq_1_1tiered__vector}{seq\+::tiered\+\_\+vector}} instead of a flat array. Therefore, it inherits \mbox{\hyperlink{classseq_1_1tiered__vector}{seq\+::tiered\+\_\+vector}} properties\+: faster insertion and deletion of individual values (thanks to its tiered-\/vector based implementation), fast iteration, random access, invalidation of references/iterators on insertion and deletion.

All keys in a \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}} are unique. All references and iterators are invalidated when inserting/removing keys.\hypertarget{classseq_1_1flat__set_autotoc_md13}{}\doxysubsubsection{Interface}\label{classseq_1_1flat__set_autotoc_md13}
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}} provides a similar interface to std\+::set with the following differences\+:
\begin{DoxyItemize}
\item The node related functions are not implemented,
\item The member \mbox{\hyperlink{classseq_1_1flat__set_a0c36b1aaec8f9d12343152213a4789ad}{flat\+\_\+set\+::pos()}} is used to access to a random location,
\item The members \mbox{\hyperlink{classseq_1_1flat__set_a62f600b3a19bfeb5bb3515a915f184f7}{flat\+\_\+set\+::tvector()}} returns a reference to the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{seq\+::tiered\+\_\+vector}} object,
\item Its iterator and \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} types are random access iterators.
\end{DoxyItemize}

The underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}} object stores plain non const Key objects. However, in order to avoid modifying the keys through iterators (and potentially invalidating the order), both iterator and \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} types can only return const references.

In addition to members returning (const\+\_\+)iterator(s), the \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} provides the same members ending with the \textquotesingle{}\+\_\+pos\textquotesingle{} prefix and returning positions within the \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}} instead of iterators. These functions are slightly faster than the iterator based members.\hypertarget{classseq_1_1flat__set_autotoc_md14}{}\doxysubsubsection{Direct access to tiered\+\_\+vector}\label{classseq_1_1flat__set_autotoc_md14}
Unlike most flat set implementations, it it possible to directly access and modify the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}} directly. This possibility must be used with great care, as modifying directly the \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}} might break the key ordering. When calling the non-\/const version of \mbox{\hyperlink{classseq_1_1flat__set_a62f600b3a19bfeb5bb3515a915f184f7}{flat\+\_\+set\+::tvector()}}, the \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} will be marked as dirty, and further attempts to call functions like \mbox{\hyperlink{classseq_1_1flat__set_ab57074210e38022bdea1e1d34eaea124}{flat\+\_\+set\+::find()}} of \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{flat\+\_\+set\+::lower\+\_\+bound()}} (functions based on key ordering) will throw a std\+::logic\+\_\+error.

Therefore, after finishing modifying the \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}, you must call \mbox{\hyperlink{classseq_1_1flat__set_aed2aa28ae90743b550fd6543126d6138}{flat\+\_\+set\+::sort()}} to sort again the \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}, remove potential duplicates, and mark the \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} as non dirty anymore.

This way of modifying a \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} must be used carefully, but is way faster than multiple calls to \mbox{\hyperlink{classseq_1_1flat__set_a1d303585e85156afba2c58aafab309a4}{flat\+\_\+set\+::insert()}} of \mbox{\hyperlink{classseq_1_1flat__set_a5bb1e814df180dd44a0032b877e823df}{flat\+\_\+set\+::erase()}}.\hypertarget{classseq_1_1flat__set_autotoc_md15}{}\doxysubsubsection{Range insertion}\label{classseq_1_1flat__set_autotoc_md15}
Inserting a range of values using flat\+\_\+set\+::insert(first, last) is faster than inserting keys one by one, and should be favored if possible. Range insertion works the following way\+:
\begin{DoxyItemize}
\item New keys are first appended to the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}
\item These new keys are sorted directly within the \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}
\item Old keys and new keys are merged using std\+::inplace\+\_\+merge
\item Duplicate values are removed if necessary using std\+::unique.
\end{DoxyItemize}

Note that \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} used by default \href{https://github.com/orlp/pdqsort}{\texttt{ pdqsort}} implementation from Orson Peters which is not stable. If you need to keep stability when inserting range of values, you must set the Stable template parameter to true. std\+::stable\+\_\+sort will be used instead of pdqsort (std\+::inplace\+\_\+merge and std\+::unique are already stable).\hypertarget{classseq_1_1flat__set_autotoc_md16}{}\doxysubsubsection{Exception guarantee}\label{classseq_1_1flat__set_autotoc_md16}
All \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}} operations only provide {\bfseries{basic exception guarantee}}, exactly like the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{seq\+::tiered\+\_\+vector}}.\hypertarget{classseq_1_1flat__set_autotoc_md17}{}\doxysubsubsection{Performances}\label{classseq_1_1flat__set_autotoc_md17}
Performances of \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}} has been measured and compared to std\+::set, std\+::unordered\+\_\+set, \href{https://www.boost.org/doc/libs/1_64_0/doc/html/boost/container/flat_set.html}{\texttt{ boost\+::flat\+\_\+set}} and \href{https://abseil.io/docs/cpp/guides/container}{\texttt{ absel\+::btree\+\_\+set}}. The following table show the results when compiled with gcc 10.\+1.\+0 (-\/O3) for msys2 on Windows 10, using Intel(\+R) Core(\+T\+M) i7-\/10850H at 2.\+70\+G\+Hz. Measured operations are\+:
\begin{DoxyItemize}
\item Insert successfully a range of 1M unique double randomly shuffled using set\+\_\+class\+::insert(first,last)
\item Insert successfully 1M unique double randomly shuffled one by one using set\+\_\+class\+::insert(const Key\&)
\item Insert 1M double randomly shuffled one by one and already present in the set (failed insertion)
\item Successfully search for 1M double in the set using set\+\_\+class\+::find(const Key\&), or flat\+\_\+set\+::find\+\_\+pos(const Key\&)
\item Search for 1M double not present in the set (failed lookup)
\item Walk through the full set (1M double) using iterators
\item Erase all 1M double one by one using set\+\_\+class\+::erase(iterator)
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{8}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Set name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert range }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert (success) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert (fail) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find (success) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find (fail) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Iterate }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Erase  }\\\cline{1-8}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Set name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert range }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert (success) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert (fail) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find (success) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find (fail) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Iterate }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Erase  }\\\cline{1-8}
\endhead
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}} &53 ms &260 ms &96 ms &97 ms &38 ms &1 ms &213 ms  \\\cline{1-8}
absl\+::btree\+\_\+set &98 ms &98 ms &77 ms &82 ms &55 ms &2 ms &94 ms  \\\cline{1-8}
boost\+::flat\+\_\+set &50 ms &8756 ms &87 ms &94 ms &29 ms &0 ms &223106 ms  \\\cline{1-8}
std\+::set &252 ms &263 ms &245 ms &306 ms &41 ms &40 ms &333 ms  \\\cline{1-8}
std\+::unordered\+\_\+set &203 ms &206 ms &107 ms &104 ms &161 ms &34 ms &258 ms  \\\cline{1-8}
\end{longtabu}


\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}} behaves quite well compared to absl\+::btree\+\_\+set or boost\+::flat\+\_\+set, and is even faster for single insertion/deletion than std\+::set.

\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}} insertion/deletion perform in O(sqrt(\+N)) on average, as compared to std\+::set that performs in O(log(\+N)). \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}} is therfore slower for inserting and deleting elements than std\+::set when dealing with several millions of elements. Lookup functions (find, lower\+\_\+bound, upper\+\_\+bound...) still perform in O(log(\+N)) and remain faster that std\+::set couterparts because \mbox{\hyperlink{classseq_1_1tiered__vector}{seq\+::tiered\+\_\+vector}} is much more cache friendly than std\+::set. \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} will always be slower for element lookup than boost\+::flat\+\_\+set wich uses a single dense array.

Inserting/removing relocatable types (where \mbox{\hyperlink{structseq_1_1is__relocatable_a9bc3104d310961a601c2185957f846ad}{seq\+::is\+\_\+relocatable$<$\+T$>$\+::value}} is true) is faster than for other types.

Note that insertion/deletion of single elements become slower when sizeof(\+Key) increases, where std\+::set performances remain stable. Also note that the members using the \textquotesingle{}\+\_\+pos\textquotesingle{} prefix are usually slightly faster than their iterator based counterparts. 

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{classseq_1_1flat__set_a45e750bb1eb6ece2521d164c022287d7}\label{classseq_1_1flat__set_a45e750bb1eb6ece2521d164c022287d7}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a45e750bb1eb6ece2521d164c022287d7}{allocator\+\_\+type}} =  Allocator}

\mbox{\Hypertarget{classseq_1_1flat__set_ac56ed1e8f1b1fee2c4f8a26f16969210}\label{classseq_1_1flat__set_ac56ed1e8f1b1fee2c4f8a26f16969210}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!const\_pointer@{const\_pointer}}
\index{const\_pointer@{const\_pointer}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{const\_pointer}{const\_pointer}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_ac56ed1e8f1b1fee2c4f8a26f16969210}{const\+\_\+pointer}} =  typename std\+::allocator\+\_\+traits$<$Allocator$>$\+::\mbox{\hyperlink{classseq_1_1flat__set_ac56ed1e8f1b1fee2c4f8a26f16969210}{const\+\_\+pointer}}}

\mbox{\Hypertarget{classseq_1_1flat__set_ac3aa14284b49ee04935c41c6e8c01a55}\label{classseq_1_1flat__set_ac3aa14284b49ee04935c41c6e8c01a55}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!const\_reference@{const\_reference}}
\index{const\_reference@{const\_reference}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{const\_reference}{const\_reference}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_ac3aa14284b49ee04935c41c6e8c01a55}{const\+\_\+reference}} =  const Key\&}

\mbox{\Hypertarget{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}\label{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!const\_reverse\_iterator@{const\_reverse\_iterator}}
\index{const\_reverse\_iterator@{const\_reverse\_iterator}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{const\_reverse\_iterator}{const\_reverse\_iterator}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}} =  std\+::reverse\+\_\+iterator$<$\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}$>$}

\mbox{\Hypertarget{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}\label{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!deque\_type@{deque\_type}}
\index{deque\_type@{deque\_type}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{deque\_type}{deque\_type}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}{deque\+\_\+type}} =  typename \mbox{\hyperlink{structseq_1_1detail_1_1flat__tree_a206db35a1c2d1065d811172700f3518d}{flat\+\_\+tree\+\_\+type\+::deque\+\_\+type}}}

\mbox{\Hypertarget{classseq_1_1flat__set_a9d8481828c9f2f74c4e061acfdc1e02a}\label{classseq_1_1flat__set_a9d8481828c9f2f74c4e061acfdc1e02a}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!difference\_type@{difference\_type}}
\index{difference\_type@{difference\_type}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{difference\_type}{difference\_type}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a9d8481828c9f2f74c4e061acfdc1e02a}{difference\+\_\+type}} =  typename std\+::allocator\+\_\+traits$<$Allocator$>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a9d8481828c9f2f74c4e061acfdc1e02a}{difference\+\_\+type}}}

\mbox{\Hypertarget{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}\label{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!iterator@{iterator}}
\index{iterator@{iterator}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{iterator}{iterator}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} =  \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}}

\mbox{\Hypertarget{classseq_1_1flat__set_a0a1d4b80fd721e98fd252d5f2dbc674d}\label{classseq_1_1flat__set_a0a1d4b80fd721e98fd252d5f2dbc674d}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!key\_compare@{key\_compare}}
\index{key\_compare@{key\_compare}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{key\_compare}{key\_compare}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a0a1d4b80fd721e98fd252d5f2dbc674d}{key\+\_\+compare}} =  Compare}

\mbox{\Hypertarget{classseq_1_1flat__set_a95c948977310c47866584a268790a6f0}\label{classseq_1_1flat__set_a95c948977310c47866584a268790a6f0}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!key\_type@{key\_type}}
\index{key\_type@{key\_type}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{key\_type}{key\_type}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a95c948977310c47866584a268790a6f0}{key\+\_\+type}} =  Key}

\mbox{\Hypertarget{classseq_1_1flat__set_a32c4082dfe9ef37b2894e9a785830887}\label{classseq_1_1flat__set_a32c4082dfe9ef37b2894e9a785830887}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!pointer@{pointer}}
\index{pointer@{pointer}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{pointer}{pointer}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a32c4082dfe9ef37b2894e9a785830887}{pointer}} =  typename std\+::allocator\+\_\+traits$<$Allocator$>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a32c4082dfe9ef37b2894e9a785830887}{pointer}}}

\mbox{\Hypertarget{classseq_1_1flat__set_a3dac755c1568229cf24798257217d0b3}\label{classseq_1_1flat__set_a3dac755c1568229cf24798257217d0b3}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!reference@{reference}}
\index{reference@{reference}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{reference}{reference}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a3dac755c1568229cf24798257217d0b3}{reference}} =  Key\&}

\mbox{\Hypertarget{classseq_1_1flat__set_aa005e31dc3f4c6de57c78c08579c0350}\label{classseq_1_1flat__set_aa005e31dc3f4c6de57c78c08579c0350}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!reverse\_iterator@{reverse\_iterator}}
\index{reverse\_iterator@{reverse\_iterator}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{reverse\_iterator}{reverse\_iterator}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_aa005e31dc3f4c6de57c78c08579c0350}{reverse\+\_\+iterator}} =  std\+::reverse\+\_\+iterator$<$\mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}$>$}

\mbox{\Hypertarget{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}\label{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!size\_type@{size\_type}}
\index{size\_type@{size\_type}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{size\_type}{size\_type}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}} =  typename std\+::allocator\+\_\+traits$<$Allocator$>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}}

\mbox{\Hypertarget{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}\label{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
using \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} =  Key}



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classseq_1_1flat__set_af28779bd30528cfb05dbdd6738a5e230}\label{classseq_1_1flat__set_af28779bd30528cfb05dbdd6738a5e230}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Default constructor. 

\mbox{\Hypertarget{classseq_1_1flat__set_a43495f719ac2a6337b70580292767eab}\label{classseq_1_1flat__set_a43495f719ac2a6337b70580292767eab}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{const Compare \&}]{comp,  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Construct from comparator function and optional allocator object. 


\begin{DoxyParams}{Parameters}
{\em comp} & comparison function object to use for all comparisons of keys \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1flat__set_a96ca0e8e62ba5e2400f60678eb8e038f}\label{classseq_1_1flat__set_a96ca0e8e62ba5e2400f60678eb8e038f}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [3/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Construct from allocator object. 


\begin{DoxyParams}{Parameters}
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1flat__set_ab3e6b15d9f9e06b35f91e61f35f73862}\label{classseq_1_1flat__set_ab3e6b15d9f9e06b35f91e61f35f73862}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [4/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class Input\+It $>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last,  }\item[{const Compare \&}]{comp = {\ttfamily Compare()},  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Range constructor. Constructs the container with the contents of the range \mbox{[}first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. 


\begin{DoxyParams}{Parameters}
{\em first} & the range to copy the elements from \\
\hline
{\em last} & the range to copy the elements from \\
\hline
{\em comp} & comparison function object to use for all comparisons of keys \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1flat__set_a5e37d39789987ad2558c9c44ed3d0785}\label{classseq_1_1flat__set_a5e37d39789987ad2558c9c44ed3d0785}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [5/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class Input\+It $>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Range constructor. Constructs the container with the contents of the range \mbox{[}first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. 


\begin{DoxyParams}{Parameters}
{\em first} & the range to copy the elements from \\
\hline
{\em last} & the range to copy the elements from \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1flat__set_a55ba984f81b0db26a01612988d610318}\label{classseq_1_1flat__set_a55ba984f81b0db26a01612988d610318}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [6/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1flat__set_a6ebb1cbcd91fd9baf92dd692511796b0}\label{classseq_1_1flat__set_a6ebb1cbcd91fd9baf92dd692511796b0}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [7/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$ \&}]{other,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1flat__set_a0a5ef5410087dbbfac294b6c3863838f}\label{classseq_1_1flat__set_a0a5ef5410087dbbfac294b6c3863838f}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [8/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-\/construction from the allocator belonging to other. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1flat__set_ab7a6058962930dd09aa6f7f1579d266e}\label{classseq_1_1flat__set_ab7a6058962930dd09aa6f7f1579d266e}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [9/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$ \&\&}]{other,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-\/construction from the allocator belonging to other. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1flat__set_a834fe917b40b91a984b0b6e6a873fb77}\label{classseq_1_1flat__set_a834fe917b40b91a984b0b6e6a873fb77}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [10/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} $>$}]{init,  }\item[{const Compare \&}]{comp = {\ttfamily Compare()},  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Initializer-\/list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. 


\begin{DoxyParams}{Parameters}
{\em init} & initializer list to initialize the elements of the container with \\
\hline
{\em comp} & comparison function object to use for all comparisons of keys \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1flat__set_ad129f6187e0badecbcf74e653813b751}\label{classseq_1_1flat__set_ad129f6187e0badecbcf74e653813b751}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!flat\_set@{flat\_set}}
\index{flat\_set@{flat\_set}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{flat\_set()}{flat\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [11/11]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} $>$}]{init,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Initializer-\/list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. 


\begin{DoxyParams}{Parameters}
{\em init} & initializer list to initialize the elements of the container with \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classseq_1_1flat__set_ae51062a09feb26117423c5e2637cdd91}\label{classseq_1_1flat__set_ae51062a09feb26117423c5e2637cdd91}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!assign@{assign}}
\index{assign@{assign}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{assign()}{assign()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class Iter $>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::assign (\begin{DoxyParamCaption}\item[{Iter}]{first,  }\item[{Iter}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Assign the content of the range \mbox{[}first, last) to this container, discarding previous values. 

\mbox{\Hypertarget{classseq_1_1flat__set_a6fce030fb400220bed09cc61e5481660}\label{classseq_1_1flat__set_a6fce030fb400220bed09cc61e5481660}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!begin@{begin}}
\index{begin@{begin}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the first element of the container. 

\mbox{\Hypertarget{classseq_1_1flat__set_a2e0ae68bbfdd65d872ced19448211dc6}\label{classseq_1_1flat__set_a2e0ae68bbfdd65d872ced19448211dc6}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!begin@{begin}}
\index{begin@{begin}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the first element of the container. 

\mbox{\Hypertarget{classseq_1_1flat__set_aa31bc4f93192298eae80d450128f19fe}\label{classseq_1_1flat__set_aa31bc4f93192298eae80d450128f19fe}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!cbegin@{cbegin}}
\index{cbegin@{cbegin}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{cbegin()}{cbegin()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::cbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the first element of the container. 

\mbox{\Hypertarget{classseq_1_1flat__set_a45a2f7b8e1111e564d7a697fcc636ae4}\label{classseq_1_1flat__set_a45a2f7b8e1111e564d7a697fcc636ae4}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!cend@{cend}}
\index{cend@{cend}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{cend()}{cend()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::cend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the element following the last element of the container. 

\mbox{\Hypertarget{classseq_1_1flat__set_af48d76f5df8ae9b333e7d947e7132505}\label{classseq_1_1flat__set_af48d76f5df8ae9b333e7d947e7132505}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!clear@{clear}}
\index{clear@{clear}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Clears the container. 

\mbox{\Hypertarget{classseq_1_1flat__set_a9f918ac2c34f0fc4ad9bad3cd6ea8020}\label{classseq_1_1flat__set_a9f918ac2c34f0fc4ad9bad3cd6ea8020}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!contains@{contains}}
\index{contains@{contains}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::contains (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ bool  \hspace{0.3cm}{\ttfamily [inline]}}



Checks if there is an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 

\mbox{\Hypertarget{classseq_1_1flat__set_a322fde5fca97a0c3da93f391d2809d11}\label{classseq_1_1flat__set_a322fde5fca97a0c3da93f391d2809d11}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!contains@{contains}}
\index{contains@{contains}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::contains (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const -\/$>$ bool  \hspace{0.3cm}{\ttfamily [inline]}}



Checks if there is an element with key equivalent to key in the container. 

\mbox{\Hypertarget{classseq_1_1flat__set_aed5760dc699ac86f0faf0900ab6d1cc1}\label{classseq_1_1flat__set_aed5760dc699ac86f0faf0900ab6d1cc1}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!count@{count}}
\index{count@{count}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{count()}{count()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::count (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns the number of elements with key key (either 1 or 0 for \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} and \mbox{\hyperlink{classseq_1_1flat__map}{flat\+\_\+map}}). This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 

\mbox{\Hypertarget{classseq_1_1flat__set_a0108b61136b039802e0a5d630b528ba7}\label{classseq_1_1flat__set_a0108b61136b039802e0a5d630b528ba7}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!count@{count}}
\index{count@{count}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{count()}{count()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::count (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns the number of elements with key key (either 1 or 0 for \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}} and \mbox{\hyperlink{classseq_1_1flat__map}{flat\+\_\+map}}). 

\mbox{\Hypertarget{classseq_1_1flat__set_a888df9ed8978abe58fd4d244177caf91}\label{classseq_1_1flat__set_a888df9ed8978abe58fd4d244177caf91}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!crbegin@{crbegin}}
\index{crbegin@{crbegin}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{crbegin()}{crbegin()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::crbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the first element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1flat__set_a2a9923cc9ecdcc5c25c96dd5508b72c7}\label{classseq_1_1flat__set_a2a9923cc9ecdcc5c25c96dd5508b72c7}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!crend@{crend}}
\index{crend@{crend}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{crend()}{crend()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::crend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the element following the last element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1flat__set_a5d89147ce2a02f2054ee1441f827b329}\label{classseq_1_1flat__set_a5d89147ce2a02f2054ee1441f827b329}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!ctvector@{ctvector}}
\index{ctvector@{ctvector}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{ctvector()}{ctvector()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::ctvector (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ const \mbox{\hyperlink{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}{deque\+\_\+type}}\& \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a const reference to the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}. The container will N\+OT be marked as dirty. 

\mbox{\Hypertarget{classseq_1_1flat__set_a7e7400d10c6be9c84e4302950a039a48}\label{classseq_1_1flat__set_a7e7400d10c6be9c84e4302950a039a48}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!emplace@{emplace}}
\index{emplace@{emplace}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{emplace()}{emplace()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class... Args$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::emplace (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption}) -\/$>$ std\+::pair$<$\mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, bool$>$ \hspace{0.3cm}{\ttfamily [inline]}}



See std\+::set\+::emplace(). 

\mbox{\Hypertarget{classseq_1_1flat__set_a58d3bc87ac76060a64df3cff86de25c1}\label{classseq_1_1flat__set_a58d3bc87ac76060a64df3cff86de25c1}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!emplace\_hint@{emplace\_hint}}
\index{emplace\_hint@{emplace\_hint}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_hint()}{emplace\_hint()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class... Args$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::emplace\+\_\+hint (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}}]{hint,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} \hspace{0.3cm}{\ttfamily [inline]}}



Same as std\+::set\+::emplace\+\_\+hint. 

\mbox{\Hypertarget{classseq_1_1flat__set_a6758b8d25da755df20ab3f5cfa56bc30}\label{classseq_1_1flat__set_a6758b8d25da755df20ab3f5cfa56bc30}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!emplace\_pos@{emplace\_pos}}
\index{emplace\_pos@{emplace\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_pos()}{emplace\_pos()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class... Args$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::emplace\+\_\+pos (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption}) -\/$>$ std\+::pair$<$size\+\_\+t, bool$>$ \hspace{0.3cm}{\ttfamily [inline]}}



Same as \mbox{\hyperlink{classseq_1_1flat__set_a7e7400d10c6be9c84e4302950a039a48}{emplace()}}, but returns the inserted object position instead of iterator (or \mbox{\hyperlink{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}{size()}} if no element was inserted). 

\mbox{\Hypertarget{classseq_1_1flat__set_ab2096ed6a791d86016655b8ea6806405}\label{classseq_1_1flat__set_ab2096ed6a791d86016655b8ea6806405}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!empty@{empty}}
\index{empty@{empty}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ bool \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns true if container is empty, false otherwise. 

\mbox{\Hypertarget{classseq_1_1flat__set_a6ac3bfe3b3689202b76363abab0c2b22}\label{classseq_1_1flat__set_a6ac3bfe3b3689202b76363abab0c2b22}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!end@{end}}
\index{end@{end}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{end()}{end()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the element following the last element of the container. 

\mbox{\Hypertarget{classseq_1_1flat__set_a24c05caf75cab36a9867f327b36a0e1a}\label{classseq_1_1flat__set_a24c05caf75cab36a9867f327b36a0e1a}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!end@{end}}
\index{end@{end}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{end()}{end()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the element following the last element of the container. 

\mbox{\Hypertarget{classseq_1_1flat__set_a335c56f73beb14db8a2533352f53ad9d}\label{classseq_1_1flat__set_a335c56f73beb14db8a2533352f53ad9d}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!equal\_range@{equal\_range}}
\index{equal\_range@{equal\_range}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{equal\_range()}{equal\_range()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::equal\+\_\+range (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) -\/$>$ std\+::pair$<$\mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}$>$  \hspace{0.3cm}{\ttfamily [inline]}}



Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{lower\+\_\+bound()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}{upper\+\_\+bound()}}. 

This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \mbox{\Hypertarget{classseq_1_1flat__set_a1e81e0e8b7082f46c5dd53a189ed6a04}\label{classseq_1_1flat__set_a1e81e0e8b7082f46c5dd53a189ed6a04}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!equal\_range@{equal\_range}}
\index{equal\_range@{equal\_range}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{equal\_range()}{equal\_range()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::equal\+\_\+range (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ std\+::pair$<$\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}, \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}$>$  \hspace{0.3cm}{\ttfamily [inline]}}



Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{lower\+\_\+bound()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}{upper\+\_\+bound()}}. 

This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \mbox{\Hypertarget{classseq_1_1flat__set_abf33465b2705df1b6b8063bd89822610}\label{classseq_1_1flat__set_abf33465b2705df1b6b8063bd89822610}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!equal\_range@{equal\_range}}
\index{equal\_range@{equal\_range}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{equal\_range()}{equal\_range()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::equal\+\_\+range (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) -\/$>$ std\+::pair$<$\mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}$>$  \hspace{0.3cm}{\ttfamily [inline]}}



Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{lower\+\_\+bound()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}{upper\+\_\+bound()}}. 

\mbox{\Hypertarget{classseq_1_1flat__set_a1873a004bfa957a6454704e2f8ab91cc}\label{classseq_1_1flat__set_a1873a004bfa957a6454704e2f8ab91cc}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!equal\_range@{equal\_range}}
\index{equal\_range@{equal\_range}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{equal\_range()}{equal\_range()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::equal\+\_\+range (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const -\/$>$ std\+::pair$<$\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}, \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}$>$  \hspace{0.3cm}{\ttfamily [inline]}}



Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}{lower\+\_\+bound()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}{upper\+\_\+bound()}}. 

\mbox{\Hypertarget{classseq_1_1flat__set_a43a4cceb7d0c71e85df8f532ba8eaf6f}\label{classseq_1_1flat__set_a43a4cceb7d0c71e85df8f532ba8eaf6f}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!equal\_range\_pos@{equal\_range\_pos}}
\index{equal\_range\_pos@{equal\_range\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{equal\_range\_pos()}{equal\_range\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::equal\+\_\+range\+\_\+pos (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ std\+::pair$<$size\+\_\+t, size\+\_\+t$>$  \hspace{0.3cm}{\ttfamily [inline]}}



Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_abaab3b186746f31c608223d263a337d3}{lower\+\_\+bound\+\_\+pos()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a157af0b66ff9eb5a8892a052b5437039}{upper\+\_\+bound\+\_\+pos()}}. 

This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. \mbox{\Hypertarget{classseq_1_1flat__set_a3dc1702bfbf2b5fb80fde4a68c604564}\label{classseq_1_1flat__set_a3dc1702bfbf2b5fb80fde4a68c604564}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!equal\_range\_pos@{equal\_range\_pos}}
\index{equal\_range\_pos@{equal\_range\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{equal\_range\_pos()}{equal\_range\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::equal\+\_\+range\+\_\+pos (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const -\/$>$ std\+::pair$<$size\+\_\+t, size\+\_\+t$>$  \hspace{0.3cm}{\ttfamily [inline]}}



Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with \mbox{\hyperlink{classseq_1_1flat__set_abaab3b186746f31c608223d263a337d3}{lower\+\_\+bound\+\_\+pos()}}, and the second with \mbox{\hyperlink{classseq_1_1flat__set_a157af0b66ff9eb5a8892a052b5437039}{upper\+\_\+bound\+\_\+pos()}}. 

\mbox{\Hypertarget{classseq_1_1flat__set_a81b66ef1a67458556d4a8573cc2d7862}\label{classseq_1_1flat__set_a81b66ef1a67458556d4a8573cc2d7862}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!erase@{erase}}
\index{erase@{erase}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::erase (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}\hspace{0.3cm}{\ttfamily [inline]}}



Removes the element (if one exists) with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type, and neither iterator nor \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} is implicitly convertible from K. It allows calling this function without constructing an instance of Key. 


\begin{DoxyParams}{Parameters}
{\em key} & key value of the elements to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of erased elements 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_a769ae39fe7a3aabb03bc9eba700081eb}\label{classseq_1_1flat__set_a769ae39fe7a3aabb03bc9eba700081eb}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!erase@{erase}}
\index{erase@{erase}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::erase (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}} \hspace{0.3cm}{\ttfamily [inline]}}



Removes the element (if one exists) with the key equivalent to key. 


\begin{DoxyParams}{Parameters}
{\em key} & key value of the elements to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of erased elements 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_a9fb8322374785d7c6dc51938a16e13ce}\label{classseq_1_1flat__set_a9fb8322374785d7c6dc51938a16e13ce}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!erase@{erase}}
\index{erase@{erase}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}}]{first,  }\item[{\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}}]{last }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}\hspace{0.3cm}{\ttfamily [inline]}}



Erase elements in the range \mbox{[}first, last) 

\mbox{\Hypertarget{classseq_1_1flat__set_a5bb1e814df180dd44a0032b877e823df}\label{classseq_1_1flat__set_a5bb1e814df180dd44a0032b877e823df}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!erase@{erase}}
\index{erase@{erase}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}}]{pos }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}\hspace{0.3cm}{\ttfamily [inline]}}



Erase element at given location. 

\mbox{\Hypertarget{classseq_1_1flat__set_aaf5bf6cec1d8e7106f6c34a5cae2850e}\label{classseq_1_1flat__set_aaf5bf6cec1d8e7106f6c34a5cae2850e}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!erase@{erase}}
\index{erase@{erase}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::erase (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{first,  }\item[{size\+\_\+t}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Erase elements in the range \mbox{[}first, last) 

\mbox{\Hypertarget{classseq_1_1flat__set_aa211185e183f54d722afea2e38769f6b}\label{classseq_1_1flat__set_aa211185e183f54d722afea2e38769f6b}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!erase\_pos@{erase\_pos}}
\index{erase\_pos@{erase\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{erase\_pos()}{erase\_pos()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::erase\+\_\+pos (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}}}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Erase element at given position in the container. This is slightly faster than calling \mbox{\hyperlink{classseq_1_1flat__set_a5bb1e814df180dd44a0032b877e823df}{erase(iterator)}}. 

\mbox{\Hypertarget{classseq_1_1flat__set_ab57074210e38022bdea1e1d34eaea124}\label{classseq_1_1flat__set_ab57074210e38022bdea1e1d34eaea124}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!find@{find}}
\index{find@{find}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::find (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}\hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 


\begin{DoxyParams}{Parameters}
{\em key} & value to look for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator pointing to found element, or end iterator 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_a6c519766a4d8b7c1e16a91e9347fa6d6}\label{classseq_1_1flat__set_a6c519766a4d8b7c1e16a91e9347fa6d6}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!find@{find}}
\index{find@{find}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::find (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 


\begin{DoxyParams}{Parameters}
{\em key} & value to look for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator pointing to found element, or end iterator 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_a9edc18a9b502e44daf57d8343e249994}\label{classseq_1_1flat__set_a9edc18a9b502e44daf57d8343e249994}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!find@{find}}
\index{find@{find}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::find (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key equivalent to key. 


\begin{DoxyParams}{Parameters}
{\em key} & value to look for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator pointing to found element, or end iterator 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_ae8e1aeb2634304ff1c1bf26a0107d918}\label{classseq_1_1flat__set_ae8e1aeb2634304ff1c1bf26a0107d918}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!find@{find}}
\index{find@{find}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::find (\begin{DoxyParamCaption}\item[{const Key \&}]{x }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key equivalent to key. 


\begin{DoxyParams}{Parameters}
{\em key} & value to look for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator pointing to found element, or end iterator 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_ab9949c1ca56b3124db9bffd2581bdbce}\label{classseq_1_1flat__set_ab9949c1ca56b3124db9bffd2581bdbce}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!find\_pos@{find\_pos}}
\index{find\_pos@{find\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{find\_pos()}{find\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::find\+\_\+pos (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ size\+\_\+t \hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 


\begin{DoxyParams}{Parameters}
{\em key} & value to look for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
position of found value, or \mbox{\hyperlink{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}{size()}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_ae3b92a2a8e8a39936d16846c2f12dcf8}\label{classseq_1_1flat__set_ae3b92a2a8e8a39936d16846c2f12dcf8}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!find\_pos@{find\_pos}}
\index{find\_pos@{find\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{find\_pos()}{find\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::find\+\_\+pos (\begin{DoxyParamCaption}\item[{const Key \&}]{x }\end{DoxyParamCaption}) const -\/$>$ size\+\_\+t  \hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key equivalent to key. 


\begin{DoxyParams}{Parameters}
{\em key} & value to look for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
position of found value, or \mbox{\hyperlink{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}{size()}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_a050ce6bc5285419473b22f7aade304ae}\label{classseq_1_1flat__set_a050ce6bc5285419473b22f7aade304ae}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ Allocator \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns container\textquotesingle{}s allocator. 

\mbox{\Hypertarget{classseq_1_1flat__set_a1d303585e85156afba2c58aafab309a4}\label{classseq_1_1flat__set_a1d303585e85156afba2c58aafab309a4}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!insert@{insert}}
\index{insert@{insert}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::insert (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption}) -\/$>$ std\+::pair$<$\mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, bool$>$ \hspace{0.3cm}{\ttfamily [inline]}}



See std\+::set\+::insert. 

\mbox{\Hypertarget{classseq_1_1flat__set_ae026ff05db15ce89a04df42942a73505}\label{classseq_1_1flat__set_ae026ff05db15ce89a04df42942a73505}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!insert@{insert}}
\index{insert@{insert}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}}]{hint,  }\item[{const \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} \hspace{0.3cm}{\ttfamily [inline]}}



Same as std\+::set\+::insert() 

\mbox{\Hypertarget{classseq_1_1flat__set_a71768fa11e840ccf87e601102e4355ce}\label{classseq_1_1flat__set_a71768fa11e840ccf87e601102e4355ce}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!insert@{insert}}
\index{insert@{insert}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}}]{hint,  }\item[{\mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}} \hspace{0.3cm}{\ttfamily [inline]}}



Same as std\+::set\+::insert() 

\mbox{\Hypertarget{classseq_1_1flat__set_a370336c5106645ee45fec8a2a26eadc4}\label{classseq_1_1flat__set_a370336c5106645ee45fec8a2a26eadc4}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!insert@{insert}}
\index{insert@{insert}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class Input\+It $>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::insert (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements from range \mbox{[}first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range \mbox{[}first, last) is roughly equal or greater than the container\textquotesingle{}s size, this function is much faster than inserting elements one by one. 

\mbox{\Hypertarget{classseq_1_1flat__set_ace98a525dfd46ea113f9f151c63f2411}\label{classseq_1_1flat__set_ace98a525dfd46ea113f9f151c63f2411}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!insert@{insert}}
\index{insert@{insert}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::insert (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} $>$}]{ilist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. 

\mbox{\Hypertarget{classseq_1_1flat__set_ab40f91951dc0cffa782856434f3d98e3}\label{classseq_1_1flat__set_ab40f91951dc0cffa782856434f3d98e3}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!insert@{insert}}
\index{insert@{insert}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption}) -\/$>$ std\+::pair$<$\mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}, bool$>$ \hspace{0.3cm}{\ttfamily [inline]}}



See std\+::set\+::insert. 

\mbox{\Hypertarget{classseq_1_1flat__set_abcb5126c808ca716db9fd0e3d4e306b7}\label{classseq_1_1flat__set_abcb5126c808ca716db9fd0e3d4e306b7}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!insert\_pos@{insert\_pos}}
\index{insert\_pos@{insert\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{insert\_pos()}{insert\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::insert\+\_\+pos (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption}) -\/$>$ std\+::pair$<$size\+\_\+t, bool$>$ \hspace{0.3cm}{\ttfamily [inline]}}



Same as \mbox{\hyperlink{classseq_1_1flat__set_a1d303585e85156afba2c58aafab309a4}{insert()}}, but returns the inserted object position instead of iterator (or \mbox{\hyperlink{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}{size()}} if no element was inserted). 

\mbox{\Hypertarget{classseq_1_1flat__set_a9a413bfa23fb123841f4c0b7c3e045cd}\label{classseq_1_1flat__set_a9a413bfa23fb123841f4c0b7c3e045cd}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!insert\_pos@{insert\_pos}}
\index{insert\_pos@{insert\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{insert\_pos()}{insert\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::insert\+\_\+pos (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption}) -\/$>$ std\+::pair$<$size\+\_\+t, bool$>$ \hspace{0.3cm}{\ttfamily [inline]}}



Same as \mbox{\hyperlink{classseq_1_1flat__set_a1d303585e85156afba2c58aafab309a4}{insert()}}, but returns the inserted object position instead of iterator (or \mbox{\hyperlink{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}{size()}} if no element was inserted). 

\mbox{\Hypertarget{classseq_1_1flat__set_aab8c0e7201020733f0240a4d0036148a}\label{classseq_1_1flat__set_aab8c0e7201020733f0240a4d0036148a}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!key\_comp@{key\_comp}}
\index{key\_comp@{key\_comp}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{key\_comp()}{key\_comp()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::key\+\_\+comp (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a0a1d4b80fd721e98fd252d5f2dbc674d}{key\+\_\+compare}} \hspace{0.3cm}{\ttfamily [inline]}}



Returns the comparison object. 

\mbox{\Hypertarget{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}\label{classseq_1_1flat__set_a05a4bd7956b3d665fabb283c7ac92457}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!lower\_bound@{lower\_bound}}
\index{lower\_bound@{lower\_bound}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{lower\_bound()}{lower\_bound()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::lower\+\_\+bound (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator pointing to the first element that compares not less (i.\+e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 

\mbox{\Hypertarget{classseq_1_1flat__set_af8ac90f96ae7a84fba51fbe80fec29b8}\label{classseq_1_1flat__set_af8ac90f96ae7a84fba51fbe80fec29b8}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!lower\_bound@{lower\_bound}}
\index{lower\_bound@{lower\_bound}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{lower\_bound()}{lower\_bound()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::lower\+\_\+bound (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator pointing to the first element that compares not less (i.\+e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 

\mbox{\Hypertarget{classseq_1_1flat__set_a629a2e5125b9141860aed25f26ea9a53}\label{classseq_1_1flat__set_a629a2e5125b9141860aed25f26ea9a53}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!lower\_bound@{lower\_bound}}
\index{lower\_bound@{lower\_bound}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{lower\_bound()}{lower\_bound()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::lower\+\_\+bound (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator pointing to the first element that is not less than (i.\+e. greater or equal to) key. 

\mbox{\Hypertarget{classseq_1_1flat__set_a23b604bc495608e02a17696fed13493d}\label{classseq_1_1flat__set_a23b604bc495608e02a17696fed13493d}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!lower\_bound@{lower\_bound}}
\index{lower\_bound@{lower\_bound}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{lower\_bound()}{lower\_bound()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::lower\+\_\+bound (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator pointing to the first element that is not less than (i.\+e. greater or equal to) key. 

\mbox{\Hypertarget{classseq_1_1flat__set_abaab3b186746f31c608223d263a337d3}\label{classseq_1_1flat__set_abaab3b186746f31c608223d263a337d3}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!lower\_bound\_pos@{lower\_bound\_pos}}
\index{lower\_bound\_pos@{lower\_bound\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{lower\_bound\_pos()}{lower\_bound\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::lower\+\_\+bound\+\_\+pos (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ size\+\_\+t  \hspace{0.3cm}{\ttfamily [inline]}}



Returns the position of the first element that compares not less (i.\+e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 

\mbox{\Hypertarget{classseq_1_1flat__set_af6077925167e63133dccb4590e93d2df}\label{classseq_1_1flat__set_af6077925167e63133dccb4590e93d2df}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!lower\_bound\_pos@{lower\_bound\_pos}}
\index{lower\_bound\_pos@{lower\_bound\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{lower\_bound\_pos()}{lower\_bound\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::lower\+\_\+bound\+\_\+pos (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const -\/$>$ size\+\_\+t  \hspace{0.3cm}{\ttfamily [inline]}}



Returns the position of the first element that is not less than (i.\+e. greater or equal to) key. 

\mbox{\Hypertarget{classseq_1_1flat__set_aa85b0206e6306dc533f30c34dd55a065}\label{classseq_1_1flat__set_aa85b0206e6306dc533f30c34dd55a065}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!max\_size@{max\_size}}
\index{max\_size@{max\_size}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{max\_size()}{max\_size()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::max\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the container maximum size. 

\mbox{\Hypertarget{classseq_1_1flat__set_ad53ba988a2774436198f857105de9969}\label{classseq_1_1flat__set_ad53ba988a2774436198f857105de9969}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!merge@{merge}}
\index{merge@{merge}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{merge()}{merge()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class C2 , Layout\+Management layout2$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::merge (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}$<$ Key, C2, Allocator, layout2 $>$ \&}]{source }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Attempts to extract each element in source and insert it into this using the comparison object of this. If there is an element in this with key equivalent to the key of an element from source, then that element is not extracted from source. Note that elements from source are moved to this. 

\mbox{\Hypertarget{classseq_1_1flat__set_a85c5d9440fe54481bdd8db47a0c4256a}\label{classseq_1_1flat__set_a85c5d9440fe54481bdd8db47a0c4256a}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!operator=@{operator=}}
\index{operator=@{operator=}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$ \&}]{other }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}\& \hspace{0.3cm}{\ttfamily [inline]}}



Copy operator. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to this container 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_aad22c9c9dad8a9720aa3c1f6dee76430}\label{classseq_1_1flat__set_aad22c9c9dad8a9720aa3c1f6dee76430}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!operator=@{operator=}}
\index{operator=@{operator=}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::operator= (\begin{DoxyParamCaption}\item[{const std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}} $>$ \&}]{init }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}\&
		\hspace{0.3cm}{\ttfamily [inline]}}



Assign initializer-\/list. 


\begin{DoxyParams}{Parameters}
{\em init} & initializer list to initialize the elements of the container with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to this container 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_a38730475abb8a0a31dcc8674ec8712a3}\label{classseq_1_1flat__set_a38730475abb8a0a31dcc8674ec8712a3}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!operator=@{operator=}}
\index{operator=@{operator=}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$ \&\&}]{other }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}\& \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Move assignment operator. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to this container 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_a0c36b1aaec8f9d12343152213a4789ad}\label{classseq_1_1flat__set_a0c36b1aaec8f9d12343152213a4789ad}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!pos@{pos}}
\index{pos@{pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{pos()}{pos()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::pos (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{i }\end{DoxyParamCaption}) const -\/$>$ const \mbox{\hyperlink{classseq_1_1flat__set_a423dfd403dcf1078aa0400ceb34aca10}{value\+\_\+type}}\& \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns value at given flat position. 

\mbox{\Hypertarget{classseq_1_1flat__set_a6ca9925da3e6ac9e5892a29dc9ac49b2}\label{classseq_1_1flat__set_a6ca9925da3e6ac9e5892a29dc9ac49b2}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{rbegin()}{rbegin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the first element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1flat__set_a08f8f14f5d3939b85d73bfd33ff18b6b}\label{classseq_1_1flat__set_a08f8f14f5d3939b85d73bfd33ff18b6b}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{rbegin()}{rbegin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_aa005e31dc3f4c6de57c78c08579c0350}{reverse\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the first element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1flat__set_a3e186cc2c502d5dfd123e6ca38cdf6c5}\label{classseq_1_1flat__set_a3e186cc2c502d5dfd123e6ca38cdf6c5}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!rend@{rend}}
\index{rend@{rend}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{rend()}{rend()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a59f0b73c32e563991fa077115d501c69}{const\+\_\+reverse\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the element following the last element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1flat__set_a05da8c9d8495c529c8487b3f4a8cc724}\label{classseq_1_1flat__set_a05da8c9d8495c529c8487b3f4a8cc724}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!rend@{rend}}
\index{rend@{rend}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{rend()}{rend()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_aa005e31dc3f4c6de57c78c08579c0350}{reverse\+\_\+iterator}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the element following the last element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}\label{classseq_1_1flat__set_adad47840009cc56187911e7f2a47193d}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!size@{size}}
\index{size@{size}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a4c2f707cf8f7944eda425023d33003e7}{size\+\_\+type}} \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the container size. 

\mbox{\Hypertarget{classseq_1_1flat__set_aed2aa28ae90743b550fd6543126d6138}\label{classseq_1_1flat__set_aed2aa28ae90743b550fd6543126d6138}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!sort@{sort}}
\index{sort@{sort}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{sort()}{sort()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::sort (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sort the container. This function sort again the container only if\+: 


\begin{DoxyItemize}
\item The container is dirty (because of \mbox{\hyperlink{classseq_1_1flat__set_a62f600b3a19bfeb5bb3515a915f184f7}{flat\+\_\+set\+::tvector()}} calls) and
\item the container is not already sorted. This function also remove duplicates if necessary. 
\end{DoxyItemize}\mbox{\Hypertarget{classseq_1_1flat__set_a145a8c0071d070fc5f1f4ceb03bb595e}\label{classseq_1_1flat__set_a145a8c0071d070fc5f1f4ceb03bb595e}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!swap@{swap}}
\index{swap@{swap}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1flat__set}{flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Swap this container\textquotesingle{}s content with another. Iterators to both containers remain valid, including end iterators. 

\mbox{\Hypertarget{classseq_1_1flat__set_af71e0e9ba96e3cb66048659fa6af5dd2}\label{classseq_1_1flat__set_af71e0e9ba96e3cb66048659fa6af5dd2}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!tvector@{tvector}}
\index{tvector@{tvector}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{tvector()}{tvector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::tvector (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ const \mbox{\hyperlink{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}{deque\+\_\+type}}\& \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a const reference to the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}. The container will N\+OT be marked as dirty. 

\mbox{\Hypertarget{classseq_1_1flat__set_a62f600b3a19bfeb5bb3515a915f184f7}\label{classseq_1_1flat__set_a62f600b3a19bfeb5bb3515a915f184f7}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!tvector@{tvector}}
\index{tvector@{tvector}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{tvector()}{tvector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::tvector (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1a99d74a2c1b1287883c1aa8f77b9d23}{deque\+\_\+type}}\& \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{tiered\+\_\+vector}}. Calling this function will mark the container as dirty. Any further attempts to call members like \mbox{\hyperlink{classseq_1_1flat__set_ab57074210e38022bdea1e1d34eaea124}{find()}}, lower\+\_\+bound, upper\+\_\+bound... will raise a std\+::logic\+\_\+error. To mark the container as non dirty anymore, the user must call \mbox{\hyperlink{classseq_1_1flat__set_aed2aa28ae90743b550fd6543126d6138}{flat\+\_\+set\+::sort()}}. 

\begin{DoxyReturn}{Returns}
a reference to the underlying \mbox{\hyperlink{classseq_1_1tiered__vector}{seq\+::tiered\+\_\+vector}} object 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}\label{classseq_1_1flat__set_a7cedd5671e9b0111d8b443727401c6c3}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!upper\_bound@{upper\_bound}}
\index{upper\_bound@{upper\_bound}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{upper\_bound()}{upper\_bound()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::upper\+\_\+bound (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 

\mbox{\Hypertarget{classseq_1_1flat__set_ac41bad49d5d46802758f61ec0e1b74ae}\label{classseq_1_1flat__set_ac41bad49d5d46802758f61ec0e1b74ae}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!upper\_bound@{upper\_bound}}
\index{upper\_bound@{upper\_bound}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{upper\_bound()}{upper\_bound()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::upper\+\_\+bound (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 

\mbox{\Hypertarget{classseq_1_1flat__set_a2bee27bd128f6aefc76bd804a083aa55}\label{classseq_1_1flat__set_a2bee27bd128f6aefc76bd804a083aa55}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!upper\_bound@{upper\_bound}}
\index{upper\_bound@{upper\_bound}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{upper\_bound()}{upper\_bound()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::upper\+\_\+bound (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1flat__set_a1b64c5f701a2ab7921e34ce3d5b5d1a6}{iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator pointing to the first element that is greater than key. 

\mbox{\Hypertarget{classseq_1_1flat__set_a8a85ecad5fd863135883a958f5e02f52}\label{classseq_1_1flat__set_a8a85ecad5fd863135883a958f5e02f52}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!upper\_bound@{upper\_bound}}
\index{upper\_bound@{upper\_bound}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{upper\_bound()}{upper\_bound()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::upper\+\_\+bound (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const -\/$>$ \mbox{\hyperlink{structseq_1_1flat__set_1_1const__iterator}{const\+\_\+iterator}}  \hspace{0.3cm}{\ttfamily [inline]}}



Returns an iterator pointing to the first element that is greater than key. 

\mbox{\Hypertarget{classseq_1_1flat__set_a157af0b66ff9eb5a8892a052b5437039}\label{classseq_1_1flat__set_a157af0b66ff9eb5a8892a052b5437039}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!upper\_bound\_pos@{upper\_bound\_pos}}
\index{upper\_bound\_pos@{upper\_bound\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{upper\_bound\_pos()}{upper\_bound\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
template$<$class K , class LE  = Compare, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ L\+E $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::upper\+\_\+bound\+\_\+pos (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const -\/$>$ size\+\_\+t  \hspace{0.3cm}{\ttfamily [inline]}}



Returns the position of the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-\/id Compare\+::is\+\_\+transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. 

\mbox{\Hypertarget{classseq_1_1flat__set_a9032ec73505dff2edef68f48b8867e5c}\label{classseq_1_1flat__set_a9032ec73505dff2edef68f48b8867e5c}} 
\index{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}!upper\_bound\_pos@{upper\_bound\_pos}}
\index{upper\_bound\_pos@{upper\_bound\_pos}!seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$@{seq::flat\_set$<$ Key, Compare, Allocator, layout, Stable, Unique $>$}}
\doxysubsubsection{\texorpdfstring{upper\_bound\_pos()}{upper\_bound\_pos()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Compare  = std\+::less$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management layout = Optimize\+For\+Memory, bool Stable = false, bool Unique = true$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} auto \mbox{\hyperlink{classseq_1_1flat__set}{seq\+::flat\+\_\+set}}$<$ Key, Compare, Allocator, layout, Stable, Unique $>$\+::upper\+\_\+bound\+\_\+pos (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const -\/$>$ size\+\_\+t  \hspace{0.3cm}{\ttfamily [inline]}}



Returns the position of the first element that is greater than key. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
seq/\mbox{\hyperlink{flat__map_8hpp}{flat\+\_\+map.\+hpp}}\end{DoxyCompactItemize}
