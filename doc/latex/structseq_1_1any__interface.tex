\hypertarget{structseq_1_1any__interface}{}\doxysection{seq\+::any\+\_\+interface$<$ Type\+Info, Static\+Size, Alignment $>$ Struct Template Reference}
\label{structseq_1_1any__interface}\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}


Base (an default) interface for \mbox{\hyperlink{classseq_1_1hold__any}{hold\+\_\+any}} class.  




{\ttfamily \#include $<$any -\/ Copie.\+hpp$>$}



Inherits \mbox{\hyperlink{structseq_1_1detail_1_1null__policy}{seq\+::detail\+::null\+\_\+policy}}.

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{structseq_1_1any__interface_a8f1c148efe5e1b91926ed3f361a7dfe0}{type\+\_\+info\+\_\+type}} = Type\+Info
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const void $\ast$ \mbox{\hyperlink{structseq_1_1any__interface_ad79eb510b2ef28842fc9bc1e9a23f972}{data}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the underlying object as a void$\ast$. Never returns a N\+U\+LL pointer, even for empty object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void $\ast$ \mbox{\hyperlink{structseq_1_1any__interface_ae2902f01e2e1384b79e9585b1bb3cbd8}{data}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns the underlying object as a void$\ast$. Never returns a N\+U\+LL pointer, even for empty object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} Type\+Info $\ast$ \mbox{\hyperlink{structseq_1_1any__interface_ad6444b5617c79d79c0339492f1bb7347}{type}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns the type information as a Type\+Info pointer. Returns N\+U\+LL if the object is empty. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const Type\+Info $\ast$ \mbox{\hyperlink{structseq_1_1any__interface_a5bcd8d5d43cdec7ff3336ed1fb2fd517}{type}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the type information as a Type\+Info pointer. Returns N\+U\+LL if the object is empty. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} int \mbox{\hyperlink{structseq_1_1any__interface_ab95f2e3edd6f4f32c5b00da5ec1eb199}{type\+\_\+id}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the type id for this object. Returns 0 if the object is empty. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} bool \mbox{\hyperlink{structseq_1_1any__interface_a7fd00b1480b121d411c78bd2e1eb4d7c}{empty}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns true if this object is empty, false otherwise. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} size\+\_\+t \mbox{\hyperlink{structseq_1_1any__interface_a9587a1118997dfc48bf5b483324c129c}{sizeof\+\_\+type}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the size of underlying type, 0 if empty. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T \mbox{\hyperlink{structseq_1_1any__interface_a5d69d61bda53a51fcd7d338e3a6e38ff}{cast}} ()
\begin{DoxyCompactList}\small\item\em Cast any object to given type. Throw a std\+::bad\+\_\+cast on error. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T \mbox{\hyperlink{structseq_1_1any__interface_adb887b544a3bc663db27c66e81255361}{cast}} () const
\begin{DoxyCompactList}\small\item\em Cast any object to given type. Throw a std\+::bad\+\_\+cast on error. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} size\+\_\+t \mbox{\hyperlink{structseq_1_1any__interface_afb9c3a0fef8c62238700d805dcd2e7f3}{hash}} () const
\begin{DoxyCompactList}\small\item\em Returns the hash value for underlying object based on std\+::hash. Might throw a std\+::bad\+\_\+function\+\_\+call. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{structseq_1_1any__interface_a02f5afdfdb516af7a7d912d353819773}{storage\+\_\+type}} = typename std\+::aligned\+\_\+storage$<$ Static\+Size, Alignment $>$\+::\mbox{\hyperlink{structseq_1_1any__interface_ad6444b5617c79d79c0339492f1bb7347}{type}}
\item 
using \mbox{\hyperlink{structseq_1_1any__interface_a41139fb92d50855a61edaaeaa8ef34ab}{pointer\+\_\+type}} = \mbox{\hyperlink{classseq_1_1tagged__pointer}{tagged\+\_\+pointer}}$<$ Type\+Info, \mbox{\hyperlink{namespaceseq_affae767f96f2af9924f7c6f3bdd4c72aad297c23409b392745ce5f3024304a8e8}{Custom\+Alignment}}, 16 $>$
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class T $>$ }\\void $\ast$ \mbox{\hyperlink{structseq_1_1any__interface_a7b471da36550f133f3b6c64ac5fb2eba}{alloc}} ()
\item 
void \mbox{\hyperlink{structseq_1_1any__interface_a31b929552dc9c823dca1704481fc3d01}{dealloc}} () noexcept
\item 
{\footnotesize template$<$class T $>$ }\\std\+::decay$<$ T $>$\+::\mbox{\hyperlink{structseq_1_1any__interface_ad6444b5617c79d79c0339492f1bb7347}{type}} \mbox{\hyperlink{structseq_1_1any__interface_a4973c3cdae25ef87930ad75e65febd44}{convert}} (const Type\+Info $\ast$info, const Type\+Info $\ast$out\+\_\+p) const
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structseq_1_1any__interface_a41139fb92d50855a61edaaeaa8ef34ab}{pointer\+\_\+type}} \mbox{\hyperlink{structseq_1_1any__interface_a7db9b99517b26c0ddc5473f3dc29884c}{d\+\_\+type\+\_\+info}}
\item 
\mbox{\hyperlink{structseq_1_1any__interface_a02f5afdfdb516af7a7d912d353819773}{storage\+\_\+type}} \mbox{\hyperlink{structseq_1_1any__interface_ae9972f0fd985c59da519a907843c45ce}{d\+\_\+storage}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class Type\+Info, size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$\newline
struct seq\+::any\+\_\+interface$<$ Type\+Info, Static\+Size, Alignment $>$}

Base (an default) interface for \mbox{\hyperlink{classseq_1_1hold__any}{hold\+\_\+any}} class. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Type\+Info} & the type info class (inheriting \mbox{\hyperlink{classseq_1_1any__type__info}{any\+\_\+type\+\_\+info}}) that this interface uses\\
\hline
\end{DoxyTemplParams}
\mbox{\hyperlink{classseq_1_1hold__any}{hold\+\_\+any}} will directly inherit \mbox{\hyperlink{structseq_1_1any__interface}{any\+\_\+interface}} that provides the following members\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{structseq_1_1any__interface_a7fd00b1480b121d411c78bd2e1eb4d7c}{any\+\_\+interface\+::empty()}} \+: check for empty any
\item \mbox{\hyperlink{structseq_1_1any__interface_ae2902f01e2e1384b79e9585b1bb3cbd8}{any\+\_\+interface\+::data()}} \+: returns underlying object as a void$\ast$
\item \mbox{\hyperlink{structseq_1_1any__interface_ad6444b5617c79d79c0339492f1bb7347}{any\+\_\+interface\+::type()}} \+: returns the type as a Type\+Info pointer
\item \mbox{\hyperlink{structseq_1_1any__interface_ab95f2e3edd6f4f32c5b00da5ec1eb199}{any\+\_\+interface\+::type\+\_\+id()}} \+: returns the type id (as \mbox{\hyperlink{namespaceseq_ae671e0f695cb6f085d8255e0de4d2281}{get\+\_\+type\+\_\+id()}})
\item \mbox{\hyperlink{structseq_1_1any__interface_a5d69d61bda53a51fcd7d338e3a6e38ff}{any\+\_\+interface\+::cast()}} \+: cast to template type
\item \mbox{\hyperlink{structseq_1_1any__interface_a9587a1118997dfc48bf5b483324c129c}{any\+\_\+interface\+::sizeof\+\_\+type()}}\+: returns the size of underlying type
\item \mbox{\hyperlink{structseq_1_1any__interface_afb9c3a0fef8c62238700d805dcd2e7f3}{any\+\_\+interface\+::hash()}}\+: returns a hash value (based on std\+::hash) for underlying object
\end{DoxyItemize}

It is possible to inherit \mbox{\hyperlink{structseq_1_1any__interface}{any\+\_\+interface}} in order to provide an extended interface to \mbox{\hyperlink{classseq_1_1hold__any}{hold\+\_\+any}} (see \mbox{\hyperlink{classseq_1_1hold__any}{hold\+\_\+any}} documentation for an example). 

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{structseq_1_1any__interface_a41139fb92d50855a61edaaeaa8ef34ab}\label{structseq_1_1any__interface_a41139fb92d50855a61edaaeaa8ef34ab}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!pointer\_type@{pointer\_type}}
\index{pointer\_type@{pointer\_type}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{pointer\_type}{pointer\_type}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
using \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::\mbox{\hyperlink{structseq_1_1any__interface_a41139fb92d50855a61edaaeaa8ef34ab}{pointer\+\_\+type}} =  \mbox{\hyperlink{classseq_1_1tagged__pointer}{tagged\+\_\+pointer}}$<$Type\+Info, \mbox{\hyperlink{namespaceseq_affae767f96f2af9924f7c6f3bdd4c72aad297c23409b392745ce5f3024304a8e8}{Custom\+Alignment}}, 16$>$\hspace{0.3cm}{\ttfamily [protected]}}

\mbox{\Hypertarget{structseq_1_1any__interface_a02f5afdfdb516af7a7d912d353819773}\label{structseq_1_1any__interface_a02f5afdfdb516af7a7d912d353819773}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!storage\_type@{storage\_type}}
\index{storage\_type@{storage\_type}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{storage\_type}{storage\_type}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
using \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::\mbox{\hyperlink{structseq_1_1any__interface_a02f5afdfdb516af7a7d912d353819773}{storage\+\_\+type}} =  typename std\+::aligned\+\_\+storage$<$ Static\+Size, Alignment$>$\+::\mbox{\hyperlink{structseq_1_1any__interface_ad6444b5617c79d79c0339492f1bb7347}{type}}\hspace{0.3cm}{\ttfamily [protected]}}

\mbox{\Hypertarget{structseq_1_1any__interface_a8f1c148efe5e1b91926ed3f361a7dfe0}\label{structseq_1_1any__interface_a8f1c148efe5e1b91926ed3f361a7dfe0}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!type\_info\_type@{type\_info\_type}}
\index{type\_info\_type@{type\_info\_type}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{type\_info\_type}{type\_info\_type}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
using \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::\mbox{\hyperlink{structseq_1_1any__interface_a8f1c148efe5e1b91926ed3f361a7dfe0}{type\+\_\+info\+\_\+type}} =  Type\+Info}



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{structseq_1_1any__interface_a7b471da36550f133f3b6c64ac5fb2eba}\label{structseq_1_1any__interface_a7b471da36550f133f3b6c64ac5fb2eba}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!alloc@{alloc}}
\index{alloc@{alloc}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{alloc()}{alloc()}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
template$<$class T $>$ \\
void$\ast$ \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::alloc (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

\mbox{\Hypertarget{structseq_1_1any__interface_a5d69d61bda53a51fcd7d338e3a6e38ff}\label{structseq_1_1any__interface_a5d69d61bda53a51fcd7d338e3a6e38ff}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!cast@{cast}}
\index{cast@{cast}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{cast()}{cast()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
template$<$class T $>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} T \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::cast (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Cast any object to given type. Throw a std\+::bad\+\_\+cast on error. 

\mbox{\Hypertarget{structseq_1_1any__interface_adb887b544a3bc663db27c66e81255361}\label{structseq_1_1any__interface_adb887b544a3bc663db27c66e81255361}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!cast@{cast}}
\index{cast@{cast}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{cast()}{cast()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
template$<$class T $>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const T \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::cast (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Cast any object to given type. Throw a std\+::bad\+\_\+cast on error. 

\mbox{\Hypertarget{structseq_1_1any__interface_a4973c3cdae25ef87930ad75e65febd44}\label{structseq_1_1any__interface_a4973c3cdae25ef87930ad75e65febd44}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!convert@{convert}}
\index{convert@{convert}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
template$<$class T $>$ \\
std\+::decay$<$T$>$\+::\mbox{\hyperlink{structseq_1_1any__interface_ad6444b5617c79d79c0339492f1bb7347}{type}} \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::convert (\begin{DoxyParamCaption}\item[{const Type\+Info $\ast$}]{info,  }\item[{const Type\+Info $\ast$}]{out\+\_\+p }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

\mbox{\Hypertarget{structseq_1_1any__interface_ad79eb510b2ef28842fc9bc1e9a23f972}\label{structseq_1_1any__interface_ad79eb510b2ef28842fc9bc1e9a23f972}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!data@{data}}
\index{data@{data}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{data()}{data()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const void$\ast$ \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the underlying object as a void$\ast$. Never returns a N\+U\+LL pointer, even for empty object. 

\mbox{\Hypertarget{structseq_1_1any__interface_ae2902f01e2e1384b79e9585b1bb3cbd8}\label{structseq_1_1any__interface_ae2902f01e2e1384b79e9585b1bb3cbd8}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!data@{data}}
\index{data@{data}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{data()}{data()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} void$\ast$ \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the underlying object as a void$\ast$. Never returns a N\+U\+LL pointer, even for empty object. 

\mbox{\Hypertarget{structseq_1_1any__interface_a31b929552dc9c823dca1704481fc3d01}\label{structseq_1_1any__interface_a31b929552dc9c823dca1704481fc3d01}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!dealloc@{dealloc}}
\index{dealloc@{dealloc}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{dealloc()}{dealloc()}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
void \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::dealloc (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}

\mbox{\Hypertarget{structseq_1_1any__interface_a7fd00b1480b121d411c78bd2e1eb4d7c}\label{structseq_1_1any__interface_a7fd00b1480b121d411c78bd2e1eb4d7c}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!empty@{empty}}
\index{empty@{empty}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} bool \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns true if this object is empty, false otherwise. 

\mbox{\Hypertarget{structseq_1_1any__interface_afb9c3a0fef8c62238700d805dcd2e7f3}\label{structseq_1_1any__interface_afb9c3a0fef8c62238700d805dcd2e7f3}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!hash@{hash}}
\index{hash@{hash}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{hash()}{hash()}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} size\+\_\+t \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::hash (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the hash value for underlying object based on std\+::hash. Might throw a std\+::bad\+\_\+function\+\_\+call. 

\mbox{\Hypertarget{structseq_1_1any__interface_a9587a1118997dfc48bf5b483324c129c}\label{structseq_1_1any__interface_a9587a1118997dfc48bf5b483324c129c}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!sizeof\_type@{sizeof\_type}}
\index{sizeof\_type@{sizeof\_type}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{sizeof\_type()}{sizeof\_type()}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} size\+\_\+t \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::sizeof\+\_\+type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the size of underlying type, 0 if empty. 

\mbox{\Hypertarget{structseq_1_1any__interface_a5bcd8d5d43cdec7ff3336ed1fb2fd517}\label{structseq_1_1any__interface_a5bcd8d5d43cdec7ff3336ed1fb2fd517}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!type@{type}}
\index{type@{type}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{type()}{type()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} const Type\+Info$\ast$ \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the type information as a Type\+Info pointer. Returns N\+U\+LL if the object is empty. 

\mbox{\Hypertarget{structseq_1_1any__interface_ad6444b5617c79d79c0339492f1bb7347}\label{structseq_1_1any__interface_ad6444b5617c79d79c0339492f1bb7347}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!type@{type}}
\index{type@{type}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{type()}{type()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} Type\+Info$\ast$ \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the type information as a Type\+Info pointer. Returns N\+U\+LL if the object is empty. 

\mbox{\Hypertarget{structseq_1_1any__interface_ab95f2e3edd6f4f32c5b00da5ec1eb199}\label{structseq_1_1any__interface_ab95f2e3edd6f4f32c5b00da5ec1eb199}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!type\_id@{type\_id}}
\index{type\_id@{type\_id}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{type\_id()}{type\_id()}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} int \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::type\+\_\+id (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the type id for this object. Returns 0 if the object is empty. 



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{structseq_1_1any__interface_ae9972f0fd985c59da519a907843c45ce}\label{structseq_1_1any__interface_ae9972f0fd985c59da519a907843c45ce}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!d\_storage@{d\_storage}}
\index{d\_storage@{d\_storage}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{d\_storage}{d\_storage}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{structseq_1_1any__interface_a02f5afdfdb516af7a7d912d353819773}{storage\+\_\+type}} \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::d\+\_\+storage\hspace{0.3cm}{\ttfamily [protected]}}

\mbox{\Hypertarget{structseq_1_1any__interface_a7db9b99517b26c0ddc5473f3dc29884c}\label{structseq_1_1any__interface_a7db9b99517b26c0ddc5473f3dc29884c}} 
\index{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}!d\_type\_info@{d\_type\_info}}
\index{d\_type\_info@{d\_type\_info}!seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$@{seq::any\_interface$<$ TypeInfo, StaticSize, Alignment $>$}}
\doxysubsubsection{\texorpdfstring{d\_type\_info}{d\_type\_info}}
{\footnotesize\ttfamily template$<$class Type\+Info , size\+\_\+t Static\+Size = sizeof(void$\ast$), size\+\_\+t Alignment = alignof(void$\ast$)$>$ \\
\mbox{\hyperlink{structseq_1_1any__interface_a41139fb92d50855a61edaaeaa8ef34ab}{pointer\+\_\+type}} \mbox{\hyperlink{structseq_1_1any__interface}{seq\+::any\+\_\+interface}}$<$ Type\+Info, Static\+Size, Alignment $>$\+::d\+\_\+type\+\_\+info\hspace{0.3cm}{\ttfamily [protected]}}



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
seq/\mbox{\hyperlink{any_01-_01_copie_8hpp}{any -\/ Copie.\+hpp}}\end{DoxyCompactItemize}
