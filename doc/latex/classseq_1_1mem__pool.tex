\hypertarget{classseq_1_1mem__pool}{}\doxysection{seq\+::mem\+\_\+pool$<$ T, Allocator, Align, Lock $>$ Class Template Reference}
\label{classseq_1_1mem__pool}\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}


{\ttfamily \#include $<$mem\+\_\+pool.\+hpp$>$}



Inherits \mbox{\hyperlink{classseq_1_1detail_1_1base__mem__pool}{seq\+::detail\+::base\+\_\+mem\+\_\+pool}}.

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_ac8c093966dc4a10702b0f14ac986c219}\label{classseq_1_1mem__pool_ac8c093966dc4a10702b0f14ac986c219}} 
using {\bfseries value\+\_\+type} = T
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_a31d65700937baa33fb4c440c4dd8fb90}\label{classseq_1_1mem__pool_a31d65700937baa33fb4c440c4dd8fb90}} 
using {\bfseries pointer} = T $\ast$
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_a881e0432e1ee4a9d4bc27d65af77280d}\label{classseq_1_1mem__pool_a881e0432e1ee4a9d4bc27d65af77280d}} 
using {\bfseries const\+\_\+pointer} = const T $\ast$
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_a152b5c9f9b220bc20383cbbb5f7554f1}\label{classseq_1_1mem__pool_a152b5c9f9b220bc20383cbbb5f7554f1}} 
using {\bfseries allocator\+\_\+type} = Allocator
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classseq_1_1mem__pool_ab990cb00b85c1cdbaf975ae62686a7af}{mem\+\_\+pool}} (const Allocator \&alloc=Allocator()) noexcept
\item 
\mbox{\hyperlink{classseq_1_1mem__pool_a4636bae49c0a12a2e98ef2b0e3c1243f}{mem\+\_\+pool}} (size\+\_\+t elem\+\_\+count, const Allocator \&alloc=Allocator())
\item 
\mbox{\hyperlink{classseq_1_1mem__pool_a65b35165ac7ce5b1a2d78defdddcacbd}{$\sim$mem\+\_\+pool}} ()
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_aef6d3ad6358eb1400829dc30ec029a55}\label{classseq_1_1mem__pool_aef6d3ad6358eb1400829dc30ec029a55}} 
{\bfseries mem\+\_\+pool} (const \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} \&)=delete
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_aefb6761a4edd93323adb4e5db965a68a}\label{classseq_1_1mem__pool_aefb6761a4edd93323adb4e5db965a68a}} 
\mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} \& {\bfseries operator=} (const \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} \&)=delete
\item 
Allocator \mbox{\hyperlink{classseq_1_1mem__pool_ac5d9a8a9fc4c365f9a908974cef0f67b}{get\+\_\+allocator}} () const noexcept
\item 
Allocator \& \mbox{\hyperlink{classseq_1_1mem__pool_a8dd5e96f66b86bbcda82224daea415aa}{get\+\_\+allocator}} () noexcept
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1mem__pool_ac7f0ff8188ada02c2a3227ba2cc789d4}{free\+\_\+count}} () const noexcept
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_a2a233d92720804a01b79246576459c8e}\label{classseq_1_1mem__pool_a2a233d92720804a01b79246576459c8e}} 
bool {\bfseries reclaim\+\_\+memory} () const noexcept
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_a596223ab4a3267706b812b40a8b5e49b}\label{classseq_1_1mem__pool_a596223ab4a3267706b812b40a8b5e49b}} 
void {\bfseries set\+\_\+reclaim\+\_\+memory} (bool reclaim)
\item 
virtual void \mbox{\hyperlink{classseq_1_1mem__pool_abd47976e06493962b756b8ab8dd4dcba}{reserve}} (size\+\_\+t count)
\item 
void \mbox{\hyperlink{classseq_1_1mem__pool_a0ea416f3ed99394d9410a6a7ffb7b39c}{release\+\_\+unused\+\_\+memory}} ()
\item 
T $\ast$ \mbox{\hyperlink{classseq_1_1mem__pool_abdb785c7b32c2de159efddcb77c37248}{allocate}} ()
\item 
bool \mbox{\hyperlink{classseq_1_1mem__pool_a91d636cee94ac1577d4a87cfe6d5e807}{deallocate\+\_\+if\+\_\+inside}} (T $\ast$ptr)
\item 
void \mbox{\hyperlink{classseq_1_1mem__pool_ac83aad427b5421bb3ffa67fab21d0ea2}{deallocate}} (T $\ast$ptr)
\item 
void \mbox{\hyperlink{classseq_1_1mem__pool_a7ac253cb241250f34e1d76f47507c2f6}{clear}} ()
\item 
void \mbox{\hyperlink{classseq_1_1mem__pool_a5090da6562ea8aae3f697f46408c67e5}{transfer\+\_\+content\+\_\+to}} (\mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} \&other)
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_af907830e3c92f98a9bcab3010330f0c9}\label{classseq_1_1mem__pool_af907830e3c92f98a9bcab3010330f0c9}} 
void {\bfseries reset\+\_\+statistics} ()
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_a4d9b52facccafe0ababef297cbceea64}\label{classseq_1_1mem__pool_a4d9b52facccafe0ababef297cbceea64}} 
void {\bfseries dump\+\_\+statistics} (\mbox{\hyperlink{structseq_1_1mem__pool__statistics}{mem\+\_\+pool\+\_\+statistics}} \&stats)
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1mem__pool_ae2918b0a998fe4aaf9770ced9d672ad5}{memory\+\_\+footprint}} () const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1mem__pool_ae7fa2aa92f0c58b71eb16ab9c875c676}{capacity}} () const
\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1mem__pool_a9fa4c3a7a0746cf7c6cafbb25353c075}{objects}} () const
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_a43ae6a34abd685ad7e48194dc1a25f8b}\label{classseq_1_1mem__pool_a43ae6a34abd685ad7e48194dc1a25f8b}} 
size\+\_\+t {\bfseries key} () const noexcept
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_ab29096765d94b88bc50e20f3b95eeac7}\label{classseq_1_1mem__pool_ab29096765d94b88bc50e20f3b95eeac7}} 
void $\ast$ {\bfseries allocate\+\_\+one} (void $\ast$)
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_ac315cc34f42d6737715ff1e7c9975eaf}\label{classseq_1_1mem__pool_ac315cc34f42d6737715ff1e7c9975eaf}} 
void {\bfseries deallocate\+\_\+one} (void $\ast$ptr)
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classseq_1_1mem__pool_a06a43d39c49474005408c7b5777e7d33}\label{classseq_1_1mem__pool_a06a43d39c49474005408c7b5777e7d33}} 
{\footnotesize template$<$class U , class Al , size\+\_\+t A, class L $>$ }\\class {\bfseries parallel\+\_\+mem\+\_\+pool}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class T, class Allocator = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock = null\+\_\+lock$>$\newline
class seq\+::mem\+\_\+pool$<$ T, Allocator, Align, Lock $>$}

Memory pool class used to allocate individual elements.

\mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} class allocates/deallocates individual elements of type {\itshape T}. It internally allocates chunks of T objects using a growing strategy based on the global growth factor S\+E\+Q\+\_\+\+G\+R\+O\+W\+\_\+\+F\+A\+C\+T\+OR (1.\+6 by default). The chunks are allocated using given allocator as template parameter, by default {\itshape std\+::allocator$<$\+T$>$}.

Objects allocated using \#mem\+\_\+pool\+::allocate are always aligned on the default platform alignment value (usually alignof(std\+::max\+\_\+align\+\_\+t)), even if sizeof(\+T) $<$ alignof(std\+::max\+\_\+align\+\_\+t).

The {\itshape Lock} template parameter is a mutex-\/like class that can be set to std\+::mutex or seq\+::spinlock for multithreaded allocations/deallocations. Using {\itshape \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}}} class in a multithreaded context with the default {\itshape \mbox{\hyperlink{structnull__lock}{null\+\_\+lock}}} class will introduce undefined behaviors in your program.

If {\itshape Reclaim\+Memory} is false, {\itshape the} \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} object will never free its internal memory on calls to \#mem\+\_\+pool\+::deallocate. In such case, only calls to \#mem\+\_\+pool\+::release\+\_\+unused\+\_\+memory() and the class destructor will release previously allocated memory.

{\itshape \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}}} class has been tested on Windows and Linux where performances are very similar\+:


\begin{DoxyItemize}
\item Calls to \#mem\+\_\+pool\+::allocate and mem\+\_\+pool\+::deallocate are usually 5 times faster than the stock malloc/free, and around 3 times faster when using seq\+::spinlock.
\item Using \#mem\+\_\+pool\+::allocate instead of malloc results in a 8 bytes saving per allocation (on 64 bits platforms), since malloc almost always uses a 8-\/4 bytes control block per allocation. 
\end{DoxyItemize}

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classseq_1_1mem__pool_ab990cb00b85c1cdbaf975ae62686a7af}\label{classseq_1_1mem__pool_ab990cb00b85c1cdbaf975ae62686a7af}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!mem\_pool@{mem\_pool}}
\index{mem\_pool@{mem\_pool}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{mem\_pool()}{mem\_pool()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
\mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::\mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} (\begin{DoxyParamCaption}\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Constructor the \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} using an Allocator object \mbox{\Hypertarget{classseq_1_1mem__pool_a4636bae49c0a12a2e98ef2b0e3c1243f}\label{classseq_1_1mem__pool_a4636bae49c0a12a2e98ef2b0e3c1243f}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!mem\_pool@{mem\_pool}}
\index{mem\_pool@{mem\_pool}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{mem\_pool()}{mem\_pool()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
\mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::\mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{elem\+\_\+count,  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Construct the \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} by reserving {\itshape elem\+\_\+count} elements. Throws a std\+::bad\+\_\+alloc exception on failure. \mbox{\Hypertarget{classseq_1_1mem__pool_a65b35165ac7ce5b1a2d78defdddcacbd}\label{classseq_1_1mem__pool_a65b35165ac7ce5b1a2d78defdddcacbd}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!````~mem\_pool@{$\sim$mem\_pool}}
\index{````~mem\_pool@{$\sim$mem\_pool}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$mem\_pool()}{~mem\_pool()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
\mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::$\sim$\mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Destructor, free all previously allocated memory. This will invalidate all previously allocated objects. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classseq_1_1mem__pool_abdb785c7b32c2de159efddcb77c37248}\label{classseq_1_1mem__pool_abdb785c7b32c2de159efddcb77c37248}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!allocate@{allocate}}
\index{allocate@{allocate}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
T$\ast$ \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::allocate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Allocate an uninitialized T object. This operation performs in amortized O(1).

Throws a std\+::bad\+\_\+alloc exception on failure. \mbox{\Hypertarget{classseq_1_1mem__pool_ae7fa2aa92f0c58b71eb16ab9c875c676}\label{classseq_1_1mem__pool_ae7fa2aa92f0c58b71eb16ab9c875c676}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!capacity@{capacity}}
\index{capacity@{capacity}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{capacity()}{capacity()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::capacity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Returns the \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} capacity in terms of T objects. 

Implements \mbox{\hyperlink{classseq_1_1detail_1_1base__mem__pool}{seq\+::detail\+::base\+\_\+mem\+\_\+pool}}.

\mbox{\Hypertarget{classseq_1_1mem__pool_a7ac253cb241250f34e1d76f47507c2f6}\label{classseq_1_1mem__pool_a7ac253cb241250f34e1d76f47507c2f6}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!clear@{clear}}
\index{clear@{clear}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
void \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Free all previously allocated memory. This will invalidate all previously allocated objects. Reinitialize the \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} object. \mbox{\Hypertarget{classseq_1_1mem__pool_ac83aad427b5421bb3ffa67fab21d0ea2}\label{classseq_1_1mem__pool_ac83aad427b5421bb3ffa67fab21d0ea2}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{deallocate()}{deallocate()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
void \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::deallocate (\begin{DoxyParamCaption}\item[{T $\ast$}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Deallocate a single object. The object destructor must be called before calling mem\+\_\+pool\+::deallocate. {\itshape ptr} must have been allocated with this \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}}. Calls abort() if the pointer does not belong to this \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}}. \mbox{\Hypertarget{classseq_1_1mem__pool_a91d636cee94ac1577d4a87cfe6d5e807}\label{classseq_1_1mem__pool_a91d636cee94ac1577d4a87cfe6d5e807}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!deallocate\_if\_inside@{deallocate\_if\_inside}}
\index{deallocate\_if\_inside@{deallocate\_if\_inside}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{deallocate\_if\_inside()}{deallocate\_if\_inside()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
bool \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::deallocate\+\_\+if\+\_\+inside (\begin{DoxyParamCaption}\item[{T $\ast$}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Deallocate a single object. The object destructor must be called before calling mem\+\_\+pool\+::deallocate. Silently fails if {\itshape ptr} does not belong to this \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}}. \mbox{\Hypertarget{classseq_1_1mem__pool_ac7f0ff8188ada02c2a3227ba2cc789d4}\label{classseq_1_1mem__pool_ac7f0ff8188ada02c2a3227ba2cc789d4}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!free\_count@{free\_count}}
\index{free\_count@{free\_count}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{free\_count()}{free\_count()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::free\+\_\+count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns the number of available free slots \mbox{\Hypertarget{classseq_1_1mem__pool_ac5d9a8a9fc4c365f9a908974cef0f67b}\label{classseq_1_1mem__pool_ac5d9a8a9fc4c365f9a908974cef0f67b}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
Allocator \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns the underlying allocator \mbox{\Hypertarget{classseq_1_1mem__pool_a8dd5e96f66b86bbcda82224daea415aa}\label{classseq_1_1mem__pool_a8dd5e96f66b86bbcda82224daea415aa}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
Allocator\& \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns the underlying allocator \mbox{\Hypertarget{classseq_1_1mem__pool_ae2918b0a998fe4aaf9770ced9d672ad5}\label{classseq_1_1mem__pool_ae2918b0a998fe4aaf9770ced9d672ad5}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!memory\_footprint@{memory\_footprint}}
\index{memory\_footprint@{memory\_footprint}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{memory\_footprint()}{memory\_footprint()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::memory\+\_\+footprint (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Returns the object memory footprint in bytes excluding sizeof($\ast$this). 

Implements \mbox{\hyperlink{classseq_1_1detail_1_1base__mem__pool}{seq\+::detail\+::base\+\_\+mem\+\_\+pool}}.

\mbox{\Hypertarget{classseq_1_1mem__pool_a9fa4c3a7a0746cf7c6cafbb25353c075}\label{classseq_1_1mem__pool_a9fa4c3a7a0746cf7c6cafbb25353c075}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!objects@{objects}}
\index{objects@{objects}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{objects()}{objects()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::objects (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Returns the number of allocated objects. 

Implements \mbox{\hyperlink{classseq_1_1detail_1_1base__mem__pool}{seq\+::detail\+::base\+\_\+mem\+\_\+pool}}.

\mbox{\Hypertarget{classseq_1_1mem__pool_a0ea416f3ed99394d9410a6a7ffb7b39c}\label{classseq_1_1mem__pool_a0ea416f3ed99394d9410a6a7ffb7b39c}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!release\_unused\_memory@{release\_unused\_memory}}
\index{release\_unused\_memory@{release\_unused\_memory}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{release\_unused\_memory()}{release\_unused\_memory()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
void \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::release\+\_\+unused\+\_\+memory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Free all unused memory. This only makes sense if \#reclaim\+\_\+memory() is false. \mbox{\Hypertarget{classseq_1_1mem__pool_abd47976e06493962b756b8ab8dd4dcba}\label{classseq_1_1mem__pool_abd47976e06493962b756b8ab8dd4dcba}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!reserve@{reserve}}
\index{reserve@{reserve}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
virtual void \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::reserve (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Extend the \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} object in order to hold at least {\itshape count} slots. Does nothing if count $<$= \mbox{\hyperlink{classseq_1_1mem__pool_ae7fa2aa92f0c58b71eb16ab9c875c676}{capacity()}}.

Throws a std\+::bad\+\_\+alloc exception on failure. 

Implements \mbox{\hyperlink{classseq_1_1detail_1_1base__mem__pool}{seq\+::detail\+::base\+\_\+mem\+\_\+pool}}.

\mbox{\Hypertarget{classseq_1_1mem__pool_a5090da6562ea8aae3f697f46408c67e5}\label{classseq_1_1mem__pool_a5090da6562ea8aae3f697f46408c67e5}} 
\index{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}!transfer\_content\_to@{transfer\_content\_to}}
\index{transfer\_content\_to@{transfer\_content\_to}!seq::mem\_pool$<$ T, Allocator, Align, Lock $>$@{seq::mem\_pool$<$ T, Allocator, Align, Lock $>$}}
\doxysubsubsection{\texorpdfstring{transfer\_content\_to()}{transfer\_content\_to()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = 0, class Lock  = null\+\_\+lock$>$ \\
void \mbox{\hyperlink{classseq_1_1mem__pool}{seq\+::mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$\+::transfer\+\_\+content\+\_\+to (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}}$<$ T, Allocator, Align, Lock $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Transfer the content of this \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} to {\itshape other}. All the slots (occupied or not) ar transferred to {\itshape other}. Therefore, objects previously allocated by this can only be deallocated by {\itshape other} after the call to {\itshape transfer\+\_\+content\+\_\+to}. {\itshape this} \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} \mbox{\hyperlink{classseq_1_1mem__pool}{mem\+\_\+pool}} is considered as empty and can be reused afterward.

This function does nothing if \mbox{\hyperlink{classseq_1_1mem__pool_a8dd5e96f66b86bbcda82224daea415aa}{get\+\_\+allocator()}} != other.\+get\+\_\+allocator(). 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
mem\+\_\+pool.\+hpp\end{DoxyCompactItemize}
