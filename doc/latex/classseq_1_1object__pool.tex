\hypertarget{classseq_1_1object__pool}{}\doxysection{seq\+::object\+\_\+pool$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$ Class Template Reference}
\label{classseq_1_1object__pool}\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}


Object pool class used to allocate objects of type T.  




{\ttfamily \#include $<$memory.\+hpp$>$}



Inherits \mbox{\hyperlink{structseq_1_1detail_1_1base__object__pool}{seq\+::detail\+::base\+\_\+object\+\_\+pool$<$ T $>$}}, \mbox{\hyperlink{structseq_1_1detail_1_1stats__data_3_01false_01_4}{seq\+::detail\+::stats\+\_\+data$<$ false $>$}}, and allocator$<$ T $>$.

\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structseq_1_1object__pool_1_1rebind}{rebind}}
\begin{DoxyCompactList}\small\item\em Rebind struct, used for \mbox{\hyperlink{classseq_1_1object__allocator}{seq\+::object\+\_\+allocator}}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classseq_1_1object__pool_a8b6a4b58f45dfb4560a16c9b4a6454e0}{value\+\_\+type}} = T
\begin{DoxyCompactList}\small\item\em object type \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classseq_1_1object__pool_a72539665f913721acd4787fedaa5a2c7}{pointer}} = T $\ast$
\begin{DoxyCompactList}\small\item\em pointer type \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classseq_1_1object__pool_a4fe372637946e7d71e0d77363bcec812}{allocator\+\_\+type}} = Allocator
\begin{DoxyCompactList}\small\item\em supplied allocator type \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classseq_1_1object__pool_a38e3596ddb1309e36ebc321386d6dc5d}{unique\+\_\+ptr}} = std\+::unique\+\_\+ptr$<$ T, \mbox{\hyperlink{structseq_1_1unique__ptr__deleter}{unique\+\_\+ptr\+\_\+deleter}}$<$ T $>$ $>$
\begin{DoxyCompactList}\small\item\em unique\+\_\+ptr type if Enable\+Unique\+Ptr is true \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classseq_1_1object__pool_a2deaec289a41210128d70792113aaeed}{shared\+\_\+ptr}} = std\+::shared\+\_\+ptr$<$ T $>$
\begin{DoxyCompactList}\small\item\em shared\+\_\+ptr type if \mbox{\hyperlink{structseq_1_1shared__ptr__allocation}{shared\+\_\+ptr\+\_\+allocation}} is used with Enable\+Unique\+Ptr \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classseq_1_1object__pool_a72acd76f831a3e0c65fdcbde44f9f6fa}{allocation\+\_\+type}} = object\+\_\+allocation
\begin{DoxyCompactList}\small\item\em allocation pattern \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classseq_1_1object__pool_a799aee7e762678e020cd05b8cb27631f}{object\+\_\+pool}} (const Allocator \&al=Allocator()) noexcept
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1object__pool_a203e9fbadbf9152df5630ba693df64e8}{$\sim$object\+\_\+pool}} ()
\item 
void \mbox{\hyperlink{classseq_1_1object__pool_ab508ba0903b7b60224c116c1016be050}{clear}} ()
\begin{DoxyCompactList}\small\item\em Free all blocks. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1object__pool_a12613b106f8af2a86e9084da4e2cd4bb}{reset}} ()
\begin{DoxyCompactList}\small\item\em Reset the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1object__pool_a5ba0e2834a30fa3cbb4a1d895eb0f687}{reset\+\_\+statistics}} () noexcept
\begin{DoxyCompactList}\small\item\em Reset statistics. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1object__pool_ae2eeb6dbde18dbe45eba8527db0dec52}{dump\+\_\+statistics}} (\mbox{\hyperlink{structseq_1_1object__pool__stats}{object\+\_\+pool\+\_\+stats}} \&stats)
\begin{DoxyCompactList}\small\item\em Dump \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} statistics into a \mbox{\hyperlink{structseq_1_1object__pool__stats}{object\+\_\+pool\+\_\+stats}}. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classseq_1_1object__pool_aa7f2219bf1f9dc09c5c1e67948febd70}{get\+\_\+allocator}} () const noexcept -\/$>$ const Allocator \&
\begin{DoxyCompactList}\small\item\em Returns the underlying allocator object. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classseq_1_1object__pool_a2286444dc9ce69a944f9465f0e12b37d}{get\+\_\+allocator}} () noexcept -\/$>$ Allocator \&
\begin{DoxyCompactList}\small\item\em Returns the underlying allocator object. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classseq_1_1object__pool_adcb78702499af1357a871e3a0aadf0d8}{memory\+\_\+footprint}} () const noexcept -\/$>$ std\+::size\+\_\+t
\begin{DoxyCompactList}\small\item\em Returns the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} memory footprint in bytes excluding sizeof($\ast$this). \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classseq_1_1object__pool_aa38fbf8d66be889bb4b075b917942c89}{peak\+\_\+memory\+\_\+footprint}} () const noexcept -\/$>$ std\+::size\+\_\+t
\begin{DoxyCompactList}\small\item\em Returns the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} peak memory footprint in bytes excluding sizeof($\ast$this). \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classseq_1_1object__pool_ad97abff55ea874b6a6d1777fc3da9e15}{reclaim\+\_\+memory}} () const noexcept -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Returns true if the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} reclaim freed memory, false otherwise. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1object__pool_aee9c75a122612306b3a95466946afddc}{set\+\_\+reclaim\+\_\+memory}} (bool reclaim)
\begin{DoxyCompactList}\small\item\em Set the reclaim\+\_\+memory flag. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1object__pool_a575391a7d2cc25c2e8d0394d6057a5a9}{release\+\_\+unused\+\_\+memory}} ()
\begin{DoxyCompactList}\small\item\em Deallocate all unused memory blocks. This only makes sense if \mbox{\hyperlink{classseq_1_1object__pool_ad97abff55ea874b6a6d1777fc3da9e15}{reclaim\+\_\+memory()}} is false. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}{allocate}} (size\+\_\+t size) -\/$>$ T $\ast$
\begin{DoxyCompactList}\small\item\em Allocate size objects. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}{deallocate}} (T $\ast$ptr, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Deallocate size objects. Non P\+OD objects must have been destroyed previously. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1object__pool_aa96fd22de10478226d8d5650ef4efb1a}{reserve}} (size\+\_\+t alloc\+\_\+size, size\+\_\+t count)
\begin{DoxyCompactList}\small\item\em Extend the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} in order to hold at least count free slots for calls to allocate(alloc\+\_\+size). \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\auto \mbox{\hyperlink{classseq_1_1object__pool_a6c693c5b972f21af9ab51a7fd22d15ba}{make\+\_\+unique}} (Args \&\&... args) -\/$>$ \mbox{\hyperlink{classseq_1_1object__pool_a38e3596ddb1309e36ebc321386d6dc5d}{unique\+\_\+ptr}}
\begin{DoxyCompactList}\small\item\em Returns a unique\+\_\+ptr object constructed from the forwarded argument. \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\auto \mbox{\hyperlink{classseq_1_1object__pool_a46c19b78510cd2becc02db55eea3dc62}{make\+\_\+shared}} (Args \&\&... args) -\/$>$ std\+::shared\+\_\+ptr$<$ T $>$
\begin{DoxyCompactList}\small\item\em Experimental. Returns a shared\+\_\+ptr object built with this \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const bool \mbox{\hyperlink{classseq_1_1object__pool_a304a11305aae4756635ef6d318d322ce}{enable\+\_\+unique\+\_\+ptr}} = Enable\+Unique\+Ptr
\begin{DoxyCompactList}\small\item\em enable/disable unique\+\_\+ptr support \end{DoxyCompactList}\item 
static const bool \mbox{\hyperlink{classseq_1_1object__pool_aa3e04ee3d7d7a20bdce33ae208ac47d8}{generate\+\_\+statistics}} = Generate\+Stats
\begin{DoxyCompactList}\small\item\em generate temporal statistics \end{DoxyCompactList}\item 
static const size\+\_\+t \mbox{\hyperlink{classseq_1_1object__pool_add308abe3f00a1e6938b9405439b92f5}{alignment}} = (Align == 0 $\vert$$\vert$ Align $<$ \mbox{\hyperlink{group__bits_ga4358957bf3c41e772ade27671699c4e6}{S\+E\+Q\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}) ? \mbox{\hyperlink{group__bits_ga4358957bf3c41e772ade27671699c4e6}{S\+E\+Q\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}} \+: Align
\begin{DoxyCompactList}\small\item\em object alignment \end{DoxyCompactList}\item 
static const size\+\_\+t \mbox{\hyperlink{classseq_1_1object__pool_a6914cbef77dc008cc1bc5ffaf81adec9}{max\+\_\+objects}} = object\+\_\+allocation\+::max\+\_\+objects
\begin{DoxyCompactList}\small\item\em maximum number of objects per allocation before going right through the allocator \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class U , class Pool $>$ }\\class \mbox{\hyperlink{classseq_1_1object__pool_a3494f5bb0141e8c38ce58167ba42ed05}{detail\+::allocator\+\_\+for\+\_\+shared\+\_\+ptr}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class T, class Allocator = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$\newline
class seq\+::object\+\_\+pool$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$}

Object pool class used to allocate objects of type T. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & object type \\
\hline
{\em Allocator} & allocator type used by this \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} \\
\hline
{\em object\+\_\+allocation} & allocation pattern \\
\hline
{\em Enable\+Unique\+Ptr} & allow creating std\+::unique\+\_\+ptr with this \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} \\
\hline
{\em Generate\+Stats} & maintains temporal statistics\\
\hline
\end{DoxyTemplParams}
\mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}} is a memory pool class used to allocate objects of type T. It does so by managing internally contiguous memory blocks of increasing size, based on the growth factor S\+E\+Q\+\_\+\+G\+R\+O\+W\+\_\+\+F\+A\+C\+T\+OR (default to 1.\+6).

\mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}} has the following properties\+:
\begin{DoxyItemize}
\item It is fast for allocating single objects, typically 10 times faster than the default malloc/free implementation.
\item It reduces memory fragmentation for small data types.
\item It can allocate more than one object at a time based on the provided object\+\_\+allocation template parameter.
\item It provides statistics\+: memory footprint, peak memory footprint, number of objects, total number of allocated/deallocated objects (if Generate\+Stats is true).
\item The memory blocks are released on destruction or on calls to \mbox{\hyperlink{classseq_1_1object__pool_ab508ba0903b7b60224c116c1016be050}{clear()}} or \mbox{\hyperlink{classseq_1_1object__pool_a575391a7d2cc25c2e8d0394d6057a5a9}{release\+\_\+unused\+\_\+memory()}}.
\item It can generate std\+::unique\+\_\+ptr object (if Enable\+Unique\+Ptr is true) that outlive the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} object.
\end{DoxyItemize}

\mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} is N\+OT thread safe. For a thread safe alternative, see \mbox{\hyperlink{classseq_1_1parallel__object__pool}{seq\+::parallel\+\_\+object\+\_\+pool}}.\hypertarget{classseq_1_1object__pool_autotoc_md28}{}\doxysubsubsection{Allocation}\label{classseq_1_1object__pool_autotoc_md28}
Use \mbox{\hyperlink{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}{object\+\_\+pool\+::allocate()}} to allocate one or more objects. If the requested number of objects is lower or equal to object\+\_\+allocation\+::max\+\_\+objects, the pool will look for a memory block able to allocate the requested size. If no such block exists, a new block is created based on provided allocator. If the object count is greater than object\+\_\+allocation\+::max\+\_\+objects, \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} will directly use the supplied allocator object.

Each memory block is a contiguous memory chunk, where new objects are extracted by incrementing a head pointer (this is a simplification as the provided alignment must be taken into account). On deallocation, the created free slot is added to a monodirectional linked list of free slots and ready to be used for further allocations. The allocation process always performs in O(1), except when a new memory block must be created (in which case the behavior depends on the provided allocator).

\mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} can potentially allocate more than one object using the internal block mechanism. This depends on the provided object\+\_\+allocation type, which defines the maximum number of objects a user can request, and the allocation pattern. The default type is linear\+\_\+object\+\_\+allocation$<$1$>$ that can only allocate 1 object per call using the block mechanism. The possible object\+\_\+allocation types are\+:
\begin{DoxyItemize}
\item linear\+\_\+object\+\_\+allocation$<$\+Max\+Size$>$\+: can allocate up to Max\+Size contiguous objects at once. For instance, when using Max\+Object == 2, the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} will manage 2 types of memory blocks\+: those than can allocate 1 object, and those that can allocate 2 objects. These types of block are managed independently, and grow independently based on user requests. This is, in fact, very similar to managing 2 different \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}}, except that a free memory block used initially to allocate 1 object can be reused later to allocate 2 objects.
\item block\+\_\+object\+\_\+allocation$<$\+Max\+Size,\+Block\+Size$>$\+: can allocate up to Max\+Size contiguous objects by step of Block\+Size. For instance with block\+\_\+object\+\_\+allocation$<$12,4$>$, if the user ask for 10 objects, these objects will be extracted from a block managing 12 objects.
\item pow\+\_\+object\+\_\+allocation$<$\+Max\+Size$>$\+: can allocate up to Max\+Size contiguous objects by steps which are power of 2. For pow\+\_\+object\+\_\+allocation$<$16$>$, the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} manages 5 types of memory block, which can allocate 1, 2, 4, 8 or 16 objects.
\end{DoxyItemize}

As explained above, \mbox{\hyperlink{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}{object\+\_\+pool\+::allocate()}} never fails (except with a potential std\+::bad\+\_\+alloc), and will fallback to the supplied allocator if requested number of objects is not managed by the provided object\+\_\+allocation type.

Usage example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classseq_1_1object__pool}{seq::object\_pool<int, std::allocator<int>}}, \mbox{\hyperlink{namespaceseq_adac07c5c5e3d6da3ebb03f7ddd1e7cdea668d551cd99226655e9e973b6d5be517}{seq::DefaultAlignment}}, \mbox{\hyperlink{structseq_1_1linear__object__allocation}{seq::linear\_object\_allocation<2>}} > pool;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} *p1 = pool.\mbox{\hyperlink{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}{allocate}}(1); \textcolor{comment}{// use memory blocks dedicated to allocate 1 object}}
\DoxyCodeLine{\textcolor{keywordtype}{int} *p2 = pool.\mbox{\hyperlink{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}{allocate}}(2); \textcolor{comment}{// use memory blocks dedicated to allocate 2 object2}}
\DoxyCodeLine{\textcolor{keywordtype}{int} *p3 = pool.\mbox{\hyperlink{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}{allocate}}(3); \textcolor{comment}{// directly call std::allocator<int>::allocate(3)}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// deallocate all}}
\DoxyCodeLine{pool.\mbox{\hyperlink{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}{deallocate}}(p1,1);}
\DoxyCodeLine{pool.\mbox{\hyperlink{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}{deallocate}}(p2,2);}
\DoxyCodeLine{pool.\mbox{\hyperlink{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}{deallocate}}(p3,3);  \textcolor{comment}{// directly call std::allocator<int>::deallocate(p3,3)}}
\end{DoxyCode}
\hypertarget{classseq_1_1object__pool_autotoc_md29}{}\doxysubsubsection{Deallocation}\label{classseq_1_1object__pool_autotoc_md29}
Use \mbox{\hyperlink{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}{object\+\_\+pool\+::deallocate()}} to deallocate a memory region previously allocated with \mbox{\hyperlink{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}{object\+\_\+pool\+::allocate()}}. A deallocation can trigger 2 types of mechanism\+:
\begin{DoxyItemize}
\item If the number of objects to deallocate is greater than object\+\_\+allocation\+::max\+\_\+objects, the supplied allocator is directly used for the deallocation.
\item Otherwise\+:
\begin{DoxyEnumerate}
\item The memory block to which belong the objects is found,
\item The objects are marked as free slots and added to a free list
\item If the memory block is empty (no more objects inside), it is either\+:
\begin{DoxyItemize}
\item Deallocated if \mbox{\hyperlink{classseq_1_1object__pool_ad97abff55ea874b6a6d1777fc3da9e15}{reclaim\+\_\+memory()}} is true
\item Kept internally for further reuse if \mbox{\hyperlink{classseq_1_1object__pool_ad97abff55ea874b6a6d1777fc3da9e15}{reclaim\+\_\+memory()}} is false.
\end{DoxyItemize}
\end{DoxyEnumerate}
\end{DoxyItemize}

Memory blocks do not outlive the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}}. On destruction or calls to \mbox{\hyperlink{classseq_1_1object__pool_ab508ba0903b7b60224c116c1016be050}{clear()}} or \mbox{\hyperlink{classseq_1_1object__pool_a575391a7d2cc25c2e8d0394d6057a5a9}{release\+\_\+unused\+\_\+memory()}}, all memory blocks are freed (this invalidates pointers referencing these blocks). Note, however, that the memory allocated with supplied allocator when requested object count is greater than object\+\_\+allocation\+::max\+\_\+objects is not automatically deallocated.

Another exception is when dealing with std\+::unique\+\_\+ptr (see next section).\hypertarget{classseq_1_1object__pool_autotoc_md30}{}\doxysubsubsection{Unique pointers}\label{classseq_1_1object__pool_autotoc_md30}
An \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} can create std\+::unique\+\_\+ptr objects only if Enable\+Unique\+Ptr is true. In this case the unique\+\_\+ptr type is given by the typedef \mbox{\hyperlink{classseq_1_1object__pool_a38e3596ddb1309e36ebc321386d6dc5d}{object\+\_\+pool$<$\+T$>$\+::unique\+\_\+ptr}}. This is basically a std\+::unique\+\_\+ptr with a custom deleter class.

Use \mbox{\hyperlink{classseq_1_1object__pool_a6c693c5b972f21af9ab51a7fd22d15ba}{object\+\_\+pool\+::make\+\_\+unique()}} to create unique\+\_\+ptr objects. These objects will outlive the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}}. When destroying the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} or on calls to \mbox{\hyperlink{classseq_1_1object__pool_ab508ba0903b7b60224c116c1016be050}{object\+\_\+pool\+::clear()}} or \mbox{\hyperlink{classseq_1_1object__pool_a575391a7d2cc25c2e8d0394d6057a5a9}{release\+\_\+unused\+\_\+memory()}}, all memory blocks that contain at least one object stored in a unique\+\_\+ptr are not destroyed. These blocks contain a thread-\/safe reference counter that is decremented whenever a unique\+\_\+ptr is destroyed, and is eventually deallocated when the last unique\+\_\+ptr referencing it is destroyed.

You should never call \mbox{\hyperlink{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}{object\+\_\+pool\+::deallocate()}} on a pointer held by a unique\+\_\+ptr, this will lead to a segfault on unique\+\_\+ptr destruction.

You can still release the pointer using std\+::unique\+\_\+ptr\+::release(), but the pointer must then be destroyed with \mbox{\hyperlink{namespaceseq_a1349a44a2ff37300a5c72a03780780fe}{seq\+::unique\+\_\+ptr\+\_\+delete()}}, which calls the object destructor and deallocate the memory if needed.

Usage example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} pool\_type = \mbox{\hyperlink{classseq_1_1object__pool}{seq::object\_pool<int, std::allocator<int>}}, \mbox{\hyperlink{namespaceseq_adac07c5c5e3d6da3ebb03f7ddd1e7cdea668d551cd99226655e9e973b6d5be517}{seq::DefaultAlignment}}, \mbox{\hyperlink{structseq_1_1linear__object__allocation}{seq::linear\_object\_allocation<1>}}, \textcolor{keyword}{true} >;}
\DoxyCodeLine{\textcolor{keyword}{using} \mbox{\hyperlink{classseq_1_1object__pool_a38e3596ddb1309e36ebc321386d6dc5d}{unique\_ptr}} = \textcolor{keyword}{typename} pool\_type::unique\_ptr;}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{classseq_1_1object__pool_a38e3596ddb1309e36ebc321386d6dc5d}{unique\_ptr}} p1, p2;}
\DoxyCodeLine{\{}
\DoxyCodeLine{pool\_type pool;}
\DoxyCodeLine{}
\DoxyCodeLine{p1 = pool.\mbox{\hyperlink{classseq_1_1object__pool_a6c693c5b972f21af9ab51a7fd22d15ba}{make\_unique}}(1);   \textcolor{comment}{//unique ptr containing int(1)}}
\DoxyCodeLine{p2 = pool.make\_unique(2);   \textcolor{comment}{//unique ptr containing int(2)}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// p1 and p2 are still valid}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} * ptr = p1.release();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//ptr is still valid, but must now be release with seq::unique\_ptr\_delete()}}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{namespaceseq_a1349a44a2ff37300a5c72a03780780fe}{seq::unique\_ptr\_delete}}(ptr);}
\end{DoxyCode}


The unique\+\_\+ptr generation is not enabled by default as it makes the allocation process slightly slower and require more memory (one additional pointer per allocation).\hypertarget{classseq_1_1object__pool_autotoc_md31}{}\doxysubsubsection{Statistics}\label{classseq_1_1object__pool_autotoc_md31}
At any point, the total memory footprint of an \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} can be retrieved with \mbox{\hyperlink{classseq_1_1object__pool_adcb78702499af1357a871e3a0aadf0d8}{object\+\_\+pool\+::memory\+\_\+footprint()}}. The peak memory footprint can be retrieved with \mbox{\hyperlink{classseq_1_1object__pool_aa38fbf8d66be889bb4b075b917942c89}{peak\+\_\+memory\+\_\+footprint()}}.

To access to more detailed statistics, the function \mbox{\hyperlink{classseq_1_1object__pool_ae2eeb6dbde18dbe45eba8527db0dec52}{object\+\_\+pool\+::dump\+\_\+statistics()}} will provide the following information through a \mbox{\hyperlink{structseq_1_1object__pool__stats}{object\+\_\+pool\+\_\+stats}} object\+:
\begin{DoxyItemize}
\item memory\+: current memory footprint in bytes
\item peak\+\_\+memory\+: highest recorded memory footprint
\item objects\+: current number of allocated objects
\item total\+\_\+created\+: total number of objects that has been allocated (Generate\+Stats must be true)
\item total\+\_\+freed\+: total number of object that has been deallocated (Generate\+Stats must be true)
\item thread\+\_\+count\+: total number of threads using this pool (always 0 for \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}})
\end{DoxyItemize}

The peak\+\_\+memory, total\+\_\+created and total\+\_\+freed can be reseted using \mbox{\hyperlink{classseq_1_1object__pool_a5ba0e2834a30fa3cbb4a1d895eb0f687}{object\+\_\+pool\+::reset\+\_\+statistics()}}. The peak\+\_\+memory will be set to the current memory footprint, total\+\_\+created and total\+\_\+freed will be set to 0. 

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{classseq_1_1object__pool_a72acd76f831a3e0c65fdcbde44f9f6fa}\label{classseq_1_1object__pool_a72acd76f831a3e0c65fdcbde44f9f6fa}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!allocation\_type@{allocation\_type}}
\index{allocation\_type@{allocation\_type}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{allocation\_type}{allocation\_type}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
using \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::\mbox{\hyperlink{classseq_1_1object__pool_a72acd76f831a3e0c65fdcbde44f9f6fa}{allocation\+\_\+type}} =  object\+\_\+allocation}



allocation pattern 

\mbox{\Hypertarget{classseq_1_1object__pool_a4fe372637946e7d71e0d77363bcec812}\label{classseq_1_1object__pool_a4fe372637946e7d71e0d77363bcec812}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
using \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::\mbox{\hyperlink{classseq_1_1object__pool_a4fe372637946e7d71e0d77363bcec812}{allocator\+\_\+type}} =  Allocator}



supplied allocator type 

\mbox{\Hypertarget{classseq_1_1object__pool_a72539665f913721acd4787fedaa5a2c7}\label{classseq_1_1object__pool_a72539665f913721acd4787fedaa5a2c7}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!pointer@{pointer}}
\index{pointer@{pointer}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{pointer}{pointer}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
using \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::\mbox{\hyperlink{classseq_1_1object__pool_a72539665f913721acd4787fedaa5a2c7}{pointer}} =  T$\ast$}



pointer type 

\mbox{\Hypertarget{classseq_1_1object__pool_a2deaec289a41210128d70792113aaeed}\label{classseq_1_1object__pool_a2deaec289a41210128d70792113aaeed}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!shared\_ptr@{shared\_ptr}}
\index{shared\_ptr@{shared\_ptr}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{shared\_ptr}{shared\_ptr}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
using \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::\mbox{\hyperlink{classseq_1_1object__pool_a2deaec289a41210128d70792113aaeed}{shared\+\_\+ptr}} =  std\+::shared\+\_\+ptr$<$T $>$}



shared\+\_\+ptr type if \mbox{\hyperlink{structseq_1_1shared__ptr__allocation}{shared\+\_\+ptr\+\_\+allocation}} is used with Enable\+Unique\+Ptr 

\mbox{\Hypertarget{classseq_1_1object__pool_a38e3596ddb1309e36ebc321386d6dc5d}\label{classseq_1_1object__pool_a38e3596ddb1309e36ebc321386d6dc5d}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!unique\_ptr@{unique\_ptr}}
\index{unique\_ptr@{unique\_ptr}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{unique\_ptr}{unique\_ptr}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
using \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::\mbox{\hyperlink{classseq_1_1object__pool_a38e3596ddb1309e36ebc321386d6dc5d}{unique\+\_\+ptr}} =  std\+::unique\+\_\+ptr$<$T, \mbox{\hyperlink{structseq_1_1unique__ptr__deleter}{unique\+\_\+ptr\+\_\+deleter}}$<$T$>$ $>$}



unique\+\_\+ptr type if Enable\+Unique\+Ptr is true 

\mbox{\Hypertarget{classseq_1_1object__pool_a8b6a4b58f45dfb4560a16c9b4a6454e0}\label{classseq_1_1object__pool_a8b6a4b58f45dfb4560a16c9b4a6454e0}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
using \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::\mbox{\hyperlink{classseq_1_1object__pool_a8b6a4b58f45dfb4560a16c9b4a6454e0}{value\+\_\+type}} =  T}



object type 



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classseq_1_1object__pool_a799aee7e762678e020cd05b8cb27631f}\label{classseq_1_1object__pool_a799aee7e762678e020cd05b8cb27631f}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!object\_pool@{object\_pool}}
\index{object\_pool@{object\_pool}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{object\_pool()}{object\_pool()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
\mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::\mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} (\begin{DoxyParamCaption}\item[{const Allocator \&}]{al = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Constructor. 


\begin{DoxyParams}{Parameters}
{\em al} & allocator object \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1object__pool_a203e9fbadbf9152df5630ba693df64e8}\label{classseq_1_1object__pool_a203e9fbadbf9152df5630ba693df64e8}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!````~object\_pool@{$\sim$object\_pool}}
\index{````~object\_pool@{$\sim$object\_pool}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$object\_pool()}{~object\_pool()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
\mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::$\sim$\mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}\label{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!allocate@{allocate}}
\index{allocate@{allocate}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
auto \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::allocate (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption}) -\/$>$ T$\ast$
		\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Allocate size objects. 


\begin{DoxyParams}{Parameters}
{\em size} & number of objects to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to allocated objects
\end{DoxyReturn}
If size $<$= object\+\_\+allocation\+::max\+\_\+object, use the memory block mechanism. If size $>$ object\+\_\+allocation\+::max\+\_\+object, directly use the supplied allocator.

Might throw std\+::bad\+\_\+alloc. 

Implements \mbox{\hyperlink{structseq_1_1detail_1_1base__object__pool_a901146a91f522302842181dc455ad0cf}{seq\+::detail\+::base\+\_\+object\+\_\+pool$<$ T $>$}}.

\mbox{\Hypertarget{classseq_1_1object__pool_ab508ba0903b7b60224c116c1016be050}\label{classseq_1_1object__pool_ab508ba0903b7b60224c116c1016be050}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!clear@{clear}}
\index{clear@{clear}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
void \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Free all blocks. 

Free all memory blocks, except those managing at least one unique\+\_\+ptr. This will invalidate all previously allocated pointers.

Note that the objects are not destroyed, only deallocated. \mbox{\Hypertarget{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}\label{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{deallocate()}{deallocate()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
void \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::deallocate (\begin{DoxyParamCaption}\item[{T $\ast$}]{ptr,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Deallocate size objects. Non P\+OD objects must have been destroyed previously. 


\begin{DoxyParams}{Parameters}
{\em ptr} & pointer to objects to deallocate \\
\hline
{\em size} & number of objects to deallocate \\
\hline
\end{DoxyParams}


Implements \mbox{\hyperlink{structseq_1_1detail_1_1base__object__pool_a94c3d29a9aa75d5efdaa6e03e866b5d5}{seq\+::detail\+::base\+\_\+object\+\_\+pool$<$ T $>$}}.

\mbox{\Hypertarget{classseq_1_1object__pool_ae2eeb6dbde18dbe45eba8527db0dec52}\label{classseq_1_1object__pool_ae2eeb6dbde18dbe45eba8527db0dec52}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!dump\_statistics@{dump\_statistics}}
\index{dump\_statistics@{dump\_statistics}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{dump\_statistics()}{dump\_statistics()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
void \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::dump\+\_\+statistics (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1object__pool__stats}{object\+\_\+pool\+\_\+stats}} \&}]{stats }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Dump \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} statistics into a \mbox{\hyperlink{structseq_1_1object__pool__stats}{object\+\_\+pool\+\_\+stats}}. 

\mbox{\Hypertarget{classseq_1_1object__pool_aa7f2219bf1f9dc09c5c1e67948febd70}\label{classseq_1_1object__pool_aa7f2219bf1f9dc09c5c1e67948febd70}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
auto \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ const Allocator\& \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the underlying allocator object. 

\mbox{\Hypertarget{classseq_1_1object__pool_a2286444dc9ce69a944f9465f0e12b37d}\label{classseq_1_1object__pool_a2286444dc9ce69a944f9465f0e12b37d}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
auto \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) -\/$>$ Allocator\& \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the underlying allocator object. 

\mbox{\Hypertarget{classseq_1_1object__pool_a46c19b78510cd2becc02db55eea3dc62}\label{classseq_1_1object__pool_a46c19b78510cd2becc02db55eea3dc62}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!make\_shared@{make\_shared}}
\index{make\_shared@{make\_shared}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{make\_shared()}{make\_shared()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
template$<$class... Args$>$ \\
auto \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::make\+\_\+shared (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption}) -\/$>$ std\+::shared\+\_\+ptr$<$T$>$
		\hspace{0.3cm}{\ttfamily [inline]}}



Experimental. Returns a shared\+\_\+ptr object built with this \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}}. 

\mbox{\Hypertarget{classseq_1_1object__pool_a6c693c5b972f21af9ab51a7fd22d15ba}\label{classseq_1_1object__pool_a6c693c5b972f21af9ab51a7fd22d15ba}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!make\_unique@{make\_unique}}
\index{make\_unique@{make\_unique}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{make\_unique()}{make\_unique()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
template$<$class... Args$>$ \\
auto \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::make\+\_\+unique (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classseq_1_1object__pool_a38e3596ddb1309e36ebc321386d6dc5d}{unique\+\_\+ptr}}
		\hspace{0.3cm}{\ttfamily [inline]}}



Returns a unique\+\_\+ptr object constructed from the forwarded argument. 

This function is similar to std\+::make\+\_\+unique(), except that it relies on the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} to allocate the memory. The created unique\+\_\+ptr will outlive the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}}. Never deallocate a unique\+\_\+ptr pointer with \mbox{\hyperlink{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}{object\+\_\+pool\+::deallocate()}}. If unique\+\_\+ptr\+::release() is called, the pointer must be destroyed with \mbox{\hyperlink{namespaceseq_a1349a44a2ff37300a5c72a03780780fe}{seq\+::unique\+\_\+ptr\+\_\+delete()}}, which calls the object destructor and release the memory if needed. \mbox{\Hypertarget{classseq_1_1object__pool_adcb78702499af1357a871e3a0aadf0d8}\label{classseq_1_1object__pool_adcb78702499af1357a871e3a0aadf0d8}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!memory\_footprint@{memory\_footprint}}
\index{memory\_footprint@{memory\_footprint}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{memory\_footprint()}{memory\_footprint()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
auto \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::memory\+\_\+footprint (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ std\+::size\+\_\+t \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} memory footprint in bytes excluding sizeof($\ast$this). 

\mbox{\Hypertarget{classseq_1_1object__pool_aa38fbf8d66be889bb4b075b917942c89}\label{classseq_1_1object__pool_aa38fbf8d66be889bb4b075b917942c89}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!peak\_memory\_footprint@{peak\_memory\_footprint}}
\index{peak\_memory\_footprint@{peak\_memory\_footprint}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{peak\_memory\_footprint()}{peak\_memory\_footprint()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
auto \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::peak\+\_\+memory\+\_\+footprint (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ std\+::size\+\_\+t \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} peak memory footprint in bytes excluding sizeof($\ast$this). 

\mbox{\Hypertarget{classseq_1_1object__pool_ad97abff55ea874b6a6d1777fc3da9e15}\label{classseq_1_1object__pool_ad97abff55ea874b6a6d1777fc3da9e15}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!reclaim\_memory@{reclaim\_memory}}
\index{reclaim\_memory@{reclaim\_memory}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{reclaim\_memory()}{reclaim\_memory()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
auto \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::reclaim\+\_\+memory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const -\/$>$ bool \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns true if the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} reclaim freed memory, false otherwise. 

\mbox{\Hypertarget{classseq_1_1object__pool_a575391a7d2cc25c2e8d0394d6057a5a9}\label{classseq_1_1object__pool_a575391a7d2cc25c2e8d0394d6057a5a9}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!release\_unused\_memory@{release\_unused\_memory}}
\index{release\_unused\_memory@{release\_unused\_memory}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{release\_unused\_memory()}{release\_unused\_memory()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
void \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::release\+\_\+unused\+\_\+memory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deallocate all unused memory blocks. This only makes sense if \mbox{\hyperlink{classseq_1_1object__pool_ad97abff55ea874b6a6d1777fc3da9e15}{reclaim\+\_\+memory()}} is false. 

\mbox{\Hypertarget{classseq_1_1object__pool_aa96fd22de10478226d8d5650ef4efb1a}\label{classseq_1_1object__pool_aa96fd22de10478226d8d5650ef4efb1a}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!reserve@{reserve}}
\index{reserve@{reserve}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
void \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::reserve (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{alloc\+\_\+size,  }\item[{size\+\_\+t}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Extend the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} in order to hold at least count free slots for calls to allocate(alloc\+\_\+size). 


\begin{DoxyParams}{Parameters}
{\em alloc\+\_\+size} & only extend the pool in order to allocate alloc\+\_\+size objects per calls to \mbox{\hyperlink{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}{allocate()}} \\
\hline
{\em count} & make sure that at least count calls to allocate(alloc\+\_\+size) will not trigger a memory allocation\\
\hline
\end{DoxyParams}
Might throw a std\+::bad\+\_\+alloc \mbox{\Hypertarget{classseq_1_1object__pool_a12613b106f8af2a86e9084da4e2cd4bb}\label{classseq_1_1object__pool_a12613b106f8af2a86e9084da4e2cd4bb}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!reset@{reset}}
\index{reset@{reset}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
void \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Reset the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}}. 

Reset this object by clearing all memory blocks and make them ready for new allocations. This effectively invalidates all previously allocated pointers, even if the underlying memory segment has not been deallocated.

Has no effect on block managing at least one unique\+\_\+ptr. \mbox{\Hypertarget{classseq_1_1object__pool_a5ba0e2834a30fa3cbb4a1d895eb0f687}\label{classseq_1_1object__pool_a5ba0e2834a30fa3cbb4a1d895eb0f687}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!reset\_statistics@{reset\_statistics}}
\index{reset\_statistics@{reset\_statistics}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{reset\_statistics()}{reset\_statistics()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
void \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::reset\+\_\+statistics (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Reset statistics. 

Reset the following statistics\+:
\begin{DoxyItemize}
\item peak memory (reseted to the current memory footprint)
\item total number of allocated object (reseted to 0, only meaningful if Generate\+Stats is true)
\item total number of deallocated object (reseted to 0, only meaningful if Generate\+Stats is true) 
\end{DoxyItemize}\mbox{\Hypertarget{classseq_1_1object__pool_aee9c75a122612306b3a95466946afddc}\label{classseq_1_1object__pool_aee9c75a122612306b3a95466946afddc}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!set\_reclaim\_memory@{set\_reclaim\_memory}}
\index{set\_reclaim\_memory@{set\_reclaim\_memory}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{set\_reclaim\_memory()}{set\_reclaim\_memory()}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
void \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::set\+\_\+reclaim\+\_\+memory (\begin{DoxyParamCaption}\item[{bool}]{reclaim }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Set the reclaim\+\_\+memory flag. 

If false, the \mbox{\hyperlink{classseq_1_1object__pool}{object\+\_\+pool}} will not deallocate memory on calls to \mbox{\hyperlink{classseq_1_1object__pool_a99af259462a246f9b6c46a6b00a9a782}{deallocate()}}. Instead, free memory blocks will be added to an internal list and reuse on calls to \mbox{\hyperlink{classseq_1_1object__pool_a05063f627ffe9c606fe013adfed0e245}{allocate()}}. This is the only way to move a memory block dedicated to an object count for another object count.

If true, calls to deallocate will deallocate any free block. 

\doxysubsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{classseq_1_1object__pool_a3494f5bb0141e8c38ce58167ba42ed05}\label{classseq_1_1object__pool_a3494f5bb0141e8c38ce58167ba42ed05}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!detail::allocator\_for\_shared\_ptr@{detail::allocator\_for\_shared\_ptr}}
\index{detail::allocator\_for\_shared\_ptr@{detail::allocator\_for\_shared\_ptr}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{detail::allocator\_for\_shared\_ptr}{detail::allocator\_for\_shared\_ptr}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
template$<$class U , class Pool $>$ \\
friend class \mbox{\hyperlink{classseq_1_1detail_1_1allocator__for__shared__ptr}{detail\+::allocator\+\_\+for\+\_\+shared\+\_\+ptr}}\hspace{0.3cm}{\ttfamily [friend]}}



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classseq_1_1object__pool_add308abe3f00a1e6938b9405439b92f5}\label{classseq_1_1object__pool_add308abe3f00a1e6938b9405439b92f5}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!alignment@{alignment}}
\index{alignment@{alignment}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{alignment}{alignment}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
const size\+\_\+t \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::alignment = (Align == 0 $\vert$$\vert$ Align $<$ \mbox{\hyperlink{group__bits_ga4358957bf3c41e772ade27671699c4e6}{S\+E\+Q\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}) ? \mbox{\hyperlink{group__bits_ga4358957bf3c41e772ade27671699c4e6}{S\+E\+Q\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}} \+: Align\hspace{0.3cm}{\ttfamily [static]}}



object alignment 

\mbox{\Hypertarget{classseq_1_1object__pool_a304a11305aae4756635ef6d318d322ce}\label{classseq_1_1object__pool_a304a11305aae4756635ef6d318d322ce}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!enable\_unique\_ptr@{enable\_unique\_ptr}}
\index{enable\_unique\_ptr@{enable\_unique\_ptr}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{enable\_unique\_ptr}{enable\_unique\_ptr}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
const bool \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::enable\+\_\+unique\+\_\+ptr = Enable\+Unique\+Ptr\hspace{0.3cm}{\ttfamily [static]}}



enable/disable unique\+\_\+ptr support 

\mbox{\Hypertarget{classseq_1_1object__pool_aa3e04ee3d7d7a20bdce33ae208ac47d8}\label{classseq_1_1object__pool_aa3e04ee3d7d7a20bdce33ae208ac47d8}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!generate\_statistics@{generate\_statistics}}
\index{generate\_statistics@{generate\_statistics}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{generate\_statistics}{generate\_statistics}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
const bool \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::generate\+\_\+statistics = Generate\+Stats\hspace{0.3cm}{\ttfamily [static]}}



generate temporal statistics 

\mbox{\Hypertarget{classseq_1_1object__pool_a6914cbef77dc008cc1bc5ffaf81adec9}\label{classseq_1_1object__pool_a6914cbef77dc008cc1bc5ffaf81adec9}} 
\index{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}!max\_objects@{max\_objects}}
\index{max\_objects@{max\_objects}!seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$@{seq::object\_pool$<$ T, Allocator, Align, object\_allocation, EnableUniquePtr, GenerateStats $>$}}
\doxysubsubsection{\texorpdfstring{max\_objects}{max\_objects}}
{\footnotesize\ttfamily template$<$class T , class Allocator  = std\+::allocator$<$\+T$>$, size\+\_\+t Align = Default\+Alignment, class object\+\_\+allocation  = linear\+\_\+object\+\_\+allocation$<$1$>$, bool Enable\+Unique\+Ptr = false, bool Generate\+Stats = false$>$ \\
const size\+\_\+t \mbox{\hyperlink{classseq_1_1object__pool}{seq\+::object\+\_\+pool}}$<$ T, Allocator, Align, object\+\_\+allocation, Enable\+Unique\+Ptr, Generate\+Stats $>$\+::max\+\_\+objects = object\+\_\+allocation\+::max\+\_\+objects\hspace{0.3cm}{\ttfamily [static]}}



maximum number of objects per allocation before going right through the allocator 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
seq/\mbox{\hyperlink{memory_8hpp}{memory.\+hpp}}\end{DoxyCompactItemize}
