\hypertarget{classseq_1_1ordered__set}{}\doxysection{seq\+::ordered\+\_\+set$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$ Class Template Reference}
\label{classseq_1_1ordered__set}\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}


Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-\/time complexity.  




{\ttfamily \#include $<$ordered\+\_\+map.\+hpp$>$}



Inherits \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table}{seq\+::detail\+::\+Sparse\+Flat\+Node\+Hash\+Table$<$ Key, Key, std\+::hash$<$ Key $>$, std\+::equal\+\_\+to$<$ Key $>$, std\+::allocator$<$ Key $>$, Optimize\+For\+Speed $>$}}.

\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}{sequence\+\_\+type}} = typename \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a98d750db6b916e5c8c9d287a31c79f6c}{base\+\_\+type\+::sequence\+\_\+type}}
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} = \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a8df3f900aa837aab6177961dd338c1b6}{key\+\_\+type}} = Key
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} = Key
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a73fdf0cb0cfbd9e15e6c9d72c2dde6fd}{allocator\+\_\+type}} = Allocator
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} = size\+\_\+t
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_aa5395a6fe5848dd040ffb3e59d3f6c3c}{difference\+\_\+type}} = std\+::ptrdiff\+\_\+t
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a878f53e048251a95c495145448f628f5}{hasher}} = Hash
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}} = Key\+Equal
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a8006e5f056b3fb50a17d0bf3df9ac2ad}{reference}} = \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a87adb9393e20f2c19129bf916f512dbc}{const\+\_\+reference}} = const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_ad784defbe06bd89595059b376df90062}{pointer}} = typename std\+::allocator\+\_\+traits$<$ Allocator $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_ad784defbe06bd89595059b376df90062}{pointer}}
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a4f08d42969711a69c876b66cbc87b500}{const\+\_\+pointer}} = typename std\+::allocator\+\_\+traits$<$ Allocator $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a4f08d42969711a69c876b66cbc87b500}{const\+\_\+pointer}}
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a432ef60eab5f87e4ed9293dc2c893cbc}{reverse\+\_\+iterator}} = std\+::reverse\+\_\+iterator$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} $>$
\item 
using \mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} = std\+::reverse\+\_\+iterator$<$ \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} $>$
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a96ea410f4493eee72013cfc7b6305b77}{ordered\+\_\+set}} (const Hash \&\mbox{\hyperlink{structseq_1_1detail_1_1_hash_equal_ae93d63f42e715da31f2f1b8ea083ac1e}{hash}}=Hash(), const Key\+Equal \&equal=Key\+Equal(), const Allocator \&alloc=Allocator()) noexcept
\begin{DoxyCompactList}\small\item\em Constructs empty container. Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a9179dfd353fd9781409d2cc92006fb24}{ordered\+\_\+set}} (const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Constructs empty container. Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+It $>$ }\\\mbox{\hyperlink{classseq_1_1ordered__set_a6f6bcc81b7efdb3553fe0ff3b36af990}{ordered\+\_\+set}} (Input\+It first, Input\+It last, const Hash \&\mbox{\hyperlink{structseq_1_1detail_1_1_hash_equal_ae93d63f42e715da31f2f1b8ea083ac1e}{hash}}=Hash(), const \mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}} \&equal=\mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}}(), const Allocator \&alloc=Allocator())
\begin{DoxyCompactList}\small\item\em constructs the container with the contents of the range \mbox{[}first, last). Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+It $>$ }\\\mbox{\hyperlink{classseq_1_1ordered__set_ac7f84ee00fc14d4117d6f1b94ed93e0a}{ordered\+\_\+set}} (Input\+It first, Input\+It last, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em constructs the container with the contents of the range \mbox{[}first, last). Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+It $>$ }\\\mbox{\hyperlink{classseq_1_1ordered__set_ae695e84589fc08e4c9f9bbc32ef9bc15}{ordered\+\_\+set}} (Input\+It first, Input\+It last, const Hash \&\mbox{\hyperlink{structseq_1_1detail_1_1_hash_equal_ae93d63f42e715da31f2f1b8ea083ac1e}{hash}}, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em constructs the container with the contents of the range \mbox{[}first, last). Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a19292e709db9f5932a5fb15d4241924a}{ordered\+\_\+set}} (const \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} \&other, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a98a9e6f92a609ee74b285938413e0850}{ordered\+\_\+set}} (const \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a1e87480d5c9721a44724f350abcbd2bb}{ordered\+\_\+set}} (\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} \&\&other)
\begin{DoxyCompactList}\small\item\em Move constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a2bdb40f76a9f82431b70484dc786c25f}{ordered\+\_\+set}} (\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} \&\&other, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em Move constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a011127b90b2248894df0fe2456bf7a7a}{ordered\+\_\+set}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} $>$ init, const Hash \&\mbox{\hyperlink{structseq_1_1detail_1_1_hash_equal_ae93d63f42e715da31f2f1b8ea083ac1e}{hash}}=Hash(), const \mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}} \&equal=\mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}}(), const Allocator \&alloc=Allocator())
\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a5ec56dda7502a497016d12d495ae2ade}{ordered\+\_\+set}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} $>$ init, const Hash \&\mbox{\hyperlink{structseq_1_1detail_1_1_hash_equal_ae93d63f42e715da31f2f1b8ea083ac1e}{hash}}, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em constructs the container with the contents of the initializer list init, same as \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}(init.\+begin(), init.\+end()) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_af783eef5a121f45a78b9aa1bd64a4e1f}{ordered\+\_\+set}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} $>$ init, const Allocator \&alloc)
\begin{DoxyCompactList}\small\item\em constructs the container with the contents of the initializer list init, same as \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}(init.\+begin(), init.\+end()) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} \& \mbox{\hyperlink{classseq_1_1ordered__set_a4536ee7c30e5718d8469d1d49a34b81a}{operator=}} (const \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} \&other)
\begin{DoxyCompactList}\small\item\em Copy assignment operator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} \& \mbox{\hyperlink{classseq_1_1ordered__set_a354660e510ee08b28ff5787313fe7616}{operator=}} (\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} \&\&other)
\begin{DoxyCompactList}\small\item\em Move assignment operator. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1ordered__set_abca7e24629ce431774748e300f019d81}{size}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the container size. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classseq_1_1ordered__set_ace3604ad070d7b132932431ee70f166d}{max\+\_\+size}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the container maximum size. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classseq_1_1ordered__set_a56f66564f55a08b8db92caaf4063b4d4}{empty}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns true if the container is empty, false otherwise. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classseq_1_1ordered__set_a3803e22fd0b5f39f6df93d9f92838842}{max\+\_\+probe\+\_\+distance}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the current maximum possible probe distance. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{classseq_1_1ordered__set_ab700f354560059fd8aae90ecc8712d82}{load\+\_\+factor}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the current load factor. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{classseq_1_1ordered__set_a0b853d3635dee2ae6869a31ad775d9a3}{max\+\_\+load\+\_\+factor}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the current maximum load factor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1ordered__set_a403cd189fba893ab4f06b6cb28247288}{max\+\_\+load\+\_\+factor}} (float f) noexcept
\begin{DoxyCompactList}\small\item\em Set the maximum load factor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a73fdf0cb0cfbd9e15e6c9d72c2dde6fd}{allocator\+\_\+type}} \& \mbox{\hyperlink{classseq_1_1ordered__set_a08b784bd6254b797ed667cdcc340cca1}{get\+\_\+allocator}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns the container allocator object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a73fdf0cb0cfbd9e15e6c9d72c2dde6fd}{allocator\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set_ac6e9e655e89f7ec884242b68a03150cb}{get\+\_\+allocator}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the container allocator object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a878f53e048251a95c495145448f628f5}{hasher}} \mbox{\hyperlink{classseq_1_1ordered__set_aa94a43b2144d15120ec9da3745e03391}{hash\+\_\+function}} () const
\begin{DoxyCompactList}\small\item\em Returns the hash function. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}} \mbox{\hyperlink{classseq_1_1ordered__set_a01914afcdfeff7e3b271423bcb6916ae}{key\+\_\+eq}} () const
\begin{DoxyCompactList}\small\item\em Returns the equality comparison function. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}{sequence\+\_\+type}} \& \mbox{\hyperlink{classseq_1_1ordered__set_aa17f2ac25803a8cd75a632fe5a7f0fc9}{sequence}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns the underlying sequence object. Calling this function will mark the container as dirty. Any further attempts to call members like \mbox{\hyperlink{classseq_1_1ordered__set_a9975553b3f3550624489307d2906e68b}{find()}} or \mbox{\hyperlink{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}{insert()}} (relying on the hash function) will raise a std\+::logic\+\_\+error. To mark the container as non dirty anymore, the user must call \mbox{\hyperlink{classseq_1_1ordered__set_a2bb1f28b32c0c6c0422540b7986a49b0}{ordered\+\_\+set\+::rehash()}}. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}{sequence\+\_\+type}} \& \mbox{\hyperlink{classseq_1_1ordered__set_a2e293647b0ab4d65ce9fa42c2eae88e2}{sequence}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the underlying sequence object. Do N\+OT mark the container as dirty. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}{sequence\+\_\+type}} \& \mbox{\hyperlink{classseq_1_1ordered__set_ac0c72361a98b4408d42278dafe331bcb}{csequence}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns the underlying sequence object. Do N\+OT mark the container as dirty. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a3ff11b33174e2a29e741263be87280ec}{end}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a43ac1ffc3edd4520c32a30b79fb05598}{end}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a46659ad6597396632fffe96114856ef8}{cend}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the first element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a17b30b641deb6f8dead6b218851422a3}{begin}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a4cc6ec3c84dbaf96863708cf447b994c}{begin}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a410d0dfec4fd48506824a6dcedcc8273}{cbegin}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns an iterator to the element following the last element of the container. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a432ef60eab5f87e4ed9293dc2c893cbc}{reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_ad25d9c6aa7377945695c2d4d1f733637}{rbegin}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a8061cfea560a5d1ea776671b398ee9b5}{rbegin}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a03883efcebbbeb7278d5ec4f03e2d732}{crbegin}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the first element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a432ef60eab5f87e4ed9293dc2c893cbc}{reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a608c8538b094d2477f6b67a3a3320dd5}{rend}} () noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a77890a2e98f5f0a0b5f83f8966594619}{rend}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed list. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a321bedfdd099bcd8b4d0b43116b1892c}{crend}} () const noexcept
\begin{DoxyCompactList}\small\item\em Returns a reverse iterator to the element following the last element of the reversed list. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1ordered__set_a26e9b089e85777a7b1e0eb27ec05a51a}{clear}} ()
\begin{DoxyCompactList}\small\item\em Clear the container. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1ordered__set_a2bb1f28b32c0c6c0422540b7986a49b0}{rehash}} ()
\begin{DoxyCompactList}\small\item\em Rehash the container. This function triggers a full rehash if\+: \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1ordered__set_a4fc52f5ac410c23469f67314d85fc96f}{reserve}} (size\+\_\+t \mbox{\hyperlink{classseq_1_1ordered__set_af2e74048be4dd99fa0f79b269ac2125b}{count}})
\begin{DoxyCompactList}\small\item\em Sets the number of nodes to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Less $>$ }\\void \mbox{\hyperlink{classseq_1_1ordered__set_ad8c0514644286c8155f35d87dab0e3e9}{sort}} (Less le)
\begin{DoxyCompactList}\small\item\em Sort the container based on given comparator. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1ordered__set_a36a66b34dafa44d2f963a201272b2d24}{sort}} ()
\begin{DoxyCompactList}\small\item\em Sort the container using std\+::less$<$\+Key$>$. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Less $>$ }\\void \mbox{\hyperlink{classseq_1_1ordered__set_aa23ceeda63ee924eae70f4f2a40e6b7d}{stable\+\_\+sort}} (Less le)
\begin{DoxyCompactList}\small\item\em Sort the container based on given comparator and using std\+::stable\+\_\+sort. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1ordered__set_ae64707af69a6b261413d1325c8f35d30}{stable\+\_\+sort}} ()
\begin{DoxyCompactList}\small\item\em Sort the container based on std\+::less$<$\+Key$>$ and using std\+::stable\+\_\+sort. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1ordered__set_a13ba901e3b3b3be36be8a12156f4614e}{shrink\+\_\+to\+\_\+fit}} ()
\begin{DoxyCompactList}\small\item\em Calls \mbox{\hyperlink{classseq_1_1sequence_a1bf494125859119c2748a7a5e59588fa}{seq\+::sequence\+::shrink\+\_\+to\+\_\+fit()}}. Remove potential holes in the sequence object due to calls to \mbox{\hyperlink{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}{ordered\+\_\+set\+::erase()}}. Does not allocate memory, except for the hash table itself. Invalidate all references and iterators. Basic exception guarantee only. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1ordered__set_a768027febcc0b8e7df4465815510715d}{swap}} (\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} \&other)
\begin{DoxyCompactList}\small\item\em Swap this container with other. \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\std\+::pair$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool $>$ \mbox{\hyperlink{classseq_1_1ordered__set_a6d056ca8203ca976bc05e6873e32b9dd}{emplace}} (Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Inserts a new element into the container constructed in-\/place with the given args if there is no element with the key in the container. Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace, forwarded via std\+::forward$<$\+Args$>$(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a66e2ee127bb171c0780d79b922d09aca}{emplace\+\_\+hint}} (\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} hint, Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Inserts a new element into the container constructed in-\/place with the given args if there is no element with the key in the container. Same as \mbox{\hyperlink{classseq_1_1ordered__set_a6d056ca8203ca976bc05e6873e32b9dd}{ordered\+\_\+set\+::emplace()}}. \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool $>$ \mbox{\hyperlink{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}{insert}} (const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&value)
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). This function calls \mbox{\hyperlink{classseq_1_1sequence_a3a6276982c81ecc0cfc2b0f22a896a7a}{seq\+::sequence\+::insert()}} which insert the new element anywhere in the sequence, trying to fill holes left by calls to \mbox{\hyperlink{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}{ordered\+\_\+set\+::erase()}}. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool $>$ \mbox{\hyperlink{classseq_1_1ordered__set_a5248034d5ee90fe8389ccff6a8513636}{insert}} (\mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&\&value)
\begin{DoxyCompactList}\small\item\em Inserts element into the container using move semantic, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). This function calls \mbox{\hyperlink{classseq_1_1sequence_a3a6276982c81ecc0cfc2b0f22a896a7a}{seq\+::sequence\+::insert()}} which insert the new element anywhere in the sequence, trying to fill holes left by calls to \mbox{\hyperlink{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}{ordered\+\_\+set\+::erase()}}. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a8c12858c2c7bd944c52db7cb228c44c3}{insert}} (\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} hint, const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&value)
\begin{DoxyCompactList}\small\item\em Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Same as \mbox{\hyperlink{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}{ordered\+\_\+set\+::insert()}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a261954fa1669bd5afbd67395fb2044c8}{insert}} (\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} hint, \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&\&value)
\begin{DoxyCompactList}\small\item\em Inserts element into the container using move semantic, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Same as \mbox{\hyperlink{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}{ordered\+\_\+set\+::insert()}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Input\+It $>$ }\\void \mbox{\hyperlink{classseq_1_1ordered__set_ad97d9655ac3a0a3f954c1bfae0ddc8c3}{insert}} (Input\+It first, Input\+It last)
\begin{DoxyCompactList}\small\item\em Inserts elements from range \mbox{[}first, last). If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Elements are inserted in any order. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classseq_1_1ordered__set_af008845549da85d2b5ec77e10020361f}{insert}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} $>$ ilist)
\begin{DoxyCompactList}\small\item\em Inserts elements from range \mbox{[}init.\+begin(), init.\+end()). If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Elements are inserted in any order. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\std\+::pair$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool $>$ \mbox{\hyperlink{classseq_1_1ordered__set_a389fc041021ac912d72d6cd0f6b158ee}{emplace\+\_\+back}} (Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Inserts a new element at the back of the container, constructed in-\/place with the given args if there is no element with the key in the container. Careful use of emplace\+\_\+back allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace\+\_\+back, forwarded via std\+::forward$<$\+Args$>$(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool $>$ \mbox{\hyperlink{classseq_1_1ordered__set_ae5cf95d12190533776ec9da46196a8da}{push\+\_\+back}} (const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&value)
\begin{DoxyCompactList}\small\item\em Inserts element at the back of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool $>$ \mbox{\hyperlink{classseq_1_1ordered__set_ac6c5a2f25f46714a26174aba6826a240}{push\+\_\+back}} (\mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&\&value)
\begin{DoxyCompactList}\small\item\em Inserts element at the back of the container use move semantic, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Args$>$ }\\std\+::pair$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool $>$ \mbox{\hyperlink{classseq_1_1ordered__set_abd459427704543cc045c0add01253d72}{emplace\+\_\+front}} (Args \&\&... args)
\begin{DoxyCompactList}\small\item\em Inserts a new element at the front of the container, constructed in-\/place with the given args if there is no element with the key in the container. Careful use of emplace\+\_\+front allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace\+\_\+front, forwarded via std\+::forward$<$\+Args$>$(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool $>$ \mbox{\hyperlink{classseq_1_1ordered__set_a32e89bccd351ad976cee5e6edd58158e}{push\+\_\+front}} (const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&value)
\begin{DoxyCompactList}\small\item\em Inserts element at the front of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool $>$ \mbox{\hyperlink{classseq_1_1ordered__set_aa5b741972de9ec05a481d5f1d6c3fd29}{push\+\_\+front}} (\mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&\&value)
\begin{DoxyCompactList}\small\item\em Inserts element at the front of the container using move semantic, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}{erase}} (\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{namespaceseq_a4af98bbd3b7d9b7d7cb552f6f3a8d220}{pos}})
\begin{DoxyCompactList}\small\item\em Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set_a994967fe6f29b325a7452065df7f8257}{erase}} (const Key \&key)
\begin{DoxyCompactList}\small\item\em Erase element comparing equal to given key (if any). Iterators and references are not invalidated. Rehashing never occurs. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set_ae8be2eae6a142bbc73cb57c98558f80a}{erase}} (const K \&x)
\begin{DoxyCompactList}\small\item\em Erase element comparing equal to given key (if any). Removes the element (if one exists) with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash\+::is\+\_\+transparent and Key\+Equal\+::is\+\_\+transparent are valid and each denotes a type, and neither iterator nor \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} is implicitly convertible from K. This assumes that such Hash is callable with both K and Key type, and that the Key\+Equal is transparent, which, together, allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_ac23ff5e436a3f5d52ad21ef54d350a16}{erase}} (\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} first, \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} last)
\begin{DoxyCompactList}\small\item\em Removes the elements in the range \mbox{[}first; last), which must be a valid range in $\ast$this. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a9975553b3f3550624489307d2906e68b}{find}} (const Key \&key) const
\begin{DoxyCompactList}\small\item\em Finds an element with key equivalent to key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a5bec85cff7f40a66fb13c52c4f6ab091}{find}} (const Key \&value)
\begin{DoxyCompactList}\small\item\em Finds an element with key equivalent to key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a2722cf1834632a70c1c46b79c5e20bda}{find}} (const K \&x) const
\begin{DoxyCompactList}\small\item\em Finds an element with key equivalent to key. Finds an element with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash\+::is\+\_\+transparent and Key\+Equal\+::is\+\_\+transparent are valid and each denotes a type. This assumes that such Hash is callable with both K and Key type, and that the Key\+Equal is transparent, which, together, allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set_a0f073c3b2c72ad39d9e7d595d5c6d348}{find}} (const K \&key)
\begin{DoxyCompactList}\small\item\em Finds an element with key equivalent to key. Finds an element with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash\+::is\+\_\+transparent and Key\+Equal\+::is\+\_\+transparent are valid and each denotes a type. This assumes that such Hash is callable with both K and Key type, and that the Key\+Equal is transparent, which, together, allows calling this function without constructing an instance of Key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set_af2e74048be4dd99fa0f79b269ac2125b}{count}} (const Key \&key) const
\begin{DoxyCompactList}\small\item\em Returns 1 of key exists, 0 otherwise. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\\mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set_a307dbd7f5b62a9469a47a955279ce288}{count}} (const K \&key) const
\begin{DoxyCompactList}\small\item\em Returns 1 of key exists, 0 otherwise. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classseq_1_1ordered__set_add3437ee0e1dc0e479949b622df8671a}{contains}} (const Key \&key) const
\begin{DoxyCompactList}\small\item\em Returns true of key exists, false otherwise. \end{DoxyCompactList}\item 
{\footnotesize template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\bool \mbox{\hyperlink{classseq_1_1ordered__set_a784bc98a40616dd5676c80b3ac4430c8}{contains}} (const K \&key) const
\begin{DoxyCompactList}\small\item\em Returns true of key exists, false otherwise. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class Key, class Hash = std\+::hash$<$\+Key$>$, class Key\+Equal = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$\newline
class seq\+::ordered\+\_\+set$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$}

Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-\/time complexity. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Key} & Key type \\
\hline
{\em Hash} & Hash function \\
\hline
{\em Key\+Equal} & Equality comparison function \\
\hline
{\em Allocator} & allocator object \\
\hline
{\em Layout} & memory layout used by the underlying sequence object\\
\hline
\end{DoxyTemplParams}
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} is a open addressing hash table using robin hood hashing and backward shift deletion. Its main properties are\+:
\begin{DoxyItemize}
\item Keys are ordered by insertion order. Therefore, \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} provides the additional members \mbox{\hyperlink{classseq_1_1ordered__set_ae5cf95d12190533776ec9da46196a8da}{push\+\_\+back()}}, \mbox{\hyperlink{classseq_1_1ordered__set_a32e89bccd351ad976cee5e6edd58158e}{push\+\_\+front()}}, \mbox{\hyperlink{classseq_1_1ordered__set_a389fc041021ac912d72d6cd0f6b158ee}{emplace\+\_\+back()}} and \mbox{\hyperlink{classseq_1_1ordered__set_abd459427704543cc045c0add01253d72}{emplace\+\_\+front()}} to constrol key ordering.
\item Since the container is ordered, it is also sortable. \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} provides the additional members \mbox{\hyperlink{classseq_1_1ordered__set_a36a66b34dafa44d2f963a201272b2d24}{sort()}} and \mbox{\hyperlink{classseq_1_1ordered__set_ae64707af69a6b261413d1325c8f35d30}{stable\+\_\+sort()}} for this purpose.
\item The hash table itself basically stores iterators to a \mbox{\hyperlink{classseq_1_1sequence}{seq\+::sequence}} object storing the actual values. Therefore, \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} provides {\bfseries{stable references and iterators, even on rehash}} (unlike std\+::unordered\+\_\+set that invalidates iterators on rehash).
\item No memory peak on rehash.
\item \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} uses robin hood probing with backard shift deletion. It does not rely on tombstones and supports high load factors.
\item It is fast and memory efficient compared to other node based hash tables (see section {\bfseries{Performances}}), but still slower than most open addressing hash tables due to the additional indirection.
\end{DoxyItemize}\hypertarget{classseq_1_1ordered__set_autotoc_md39}{}\doxysubsubsection{Interface}\label{classseq_1_1ordered__set_autotoc_md39}
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} provides a similar interface to std\+::unordered\+\_\+set with the following differences\+:
\begin{DoxyItemize}
\item The bucket related functions are not implemented,
\item The default load factor is set to 0.\+6,
\item Additional members \mbox{\hyperlink{classseq_1_1ordered__set_ae5cf95d12190533776ec9da46196a8da}{push\+\_\+back()}}, \mbox{\hyperlink{classseq_1_1ordered__set_a32e89bccd351ad976cee5e6edd58158e}{push\+\_\+front()}}, \mbox{\hyperlink{classseq_1_1ordered__set_a389fc041021ac912d72d6cd0f6b158ee}{emplace\+\_\+back()}} and \mbox{\hyperlink{classseq_1_1ordered__set_abd459427704543cc045c0add01253d72}{emplace\+\_\+front()}} let you control the key ordering,
\item Additional members \mbox{\hyperlink{classseq_1_1ordered__set_a36a66b34dafa44d2f963a201272b2d24}{sort()}} and \mbox{\hyperlink{classseq_1_1ordered__set_ae64707af69a6b261413d1325c8f35d30}{stable\+\_\+sort()}} let you sort the container,
\item The member \mbox{\hyperlink{classseq_1_1ordered__set_aa17f2ac25803a8cd75a632fe5a7f0fc9}{ordered\+\_\+set\+::sequence()}} returns a reference to the underlying \mbox{\hyperlink{classseq_1_1sequence}{seq\+::sequence}} object,
\item Its iterator and \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} types are bidirectional iterators.
\end{DoxyItemize}

The underlying sequence object stores plain non const Key objects. However, in order to avoid modifying the keys through iterators (and potentially invalidating the order), both iterator and \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} types can only return const references.\hypertarget{classseq_1_1ordered__set_autotoc_md40}{}\doxysubsubsection{Direct access to sequence}\label{classseq_1_1ordered__set_autotoc_md40}
Unlike most hash table implementations, it it possible to access and modify the underlying value storage directly (a \mbox{\hyperlink{classseq_1_1sequence}{seq\+::sequence}} object). This possibility musy be used with great care, as modifying directly the sequence might break the hashing. When calling the non-\/const version of \mbox{\hyperlink{classseq_1_1ordered__set_aa17f2ac25803a8cd75a632fe5a7f0fc9}{ordered\+\_\+set\+::sequence()}}, the \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} will be marked as dirty, and further attempts to call functions like \mbox{\hyperlink{classseq_1_1ordered__set_a9975553b3f3550624489307d2906e68b}{ordered\+\_\+set\+::find()}} of \mbox{\hyperlink{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}{ordered\+\_\+set\+::insert()}} (functions based on hash value) will throw a std\+::logic\+\_\+error.

Therefore, after finishing modifying the sequence, you must call \mbox{\hyperlink{classseq_1_1ordered__set_a2bb1f28b32c0c6c0422540b7986a49b0}{ordered\+\_\+set\+::rehash()}} to rehash the sequence, remove potential duplicates, and mark the \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} as non dirty anymore.

This way of modifying a \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} must be used carefully, but is way faster than multiple calls to \mbox{\hyperlink{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}{ordered\+\_\+set\+::insert()}} of \mbox{\hyperlink{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}{ordered\+\_\+set\+::erase()}}. For instance, it is usually faster to insert values this way than reserving the hash table ahead, except when inserting lots of duplicate keys. Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<double> keys = ...}
\DoxyCodeLine{}
\DoxyCodeLine{seq::ordered\_set<\textcolor{keywordtype}{double}> set;}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i < keys.size(); ++i)}
\DoxyCodeLine{    set.sequence().insert(keys[i]);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// rehash the set and remove potential duplicate values in a stable way}}
\DoxyCodeLine{set.rehash();}
\end{DoxyCode}
\hypertarget{classseq_1_1ordered__set_autotoc_md41}{}\doxysubsubsection{Exception guarantee}\label{classseq_1_1ordered__set_autotoc_md41}
Most members of \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} provide {\bfseries{strong exception guarantee}}, except if specified otherwise (mentionned in function documentation).\hypertarget{classseq_1_1ordered__set_autotoc_md42}{}\doxysubsubsection{Growth policy and load factor}\label{classseq_1_1ordered__set_autotoc_md42}
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} uses a growth factor of 2 to use the fast modulo. The hash table size is multiplied by 2 each time the table load factor exceeds the given \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}. The default maximum load factor is set to 0.\+6 and can by set up to 0.\+95, which is well supported thanks to the robin hood hashing.

In some cases, the actual load factor can exceed the provided maximum load factor. This holds when the keys are very well distributed, and the maximum distance of a key to its computed location is low (below 8). This strategy avoids some unnecessary rehash for very strong hash function (or well distributed keys). Note however that the load factor will never exceed 0.\+95.

On rehash, the old table is deallocated before allocating the new (twice as big) one. This is possible thanks to the double storage strategy (values are stored in an independant sequence object) and avoid memory peaks.\hypertarget{classseq_1_1ordered__set_autotoc_md43}{}\doxysubsubsection{Handling of bad hash function}\label{classseq_1_1ordered__set_autotoc_md43}
Like most robin hood based hash tables (ska\+::flat\+\_\+hash\+\_\+set, tsl\+::robin\+\_\+set...), \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} uses 8 bits to store the node distance to its computed location. For a bad hash function leading to strong clustering, this 8 bits distance quickly overflows. The usual strategy in this case is to rehash the table based on the growth strategy, hopping for a better key distribution.

For very bad hash function (or in case of D\+OS attack), hash tables like ska\+::flat\+\_\+hash\+\_\+set and tsl\+::robin\+\_\+set will keep rehashing its values and reallocating the table, until a fatal std\+::bad\+\_\+alloc is thrown. \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} uses a different strategy to cope with such situation\+:
\begin{DoxyItemize}
\item When the distance value overflows, it is discarded and the table relies on pure linear hashing.
\item In this case, deleting an entry will create a tombstone instead of the standard backward shift deletion.
\item The linear probing behavior is kept until a call to \mbox{\hyperlink{classseq_1_1ordered__set_a2bb1f28b32c0c6c0422540b7986a49b0}{ordered\+\_\+set\+::rehash()}} that might switch back the behavior to robin hood hashing.
\end{DoxyItemize}

Therefore, a (very) bad hash function will only make the table slower but will never explode with a std\+::bad\+\_\+alloc exception\hypertarget{classseq_1_1ordered__set_autotoc_md44}{}\doxysubsubsection{Deleting entries}\label{classseq_1_1ordered__set_autotoc_md44}
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} uses backward shift deletion to avoid introducing tombstone, except for bad hash functions (see section above). The key lookup remains fast when deleting lots of entries, and mixed scenarios involving lots of interleaved insertion/deletion are well supported.

Note however that removing a key will never trigger a rehash. The user is free to rehash the \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} at any point using \mbox{\hyperlink{classseq_1_1ordered__set_a2bb1f28b32c0c6c0422540b7986a49b0}{ordered\+\_\+set\+::rehash()}} member.\hypertarget{classseq_1_1ordered__set_autotoc_md45}{}\doxysubsubsection{Sorting}\label{classseq_1_1ordered__set_autotoc_md45}
Since the \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} is ordered by key insertion order, it makes sense to provide a function to sort it. The members \mbox{\hyperlink{classseq_1_1ordered__set_a36a66b34dafa44d2f963a201272b2d24}{ordered\+\_\+set\+::sort()}} and \mbox{\hyperlink{classseq_1_1ordered__set_ae64707af69a6b261413d1325c8f35d30}{ordered\+\_\+set\+::stable\+\_\+sort()}} are provided and call respectively \mbox{\hyperlink{classseq_1_1sequence_a0c2005c28e8537de74b4c1e588180463}{seq\+::sequence\+::sort()}} and \mbox{\hyperlink{classseq_1_1sequence_a5aaca3cd0a83c4637c28599ac55d70a0}{seq\+::sequence\+::stable\+\_\+sort()}}. These functions rehash the full table after sorting.\hypertarget{classseq_1_1ordered__set_autotoc_md46}{}\doxysubsubsection{Performances}\label{classseq_1_1ordered__set_autotoc_md46}
Performances of \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} has been measured and compared to other node based hash tables\+: std\+::unordered\+\_\+set, \href{https://github.com/skarupke/flat_hash_map/blob/master/unordered_map.hpp}{\texttt{ ska\+::unordered\+\_\+set}}, \href{https://github.com/martinus/robin-hood-hashing}{\texttt{ robin\+\_\+hood\+::unordered\+\_\+node\+\_\+set}} and \href{https://github.com/greg7mdp/parallel-hashmap}{\texttt{ phmap\+::node\+\_\+hash\+\_\+set}} (based on abseil hash table). The following table show the results when compiled with gcc 10.\+1.\+0 (-\/O3) for msys2 on Windows 10, using Intel(\+R) Core(\+T\+M) i7-\/10850H at 2.\+70\+G\+Hz. Measured operations are\+:
\begin{DoxyItemize}
\item Insert successfully 5M unique double randomly shuffled in an empty table using hash\+\_\+table\+::insert()
\item Insert successfully 5M unique double randomly shuffled in an empty table using hash\+\_\+table\+::insert() after reserving enough space
\item Successfully search for 5M double in random order using hash\+\_\+table\+::find(const Key\&)
\item Search for 5M double not present in the table (failed lookup)
\item Walk through the full table (5M double) using iterators
\item Erase half the table in random order using hash\+\_\+table\+::erase(iterator)
\item Perform mixed failed/successfull lookups on the remaining 2.\+5M keys.
\end{DoxyItemize}

For each tested hash table, the maximum load factor is left to its default value, and std\+::hash$<$double$>$ is used. For insert and erase operations, the program memory consumption is given. Note that the memory consumption is not the exact memory usage of the hash table, and should only bu used to measure the difference between implementations.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{8}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Hash table name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert (reserve) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find (success) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find (failed) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Iterate }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Erase }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find again  }\\\cline{1-8}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Hash table name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Insert (reserve) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find (success) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find (failed) }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Iterate }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Erase }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Find again  }\\\cline{1-8}
\endhead
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} &477 ms/145 MO &302 ms/145 MO &282 ms &188 ms &6 ms &269 ms/210 MO &166 ms  \\\cline{1-8}
phmap\+::node\+\_\+hash\+\_\+set &926 ms/187 MO &492 ms/188 MO &370 ms &130 ms &96 ms &501 ms/232 MO &193 ms  \\\cline{1-8}
robin\+\_\+hood\+::unordered\+\_\+node\+\_\+set &598 ms/182 MO &448 ms/182 MO &394 ms &134 ms &87 ms &407 ms/259 MO &212 ms  \\\cline{1-8}
ska\+::unordered\+\_\+set &1540 ms/256 MO &728 ms/256 MO &300 ms &261 ms &141 ms &513 ms/268 MO &204 ms  \\\cline{1-8}
std\+::unordered\+\_\+set &1844 ms/238 MO &1148 ms/231 MO &751 ms &941 ms &205 ms &868 ms/245 MO &509 ms  \\\cline{1-8}
\end{longtabu}


\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}} is significantly faster than the other hash tables except for failed lookup, and has a lower memory overhead. Note that this benchmark does not represent all possible workloads, and additional tests must be fullfilled for specific scenarios. 

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{classseq_1_1ordered__set_a73fdf0cb0cfbd9e15e6c9d72c2dde6fd}\label{classseq_1_1ordered__set_a73fdf0cb0cfbd9e15e6c9d72c2dde6fd}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a73fdf0cb0cfbd9e15e6c9d72c2dde6fd}{allocator\+\_\+type}} =  Allocator}

\mbox{\Hypertarget{classseq_1_1ordered__set_a4f08d42969711a69c876b66cbc87b500}\label{classseq_1_1ordered__set_a4f08d42969711a69c876b66cbc87b500}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!const\_pointer@{const\_pointer}}
\index{const\_pointer@{const\_pointer}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{const\_pointer}{const\_pointer}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a4f08d42969711a69c876b66cbc87b500}{const\+\_\+pointer}} =  typename std\+::allocator\+\_\+traits$<$Allocator$>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a4f08d42969711a69c876b66cbc87b500}{const\+\_\+pointer}}}

\mbox{\Hypertarget{classseq_1_1ordered__set_a87adb9393e20f2c19129bf916f512dbc}\label{classseq_1_1ordered__set_a87adb9393e20f2c19129bf916f512dbc}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!const\_reference@{const\_reference}}
\index{const\_reference@{const\_reference}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{const\_reference}{const\_reference}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a87adb9393e20f2c19129bf916f512dbc}{const\+\_\+reference}} =  const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}}\&}

\mbox{\Hypertarget{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}\label{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!const\_reverse\_iterator@{const\_reverse\_iterator}}
\index{const\_reverse\_iterator@{const\_reverse\_iterator}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{const\_reverse\_iterator}{const\_reverse\_iterator}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} =  std\+::reverse\+\_\+iterator$<$\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}$>$}

\mbox{\Hypertarget{classseq_1_1ordered__set_aa5395a6fe5848dd040ffb3e59d3f6c3c}\label{classseq_1_1ordered__set_aa5395a6fe5848dd040ffb3e59d3f6c3c}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!difference\_type@{difference\_type}}
\index{difference\_type@{difference\_type}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{difference\_type}{difference\_type}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_aa5395a6fe5848dd040ffb3e59d3f6c3c}{difference\+\_\+type}} =  std\+::ptrdiff\+\_\+t}

\mbox{\Hypertarget{classseq_1_1ordered__set_a878f53e048251a95c495145448f628f5}\label{classseq_1_1ordered__set_a878f53e048251a95c495145448f628f5}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!hasher@{hasher}}
\index{hasher@{hasher}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{hasher}{hasher}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a878f53e048251a95c495145448f628f5}{hasher}} =  Hash}

\mbox{\Hypertarget{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}\label{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!iterator@{iterator}}
\index{iterator@{iterator}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{iterator}{iterator}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} =  \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}}

\mbox{\Hypertarget{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}\label{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!key\_equal@{key\_equal}}
\index{key\_equal@{key\_equal}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{key\_equal}{key\_equal}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}} =  Key\+Equal}

\mbox{\Hypertarget{classseq_1_1ordered__set_a8df3f900aa837aab6177961dd338c1b6}\label{classseq_1_1ordered__set_a8df3f900aa837aab6177961dd338c1b6}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!key\_type@{key\_type}}
\index{key\_type@{key\_type}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{key\_type}{key\_type}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a8df3f900aa837aab6177961dd338c1b6}{key\+\_\+type}} =  Key}

\mbox{\Hypertarget{classseq_1_1ordered__set_ad784defbe06bd89595059b376df90062}\label{classseq_1_1ordered__set_ad784defbe06bd89595059b376df90062}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!pointer@{pointer}}
\index{pointer@{pointer}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{pointer}{pointer}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_ad784defbe06bd89595059b376df90062}{pointer}} =  typename std\+::allocator\+\_\+traits$<$Allocator$>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_ad784defbe06bd89595059b376df90062}{pointer}}}

\mbox{\Hypertarget{classseq_1_1ordered__set_a8006e5f056b3fb50a17d0bf3df9ac2ad}\label{classseq_1_1ordered__set_a8006e5f056b3fb50a17d0bf3df9ac2ad}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!reference@{reference}}
\index{reference@{reference}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{reference}{reference}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a8006e5f056b3fb50a17d0bf3df9ac2ad}{reference}} =  \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}}\&}

\mbox{\Hypertarget{classseq_1_1ordered__set_a432ef60eab5f87e4ed9293dc2c893cbc}\label{classseq_1_1ordered__set_a432ef60eab5f87e4ed9293dc2c893cbc}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!reverse\_iterator@{reverse\_iterator}}
\index{reverse\_iterator@{reverse\_iterator}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{reverse\_iterator}{reverse\_iterator}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a432ef60eab5f87e4ed9293dc2c893cbc}{reverse\+\_\+iterator}} =  std\+::reverse\+\_\+iterator$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}$>$}

\mbox{\Hypertarget{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}\label{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!sequence\_type@{sequence\_type}}
\index{sequence\_type@{sequence\_type}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{sequence\_type}{sequence\_type}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}{sequence\+\_\+type}} =  typename \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a98d750db6b916e5c8c9d287a31c79f6c}{base\+\_\+type\+::sequence\+\_\+type}}}

\mbox{\Hypertarget{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}\label{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!size\_type@{size\_type}}
\index{size\_type@{size\_type}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{size\_type}{size\_type}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} =  size\+\_\+t}

\mbox{\Hypertarget{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}\label{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
using \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} =  Key}



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classseq_1_1ordered__set_a96ea410f4493eee72013cfc7b6305b77}\label{classseq_1_1ordered__set_a96ea410f4493eee72013cfc7b6305b77}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{const Hash \&}]{hash = {\ttfamily Hash()},  }\item[{const Key\+Equal \&}]{equal = {\ttfamily KeyEqual()},  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Constructs empty container. Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. 


\begin{DoxyParams}{Parameters}
{\em hash} & hash function to use \\
\hline
{\em equal} & comparison function to use for all key comparisons of this container \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a9179dfd353fd9781409d2cc92006fb24}\label{classseq_1_1ordered__set_a9179dfd353fd9781409d2cc92006fb24}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructs empty container. Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. 


\begin{DoxyParams}{Parameters}
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a6f6bcc81b7efdb3553fe0ff3b36af990}\label{classseq_1_1ordered__set_a6f6bcc81b7efdb3553fe0ff3b36af990}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [3/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class Input\+It $>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last,  }\item[{const Hash \&}]{hash = {\ttfamily Hash()},  }\item[{const \mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}} \&}]{equal = {\ttfamily \mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}}()},  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



constructs the container with the contents of the range \mbox{[}first, last). Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Input\+It} & iterator type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em first} & the range to copy the elements from \\
\hline
{\em last} & the range to copy the elements from \\
\hline
{\em hash} & hash function to use \\
\hline
{\em equal} & comparison function to use for all key comparisons of this container \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_ac7f84ee00fc14d4117d6f1b94ed93e0a}\label{classseq_1_1ordered__set_ac7f84ee00fc14d4117d6f1b94ed93e0a}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [4/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class Input\+It $>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



constructs the container with the contents of the range \mbox{[}first, last). Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Input\+It} & iterator type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em first} & the range to copy the elements from \\
\hline
{\em last} & the range to copy the elements from \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_ae695e84589fc08e4c9f9bbc32ef9bc15}\label{classseq_1_1ordered__set_ae695e84589fc08e4c9f9bbc32ef9bc15}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [5/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class Input\+It $>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last,  }\item[{const Hash \&}]{hash,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



constructs the container with the contents of the range \mbox{[}first, last). Sets \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}} to 0.\+6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Input\+It} & iterator type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em first} & the range to copy the elements from \\
\hline
{\em last} & the range to copy the elements from \\
\hline
{\em hash} & hash function to use \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a19292e709db9f5932a5fb15d4241924a}\label{classseq_1_1ordered__set_a19292e709db9f5932a5fb15d4241924a}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [6/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$ \&}]{other,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a98a9e6f92a609ee74b285938413e0850}\label{classseq_1_1ordered__set_a98a9e6f92a609ee74b285938413e0850}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [7/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a1e87480d5c9721a44724f350abcbd2bb}\label{classseq_1_1ordered__set_a1e87480d5c9721a44724f350abcbd2bb}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [8/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Move constructor. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a2bdb40f76a9f82431b70484dc786c25f}\label{classseq_1_1ordered__set_a2bdb40f76a9f82431b70484dc786c25f}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [9/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$ \&\&}]{other,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Move constructor. 


\begin{DoxyParams}{Parameters}
{\em other} & another container to be used as source to initialize the elements of the container with \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a011127b90b2248894df0fe2456bf7a7a}\label{classseq_1_1ordered__set_a011127b90b2248894df0fe2456bf7a7a}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [10/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} $>$}]{init,  }\item[{const Hash \&}]{hash = {\ttfamily Hash()},  }\item[{const \mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}} \&}]{equal = {\ttfamily \mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}}()},  }\item[{const Allocator \&}]{alloc = {\ttfamily Allocator()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classseq_1_1ordered__set_a5ec56dda7502a497016d12d495ae2ade}\label{classseq_1_1ordered__set_a5ec56dda7502a497016d12d495ae2ade}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [11/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} $>$}]{init,  }\item[{const Hash \&}]{hash,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



constructs the container with the contents of the initializer list init, same as \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}(init.\+begin(), init.\+end()) 


\begin{DoxyParams}{Parameters}
{\em init} & initializer list to initialize the elements of the container with \\
\hline
{\em hash} & hash function to use \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_af783eef5a121f45a78b9aa1bd64a4e1f}\label{classseq_1_1ordered__set_af783eef5a121f45a78b9aa1bd64a4e1f}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!ordered\_set@{ordered\_set}}
\index{ordered\_set@{ordered\_set}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{ordered\_set()}{ordered\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [12/12]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}} (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} $>$}]{init,  }\item[{const Allocator \&}]{alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



constructs the container with the contents of the initializer list init, same as \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}(init.\+begin(), init.\+end()) 


\begin{DoxyParams}{Parameters}
{\em init} & initializer list to initialize the elements of the container with \\
\hline
{\em alloc} & allocator to use for all memory allocations of this container \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classseq_1_1ordered__set_a4cc6ec3c84dbaf96863708cf447b994c}\label{classseq_1_1ordered__set_a4cc6ec3c84dbaf96863708cf447b994c}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!begin@{begin}}
\index{begin@{begin}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the element following the last element of the container. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a17b30b641deb6f8dead6b218851422a3}\label{classseq_1_1ordered__set_a17b30b641deb6f8dead6b218851422a3}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!begin@{begin}}
\index{begin@{begin}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the element following the last element of the container. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a410d0dfec4fd48506824a6dcedcc8273}\label{classseq_1_1ordered__set_a410d0dfec4fd48506824a6dcedcc8273}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!cbegin@{cbegin}}
\index{cbegin@{cbegin}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{cbegin()}{cbegin()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::cbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the element following the last element of the container. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a46659ad6597396632fffe96114856ef8}\label{classseq_1_1ordered__set_a46659ad6597396632fffe96114856ef8}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!cend@{cend}}
\index{cend@{cend}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{cend()}{cend()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::cend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the first element of the container. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a26e9b089e85777a7b1e0eb27ec05a51a}\label{classseq_1_1ordered__set_a26e9b089e85777a7b1e0eb27ec05a51a}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!clear@{clear}}
\index{clear@{clear}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Clear the container. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a784bc98a40616dd5676c80b3ac4430c8}\label{classseq_1_1ordered__set_a784bc98a40616dd5676c80b3ac4430c8}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!contains@{contains}}
\index{contains@{contains}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
bool \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::contains (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns true of key exists, false otherwise. 

\mbox{\Hypertarget{classseq_1_1ordered__set_add3437ee0e1dc0e479949b622df8671a}\label{classseq_1_1ordered__set_add3437ee0e1dc0e479949b622df8671a}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!contains@{contains}}
\index{contains@{contains}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
bool \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::contains (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns true of key exists, false otherwise. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a307dbd7f5b62a9469a47a955279ce288}\label{classseq_1_1ordered__set_a307dbd7f5b62a9469a47a955279ce288}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!count@{count}}
\index{count@{count}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{count()}{count()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::count (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns 1 of key exists, 0 otherwise. 

\mbox{\Hypertarget{classseq_1_1ordered__set_af2e74048be4dd99fa0f79b269ac2125b}\label{classseq_1_1ordered__set_af2e74048be4dd99fa0f79b269ac2125b}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!count@{count}}
\index{count@{count}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{count()}{count()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::count (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns 1 of key exists, 0 otherwise. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a03883efcebbbeb7278d5ec4f03e2d732}\label{classseq_1_1ordered__set_a03883efcebbbeb7278d5ec4f03e2d732}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!crbegin@{crbegin}}
\index{crbegin@{crbegin}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{crbegin()}{crbegin()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::crbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the first element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a321bedfdd099bcd8b4d0b43116b1892c}\label{classseq_1_1ordered__set_a321bedfdd099bcd8b4d0b43116b1892c}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!crend@{crend}}
\index{crend@{crend}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{crend()}{crend()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::crend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the element following the last element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1ordered__set_ac0c72361a98b4408d42278dafe331bcb}\label{classseq_1_1ordered__set_ac0c72361a98b4408d42278dafe331bcb}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!csequence@{csequence}}
\index{csequence@{csequence}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{csequence()}{csequence()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
const \mbox{\hyperlink{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}{sequence\+\_\+type}}\& \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::csequence (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the underlying sequence object. Do N\+OT mark the container as dirty. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a6d056ca8203ca976bc05e6873e32b9dd}\label{classseq_1_1ordered__set_a6d056ca8203ca976bc05e6873e32b9dd}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!emplace@{emplace}}
\index{emplace@{emplace}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{emplace()}{emplace()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class... Args$>$ \\
std\+::pair$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool$>$ \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::emplace (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts a new element into the container constructed in-\/place with the given args if there is no element with the key in the container. Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace, forwarded via std\+::forward$<$\+Args$>$(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 

This function calls \mbox{\hyperlink{classseq_1_1sequence_a3a6276982c81ecc0cfc2b0f22a896a7a}{seq\+::sequence\+::insert()}} which insert the new element anywhere in the sequence, trying to fill holes left by calls to \mbox{\hyperlink{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}{ordered\+\_\+set\+::erase()}}.

\begin{DoxyReturn}{Returns}
pair consisting of an iterator to the inserted element, or the already-\/existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a389fc041021ac912d72d6cd0f6b158ee}\label{classseq_1_1ordered__set_a389fc041021ac912d72d6cd0f6b158ee}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!emplace\_back@{emplace\_back}}
\index{emplace\_back@{emplace\_back}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_back()}{emplace\_back()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class... Args$>$ \\
std\+::pair$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool$>$ \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::emplace\+\_\+back (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts a new element at the back of the container, constructed in-\/place with the given args if there is no element with the key in the container. Careful use of emplace\+\_\+back allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace\+\_\+back, forwarded via std\+::forward$<$\+Args$>$(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 

\begin{DoxyReturn}{Returns}
pair consisting of an iterator to the inserted element, or the already-\/existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_abd459427704543cc045c0add01253d72}\label{classseq_1_1ordered__set_abd459427704543cc045c0add01253d72}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!emplace\_front@{emplace\_front}}
\index{emplace\_front@{emplace\_front}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_front()}{emplace\_front()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class... Args$>$ \\
std\+::pair$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool$>$ \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::emplace\+\_\+front (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts a new element at the front of the container, constructed in-\/place with the given args if there is no element with the key in the container. Careful use of emplace\+\_\+front allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace\+\_\+front, forwarded via std\+::forward$<$\+Args$>$(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 

\begin{DoxyReturn}{Returns}
pair consisting of an iterator to the inserted element, or the already-\/existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a66e2ee127bb171c0780d79b922d09aca}\label{classseq_1_1ordered__set_a66e2ee127bb171c0780d79b922d09aca}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!emplace\_hint@{emplace\_hint}}
\index{emplace\_hint@{emplace\_hint}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_hint()}{emplace\_hint()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class... Args$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::emplace\+\_\+hint (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}}]{hint,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts a new element into the container constructed in-\/place with the given args if there is no element with the key in the container. Same as \mbox{\hyperlink{classseq_1_1ordered__set_a6d056ca8203ca976bc05e6873e32b9dd}{ordered\+\_\+set\+::emplace()}}. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a56f66564f55a08b8db92caaf4063b4d4}\label{classseq_1_1ordered__set_a56f66564f55a08b8db92caaf4063b4d4}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!empty@{empty}}
\index{empty@{empty}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
bool \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns true if the container is empty, false otherwise. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a43ac1ffc3edd4520c32a30b79fb05598}\label{classseq_1_1ordered__set_a43ac1ffc3edd4520c32a30b79fb05598}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!end@{end}}
\index{end@{end}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{end()}{end()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the first element of the container. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a3ff11b33174e2a29e741263be87280ec}\label{classseq_1_1ordered__set_a3ff11b33174e2a29e741263be87280ec}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!end@{end}}
\index{end@{end}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{end()}{end()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns an iterator to the first element of the container. 

\mbox{\Hypertarget{classseq_1_1ordered__set_ae8be2eae6a142bbc73cb57c98558f80a}\label{classseq_1_1ordered__set_ae8be2eae6a142bbc73cb57c98558f80a}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!erase@{erase}}
\index{erase@{erase}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::erase (\begin{DoxyParamCaption}\item[{const K \&}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Erase element comparing equal to given key (if any). Removes the element (if one exists) with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash\+::is\+\_\+transparent and Key\+Equal\+::is\+\_\+transparent are valid and each denotes a type, and neither iterator nor \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} is implicitly convertible from K. This assumes that such Hash is callable with both K and Key type, and that the Key\+Equal is transparent, which, together, allows calling this function without constructing an instance of Key. 

\begin{DoxyReturn}{Returns}
number of erased elements (0 or 1) 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a994967fe6f29b325a7452065df7f8257}\label{classseq_1_1ordered__set_a994967fe6f29b325a7452065df7f8257}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!erase@{erase}}
\index{erase@{erase}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a14db22b9060c55bae803daa77fb21a6f}{size\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::erase (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Erase element comparing equal to given key (if any). Iterators and references are not invalidated. Rehashing never occurs. 


\begin{DoxyParams}{Parameters}
{\em key} & key to be erased \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of erased elements (0 or 1) 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_ac23ff5e436a3f5d52ad21ef54d350a16}\label{classseq_1_1ordered__set_ac23ff5e436a3f5d52ad21ef54d350a16}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!erase@{erase}}
\index{erase@{erase}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}}]{first,  }\item[{\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Removes the elements in the range \mbox{[}first; last), which must be a valid range in $\ast$this. 


\begin{DoxyParams}{Parameters}
{\em first} & range of elements to remove \\
\hline
{\em last} & range of elements to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Iterator following the last removed element 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}\label{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!erase@{erase}}
\index{erase@{erase}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs. 


\begin{DoxyParams}{Parameters}
{\em pos} & iterator to the element to erase \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator to the next element 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a0f073c3b2c72ad39d9e7d595d5c6d348}\label{classseq_1_1ordered__set_a0f073c3b2c72ad39d9e7d595d5c6d348}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!find@{find}}
\index{find@{find}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::find (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key equivalent to key. Finds an element with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash\+::is\+\_\+transparent and Key\+Equal\+::is\+\_\+transparent are valid and each denotes a type. This assumes that such Hash is callable with both K and Key type, and that the Key\+Equal is transparent, which, together, allows calling this function without constructing an instance of Key. 


\begin{DoxyParams}{Parameters}
{\em value} & key value to search for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator pointing to found key on success, end iterator on failure. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a2722cf1834632a70c1c46b79c5e20bda}\label{classseq_1_1ordered__set_a2722cf1834632a70c1c46b79c5e20bda}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!find@{find}}
\index{find@{find}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class K , class KE  = Key\+Equal, class H  = Hash, typename std\+::enable\+\_\+if$<$ has\+\_\+is\+\_\+transparent$<$ K\+E $>$\+::value \&\&has\+\_\+is\+\_\+transparent$<$ H $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::find (\begin{DoxyParamCaption}\item[{const K \&}]{x }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key equivalent to key. Finds an element with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash\+::is\+\_\+transparent and Key\+Equal\+::is\+\_\+transparent are valid and each denotes a type. This assumes that such Hash is callable with both K and Key type, and that the Key\+Equal is transparent, which, together, allows calling this function without constructing an instance of Key. 


\begin{DoxyParams}{Parameters}
{\em value} & key value to search for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator pointing to found key on success, end iterator on failure. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a9975553b3f3550624489307d2906e68b}\label{classseq_1_1ordered__set_a9975553b3f3550624489307d2906e68b}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!find@{find}}
\index{find@{find}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::find (\begin{DoxyParamCaption}\item[{const Key \&}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key equivalent to key. 


\begin{DoxyParams}{Parameters}
{\em value} & key value to search for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator pointing to found key on success, end iterator on failure. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a5bec85cff7f40a66fb13c52c4f6ab091}\label{classseq_1_1ordered__set_a5bec85cff7f40a66fb13c52c4f6ab091}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!find@{find}}
\index{find@{find}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{group__bits_ga68ad5ff4a759a2a341569a42f9ba2e44}{S\+E\+Q\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE}} \mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::find (\begin{DoxyParamCaption}\item[{const Key \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Finds an element with key equivalent to key. 


\begin{DoxyParams}{Parameters}
{\em value} & key value to search for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
iterator pointing to found key on success, end iterator on failure. 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_ac6e9e655e89f7ec884242b68a03150cb}\label{classseq_1_1ordered__set_ac6e9e655e89f7ec884242b68a03150cb}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a73fdf0cb0cfbd9e15e6c9d72c2dde6fd}{allocator\+\_\+type}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the container allocator object. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a08b784bd6254b797ed667cdcc340cca1}\label{classseq_1_1ordered__set_a08b784bd6254b797ed667cdcc340cca1}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a73fdf0cb0cfbd9e15e6c9d72c2dde6fd}{allocator\+\_\+type}}\& \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the container allocator object. 

\mbox{\Hypertarget{classseq_1_1ordered__set_aa94a43b2144d15120ec9da3745e03391}\label{classseq_1_1ordered__set_aa94a43b2144d15120ec9da3745e03391}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!hash\_function@{hash\_function}}
\index{hash\_function@{hash\_function}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{hash\_function()}{hash\_function()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a878f53e048251a95c495145448f628f5}{hasher}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::hash\+\_\+function (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the hash function. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}\label{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!insert@{insert}}
\index{insert@{insert}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
std\+::pair$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool$>$ \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::insert (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). This function calls \mbox{\hyperlink{classseq_1_1sequence_a3a6276982c81ecc0cfc2b0f22a896a7a}{seq\+::sequence\+::insert()}} which insert the new element anywhere in the sequence, trying to fill holes left by calls to \mbox{\hyperlink{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}{ordered\+\_\+set\+::erase()}}. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 


\begin{DoxyParams}{Parameters}
{\em value} & value to be inserted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pair consisting of an iterator to the inserted element, or the already-\/existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a8c12858c2c7bd944c52db7cb228c44c3}\label{classseq_1_1ordered__set_a8c12858c2c7bd944c52db7cb228c44c3}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!insert@{insert}}
\index{insert@{insert}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}}]{hint,  }\item[{const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Same as \mbox{\hyperlink{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}{ordered\+\_\+set\+::insert()}}. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a261954fa1669bd5afbd67395fb2044c8}\label{classseq_1_1ordered__set_a261954fa1669bd5afbd67395fb2044c8}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!insert@{insert}}
\index{insert@{insert}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structseq_1_1ordered__set_1_1const__iterator}{const\+\_\+iterator}}}]{hint,  }\item[{\mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container using move semantic, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Same as \mbox{\hyperlink{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}{ordered\+\_\+set\+::insert()}}. 

\mbox{\Hypertarget{classseq_1_1ordered__set_ad97d9655ac3a0a3f954c1bfae0ddc8c3}\label{classseq_1_1ordered__set_ad97d9655ac3a0a3f954c1bfae0ddc8c3}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!insert@{insert}}
\index{insert@{insert}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class Input\+It $>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::insert (\begin{DoxyParamCaption}\item[{Input\+It}]{first,  }\item[{Input\+It}]{last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements from range \mbox{[}first, last). If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Elements are inserted in any order. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 


\begin{DoxyParams}{Parameters}
{\em first} & range of elements to insert \\
\hline
{\em last} & range of elements to insert \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_af008845549da85d2b5ec77e10020361f}\label{classseq_1_1ordered__set_af008845549da85d2b5ec77e10020361f}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!insert@{insert}}
\index{insert@{insert}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::insert (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} $>$}]{ilist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts elements from range \mbox{[}init.\+begin(), init.\+end()). If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Elements are inserted in any order. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 


\begin{DoxyParams}{Parameters}
{\em first} & range of elements to insert \\
\hline
{\em last} & range of elements to insert \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a5248034d5ee90fe8389ccff6a8513636}\label{classseq_1_1ordered__set_a5248034d5ee90fe8389ccff6a8513636}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!insert@{insert}}
\index{insert@{insert}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
std\+::pair$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool$>$ \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element into the container using move semantic, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). This function calls \mbox{\hyperlink{classseq_1_1sequence_a3a6276982c81ecc0cfc2b0f22a896a7a}{seq\+::sequence\+::insert()}} which insert the new element anywhere in the sequence, trying to fill holes left by calls to \mbox{\hyperlink{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}{ordered\+\_\+set\+::erase()}}. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 


\begin{DoxyParams}{Parameters}
{\em value} & value to be inserted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pair consisting of an iterator to the inserted element, or the already-\/existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a01914afcdfeff7e3b271423bcb6916ae}\label{classseq_1_1ordered__set_a01914afcdfeff7e3b271423bcb6916ae}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!key\_eq@{key\_eq}}
\index{key\_eq@{key\_eq}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{key\_eq()}{key\_eq()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a233a269648da39723d38745330132eed}{key\+\_\+equal}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::key\+\_\+eq (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the equality comparison function. 

\mbox{\Hypertarget{classseq_1_1ordered__set_ab700f354560059fd8aae90ecc8712d82}\label{classseq_1_1ordered__set_ab700f354560059fd8aae90ecc8712d82}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!load\_factor@{load\_factor}}
\index{load\_factor@{load\_factor}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{load\_factor()}{load\_factor()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
float \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::load\+\_\+factor (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the current load factor. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a0b853d3635dee2ae6869a31ad775d9a3}\label{classseq_1_1ordered__set_a0b853d3635dee2ae6869a31ad775d9a3}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!max\_load\_factor@{max\_load\_factor}}
\index{max\_load\_factor@{max\_load\_factor}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{max\_load\_factor()}{max\_load\_factor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
float \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::max\+\_\+load\+\_\+factor (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the current maximum load factor. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a403cd189fba893ab4f06b6cb28247288}\label{classseq_1_1ordered__set_a403cd189fba893ab4f06b6cb28247288}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!max\_load\_factor@{max\_load\_factor}}
\index{max\_load\_factor@{max\_load\_factor}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{max\_load\_factor()}{max\_load\_factor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::max\+\_\+load\+\_\+factor (\begin{DoxyParamCaption}\item[{float}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Set the maximum load factor. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a3803e22fd0b5f39f6df93d9f92838842}\label{classseq_1_1ordered__set_a3803e22fd0b5f39f6df93d9f92838842}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!max\_probe\_distance@{max\_probe\_distance}}
\index{max\_probe\_distance@{max\_probe\_distance}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{max\_probe\_distance()}{max\_probe\_distance()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
int \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::max\+\_\+probe\+\_\+distance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the current maximum possible probe distance. 

\mbox{\Hypertarget{classseq_1_1ordered__set_ace3604ad070d7b132932431ee70f166d}\label{classseq_1_1ordered__set_ace3604ad070d7b132932431ee70f166d}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!max\_size@{max\_size}}
\index{max\_size@{max\_size}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{max\_size()}{max\_size()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::max\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the container maximum size. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a4536ee7c30e5718d8469d1d49a34b81a}\label{classseq_1_1ordered__set_a4536ee7c30e5718d8469d1d49a34b81a}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!operator=@{operator=}}
\index{operator=@{operator=}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}\& \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy assignment operator. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a354660e510ee08b28ff5787313fe7616}\label{classseq_1_1ordered__set_a354660e510ee08b28ff5787313fe7616}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!operator=@{operator=}}
\index{operator=@{operator=}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}\& \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Move assignment operator. 

\mbox{\Hypertarget{classseq_1_1ordered__set_ae5cf95d12190533776ec9da46196a8da}\label{classseq_1_1ordered__set_ae5cf95d12190533776ec9da46196a8da}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
std\+::pair$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool$>$ \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element at the back of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 


\begin{DoxyParams}{Parameters}
{\em value} & value to be inserted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pair consisting of an iterator to the inserted element, or the already-\/existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_ac6c5a2f25f46714a26174aba6826a240}\label{classseq_1_1ordered__set_ac6c5a2f25f46714a26174aba6826a240}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
std\+::pair$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool$>$ \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element at the back of the container use move semantic, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 


\begin{DoxyParams}{Parameters}
{\em value} & value to be inserted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pair consisting of an iterator to the inserted element, or the already-\/existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a32e89bccd351ad976cee5e6edd58158e}\label{classseq_1_1ordered__set_a32e89bccd351ad976cee5e6edd58158e}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!push\_front@{push\_front}}
\index{push\_front@{push\_front}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{push\_front()}{push\_front()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
std\+::pair$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool$>$ \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::push\+\_\+front (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element at the front of the container, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 


\begin{DoxyParams}{Parameters}
{\em value} & value to be inserted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pair consisting of an iterator to the inserted element, or the already-\/existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_aa5b741972de9ec05a481d5f1d6c3fd29}\label{classseq_1_1ordered__set_aa5b741972de9ec05a481d5f1d6c3fd29}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!push\_front@{push\_front}}
\index{push\_front@{push\_front}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{push\_front()}{push\_front()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
std\+::pair$<$\mbox{\hyperlink{classseq_1_1ordered__set_ac624ed3f3e8da177bf1cc5d8d5933a77}{iterator}}, bool$>$ \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::push\+\_\+front (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1ordered__set_a09f3080d8f641e7a405a0c6cfb3f953d}{value\+\_\+type}} \&\&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts element at the front of the container using move semantic, if the container doesn\textquotesingle{}t already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than \mbox{\hyperlink{structseq_1_1detail_1_1_sparse_flat_node_hash_table_a45b3895816f93ec39cf389ab3a5cf587}{max\+\_\+load\+\_\+factor()}}$\ast$size(). 


\begin{DoxyParams}{Parameters}
{\em value} & value to be inserted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pair consisting of an iterator to the inserted element, or the already-\/existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a8061cfea560a5d1ea776671b398ee9b5}\label{classseq_1_1ordered__set_a8061cfea560a5d1ea776671b398ee9b5}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{rbegin()}{rbegin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the first element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1ordered__set_ad25d9c6aa7377945695c2d4d1f733637}\label{classseq_1_1ordered__set_ad25d9c6aa7377945695c2d4d1f733637}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{rbegin()}{rbegin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a432ef60eab5f87e4ed9293dc2c893cbc}{reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the first element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a2bb1f28b32c0c6c0422540b7986a49b0}\label{classseq_1_1ordered__set_a2bb1f28b32c0c6c0422540b7986a49b0}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!rehash@{rehash}}
\index{rehash@{rehash}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{rehash()}{rehash()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::rehash (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Rehash the container. This function triggers a full rehash if\+: 

\begin{DoxyVerb}-   the container is dirty (through a call to ordered_set::sequence()
-   the hash table size is too big or too small considering the max load factor (for instance after several calls to ordered_set::erase())
-   the hash table is in linear hashing state (because of bad hash function). In this case, the hash table size is doubled.
\end{DoxyVerb}


Otherwise, this function does nothing. \mbox{\Hypertarget{classseq_1_1ordered__set_a77890a2e98f5f0a0b5f83f8966594619}\label{classseq_1_1ordered__set_a77890a2e98f5f0a0b5f83f8966594619}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!rend@{rend}}
\index{rend@{rend}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{rend()}{rend()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a77aa2c4d6b23b4782bd5f84f9edec62f}{const\+\_\+reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the element following the last element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a608c8538b094d2477f6b67a3a3320dd5}\label{classseq_1_1ordered__set_a608c8538b094d2477f6b67a3a3320dd5}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!rend@{rend}}
\index{rend@{rend}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{rend()}{rend()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_a432ef60eab5f87e4ed9293dc2c893cbc}{reverse\+\_\+iterator}} \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns a reverse iterator to the element following the last element of the reversed list. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a4fc52f5ac410c23469f67314d85fc96f}\label{classseq_1_1ordered__set_a4fc52f5ac410c23469f67314d85fc96f}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!reserve@{reserve}}
\index{reserve@{reserve}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::reserve (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the number of nodes to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container. 


\begin{DoxyParams}{Parameters}
{\em count} & new capacity of the container \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a2e293647b0ab4d65ce9fa42c2eae88e2}\label{classseq_1_1ordered__set_a2e293647b0ab4d65ce9fa42c2eae88e2}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!sequence@{sequence}}
\index{sequence@{sequence}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{sequence()}{sequence()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
const \mbox{\hyperlink{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}{sequence\+\_\+type}}\& \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1sequence}{sequence}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the underlying sequence object. Do N\+OT mark the container as dirty. 

\mbox{\Hypertarget{classseq_1_1ordered__set_aa17f2ac25803a8cd75a632fe5a7f0fc9}\label{classseq_1_1ordered__set_aa17f2ac25803a8cd75a632fe5a7f0fc9}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!sequence@{sequence}}
\index{sequence@{sequence}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{sequence()}{sequence()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
\mbox{\hyperlink{classseq_1_1ordered__set_af9cd9e0271ca9e938e1d128522da7b41}{sequence\+\_\+type}}\& \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::\mbox{\hyperlink{classseq_1_1sequence}{sequence}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the underlying sequence object. Calling this function will mark the container as dirty. Any further attempts to call members like \mbox{\hyperlink{classseq_1_1ordered__set_a9975553b3f3550624489307d2906e68b}{find()}} or \mbox{\hyperlink{classseq_1_1ordered__set_a1dbca7285370fff2f9af1493aeeced3a}{insert()}} (relying on the hash function) will raise a std\+::logic\+\_\+error. To mark the container as non dirty anymore, the user must call \mbox{\hyperlink{classseq_1_1ordered__set_a2bb1f28b32c0c6c0422540b7986a49b0}{ordered\+\_\+set\+::rehash()}}. 

\begin{DoxyReturn}{Returns}
a reference to the underlying \mbox{\hyperlink{classseq_1_1sequence}{seq\+::sequence}} object 
\end{DoxyReturn}
\mbox{\Hypertarget{classseq_1_1ordered__set_a13ba901e3b3b3be36be8a12156f4614e}\label{classseq_1_1ordered__set_a13ba901e3b3b3be36be8a12156f4614e}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!shrink\_to\_fit@{shrink\_to\_fit}}
\index{shrink\_to\_fit@{shrink\_to\_fit}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{shrink\_to\_fit()}{shrink\_to\_fit()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::shrink\+\_\+to\+\_\+fit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Calls \mbox{\hyperlink{classseq_1_1sequence_a1bf494125859119c2748a7a5e59588fa}{seq\+::sequence\+::shrink\+\_\+to\+\_\+fit()}}. Remove potential holes in the sequence object due to calls to \mbox{\hyperlink{classseq_1_1ordered__set_ab77fb73a8facb7f01ed53f43b292eed5}{ordered\+\_\+set\+::erase()}}. Does not allocate memory, except for the hash table itself. Invalidate all references and iterators. Basic exception guarantee only. 

\mbox{\Hypertarget{classseq_1_1ordered__set_abca7e24629ce431774748e300f019d81}\label{classseq_1_1ordered__set_abca7e24629ce431774748e300f019d81}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!size@{size}}
\index{size@{size}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
size\+\_\+t \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Returns the container size. 

\mbox{\Hypertarget{classseq_1_1ordered__set_a36a66b34dafa44d2f963a201272b2d24}\label{classseq_1_1ordered__set_a36a66b34dafa44d2f963a201272b2d24}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!sort@{sort}}
\index{sort@{sort}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{sort()}{sort()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::sort (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sort the container using std\+::less$<$\+Key$>$. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. 

\mbox{\Hypertarget{classseq_1_1ordered__set_ad8c0514644286c8155f35d87dab0e3e9}\label{classseq_1_1ordered__set_ad8c0514644286c8155f35d87dab0e3e9}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!sort@{sort}}
\index{sort@{sort}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{sort()}{sort()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class Less $>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::sort (\begin{DoxyParamCaption}\item[{Less}]{le }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sort the container based on given comparator. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. 


\begin{DoxyParams}{Parameters}
{\em le} & comparison function \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_ae64707af69a6b261413d1325c8f35d30}\label{classseq_1_1ordered__set_ae64707af69a6b261413d1325c8f35d30}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!stable\_sort@{stable\_sort}}
\index{stable\_sort@{stable\_sort}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{stable\_sort()}{stable\_sort()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::stable\+\_\+sort (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sort the container based on std\+::less$<$\+Key$>$ and using std\+::stable\+\_\+sort. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. 

\mbox{\Hypertarget{classseq_1_1ordered__set_aa23ceeda63ee924eae70f4f2a40e6b7d}\label{classseq_1_1ordered__set_aa23ceeda63ee924eae70f4f2a40e6b7d}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!stable\_sort@{stable\_sort}}
\index{stable\_sort@{stable\_sort}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{stable\_sort()}{stable\_sort()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
template$<$class Less $>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::stable\+\_\+sort (\begin{DoxyParamCaption}\item[{Less}]{le }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sort the container based on given comparator and using std\+::stable\+\_\+sort. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. 


\begin{DoxyParams}{Parameters}
{\em le} & comparison function \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classseq_1_1ordered__set_a768027febcc0b8e7df4465815510715d}\label{classseq_1_1ordered__set_a768027febcc0b8e7df4465815510715d}} 
\index{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}!swap@{swap}}
\index{swap@{swap}!seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$@{seq::ordered\_set$<$ Key, Hash, KeyEqual, Allocator, Layout $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily template$<$class Key , class Hash  = std\+::hash$<$\+Key$>$, class Key\+Equal  = std\+::equal\+\_\+to$<$\+Key$>$, class Allocator  = std\+::allocator$<$\+Key$>$, Layout\+Management Layout = Optimize\+For\+Speed$>$ \\
void \mbox{\hyperlink{classseq_1_1ordered__set}{seq\+::ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseq_1_1ordered__set}{ordered\+\_\+set}}$<$ Key, Hash, Key\+Equal, Allocator, Layout $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Swap this container with other. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
seq/\mbox{\hyperlink{ordered__map_8hpp}{ordered\+\_\+map.\+hpp}}\end{DoxyCompactItemize}
