<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::hold_any&lt; Interface, StaticSize, Alignment &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classseq_1_1hold__any.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classseq_1_1hold__any-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::hold_any&lt; Interface, StaticSize, Alignment &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>std::any like class optimized to build heterogeneous containers.  
 <a href="classseq_1_1hold__any.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="any_8hpp_source.html">any.hpp</a>&gt;</code></p>

<p>Inherits template any_interface&lt; any_base&lt; hold_any&lt; any_default_interface, sizeof(double), alignof(double) &gt;, Interface::type_info, sizeof(double), alignof(double) &gt; &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af66e74bcdac095ab46f55bdd9419bb34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#af66e74bcdac095ab46f55bdd9419bb34">base_type</a> = typename Interface::template any_interface&lt; <a class="el" href="structseq_1_1any__base.html">any_base</a>&lt; <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt;, typename Interface::type_info, StaticSize, Alignment &gt; &gt;</td></tr>
<tr class="memdesc:af66e74bcdac095ab46f55bdd9419bb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base public type.  <a href="classseq_1_1hold__any.html#af66e74bcdac095ab46f55bdd9419bb34">More...</a><br /></td></tr>
<tr class="separator:af66e74bcdac095ab46f55bdd9419bb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d29fc7c99e55af995fa4de7596c5c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a23d29fc7c99e55af995fa4de7596c5c3">type_info_type</a> = typename Interface::type_info</td></tr>
<tr class="memdesc:a23d29fc7c99e55af995fa4de7596c5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info as returned by type()  <a href="classseq_1_1hold__any.html#a23d29fc7c99e55af995fa4de7596c5c3">More...</a><br /></td></tr>
<tr class="separator:a23d29fc7c99e55af995fa4de7596c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcce1fa954bad763a29b08b8db95bf3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abdcce1fa954bad763a29b08b8db95bf3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#abdcce1fa954bad763a29b08b8db95bf3">typed_type_info_type</a> = typename Interface::template typed_type_info&lt; T &gt;</td></tr>
<tr class="memdesc:abdcce1fa954bad763a29b08b8db95bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual implementation of type info.  <a href="classseq_1_1hold__any.html#abdcce1fa954bad763a29b08b8db95bf3">More...</a><br /></td></tr>
<tr class="separator:abdcce1fa954bad763a29b08b8db95bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6504e84038886576e6b9bfe772b24af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#ab6504e84038886576e6b9bfe772b24af">hold_any</a> ()</td></tr>
<tr class="memdesc:ab6504e84038886576e6b9bfe772b24af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor.  <a href="classseq_1_1hold__any.html#ab6504e84038886576e6b9bfe772b24af">More...</a><br /></td></tr>
<tr class="separator:ab6504e84038886576e6b9bfe772b24af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b270bf34f7dc79b210aaafd46641bb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a1b270bf34f7dc79b210aaafd46641bb1">hold_any</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;other)</td></tr>
<tr class="memdesc:a1b270bf34f7dc79b210aaafd46641bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor Might throw std::bad_function_call if underlying type is not copy constructible (for instance std::unique_ptr)  <a href="classseq_1_1hold__any.html#a1b270bf34f7dc79b210aaafd46641bb1">More...</a><br /></td></tr>
<tr class="separator:a1b270bf34f7dc79b210aaafd46641bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac587e55fd6491bee3a704491ae45b0d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#ac587e55fd6491bee3a704491ae45b0d8">hold_any</a> (<a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ac587e55fd6491bee3a704491ae45b0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor Move constructor is NOT noexcept as <a class="el" href="namespaceseq_1_1detail.html#aadadc42324010b84a6053c3491490dea">move_any()</a> might throw.  <a href="classseq_1_1hold__any.html#ac587e55fd6491bee3a704491ae45b0d8">More...</a><br /></td></tr>
<tr class="separator:ac587e55fd6491bee3a704491ae45b0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143cd5f15f6a232497f79d40a47c0db4"><td class="memTemplParams" colspan="2">template&lt;class T , class  = typename std::enable_if&lt; !std::is_base_of&lt;detail::null_policy, typename std::decay&lt;T&gt;::type&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a143cd5f15f6a232497f79d40a47c0db4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a143cd5f15f6a232497f79d40a47c0db4">hold_any</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a143cd5f15f6a232497f79d40a47c0db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from any object except another <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a>.  <a href="classseq_1_1hold__any.html#a143cd5f15f6a232497f79d40a47c0db4">More...</a><br /></td></tr>
<tr class="separator:a143cd5f15f6a232497f79d40a47c0db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b9694ee008b29d32572a2392610fd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a82b9694ee008b29d32572a2392610fd0">~hold_any</a> ()</td></tr>
<tr class="memdesc:a82b9694ee008b29d32572a2392610fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classseq_1_1hold__any.html#a82b9694ee008b29d32572a2392610fd0">More...</a><br /></td></tr>
<tr class="separator:a82b9694ee008b29d32572a2392610fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee20937ac7a67a9565e247149490c44"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a2ee20937ac7a67a9565e247149490c44">operator=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;other) -&gt; <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;</td></tr>
<tr class="memdesc:a2ee20937ac7a67a9565e247149490c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <a href="classseq_1_1hold__any.html#a2ee20937ac7a67a9565e247149490c44">More...</a><br /></td></tr>
<tr class="separator:a2ee20937ac7a67a9565e247149490c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4000383b6d465a3007602dbbace207aa"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a4000383b6d465a3007602dbbace207aa">operator=</a> (<a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;&amp;other) -&gt; <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;</td></tr>
<tr class="memdesc:a4000383b6d465a3007602dbbace207aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment, MIGHT THROW!  <a href="classseq_1_1hold__any.html#a4000383b6d465a3007602dbbace207aa">More...</a><br /></td></tr>
<tr class="separator:a4000383b6d465a3007602dbbace207aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af674e3f02ac5c0605e52601d7d333c1a"><td class="memTemplParams" colspan="2">template&lt;class T , class  = typename std::enable_if&lt; !std::is_base_of&lt;detail::null_policy, typename std::decay&lt;T&gt;::type&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:af674e3f02ac5c0605e52601d7d333c1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#af674e3f02ac5c0605e52601d7d333c1a">operator=</a> (T &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;</td></tr>
<tr class="memdesc:af674e3f02ac5c0605e52601d7d333c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign any kind of object except a <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a>.  <a href="classseq_1_1hold__any.html#af674e3f02ac5c0605e52601d7d333c1a">More...</a><br /></td></tr>
<tr class="separator:af674e3f02ac5c0605e52601d7d333c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87143783cbfba43b22bf57d033246e34"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class... Args&gt; </td></tr>
<tr class="memitem:a87143783cbfba43b22bf57d033246e34"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a87143783cbfba43b22bf57d033246e34">emplace</a> (Args &amp;&amp;... args) -&gt; typename std::decay&lt; ValueType &gt;::type &amp;</td></tr>
<tr class="memdesc:a87143783cbfba43b22bf57d033246e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace construction.  <a href="classseq_1_1hold__any.html#a87143783cbfba43b22bf57d033246e34">More...</a><br /></td></tr>
<tr class="separator:a87143783cbfba43b22bf57d033246e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200afdd399e8169666eb47c85d60b16f"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class U , class... Args&gt; </td></tr>
<tr class="memitem:a200afdd399e8169666eb47c85d60b16f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a200afdd399e8169666eb47c85d60b16f">emplace</a> (std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args) -&gt; typename std::decay&lt; ValueType &gt;::type &amp;</td></tr>
<tr class="memdesc:a200afdd399e8169666eb47c85d60b16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace construction.  <a href="classseq_1_1hold__any.html#a200afdd399e8169666eb47c85d60b16f">More...</a><br /></td></tr>
<tr class="separator:a200afdd399e8169666eb47c85d60b16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8439dbae538c9724f1e3b3ba644708f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#ac8439dbae538c9724f1e3b3ba644708f">has_value</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:ac8439dbae538c9724f1e3b3ba644708f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> holds an object.  <a href="classseq_1_1hold__any.html#ac8439dbae538c9724f1e3b3ba644708f">More...</a><br /></td></tr>
<tr class="separator:ac8439dbae538c9724f1e3b3ba644708f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635579e9906f4b4f1401c5b68a3b7efb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a635579e9906f4b4f1401c5b68a3b7efb">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a635579e9906f4b4f1401c5b68a3b7efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion to bool.  <a href="classseq_1_1hold__any.html#a635579e9906f4b4f1401c5b68a3b7efb">More...</a><br /></td></tr>
<tr class="separator:a635579e9906f4b4f1401c5b68a3b7efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae602f9129adf5742ce96a050a82d081e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#ae602f9129adf5742ce96a050a82d081e">swap</a> (<a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;other)</td></tr>
<tr class="memdesc:ae602f9129adf5742ce96a050a82d081e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap content with another <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a>. Swap cannot be noexcept as there is no guarantee that move assignment of underlying types are noexcept.  <a href="classseq_1_1hold__any.html#ae602f9129adf5742ce96a050a82d081e">More...</a><br /></td></tr>
<tr class="separator:ae602f9129adf5742ce96a050a82d081e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af968dafb946e95314e8e223888b0a59c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#af968dafb946e95314e8e223888b0a59c">reset</a> () noexcept</td></tr>
<tr class="memdesc:af968dafb946e95314e8e223888b0a59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> by destroying underlying object (if any) and deallocating the storage (if any)  <a href="classseq_1_1hold__any.html#af968dafb946e95314e8e223888b0a59c">More...</a><br /></td></tr>
<tr class="separator:af968dafb946e95314e8e223888b0a59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeed042b82bc91b7b75dfc50064676a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abbeed042b82bc91b7b75dfc50064676a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#abbeed042b82bc91b7b75dfc50064676a">equal_to</a> (T &amp;&amp;other) const -&gt; bool</td></tr>
<tr class="memdesc:abbeed042b82bc91b7b75dfc50064676a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if underlying object is equal to other.  <a href="classseq_1_1hold__any.html#abbeed042b82bc91b7b75dfc50064676a">More...</a><br /></td></tr>
<tr class="separator:abbeed042b82bc91b7b75dfc50064676a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cb6f241bd0cd9e29961b8ba4d8d6bd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a25cb6f241bd0cd9e29961b8ba4d8d6bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a25cb6f241bd0cd9e29961b8ba4d8d6bd">less_than</a> (T &amp;&amp;other) const -&gt; bool</td></tr>
<tr class="memdesc:a25cb6f241bd0cd9e29961b8ba4d8d6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if underlying object compares less than other.  <a href="classseq_1_1hold__any.html#a25cb6f241bd0cd9e29961b8ba4d8d6bd">More...</a><br /></td></tr>
<tr class="separator:a25cb6f241bd0cd9e29961b8ba4d8d6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309289b8f08a2a8c3e587a07e35d1b15"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a309289b8f08a2a8c3e587a07e35d1b15"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a309289b8f08a2a8c3e587a07e35d1b15">greater_than</a> (T &amp;&amp;other) const -&gt; bool</td></tr>
<tr class="memdesc:a309289b8f08a2a8c3e587a07e35d1b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if underlying object compares greater than other.  <a href="classseq_1_1hold__any.html#a309289b8f08a2a8c3e587a07e35d1b15">More...</a><br /></td></tr>
<tr class="separator:a309289b8f08a2a8c3e587a07e35d1b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af042372b1ab3f7b22a58011909eeb3ef"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#af042372b1ab3f7b22a58011909eeb3ef">operator==</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;other) const -&gt; bool</td></tr>
<tr class="memdesc:af042372b1ab3f7b22a58011909eeb3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <a href="classseq_1_1hold__any.html#af042372b1ab3f7b22a58011909eeb3ef">More...</a><br /></td></tr>
<tr class="separator:af042372b1ab3f7b22a58011909eeb3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583e9d4e8516b29d396e5d337609b45e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a583e9d4e8516b29d396e5d337609b45e">operator!=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;other) const -&gt; bool</td></tr>
<tr class="separator:a583e9d4e8516b29d396e5d337609b45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b3ecb9f35ee664e2ca3545b6e48328"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#aa8b3ecb9f35ee664e2ca3545b6e48328">operator&lt;</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;other) const -&gt; bool</td></tr>
<tr class="separator:aa8b3ecb9f35ee664e2ca3545b6e48328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67323dc05989bdb7ff530ddd6606325"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#af67323dc05989bdb7ff530ddd6606325">operator&lt;=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;other) const -&gt; bool</td></tr>
<tr class="separator:af67323dc05989bdb7ff530ddd6606325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87a957815734e8e534660a9c212f0b6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#aa87a957815734e8e534660a9c212f0b6">operator&gt;</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;other) const -&gt; bool</td></tr>
<tr class="separator:aa87a957815734e8e534660a9c212f0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb748c5632f96736d9f0707dd47e9f67"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#adb748c5632f96736d9f0707dd47e9f67">operator&gt;=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a> &amp;other) const -&gt; bool</td></tr>
<tr class="separator:adb748c5632f96736d9f0707dd47e9f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a91e38de782f33532cef590a05661f9e3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a91e38de782f33532cef590a05661f9e3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a91e38de782f33532cef590a05661f9e3">get_type</a> () -&gt; <a class="el" href="classseq_1_1hold__any.html#a23d29fc7c99e55af995fa4de7596c5c3">type_info_type</a> *</td></tr>
<tr class="memdesc:a91e38de782f33532cef590a05661f9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type info for given type.  <a href="classseq_1_1hold__any.html#a91e38de782f33532cef590a05661f9e3">More...</a><br /></td></tr>
<tr class="separator:a91e38de782f33532cef590a05661f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a835540e3ff0854680297ae3531152992"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html#a835540e3ff0854680297ae3531152992">static_size</a> = sizeof(hold_any::d_storage)</td></tr>
<tr class="memdesc:a835540e3ff0854680297ae3531152992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size for Small Buffer Optimization.  <a href="classseq_1_1hold__any.html#a835540e3ff0854680297ae3531152992">More...</a><br /></td></tr>
<tr class="separator:a835540e3ff0854680297ae3531152992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Interface = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt;<br />
class seq::hold_any&lt; Interface, StaticSize, Alignment &gt;</h3>

<p>std::any like class optimized to build heterogeneous containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Interface</td><td>class Interface, default to <a class="el" href="structseq_1_1any__default__interface.html" title="Default interface for hold_any.">any_default_interface</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">seq::hold_any</a> is a std::any like class optimized to create heterogeneous containers of any types (vectors, deques, hash tables, sorted containers...).</p>
<p>The seq library provides the following aliases:</p><ul>
<li><a class="el" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">seq::any</a>: equivalent to seq::hold_any&lt;seq::any_default_interface&gt;</li>
<li><a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">seq::nh_any</a>: equivalent to seq::hold_any&lt;seq::any_no_hash_interface&gt;</li>
</ul>
<h2><a class="anchor" id="autotoc_md0"></a>
Interface</h2>
<p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> offers a similar interface to std::any and supports additional features:</p><ul>
<li>Support for comparison operators &lt;, &lt;=, &gt;, &gt;=, == and !=</li>
<li>Support for standard stream operators to/from std::ostream/std::istream</li>
<li><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> is hashable based on std::hash</li>
<li><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> can be formatted using the <a class="el" href="group__format.html">formatting</a> module of seq library</li>
<li><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> interface can be extended</li>
</ul>
<p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> is very similar to boost.TypeErasure or folly.Poly, but its default implementation provides more features in order to be used within most containers (sorted containers, hash tables,...).</p>
<p>These features do not modify the requirements of held types: they must be at least move only contructible. <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> uses type erasure to provide custom behavior based on held object type, and the additional functions like streaming or comparison support are implemented if the type supports them. If not, the corresponding functions will throw a std::bad_function_call exception:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">seq::any</a>(2);                   <span class="comment">// works as expected, print &#39;2&#39;</span></div>
<div class="line">std::cout &lt;&lt; seq::any(std::vector&lt;bool&gt;()); <span class="comment">// std::vector&lt;bool&gt; does not define stream operator to std::ostream, throw a std::bad_function_call</span></div>
</div><!-- fragment --><p>The only exception is the hashing support. Indeed, there is now way in C++11 to tell at compile time if a type is hashable or not, as most implementations of std::hash use static_assert() in the operator() member (undetectable through SFINAE). <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> optimistically assumes that all types are hashable. In order to store non hashable types, you must specialize the <a class="el" href="structseq_1_1is__hashable.html" title="Tells if given type is hashable with std::hash. True by default, optimistically assume that all types...">seq::is_hashable</a> type trait for this type:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>test{};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structseq_1_1is__hashable.html">seq::is_hashable</a>&lt;test&gt; : std::false_type {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> a = test(); <span class="comment">// compile as is_hashable is specialized for test class</span></div>
</div><!-- fragment --><p>Otherwise, you can completely disable the hashing support using <a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">seq::nh_any</a> (equivalent to seq::hold_any&lt;seq::any_no_hash_interface&gt;) :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>test{};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::nh_any</a> a = test();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1"></a>
Casting</h2>
<p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> can be casted to another type using either hold_any::cast() function or <a class="el" href="namespaceseq.html#a568a9b05cad11abae721e6b2a1a64942">seq::any_cast()</a> (similar to std::any_cast). When casting to the same type as the underlying object, it is possible to retrieve a reference to the object:</p>
<div class="fragment"><div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> a = 2;</div>
<div class="line"><span class="keywordtype">int</span> &amp;value1 = a.cast&lt;<span class="keywordtype">int</span>&amp;&gt;();</div>
<div class="line"><span class="keywordtype">int</span> &amp;value2 = seq::any_cast&lt;int&amp;&gt;(a);</div>
<div class="line"><span class="keywordtype">int</span> *value3 = seq::any_cast&lt;int&gt;(&amp;a);</div>
</div><!-- fragment --><p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> supports casting to another type. By default, the following conversion are valid:</p><ul>
<li>A pointer can be casted to void* or const void*</li>
<li>All arithmetic types can be casted between each other</li>
<li>Arithmetic types can be casted to std::string or <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">seq::tiny_string</a></li>
<li>All string types can be casted between each other (std::string, <a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5" title="Base string typedef, similar to std::string. Equivalent to tiny_string&lt;0, std::allocator&lt;char&gt;&gt;.">seq::tstring</a>, <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69" title="Base string view typedef, similar to std::string_view. Equivalent to tiny_string&lt;0,...">seq::tstring_view</a>, std::string_view, char* and const char*)</li>
<li>All string types can be casted to arithmetic types (which can throw a std::bad_cast exception if the string does not represent an arithmetic type)</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">any</a> a = <span class="stringliteral">&quot;1.2&quot;</span>; <span class="comment">// holds a const char*</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span>* c = a.cast&lt;<span class="keywordtype">char</span>*&gt;(); <span class="comment">// const char * to char* is valid (although not safe)</span></div>
<div class="line"><span class="keywordtype">void</span>* v = a.cast&lt;<span class="keywordtype">void</span>*&gt;(); <span class="comment">//conversion to void* is valid (although not safe)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// conversion to the different string types</span></div>
<div class="line"><a class="code" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a> <a class="code" href="namespaceseq_1_1detail.html#a84d714603751dddb280584583ccdd7e3">str</a> = a.cast&lt;<a class="code" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a>&gt;();</div>
<div class="line"><a class="code" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> view = a.cast&lt;<a class="code" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a>&gt;();</div>
<div class="line">std::string str2 = a.cast&lt;std::string&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// conversion to arithmetic</span></div>
<div class="line"><span class="keywordtype">double</span> d = a.cast&lt;<span class="keywordtype">double</span>&gt;(); <span class="comment">// d holds 1.2</span></div>
<div class="line"><span class="keywordtype">int</span> i = a.cast&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// i holds 1</span></div>
<div class="line"> </div>
<div class="line">a = 1.2;</div>
<div class="line">i = a.cast&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">//valid, cast double to int</span></div>
<div class="line">str2 = a.cast&lt;std::string&gt;(); <span class="comment">//valid, str2 holds &quot;1.2&quot;</span></div>
</div><!-- fragment --><p>It is possible to register additional conversion functions for custom types using <a class="el" href="namespaceseq.html#a97851d71ded4c7928aabd76f4280d268" title="Register a conversion function based on explicit conversion from type T to type U.">seq::register_any_conversion()</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_int_pair</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">int</span> a, b;</div>
<div class="line">my_int_pair(<span class="keywordtype">int</span> a = 0, <span class="keywordtype">int</span> b = 0)</div>
<div class="line">    :a(a), b(b) {}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// define conversion operator to std::string</span></div>
<div class="line"><span class="keyword">operator</span> std::string()<span class="keyword"> const </span>{</div>
<div class="line">    std::string res;</div>
<div class="line">    <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(a).append(res);</div>
<div class="line">    <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(b).append(res);</div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::string pair_to_string(<span class="keyword">const</span> std::pair&lt;int, int&gt;&amp; p)</div>
<div class="line">{</div>
<div class="line">std::string res;</div>
<div class="line"><a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(p.first).append(res);</div>
<div class="line"><a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(p.second).append(res);</div>
<div class="line"><span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// register conversion that already exists </span></div>
<div class="line">seq::register_any_conversion&lt;my_int_pair, std::string&gt;();</div>
<div class="line"><span class="comment">// register conversion function</span></div>
<div class="line">seq::register_any_conversion&lt;std::pair&lt;int, int&gt;, std::string&gt;(pair_to_string);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// disable hashing interface</span></div>
<div class="line"><span class="keyword">using</span> my_any = <a class="code" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">seq::nh_any</a>;</div>
<div class="line"> </div>
<div class="line">my_any a = std::pair&lt;int, int&gt;(1, 2);</div>
<div class="line">my_any b = my_int_pair(1, 2);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; a.cast&lt;std::string&gt;() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; b.cast&lt;std::string&gt;() &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2"></a>
Hashing</h2>
<p>As said previously, <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">seq::hold_any</a> is hashable and a specialization for std::hash is provided. This feature is mandatory when inserting any objects into hash table based containers like std::unordered_set. In order to store non hashable types (that do not specialize std::hash), you must specialize <a class="el" href="structseq_1_1is__hashable.html" title="Tells if given type is hashable with std::hash. True by default, optimistically assume that all types...">seq::is_hashable</a> type traits for this type to have seq::is_hashable&lt;Type&gt;::value == false.</p>
<p>Another way to store non hashable types is to use <a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">seq::nh_any</a> instead of <a class="el" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">seq::any</a> which disable the hashing support. Attempting to call seq::hold_any::hash() member on a non hashable type will throw a std::bad_function_call.</p>
<p>The specialization of std::hash for <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> is transparent to support heterogeneous lookup.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ordered_set.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tiny__string_8hpp.html">tiny_string.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="any_8hpp.html">any.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// build an ordered set than supports heterogeneous lookup </span></div>
<div class="line"><a class="code" href="classseq_1_1ordered__set.html">seq::ordered_set&lt;any,std::hash&lt;any&gt;</a> , std::equal_to&lt;void&gt; &gt; set;</div>
<div class="line"> </div>
<div class="line">set.<a class="code" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c">insert</a>(3);</div>
<div class="line">set.<a class="code" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c">insert</a>(2.5);</div>
<div class="line">set.<a class="code" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c">insert</a>(<a class="code" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a>(<span class="stringliteral">&quot;hello&quot;</span>));</div>
<div class="line">set.<a class="code" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c">insert</a>(1);</div>
<div class="line">set.<a class="code" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c">insert</a>(std::string(<span class="stringliteral">&quot;world&quot;</span>));</div>
<div class="line">set.<a class="code" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c">insert</a>(<span class="stringliteral">&quot;ok&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// print the set content</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code" href="namespaceseq_1_1detail.html#ad2ef3bc87521f2c064991225c99aeabf">val</a> : set)</div>
<div class="line">    std::cout &lt;&lt; <a class="code" href="namespaceseq_1_1detail.html#ad2ef3bc87521f2c064991225c99aeabf">val</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">assert(set.find(3) != set.end());           <span class="comment">// use heterogeneous lookup </span></div>
<div class="line">assert(set.find(2.5) != set.end());         <span class="comment">// use heterogeneous lookup </span></div>
<div class="line">assert(set.find(<span class="stringliteral">&quot;hello&quot;</span>)  != set.end());    <span class="comment">// use heterogeneous lookup </span></div>
<div class="line">assert(set.find(<a class="code" href="classseq_1_1tiny__string.html">tstring</a>(<span class="stringliteral">&quot;world&quot;</span>)) != set.end());    <span class="comment">// use heterogeneous lookup </span></div>
<div class="line">assert(set.find(<span class="stringliteral">&quot;ok&quot;</span>) == set.end()) ;           <span class="comment">//&quot;ok&quot; not found has we compare 2 const char* -&gt; pointer comparison, not string comparison</span></div>
<div class="line">assert(set.find(<span class="stringliteral">&quot;no&quot;</span>) == set.end());            <span class="comment">//failed lookup</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
Equality comparison</h2>
<p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> objects are equally comparable. This feature is mandatory when inserting any objects into hash table based containers like std::unordered_set. Two <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> are considered equal if:</p><ul>
<li>They are both empty.</li>
<li>They hold the same type and both underlying objects compare equals. If the type does not provide a comparison operator, the <a class="el" href="classseq_1_1hold__any.html#af042372b1ab3f7b22a58011909eeb3ef" title="Equality comparison operator.">operator==()</a> always return false.</li>
<li>They both hold an arithmetic value of possibly different types, and these values compare equals.</li>
<li>They both hold a string like object (std::string, <a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5" title="Base string typedef, similar to std::string. Equivalent to tiny_string&lt;0, std::allocator&lt;char&gt;&gt;.">seq::tstring</a>, <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69" title="Base string view typedef, similar to std::string_view. Equivalent to tiny_string&lt;0,...">seq::tstring_view</a>, std::string_view, char*, const char*) that compare equals. Note that a const char* can be compared to another string object (like std::string) using string comparison, but comparing two const char* will result in a pointer comparison!</li>
</ul>
<p>It is possible to register a comparison function for unrelated types using <a class="el" href="namespaceseq.html#adb61336a531e99a11a888883a46d0f01" title="Register the comparison function T() == U()">seq::register_any_equal_comparison()</a> function.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> a = 1.0;</div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> b = 1;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> c = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> d = std::string(<span class="stringliteral">&quot;hello&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(a == b);  <span class="comment">// compare any(double) and any(int)</span></div>
<div class="line">assert(a == 1.); <span class="comment">// compare any(double) to a double</span></div>
<div class="line">assert(a == 1);   <span class="comment">// compare any(double) to int</span></div>
<div class="line">assert(a != 1.2); <span class="comment">// compare any(double) to a double</span></div>
<div class="line">assert(a != c); <span class="comment">// compare any(double) to any(const char*)</span></div>
<div class="line">assert(c == d); <span class="comment">//compare any(const char*) to any(std::string)</span></div>
<div class="line">assert(d == <span class="stringliteral">&quot;hello&quot;</span>); <span class="comment">// compare any(std::string) to const char*</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// define a comparison function between std::pair&lt;int,int&gt; and int</span></div>
<div class="line"><span class="keyword">struct </span>equal_pair</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> std::pair&lt;int,int&gt; &amp; a, <span class="keywordtype">int</span> b)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> a.first == b &amp;&amp; a.second == b;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">seq::register_any_equal_comparison&lt;std::pair&lt;int,int&gt;, <span class="keywordtype">int</span>&gt;(equal_pair{});</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::nh_any</a> pair = std::pair&lt;int,int&gt;(2,2);</div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::nh_any</a> integer = 2;</div>
<div class="line">assert(pair == integer);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Less comparison</h2>
<p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> object can be compared using operators &lt;, &gt;, &lt;=, &gt;=, all based on the <em>less than</em> operator. This is mandatory when inserting any objects into a sorted container like std::set. A <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> object A is considered less than another <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> B if:</p><ul>
<li>A is empty and not B.</li>
<li>A and B hold the same type and object(A) &lt; object(B). If the type does not provide a less than operator, throw std::bad_function_call.</li>
<li>They both hold an arithmetic value of possibly different types, and object(A) &lt; object(B).</li>
<li>They both hold a string like object (std::string, <a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5" title="Base string typedef, similar to std::string. Equivalent to tiny_string&lt;0, std::allocator&lt;char&gt;&gt;.">seq::tstring</a>, <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69" title="Base string view typedef, similar to std::string_view. Equivalent to tiny_string&lt;0,...">seq::tstring_view</a>, std::string_view, char*, const char*) and object(A) &lt; object(B).</li>
<li>For totally unrelated types, returns get_type_id(A) &lt; get_type_id(B).</li>
</ul>
<p>It is possible to register a comparison function for unrelated types using <a class="el" href="namespaceseq.html#ab390e9bf772c9a88f9f48c5bd360d7ed" title="Register the comparison function T() &lt; U()">seq::register_any_less_comparison()</a> function.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> a = 1;</div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> b = 2.3;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> c = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> d = std::string(<span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(a &lt; b);  <span class="comment">// compare any(int) and any(double)</span></div>
<div class="line">assert(a &lt; 2.3); <span class="comment">// compare any(int) to a double</span></div>
<div class="line">assert(a &lt;= 1);   <span class="comment">// compare any(int) to int</span></div>
<div class="line">assert(b &gt;= a);   <span class="comment">// compare any(double) to any(int)</span></div>
<div class="line">assert(c &lt; d); <span class="comment">//compare any(const char*) to any(std::string)</span></div>
<div class="line">assert(d &gt; c); <span class="comment">// compare any(std::string) to const char*</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// define a dumy comparison function between std::pair&lt;int,int&gt; and int</span></div>
<div class="line"><span class="keyword">struct </span>less_pair</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> std::pair&lt;int,int&gt; &amp; a, <span class="keywordtype">int</span> b)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> a.first &lt; b &amp;&amp; a.second &lt; b;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">seq::register_any_less_comparison&lt;std::pair&lt;int,int&gt;, <span class="keywordtype">int</span>&gt;(less_pair{});</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::nh_any</a> pair = std::pair&lt;int,int&gt;(1,2);</div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::nh_any</a> integer = 3;</div>
<div class="line">assert(pair &lt; integer); </div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Small Buffer Optimization</h2>
<p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> provides a customizable Small Buffer Optimization (SBO) in order to avoid costly memory allocation for small types. The alignment of the small buffer can also be modified.</p>
<p>By default, the small buffer size is equal to sizeof(double) and its alignment is alignof(double). Therefore, on 64 bits machines, sizeof(seq::any) is 16 bytes.</p>
<p>The small buffer size and alignment can be changed through <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> template parameters:</p>
<div class="fragment"><div class="line"><span class="comment">// define an any type that can hold a tstring object on the stack</span></div>
<div class="line"><span class="keyword">using</span> my_any = <a class="code" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt;<a class="code" href="structseq_1_1any__default__interface.html">seq::any_default_interface</a>, <span class="keyword">sizeof</span>(<a class="code" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a>), <span class="keyword">alignof</span>(<a class="code" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a>) &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the tstring object is stored on the stack using the small buffer. This line does not trigger a memory allocation as tstring itself uses Small String Optimization.</span></div>
<div class="line">my_any a = <a class="code" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a>(<span class="stringliteral">&quot;hello&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Type information and various optimizations</h2>
<p>Internally, <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> uses a tagged pointer to store 3 additional information on the held type object:</p><ul>
<li>Tells if the type is relocatable (<a class="el" href="structseq_1_1is__relocatable.html#a9bc3104d310961a601c2185957f846ad">seq::is_relocatable&lt;Type&gt;::value</a> == true)</li>
<li>Tells if the type is trivially copyable (std::is_trivially_copyable&lt;Type&gt;::value == true)</li>
<li>Tells if the type is trivially destructible (std::is_trivially_destructible&lt;Type&gt;::value == true)</li>
</ul>
<p>These information are used to optimize the copy, move assignment and destruction of <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> objects.</p>
<p>Note that <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> itself is NOT relocatable as it might hold a non relocatable type inside its small buffer.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Move only types</h2>
<p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> supports holding move only types like std::unique_ptr. In this case, the <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> will silently become a move only object, and trying to copy the <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> object will throw a std::bad_function_call exception. Likewise, the <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> can only be casted to a reference to this type.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// create any from unique_ptr</span></div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> a = std::unique_ptr&lt;int&gt;(<span class="keyword">new</span> <span class="keywordtype">int</span>(3));</div>
<div class="line"><span class="comment">// retrieve a reference to the unique_ptr</span></div>
<div class="line">std::unique_ptr&lt;int&gt;&amp; val1 = a.cast&lt; std::unique_ptr&lt;int&gt;&amp;&gt;();</div>
<div class="line">std::cout &lt;&lt; *val1 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// move any object</span></div>
<div class="line"><a class="code" href="classseq_1_1hold__any.html">seq::any</a> b = std::move(a);</div>
<div class="line">std::unique_ptr&lt;int&gt;&amp; val2 = b.cast&lt; std::unique_ptr&lt;int&gt;&amp;&gt;();</div>
<div class="line">std::cout &lt;&lt; *val2 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// try to copy: throw std::bad_function_call as copy operator is disabled for unique_ptr</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <a class="code" href="classseq_1_1hold__any.html">seq::any</a> c = b;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> std::bad_function_call&amp;)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;cannot copy any object containing a unique_ptr&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Extending hold_any interface</h2>
<p><a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> interface is easily extendable to provide additional members or modify its standard behavior.</p>
<p>Below is an example of extension that adds the info() member returning a std::type_info object and modify the hash function:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a new interface for hold_any</span></div>
<div class="line"><span class="keyword">struct </span>NewInterface</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// The base type info class, must inherit seq::any_type_info virtually</span></div>
<div class="line">    <span class="keyword">struct </span>type_info : <span class="keyword">virtual</span> <a class="code" href="classseq_1_1any__type__info.html">any_type_info</a></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keyword">const</span> std::type_info&amp; info() <span class="keyword">const</span> = 0;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Concrete implementation for given type, must inherit type_info and any_typed_type_info&lt;T&gt; (for base implementation of common functions)</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    <span class="keyword">struct </span>typed_type_info : type_info, <a class="code" href="structseq_1_1any__typed__type__info.html">any_typed_type_info</a>&lt;T&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implementation of additional info() member</span></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keyword">const</span> std::type_info&amp; info()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">typeid</span>(<a class="code" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T</a>); }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// new implementation for the hash function based on the old one</span></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceseq_1_1detail.html#a280597fb66785a68b9b92e1f19bccf04">hash_any</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* in)<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="structseq_1_1any__typed__type__info.html">any_typed_type_info&lt;T&gt;</a>{}.<a class="code" href="structseq_1_1any__typed__type__info.html#a22b7544c534b15f5877b6e3756819009">hash_any</a>(in)* UINT64_C(0xc4ceb9fe1a85ec53);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Extended interface to seq::hold_any</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Base&gt;</div>
<div class="line">    <span class="keyword">struct </span>any_interface : Base</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//add function to hold_any interface</span></div>
<div class="line">        <span class="keyword">const</span> std::type_info&amp; info()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;type()-&gt;info(); }</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> my_any = <a class="code" href="classseq_1_1hold__any.html">hold_any&lt; NewInterface&gt;</a>;</div>
<div class="line"> </div>
<div class="line">my_any a  = 2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// print the type name</span></div>
<div class="line">std::cout&lt;&lt; a.info().name() &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// print the hash value</span></div>
<div class="line">std::cout&lt;&lt; a.hash() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Below is a more complex example that transform <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> into a std::function equivalent:</p>
<div class="fragment"><div class="line"><span class="comment">// for std::plus and std::multiplies (C++14)</span></div>
<div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="any_8hpp.html">any.hpp</a>&quot;</span></div>
<div class="line"><span class="comment">// for seq::is_invocable</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="type__traits_8hpp.html">type_traits.hpp</a>&quot;</span></div>
<div class="line"><span class="comment">// for seq::constexpr_if</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="utils_8hpp.html">utils.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceseq.html">seq</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Fun&gt;</div>
<div class="line">    <span class="keyword">struct </span>FunInterface;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Provide custom interface to hold_any in order to be callable like std::function</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class </span>R, <span class="keyword">class</span>... As&gt;</div>
<div class="line">    <span class="keyword">struct </span>FunInterface&lt; R(As...)&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The base type info class, must inherit seq::any_type_info virtually.</span></div>
<div class="line">        <span class="keyword">struct </span>type_info : <span class="keyword">virtual</span> any_type_info</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Add virtual members() call and target_type()</span></div>
<div class="line">            <span class="keyword">virtual</span> R call(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, As... as) <span class="keyword">const</span> = 0;</div>
<div class="line">            <span class="keyword">virtual</span> <span class="keyword">const</span> std::type_info&amp; target_type() <span class="keyword">const</span> = 0;</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Concrete implementation for given type, must inherit type_info and any_typed_type_info&lt;T&gt; (for base implementation of common functions)</span></div>
<div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">        <span class="keyword">struct </span>typed_type_info : type_info, any_typed_type_info&lt;T, false&gt; <span class="comment">//disable hashing support</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">virtual</span> R call(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, As... as)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">            </span>{</div>
<div class="line">                <span class="comment">// C++11 emulation of if constexpr</span></div>
<div class="line">                <span class="comment">// Make sure that this interface is still suitable for non invocable types</span></div>
<div class="line">                <span class="keywordflow">return</span> <a class="code" href="namespaceseq.html#a60b1a14cbf28e77e92a346892ef8531c">constexpr_if</a>&lt;is_invocable&lt;<a class="code" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T</a>, As ...&gt;::value&gt;(</div>
<div class="line">                    [&amp;as...](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fun) {<span class="keywordflow">return</span> fun(std::forward&lt;As&gt;(as)...); },</div>
<div class="line">                    [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp;) {<span class="keywordflow">throw</span> std::bad_function_call(); <span class="keywordflow">return</span> R(); },</div>
<div class="line">                    * <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T</a>*<span class="keyword">&gt;</span>(data));</div>
<div class="line">            }</div>
<div class="line">            <span class="keyword">virtual</span> <span class="keyword">const</span> std::type_info&amp; target_type()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">            </span>{</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">typeid</span>(<a class="code" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T</a>);</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Extended interface to seq::hold_any</span></div>
<div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Base&gt;</div>
<div class="line">        <span class="keyword">struct </span>any_interface : Base</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//add operator() to hold_any interface</span></div>
<div class="line">            R operator()(As... as)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">            </span>{</div>
<div class="line">                <span class="keywordflow">if</span> (this-&gt;empty())</div>
<div class="line">                    <span class="keywordflow">throw</span> std::bad_function_call();</div>
<div class="line">                <span class="keywordflow">return</span> this-&gt;type()-&gt;call(this-&gt;data(), std::forward&lt;As&gt;(as)...);</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">//add member target_type() to hold_any interface</span></div>
<div class="line">            <span class="keyword">const</span> std::type_info&amp; target_type()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">            </span>{</div>
<div class="line">                <span class="keywordflow">return</span> this-&gt;empty() ? <span class="keyword">typeid</span>(void) : this-&gt;type()-&gt;target_type();</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define the seq::function type</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Signature&gt;</div>
<div class="line">    <span class="keyword">using</span> <span class="keyword">function</span> = hold_any&lt; FunInterface&lt; Signature&gt; &gt;;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// dumy function </span></div>
<div class="line"><span class="keywordtype">int</span> divide(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {<span class="keywordflow">return</span> a / b;}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// usage</span></div>
<div class="line"> </div>
<div class="line">seq::function&lt;int(<span class="keywordtype">int</span>,<span class="keywordtype">int</span>)&gt; plus_fun = std::plus&lt;int&gt;{};                    <span class="comment">// affect functor</span></div>
<div class="line">seq::function&lt;int(<span class="keywordtype">int</span>,<span class="keywordtype">int</span>)&gt; minus_fun = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b){<span class="keywordflow">return</span> a - b;} ;   <span class="comment">// affect lambda</span></div>
<div class="line">seq::function&lt;int(<span class="keywordtype">int</span>,<span class="keywordtype">int</span>)&gt; multiplies_fun = std::multiplies&lt;int&gt;{};        <span class="comment">// affect functor</span></div>
<div class="line">seq::function&lt;int(<span class="keywordtype">int</span>,<span class="keywordtype">int</span>)&gt; divide_fun = divide;                            <span class="comment">// affect function</span></div>
<div class="line"> </div>
<div class="line">assert( plus_fun(1,2) == 3);</div>
<div class="line">assert( minus_fun(2,1) == 1);</div>
<div class="line">assert( multiplies_fun(2,3) == 6);</div>
<div class="line">assert( divide_fun(9,3) == 3);</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af66e74bcdac095ab46f55bdd9419bb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66e74bcdac095ab46f55bdd9419bb34">&#9670;&nbsp;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::<a class="el" href="classseq_1_1hold__any.html#af66e74bcdac095ab46f55bdd9419bb34">base_type</a> =  typename Interface::template any_interface&lt; <a class="el" href="structseq_1_1any__base.html">any_base</a> &lt;<a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;Interface, StaticSize, Alignment&gt;, typename Interface::type_info, StaticSize, Alignment&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base public type. </p>

</div>
</div>
<a id="a23d29fc7c99e55af995fa4de7596c5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d29fc7c99e55af995fa4de7596c5c3">&#9670;&nbsp;</a></span>type_info_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::<a class="el" href="classseq_1_1hold__any.html#a23d29fc7c99e55af995fa4de7596c5c3">type_info_type</a> =  typename Interface::type_info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type info as returned by type() </p>

</div>
</div>
<a id="abdcce1fa954bad763a29b08b8db95bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcce1fa954bad763a29b08b8db95bf3">&#9670;&nbsp;</a></span>typed_type_info_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::<a class="el" href="classseq_1_1hold__any.html#abdcce1fa954bad763a29b08b8db95bf3">typed_type_info_type</a> =  typename Interface::template typed_type_info&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actual implementation of type info. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab6504e84038886576e6b9bfe772b24af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6504e84038886576e6b9bfe772b24af">&#9670;&nbsp;</a></span>hold_any() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::<a class="el" href="classseq_1_1hold__any.html">hold_any</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default ctor. </p>

</div>
</div>
<a id="a1b270bf34f7dc79b210aaafd46641bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b270bf34f7dc79b210aaafd46641bb1">&#9670;&nbsp;</a></span>hold_any() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::<a class="el" href="classseq_1_1hold__any.html">hold_any</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor Might throw std::bad_function_call if underlying type is not copy constructible (for instance std::unique_ptr) </p>

</div>
</div>
<a id="ac587e55fd6491bee3a704491ae45b0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac587e55fd6491bee3a704491ae45b0d8">&#9670;&nbsp;</a></span>hold_any() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::<a class="el" href="classseq_1_1hold__any.html">hold_any</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor Move constructor is NOT noexcept as <a class="el" href="namespaceseq_1_1detail.html#aadadc42324010b84a6053c3491490dea">move_any()</a> might throw. </p>

</div>
</div>
<a id="a143cd5f15f6a232497f79d40a47c0db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143cd5f15f6a232497f79d40a47c0db4">&#9670;&nbsp;</a></span>hold_any() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<div class="memtemplate">
template&lt;class T , class  = typename std::enable_if&lt; !std::is_base_of&lt;detail::null_policy, typename std::decay&lt;T&gt;::type&gt;::value, void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::<a class="el" href="classseq_1_1hold__any.html">hold_any</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from any object except another <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a>. </p>

</div>
</div>
<a id="a82b9694ee008b29d32572a2392610fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b9694ee008b29d32572a2392610fd0">&#9670;&nbsp;</a></span>~hold_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::~<a class="el" href="classseq_1_1hold__any.html">hold_any</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a87143783cbfba43b22bf57d033246e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87143783cbfba43b22bf57d033246e34">&#9670;&nbsp;</a></span>emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; typename std::decay&lt;ValueType&gt;::type &amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace construction. </p>

</div>
</div>
<a id="a200afdd399e8169666eb47c85d60b16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200afdd399e8169666eb47c85d60b16f">&#9670;&nbsp;</a></span>emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class U , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::decay&lt;ValueType&gt;::type&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace construction. </p>

</div>
</div>
<a id="abbeed042b82bc91b7b75dfc50064676a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbeed042b82bc91b7b75dfc50064676a">&#9670;&nbsp;</a></span>equal_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::equal_to </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if underlying object is equal to other. </p>

</div>
</div>
<a id="a91e38de782f33532cef590a05661f9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e38de782f33532cef590a05661f9e3">&#9670;&nbsp;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1hold__any.html#a23d29fc7c99e55af995fa4de7596c5c3">type_info_type</a>* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type info for given type. </p>

</div>
</div>
<a id="a309289b8f08a2a8c3e587a07e35d1b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309289b8f08a2a8c3e587a07e35d1b15">&#9670;&nbsp;</a></span>greater_than()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::greater_than </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if underlying object compares greater than other. </p>

</div>
</div>
<a id="ac8439dbae538c9724f1e3b3ba644708f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8439dbae538c9724f1e3b3ba644708f">&#9670;&nbsp;</a></span>has_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::has_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> holds an object. </p>

</div>
</div>
<a id="a25cb6f241bd0cd9e29961b8ba4d8d6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cb6f241bd0cd9e29961b8ba4d8d6bd">&#9670;&nbsp;</a></span>less_than()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::less_than </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if underlying object compares less than other. </p>

</div>
</div>
<a id="a635579e9906f4b4f1401c5b68a3b7efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635579e9906f4b4f1401c5b68a3b7efb">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit conversion to bool. </p>

</div>
</div>
<a id="a583e9d4e8516b29d396e5d337609b45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583e9d4e8516b29d396e5d337609b45e">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8b3ecb9f35ee664e2ca3545b6e48328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b3ecb9f35ee664e2ca3545b6e48328">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af67323dc05989bdb7ff530ddd6606325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67323dc05989bdb7ff530ddd6606325">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ee20937ac7a67a9565e247149490c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee20937ac7a67a9565e247149490c44">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment. </p>

</div>
</div>
<a id="a4000383b6d465a3007602dbbace207aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4000383b6d465a3007602dbbace207aa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&amp;
  		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment, MIGHT THROW! </p>

</div>
</div>
<a id="af674e3f02ac5c0605e52601d7d333c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af674e3f02ac5c0605e52601d7d333c1a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<div class="memtemplate">
template&lt;class T , class  = typename std::enable_if&lt; !std::is_base_of&lt;detail::null_policy, typename std::decay&lt;T&gt;::type&gt;::value, void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign any kind of object except a <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a>. </p>

</div>
</div>
<a id="af042372b1ab3f7b22a58011909eeb3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af042372b1ab3f7b22a58011909eeb3ef">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>

</div>
</div>
<a id="aa87a957815734e8e534660a9c212f0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87a957815734e8e534660a9c212f0b6">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb748c5632f96736d9f0707dd47e9f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb748c5632f96736d9f0707dd47e9f67">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af968dafb946e95314e8e223888b0a59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af968dafb946e95314e8e223888b0a59c">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> by destroying underlying object (if any) and deallocating the storage (if any) </p>

</div>
</div>
<a id="ae602f9129adf5742ce96a050a82d081e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae602f9129adf5742ce96a050a82d081e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, StaticSize, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap content with another <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a>. Swap cannot be noexcept as there is no guarantee that move assignment of underlying types are noexcept. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a835540e3ff0854680297ae3531152992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835540e3ff0854680297ae3531152992">&#9670;&nbsp;</a></span>static_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface  = any_default_interface, size_t StaticSize = sizeof(double), size_t Alignment = alignof(double)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classseq_1_1hold__any.html">seq::hold_any</a>&lt; Interface, StaticSize, Alignment &gt;::static_size = sizeof(hold_any::d_storage)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size for Small Buffer Optimization. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="any_8hpp_source.html">any.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassseq_1_1any__type__info_html"><div class="ttname"><a href="classseq_1_1any__type__info.html">seq::any_type_info</a></div><div class="ttdoc">Base class representing a type and related functions.</div><div class="ttdef"><b>Definition:</b> any.hpp:628</div></div>
<div class="ttc" id="atype__traits_8hpp_html"><div class="ttname"><a href="type__traits_8hpp.html">type_traits.hpp</a></div></div>
<div class="ttc" id="autils_8hpp_html"><div class="ttname"><a href="utils_8hpp.html">utils.hpp</a></div></div>
<div class="ttc" id="anamespaceseq_html_a8d9a01a2c5a12df6d4baac1d1520d4b5"><div class="ttname"><a href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">seq::tstring</a></div><div class="ttdeci">tiny_string&lt; 0, std::allocator&lt; char &gt; &gt; tstring</div><div class="ttdoc">Base string typedef, similar to std::string. Equivalent to tiny_string&lt;0, std::allocator&lt;char&gt;&gt;.</div><div class="ttdef"><b>Definition:</b> tiny_string.hpp:84</div></div>
<div class="ttc" id="anamespaceseq_html_a60b1a14cbf28e77e92a346892ef8531c"><div class="ttname"><a href="namespaceseq.html#a60b1a14cbf28e77e92a346892ef8531c">seq::constexpr_if</a></div><div class="ttdeci">auto constexpr_if(const L1 &amp;l1, const L2 &amp;l2, Args &amp;&amp;... args) -&gt; decltype(std::declval&lt; detail::CallLambda&lt; L1, L2, IsL1 &gt; &amp; &gt;()(std::declval&lt; L1 &amp; &gt;(), std::declval&lt; L2 &amp; &gt;(), std::declval&lt; Args &gt;()...))</div><div class="ttdoc">Simulation of C++17 if constexpr.</div><div class="ttdef"><b>Definition:</b> utils.hpp:264</div></div>
<div class="ttc" id="anamespaceseq_1_1detail_html_a280597fb66785a68b9b92e1f19bccf04"><div class="ttname"><a href="namespaceseq_1_1detail.html#a280597fb66785a68b9b92e1f19bccf04">seq::detail::hash_any</a></div><div class="ttdeci">SEQ_ALWAYS_INLINE auto hash_any(const void *in) -&gt; size_t</div><div class="ttdoc">Hash object using std::hash or throw std::bad_function_call.</div><div class="ttdef"><b>Definition:</b> any.hpp:502</div></div>
<div class="ttc" id="aclassseq_1_1ordered__set_html"><div class="ttname"><a href="classseq_1_1ordered__set.html">seq::ordered_set</a></div><div class="ttdoc">Associative container that contains a set of unique objects of type Key. Search, insertion,...</div><div class="ttdef"><b>Definition:</b> ordered_map.hpp:1143</div></div>
<div class="ttc" id="anamespaceseq_1_1detail_html_a84d714603751dddb280584583ccdd7e3"><div class="ttname"><a href="namespaceseq_1_1detail.html#a84d714603751dddb280584583ccdd7e3">seq::detail::str</a></div><div class="ttdeci">Integral int char Stream &amp; str</div><div class="ttdef"><b>Definition:</b> charconv.hpp:696</div></div>
<div class="ttc" id="anamespaceseq_html"><div class="ttname"><a href="namespaceseq.html">seq</a></div><div class="ttdef"><b>Definition:</b> any.hpp:58</div></div>
<div class="ttc" id="atiny__string_8hpp_html"><div class="ttname"><a href="tiny__string_8hpp.html">tiny_string.hpp</a></div></div>
<div class="ttc" id="astructseq_1_1any__typed__type__info_html"><div class="ttname"><a href="structseq_1_1any__typed__type__info.html">seq::any_typed_type_info</a></div><div class="ttdoc">Implementation of any_type_info for specific type (Type Erasure)</div><div class="ttdef"><b>Definition:</b> any.hpp:659</div></div>
<div class="ttc" id="aclassseq_1_1ordered__set_html_afbc6c320f13dbfe438907cac9a787f6c"><div class="ttname"><a href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c">seq::ordered_set::insert</a></div><div class="ttdeci">auto insert(const value_type &amp;value) -&gt; std::pair&lt; iterator, bool &gt;</div><div class="ttdoc">Inserts element into the container, if the container doesn't already contain an element with an equiv...</div><div class="ttdef"><b>Definition:</b> ordered_map.hpp:1511</div></div>
<div class="ttc" id="anamespaceseq_html_a21b27d9d28ab49b4e36657f9e95013c7"><div class="ttname"><a href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a></div><div class="ttdeci">auto fmt(Args &amp;&amp;... args) -&gt; typename detail::BuildFormat&lt; sizeof...(Args), void, Args... &gt;::return_type</div><div class="ttdef"><b>Definition:</b> format.hpp:2160</div></div>
<div class="ttc" id="aclassseq_1_1hold__any_html"><div class="ttname"><a href="classseq_1_1hold__any.html">seq::hold_any</a></div><div class="ttdoc">std::any like class optimized to build heterogeneous containers.</div><div class="ttdef"><b>Definition:</b> any.hpp:1573</div></div>
<div class="ttc" id="aclassseq_1_1tiny__string_html"><div class="ttname"><a href="classseq_1_1tiny__string.html">seq::tiny_string</a></div><div class="ttdoc">String class with a similar interface and requirements than std::string.</div><div class="ttdef"><b>Definition:</b> tiny_string.hpp:79</div></div>
<div class="ttc" id="astructseq_1_1any__typed__type__info_html_a22b7544c534b15f5877b6e3756819009"><div class="ttname"><a href="structseq_1_1any__typed__type__info.html#a22b7544c534b15f5877b6e3756819009">seq::any_typed_type_info::hash_any</a></div><div class="ttdeci">auto hash_any(const void *in) const -&gt; size_t</div><div class="ttdoc">Hash object of underlying type.</div><div class="ttdef"><b>Definition:</b> any.hpp:676</div></div>
<div class="ttc" id="anamespaceseq_html_a24ef193cef19271b9b18ce6c74fc5b54"><div class="ttname"><a href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">seq::any</a></div><div class="ttdeci">hold_any&lt;&gt; any</div><div class="ttdef"><b>Definition:</b> any.hpp:2344</div></div>
<div class="ttc" id="anamespaceseq_1_1detail_html_ad2ef3bc87521f2c064991225c99aeabf"><div class="ttname"><a href="namespaceseq_1_1detail.html#ad2ef3bc87521f2c064991225c99aeabf">seq::detail::val</a></div><div class="ttdeci">double val</div><div class="ttdef"><b>Definition:</b> charconv.hpp:294</div></div>
<div class="ttc" id="anamespaceseq_html_a2bede5ff16f5bb9f856b3b2d78303f69"><div class="ttname"><a href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">seq::tstring_view</a></div><div class="ttdeci">tiny_string&lt; 0, view_allocator &gt; tstring_view</div><div class="ttdoc">Base string view typedef, similar to std::string_view. Equivalent to tiny_string&lt;0,...</div><div class="ttdef"><b>Definition:</b> tiny_string.hpp:82</div></div>
<div class="ttc" id="anamespaceseq_1_1detail_html_ae4e48f51c85e7a3a935596cba71a7355"><div class="ttname"><a href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">seq::detail::T</a></div><div class="ttdeci">Stream &amp;str T</div><div class="ttdef"><b>Definition:</b> charconv.hpp:661</div></div>
<div class="ttc" id="anamespaceseq_html_a2ec98840dd82cf3a3207402caa66c73f"><div class="ttname"><a href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">seq::nh_any</a></div><div class="ttdeci">hold_any&lt; any_no_hash_interface &gt; nh_any</div><div class="ttdef"><b>Definition:</b> any.hpp:2345</div></div>
<div class="ttc" id="aany_8hpp_html"><div class="ttname"><a href="any_8hpp.html">any.hpp</a></div></div>
<div class="ttc" id="astructseq_1_1is__hashable_html"><div class="ttname"><a href="structseq_1_1is__hashable.html">seq::is_hashable</a></div><div class="ttdoc">Tells if given type is hashable with std::hash. True by default, optimistically assume that all types...</div><div class="ttdef"><b>Definition:</b> type_traits.hpp:199</div></div>
<div class="ttc" id="astructseq_1_1any__default__interface_html"><div class="ttname"><a href="structseq_1_1any__default__interface.html">seq::any_default_interface</a></div><div class="ttdoc">Default interface for hold_any.</div><div class="ttdef"><b>Definition:</b> any.hpp:1011</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1hold__any.html">hold_any</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
