<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceseq.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">seq Namespace Reference<div class="ingroups"><a class="el" href="group__bits.html">Bits: collection of functions for low level bits manipulation.</a> &#124; <a class="el" href="group__charconv.html">Charconv: arithmetic value convertion from/to string</a> &#124; <a class="el" href="group__containers.html">Containers: original STL-like containers</a> &#124; <a class="el" href="group__format.html">Format: Type safe formatting module</a> &#124; <a class="el" href="group__hash.html">Hash: small collection of hash utilities</a> &#124; <a class="el" href="group__lock.html">Lock: locking classes</a> &#124; <a class="el" href="group__memory.html">Memory: collection of tools for memory management</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceseq_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceseq_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in <em>value</em>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator class with custom alignment.  <a href="classseq_1_1aligned__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1aligned__allocator_3_01_t_00_01std_1_1allocator_3_01_t_01_4_00_01_align_01_4.html">aligned_allocator&lt; T, std::allocator&lt; T &gt;, Align &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__base.html">any_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base interface for <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> class.  <a href="structseq_1_1any__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__default__interface.html">any_default_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1any__type__info.html">any_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class representing a type and related functions.  <a href="classseq_1_1any__type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__typed__type__info.html">any_typed_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classseq_1_1any__type__info.html" title="Base class representing a type and related functions.">any_type_info</a> for specific type (Type Erasure)  <a href="structseq_1_1any__typed__type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1base__ostream__format.html">base_ostream_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for formatting objects.  <a href="structseq_1_1base__ostream__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1basic__input__stream.html">basic_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for input text streams.  <a href="classseq_1_1basic__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1basic__nullbuf.html">basic_nullbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1block__object__allocation.html">block_object_allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to MaxSize objects by step of BlockSize.  <a href="structseq_1_1block__object__allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1buffer__input__stream.html">buffer_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream working on a sequence of characters.  <a href="classseq_1_1buffer__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient random access iterator on a constant value.  <a href="classseq_1_1cvalue__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1deque.html">deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classseq_1_1deque.html" title="seq::deque is a std::deque like container implemented as a tiered-vector.">seq::deque</a> is a std::deque like container implemented as a tiered-vector.  <a href="classseq_1_1deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html">devector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-ending vector implementation which can be optimized for several use case.  <a href="classseq_1_1devector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1equal__to__t.html">equal_to_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transparent comparison functor, in case std::equal_to&lt;void&gt; is not available.  <a href="structseq_1_1equal__to__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1external__allocator.html">external_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stl conforming allocator wrapper using an external class to perform the allocation.  <a href="classseq_1_1external__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1file__input__stream.html">file_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream working on a FILE pointer.  <a href="classseq_1_1file__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__map.html">flat_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted associative container that contains key-value pairs with unique keys similar to boost::flat_map with faster insertion/deletion of single values  <a href="classseq_1_1flat__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multimap.html">flat_multimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted container similar to boost::flat_multimap with faster insertion/deletion of single values  <a href="classseq_1_1flat__multimap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values  <a href="classseq_1_1flat__multiset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html">flat_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted container similar to boost::flat_set with faster insertion/deletion of single values  <a href="classseq_1_1flat__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for <a class="el" href="namespaceseq.html#ad1f5c92eee4485b984df28c1ceb0f96a" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> functions, similar to std::from_chars_result.  <a href="structseq_1_1from__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1hash__t.html">hash_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transparent hash functor using std::hash&lt;T&gt;  <a href="structseq_1_1hash__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html">hold_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::any like class optimized to build heterogeneous containers.  <a href="classseq_1_1hold__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the return type of <a class="el" href="namespaceseq.html#a97e43145f833c1fb4c26fbc91e341564" title="Returns -v if v is signed, v otherwise.">seq::negate_if_signed</a> and <a class="el" href="namespaceseq.html#af7ecbace49a8c09bb7de9eac60a97f58" title="Returns absolute value of v.">seq::abs</a>.  <a href="structseq_1_1integer__abs__return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_011_01_4.html">integer_abs_return&lt; T, true, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_012_01_4.html">integer_abs_return&lt; T, true, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_014_01_4.html">integer_abs_return&lt; T, true, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_018_01_4.html">integer_abs_return&lt; T, true, 8 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__max.html">integer_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integer type maximum value at compile time.  <a href="structseq_1_1integer__max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__max_3_01_t_00_01false_01_4.html">integer_max&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__min.html">integer_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integer type minimum value at compile time.  <a href="structseq_1_1integer__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__min_3_01_t_00_01false_01_4.html">integer_min&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for integer to string conversion using <a class="el" href="namespaceseq.html#ad80e2e70627dd4598cda06a37b7767b6" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a>.  <a href="structseq_1_1integral__chars__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string.html">is_allocated_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a>, std::string, but not tstring_view.  <a href="structseq_1_1is__allocated__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string_3_01std_1_1string_01_4.html">is_allocated_string&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string_3_01tiny__string_3_01_s_00_01_al_01_4_01_4.html">is_allocated_string&lt; tiny_string&lt; S, Al &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string_3_01tstring__view_01_4.html">is_allocated_string&lt; tstring_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__equal__comparable.html">is_equal_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__formattable.html">is_formattable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string.html">is_generic_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect all possible string types (std::string, tstring, tstring_view, std::string_view, const char*, char*.  <a href="structseq_1_1is__generic__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01char_01_5_01_4.html">is_generic_string&lt; char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01const_01char_01_5_01_4.html">is_generic_string&lt; const char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01std_1_1string_01_4.html">is_generic_string&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01tiny__string_3_01_s_00_01_al_01_4_01_4.html">is_generic_string&lt; tiny_string&lt; S, Al &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view.html">is_generic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect generic string view: tstring_view, std::string_view, char*, const char*.  <a href="structseq_1_1is__generic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view_3_01char_01_5_01_4.html">is_generic_string_view&lt; char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view_3_01const_01char_01_5_01_4.html">is_generic_string_view&lt; const char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view_3_01tstring__view_01_4.html">is_generic_string_view&lt; tstring_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__hashable.html">is_hashable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__invocable.html">is_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__invocable__r.html">is_invocable_r</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__istreamable.html">is_istreamable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__less__comparable.html">is_less_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__object__pool.html">is_object_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__object__pool_3_01object__pool_3_01_t_00_01_allocator_00_01_align_00_01object__aa897b5fd959a84c29154e339081634cc.html">is_object_pool&lt; object_pool&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__ostreamable.html">is_ostreamable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__parallel__object__pool.html">is_parallel_object_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__parallel__object__pool_3_01parallel__object__pool_3_01_t_00_01_al_00_01_a_00_01_o_00_01_g_01_4_01_4.html">is_parallel_object_pool&lt; parallel_object_pool&lt; T, Al, A, O, G &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable.html">is_relocatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait telling if a class is relocatable or not.  <a href="structseq_1_1is__relocatable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01detail_1_1_store_bucket_3_01_t_00_01_allocator_00_01_value_compdf720ebec973c8da48b23df61e3cbc7a.html">is_relocatable&lt; detail::StoreBucket&lt; T, Allocator, ValueCompare, StoreBackValues, IsArithmetic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01devector_3_01_t_00_01_alloc_00_01_f_01_4_01_4.html">is_relocatable&lt; devector&lt; T, Alloc, F &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structseq_1_1is__relocatable.html" title="Type trait telling if a class is relocatable or not.">is_relocatable</a> for devector.  <a href="structseq_1_1is__relocatable_3_01devector_3_01_t_00_01_alloc_00_01_f_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01sequence_3_01_t_00_01_al_00_01_l_00_01_a_01_4_01_4.html">is_relocatable&lt; sequence&lt; T, Al, L, A &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structseq_1_1is__relocatable.html" title="Type trait telling if a class is relocatable or not.">is_relocatable</a> for sequence type.  <a href="structseq_1_1is__relocatable_3_01sequence_3_01_t_00_01_al_00_01_l_00_01_a_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1allocator_3_01_t_01_4_01_4.html">is_relocatable&lt; std::allocator&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1pair_3_01_t_00_01_v_01_4_01_4.html">is_relocatable&lt; std::pair&lt; T, V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1shared__ptr_3_01_t_01_4_01_4.html">is_relocatable&lt; std::shared_ptr&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1unique__ptr_3_01_t_00_01_d_01_4_01_4.html">is_relocatable&lt; std::unique_ptr&lt; T, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01tiny__string_3_01_s_00_01_alloc_01_4_01_4.html">is_relocatable&lt; tiny_string&lt; S, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01view__allocator_01_4.html">is_relocatable&lt; view_allocator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__string__view.html">is_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect tstring_view or std::string_view.  <a href="structseq_1_1is__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__string__view_3_01tstring__view_01_4.html">is_string_view&lt; tstring_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__tiny__string.html">is_tiny_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a>.  <a href="structseq_1_1is__tiny__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__tiny__string_3_01tiny__string_3_01_s_00_01_al_01_4_01_4.html">is_tiny_string&lt; tiny_string&lt; S, Al &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__unique__ptr.html">is_unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits std::true_type is T is of type std::unique_ptr&lt;...&gt;, false otherwise.  <a href="structseq_1_1is__unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__unique__ptr_3_01std_1_1unique__ptr_3_01_t_00_01_del_01_4_01_4.html">is_unique_ptr&lt; std::unique_ptr&lt; T, Del &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1linear__object__allocation.html">linear_object_allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to MaxSize objects by step of 1.  <a href="structseq_1_1linear__object__allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1null__format.html">null_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placehoder when reusing a formatting object.  <a href="structseq_1_1null__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1null__lock.html">null_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumy lock class that basically does nothing.  <a href="structseq_1_1null__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1numeric__format.html">numeric_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting options for arithmetic types.  <a href="classseq_1_1numeric__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__allocator.html">object_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stl conforming allocator based on an object pool class.  <a href="classseq_1_1object__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html">object_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object pool class used to allocate objects of type T.  <a href="classseq_1_1object__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1object__pool__stats.html">object_pool_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class gathering statistics for <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">seq::object_pool</a> or <a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool.">seq::parallel_object_pool</a>.  <a href="structseq_1_1object__pool__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__map.html">ordered_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.  <a href="classseq_1_1ordered__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.  <a href="classseq_1_1ordered__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format.html">ostream_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number and string formatting class.  <a href="classseq_1_1ostream__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format_3_01hold__any_3_01_interface_00_01_s_00_01_a_01_4_01_4.html">ostream_format&lt; hold_any&lt; Interface, S, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format_3_01ostream__format_3_01_t_01_4_01_4.html">ostream_format&lt; ostream_format&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class.">ostream_format</a>.  <a href="classseq_1_1ostream__format_3_01ostream__format_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free parallel object pool.  <a href="classseq_1_1parallel__object__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1pow__object__allocation.html">pow_object_allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to MaxSize objects using power of 2 steps.  <a href="structseq_1_1pow__object__allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1random__float__genertor.html">random_float_genertor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1read__write__mutex.html">read_write_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read-write mutex based on either <a class="el" href="classseq_1_1spinlock.html" title="Lightweight and fast spinlock implementation based on https://rigtorp.se/spinlock/.">seq::spinlock</a> class or <a class="el" href="classseq_1_1spin__mutex.html" title="Mutex-like class combining a spinlock and std::mutex.">seq::spin_mutex</a> class.  <a href="classseq_1_1read__write__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html">sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sequence is an ordered container supporting constant time insertion at both end and constant removal anywhere.  <a href="classseq_1_1sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1shared__ptr__allocation.html">shared_ptr_allocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1spin__mutex.html">spin_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex-like class combining a spinlock and std::mutex.  <a href="classseq_1_1spin__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1spinlock.html">spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight and fast spinlock implementation based on <a href="https://rigtorp.se/spinlock/">https://rigtorp.se/spinlock/</a>.  <a href="classseq_1_1spinlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1static__bit__scan__reverse.html">static_bit_scan_reverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1static__bit__scan__reverse_3_010_u_l_l_01_4.html">static_bit_scan_reverse&lt; 0ULL &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1static__bit__scan__reverse_3_011_01_4.html">static_bit_scan_reverse&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1std__input__stream.html">std_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream working on a std::istream.  <a href="classseq_1_1std__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tagged__pointer.html">tagged_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged pointer class.  <a href="classseq_1_1tagged__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tagged__pointer_3_01void_00_01_type_00_01_user_defined_alignment_01_4.html">tagged_pointer&lt; void, Type, UserDefinedAlignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String class with a similar interface and requirements than std::string.  <a href="classseq_1_1tiny__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html">tiny_string&lt; 0, view_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a> for string views. You should use the global typedef tstring_view equivalent to <a class="el" href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html" title="Specialization of tiny_string for string views. You should use the global typedef tstring_view equiva...">tiny_string&lt;0,view_allocator&gt;</a>. Provides a similar interface to std::string_view. See <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a> documentation for more details.  <a href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for <a class="el" href="namespaceseq.html#ad80e2e70627dd4598cda06a37b7767b6" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a> functions, similar to std::to_chars_result.  <a href="structseq_1_1to__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1unique__ptr__deleter.html">unique_ptr_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleter class for std::unique_ptr when used with #object_pool or #parallel_object_pool.  <a href="structseq_1_1unique__ptr__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1view__allocator.html">view_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type for tiny string view.  <a href="structseq_1_1view__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1width__format.html">width_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the width formatting for a any formatting object.  <a href="structseq_1_1width__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24ef193cef19271b9b18ce6c74fc5b54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">any</a> = <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;&gt;</td></tr>
<tr class="separator:a24ef193cef19271b9b18ce6c74fc5b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec98840dd82cf3a3207402caa66c73f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">nh_any</a> = <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; <a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a> &gt;</td></tr>
<tr class="separator:a2ec98840dd82cf3a3207402caa66c73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2b0aba572fc96bdcec68b500577b5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6d2b0aba572fc96bdcec68b500577b5b">max_align_t</a> = std::max_align_t</td></tr>
<tr class="separator:a6d2b0aba572fc96bdcec68b500577b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75714ebe7ef4833c3a3a641d3389e39"><td class="memItemLeft" align="right" valign="top">typedef struct timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad75714ebe7ef4833c3a3a641d3389e39">high_def_timer</a></td></tr>
<tr class="separator:ad75714ebe7ef4833c3a3a641d3389e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae795f8c3dab753bc7283f542671183d6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structseq_1_1basic__nullbuf.html">basic_nullbuf</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae795f8c3dab753bc7283f542671183d6">nullbuf</a></td></tr>
<tr class="separator:ae795f8c3dab753bc7283f542671183d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bede5ff16f5bb9f856b3b2d78303f69"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> = <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; 0, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a> &gt;</td></tr>
<tr class="memdesc:a2bede5ff16f5bb9f856b3b2d78303f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base string view typedef, similar to std::string_view. Equivalent to <a class="el" href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html" title="Specialization of tiny_string for string views. You should use the global typedef tstring_view equiva...">tiny_string&lt;0, view_allocator&gt;</a>.  <a href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">More...</a><br /></td></tr>
<tr class="separator:a2bede5ff16f5bb9f856b3b2d78303f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9a01a2c5a12df6d4baac1d1520d4b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a> = <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; 0, std::allocator&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:a8d9a01a2c5a12df6d4baac1d1520d4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base string typedef, similar to std::string. Equivalent to <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a>&lt;0, std::allocator&lt;char&gt;&gt;.  <a href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">More...</a><br /></td></tr>
<tr class="separator:a8d9a01a2c5a12df6d4baac1d1520d4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a19a45e1f866d73140819b9ea2280c682"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> { <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682af715ab801ec116cdbb4a7f7541e46166">scientific</a> = 0x8000000, 
<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682abfc5cfa7d975226254b5443690d9f918">fixed</a> = 0x10000000, 
<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">general</a> = scientific|fixed
 }</td></tr>
<tr class="memdesc:a19a45e1f866d73140819b9ea2280c682"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BitmaskType used to specify floating-point formatting for <a class="el" href="namespaceseq.html#ad80e2e70627dd4598cda06a37b7767b6" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a>. This is similar to std::chars_format, but without the hex value.  <a href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">More...</a><br /></td></tr>
<tr class="separator:a19a45e1f866d73140819b9ea2280c682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d7eb5b00b5c7e90602aaf0e8bd23e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">StreamState</a> { <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2adc676c349921535a50db525652b39774">Ok</a>, 
<a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d">EndOfFile</a>, 
<a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587">BadInputFormat</a>
 }</td></tr>
<tr class="memdesc:ac3d7eb5b00b5c7e90602aaf0e8bd23e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream object status for classes inheriting basic_input_stream.  <a href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">More...</a><br /></td></tr>
<tr class="separator:ac3d7eb5b00b5c7e90602aaf0e8bd23e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f4e48fbeeb8d86e75555957c4e270c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270c">DEVectorFlag</a> { <a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270ca3d03c9bf4b559787d1de5ac0f9a7882d">OptimizeForPushBack</a>, 
<a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270caeb903e97e2b97b410b477676babb2653">OptimizeForPushFront</a>, 
<a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270ca998ccc48808777ad90d4228cd8fb9e84">OptimizeForBothEnds</a>
 }</td></tr>
<tr class="memdesc:a04f4e48fbeeb8d86e75555957c4e270c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the devector is optimized for back insertion, front insertion or both.  <a href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270c">More...</a><br /></td></tr>
<tr class="separator:a04f4e48fbeeb8d86e75555957c4e270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e72bbc46786ab0a7095941c5d09045"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespaceseq.html#a20e72bbc46786ab0a7095941c5d09045ad00237c7a57ddcba9f768430524651f2">EnoughForSharedPtr</a> = INT_MAX, 
<a class="el" href="namespaceseq.html#a20e72bbc46786ab0a7095941c5d09045a668d551cd99226655e9e973b6d5be517">DefaultAlignment</a> = 0
 }</td></tr>
<tr class="memdesc:a20e72bbc46786ab0a7095941c5d09045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants used by #object_pool, #parallel_object_pool and #object_allocator.  <a href="namespaceseq.html#a20e72bbc46786ab0a7095941c5d09045">More...</a><br /></td></tr>
<tr class="separator:a20e72bbc46786ab0a7095941c5d09045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affae767f96f2af9924f7c6f3bdd4c72a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72a">TagPointerType</a> { <a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72aafb05ed7193c8b361ae6679027a774673">StackPointer</a>, 
<a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72aa818e87f4cf07c4dc2006b54dbd4939e0">HeapPointer</a>, 
<a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72aad297c23409b392745ce5f3024304a8e8">CustomAlignment</a>
 }</td></tr>
<tr class="separator:affae767f96f2af9924f7c6f3bdd4c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209c3fd2e66f43ecc90862f2ee5e3dd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5">LayoutManagement</a> { <a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5a83983acd78764ffa023da74a7360670e">OptimizeForSpeed</a>, 
<a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5a51407649077d79765e15397347a57432">OptimizeForMemory</a>
 }</td></tr>
<tr class="memdesc:a209c3fd2e66f43ecc90862f2ee5e3dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory Layout Management for containers like <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant removal ...">seq::sequence</a> or <a class="el" href="classseq_1_1deque.html" title="seq::deque is a std::deque like container implemented as a tiered-vector.">seq::deque</a>.  <a href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5">More...</a><br /></td></tr>
<tr class="separator:a209c3fd2e66f43ecc90862f2ee5e3dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae671e0f695cb6f085d8255e0de4d2281"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae671e0f695cb6f085d8255e0de4d2281"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">get_type_id</a> () noexcept</td></tr>
<tr class="memdesc:ae671e0f695cb6f085d8255e0de4d2281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type Id used by <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> as a unique type identifier.  <a href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">More...</a><br /></td></tr>
<tr class="separator:ae671e0f695cb6f085d8255e0de4d2281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3f0204724ddc1fdba5f789bf26ca7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9da3f0204724ddc1fdba5f789bf26ca7"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9da3f0204724ddc1fdba5f789bf26ca7">get_type_id&lt; char &gt;</a> () noexcept</td></tr>
<tr class="separator:a9da3f0204724ddc1fdba5f789bf26ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bdf469671f96daaeaeae76df1add29"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a86bdf469671f96daaeaeae76df1add29"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a86bdf469671f96daaeaeae76df1add29">get_type_id&lt; signed char &gt;</a> () noexcept</td></tr>
<tr class="separator:a86bdf469671f96daaeaeae76df1add29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e66bbdc6a3730d5e1e5773fd873bd8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a74e66bbdc6a3730d5e1e5773fd873bd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a74e66bbdc6a3730d5e1e5773fd873bd8">get_type_id&lt; short &gt;</a> () noexcept</td></tr>
<tr class="separator:a74e66bbdc6a3730d5e1e5773fd873bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5504596c7066d0670dbb27070fe4108f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5504596c7066d0670dbb27070fe4108f"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5504596c7066d0670dbb27070fe4108f">get_type_id&lt; int &gt;</a> () noexcept</td></tr>
<tr class="separator:a5504596c7066d0670dbb27070fe4108f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270f8f53256ccbe680de58e8b295935c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a270f8f53256ccbe680de58e8b295935c"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a270f8f53256ccbe680de58e8b295935c">get_type_id&lt; long &gt;</a> () noexcept</td></tr>
<tr class="separator:a270f8f53256ccbe680de58e8b295935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b12f8d796c5f68a531312d9013ca8d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac1b12f8d796c5f68a531312d9013ca8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac1b12f8d796c5f68a531312d9013ca8d">get_type_id&lt; long long &gt;</a> () noexcept</td></tr>
<tr class="separator:ac1b12f8d796c5f68a531312d9013ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7751f74007ee1da9d4c8fad04244aa"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5d7751f74007ee1da9d4c8fad04244aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5d7751f74007ee1da9d4c8fad04244aa">get_type_id&lt; unsigned char &gt;</a> () noexcept</td></tr>
<tr class="separator:a5d7751f74007ee1da9d4c8fad04244aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912a79946b016b195aaae872f3880531"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a912a79946b016b195aaae872f3880531"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a912a79946b016b195aaae872f3880531">get_type_id&lt; unsigned short &gt;</a> () noexcept</td></tr>
<tr class="separator:a912a79946b016b195aaae872f3880531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbda3cc28bfc463ad92655a81a7e8697"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afbda3cc28bfc463ad92655a81a7e8697"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afbda3cc28bfc463ad92655a81a7e8697">get_type_id&lt; unsigned int &gt;</a> () noexcept</td></tr>
<tr class="separator:afbda3cc28bfc463ad92655a81a7e8697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d29ec40b45132cad26a58ee35eafbc1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1d29ec40b45132cad26a58ee35eafbc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1d29ec40b45132cad26a58ee35eafbc1">get_type_id&lt; unsigned long &gt;</a> () noexcept</td></tr>
<tr class="separator:a1d29ec40b45132cad26a58ee35eafbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8d3115e942c7ee280db3a773f5b290"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4b8d3115e942c7ee280db3a773f5b290"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4b8d3115e942c7ee280db3a773f5b290">get_type_id&lt; unsigned long long &gt;</a> () noexcept</td></tr>
<tr class="separator:a4b8d3115e942c7ee280db3a773f5b290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af403a261d3b265e926d12e067cbf1b14"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af403a261d3b265e926d12e067cbf1b14"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af403a261d3b265e926d12e067cbf1b14">get_type_id&lt; float &gt;</a> () noexcept</td></tr>
<tr class="separator:af403a261d3b265e926d12e067cbf1b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287623ba796c4e37c9b4d210469a5848"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a287623ba796c4e37c9b4d210469a5848"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a287623ba796c4e37c9b4d210469a5848">get_type_id&lt; double &gt;</a> () noexcept</td></tr>
<tr class="separator:a287623ba796c4e37c9b4d210469a5848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b631b774d3ead5643468e96c3f75a1f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8b631b774d3ead5643468e96c3f75a1f"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8b631b774d3ead5643468e96c3f75a1f">get_type_id&lt; long double &gt;</a> () noexcept</td></tr>
<tr class="separator:a8b631b774d3ead5643468e96c3f75a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55463d520234699844e33b644e823021"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a55463d520234699844e33b644e823021"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a55463d520234699844e33b644e823021">get_type_id&lt; std::string &gt;</a> () noexcept</td></tr>
<tr class="separator:a55463d520234699844e33b644e823021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e35629061325fb26ea45ef1567584ba"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4e35629061325fb26ea45ef1567584ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4e35629061325fb26ea45ef1567584ba">get_type_id&lt; tstring &gt;</a> () noexcept</td></tr>
<tr class="separator:a4e35629061325fb26ea45ef1567584ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d958fc758855945fbb6e1c4c856aa72"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1d958fc758855945fbb6e1c4c856aa72"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1d958fc758855945fbb6e1c4c856aa72">get_type_id&lt; tstring_view &gt;</a> () noexcept</td></tr>
<tr class="separator:a1d958fc758855945fbb6e1c4c856aa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b299fb33498ab4f7ed6fbdd11ab656"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a22b299fb33498ab4f7ed6fbdd11ab656"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a22b299fb33498ab4f7ed6fbdd11ab656">get_type_id&lt; const char * &gt;</a> () noexcept</td></tr>
<tr class="separator:a22b299fb33498ab4f7ed6fbdd11ab656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402011b5f9276ddc9680bc0c2b19b1ac"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a402011b5f9276ddc9680bc0c2b19b1ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a402011b5f9276ddc9680bc0c2b19b1ac">get_type_id&lt; char * &gt;</a> () noexcept</td></tr>
<tr class="separator:a402011b5f9276ddc9680bc0c2b19b1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bccbbebeeee8688c45c1df3e9e7e6b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6bccbbebeeee8688c45c1df3e9e7e6b9">is_signed_integral_type</a> (int id) noexcept</td></tr>
<tr class="memdesc:a6bccbbebeeee8688c45c1df3e9e7e6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to a signed integral type.  <a href="namespaceseq.html#a6bccbbebeeee8688c45c1df3e9e7e6b9">More...</a><br /></td></tr>
<tr class="separator:a6bccbbebeeee8688c45c1df3e9e7e6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db7ee7492e17303be3048c114e4264f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9db7ee7492e17303be3048c114e4264f">is_unsigned_integral_type</a> (int id) noexcept</td></tr>
<tr class="memdesc:a9db7ee7492e17303be3048c114e4264f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to an unsigned integral type.  <a href="namespaceseq.html#a9db7ee7492e17303be3048c114e4264f">More...</a><br /></td></tr>
<tr class="separator:a9db7ee7492e17303be3048c114e4264f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b539a9956d133181c00c77994436bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac3b539a9956d133181c00c77994436bf">is_integral_type</a> (int id) noexcept</td></tr>
<tr class="memdesc:ac3b539a9956d133181c00c77994436bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to an integral type.  <a href="namespaceseq.html#ac3b539a9956d133181c00c77994436bf">More...</a><br /></td></tr>
<tr class="separator:ac3b539a9956d133181c00c77994436bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b388481b03b0e9394311721d0a775a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7b388481b03b0e9394311721d0a775a7">is_floating_point_type</a> (int id) noexcept</td></tr>
<tr class="memdesc:a7b388481b03b0e9394311721d0a775a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to a floating point type.  <a href="namespaceseq.html#a7b388481b03b0e9394311721d0a775a7">More...</a><br /></td></tr>
<tr class="separator:a7b388481b03b0e9394311721d0a775a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dcabc115ead85eb0b230c30e401d20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a03dcabc115ead85eb0b230c30e401d20">is_arithmetic_type</a> (int id) noexcept</td></tr>
<tr class="memdesc:a03dcabc115ead85eb0b230c30e401d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to an arithmetic type (floating point or integral)  <a href="namespaceseq.html#a03dcabc115ead85eb0b230c30e401d20">More...</a><br /></td></tr>
<tr class="separator:a03dcabc115ead85eb0b230c30e401d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f92caef2894b34d224402ac89c65a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9a0f92caef2894b34d224402ac89c65a">is_string_type</a> (int id) noexcept</td></tr>
<tr class="memdesc:a9a0f92caef2894b34d224402ac89c65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to a string type (std::string, tstring, tstring_view or const char*)  <a href="namespaceseq.html#a9a0f92caef2894b34d224402ac89c65a">More...</a><br /></td></tr>
<tr class="separator:a9a0f92caef2894b34d224402ac89c65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97851d71ded4c7928aabd76f4280d268"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a97851d71ded4c7928aabd76f4280d268"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a97851d71ded4c7928aabd76f4280d268">register_any_conversion</a> ()</td></tr>
<tr class="separator:a97851d71ded4c7928aabd76f4280d268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Fun &gt; </td></tr>
<tr class="memitem:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad7a515ea06834d35cedd4e4f9c4ba1b0">register_any_conversion</a> (Fun fun)</td></tr>
<tr class="separator:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab390e9bf772c9a88f9f48c5bd360d7ed">register_any_less_comparison</a> ()</td></tr>
<tr class="separator:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0810417829f24c04037720cfe1cc92"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Fun &gt; </td></tr>
<tr class="memitem:a0b0810417829f24c04037720cfe1cc92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0b0810417829f24c04037720cfe1cc92">register_any_less_comparison</a> (Fun fun)</td></tr>
<tr class="separator:a0b0810417829f24c04037720cfe1cc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb61336a531e99a11a888883a46d0f01"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:adb61336a531e99a11a888883a46d0f01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adb61336a531e99a11a888883a46d0f01">register_any_equal_comparison</a> ()</td></tr>
<tr class="separator:adb61336a531e99a11a888883a46d0f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa783de724c82de2264d98a3437294df"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Fun &gt; </td></tr>
<tr class="memitem:aaa783de724c82de2264d98a3437294df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aaa783de724c82de2264d98a3437294df">register_any_equal_comparison</a> (Fun fun)</td></tr>
<tr class="separator:aaa783de724c82de2264d98a3437294df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16afe94ff6844ae0e6a3a03b4aaca97"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:ab16afe94ff6844ae0e6a3a03b4aaca97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab16afe94ff6844ae0e6a3a03b4aaca97">operator==</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:ab16afe94ff6844ae0e6a3a03b4aaca97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754af04dbc50b9221ab643cb662472cc"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a754af04dbc50b9221ab643cb662472cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a754af04dbc50b9221ab643cb662472cc">operator==</a> (const T &amp;b, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a)</td></tr>
<tr class="separator:a754af04dbc50b9221ab643cb662472cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c63e362da26d374ed74adbcf3f6d27"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:ad0c63e362da26d374ed74adbcf3f6d27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad0c63e362da26d374ed74adbcf3f6d27">operator!=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:ad0c63e362da26d374ed74adbcf3f6d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee04bc042e8f3ab7de2fcd2043b83e7c"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:aee04bc042e8f3ab7de2fcd2043b83e7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aee04bc042e8f3ab7de2fcd2043b83e7c">operator!=</a> (const T &amp;b, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a)</td></tr>
<tr class="separator:aee04bc042e8f3ab7de2fcd2043b83e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7818cfce7c07b43a84c5cd16027c6e27"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a7818cfce7c07b43a84c5cd16027c6e27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7818cfce7c07b43a84c5cd16027c6e27">operator&lt;</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a7818cfce7c07b43a84c5cd16027c6e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2d68d1bbe2979f2be27051a9190bc2"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:acd2d68d1bbe2979f2be27051a9190bc2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#acd2d68d1bbe2979f2be27051a9190bc2">operator&gt;</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:acd2d68d1bbe2979f2be27051a9190bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add444378c72974b32b72ab9740801e30"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:add444378c72974b32b72ab9740801e30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#add444378c72974b32b72ab9740801e30">operator&lt;=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:add444378c72974b32b72ab9740801e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af627534627450a46af42eae32dbac9d6"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:af627534627450a46af42eae32dbac9d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af627534627450a46af42eae32dbac9d6">operator&gt;=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:af627534627450a46af42eae32dbac9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684e5860e1daf02e4d92177ab58d7e47"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a684e5860e1daf02e4d92177ab58d7e47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a684e5860e1daf02e4d92177ab58d7e47">operator&lt;</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;b)</td></tr>
<tr class="separator:a684e5860e1daf02e4d92177ab58d7e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29745acf13b1dd0c436e7fb11d39ddad"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a29745acf13b1dd0c436e7fb11d39ddad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a29745acf13b1dd0c436e7fb11d39ddad">operator&gt;</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;b)</td></tr>
<tr class="separator:a29745acf13b1dd0c436e7fb11d39ddad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecee5def0e45356420fe839d4492d515"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:aecee5def0e45356420fe839d4492d515"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aecee5def0e45356420fe839d4492d515">operator&lt;=</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;b)</td></tr>
<tr class="separator:aecee5def0e45356420fe839d4492d515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400d2d1d88be73ebe1ad7548c7242ee4"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a400d2d1d88be73ebe1ad7548c7242ee4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a400d2d1d88be73ebe1ad7548c7242ee4">operator&gt;=</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;b)</td></tr>
<tr class="separator:a400d2d1d88be73ebe1ad7548c7242ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d82e80de97f55662208a343727653f"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:a48d82e80de97f55662208a343727653f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a48d82e80de97f55662208a343727653f">operator&lt;&lt;</a> (std::ostream &amp;oss, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a)</td></tr>
<tr class="separator:a48d82e80de97f55662208a343727653f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368335418326de8bb38c9fba7642c027"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:a368335418326de8bb38c9fba7642c027"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a368335418326de8bb38c9fba7642c027">operator&gt;&gt;</a> (std::istream &amp;iss, <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a)</td></tr>
<tr class="separator:a368335418326de8bb38c9fba7642c027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b963eb589bb722310da16e78278c62e"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:a6b963eb589bb722310da16e78278c62e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6b963eb589bb722310da16e78278c62e">any_cast</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;operand)</td></tr>
<tr class="separator:a6b963eb589bb722310da16e78278c62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accce8085ad2ebc8f3a73a876be03650c"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:accce8085ad2ebc8f3a73a876be03650c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#accce8085ad2ebc8f3a73a876be03650c">any_cast</a> (<a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;operand)</td></tr>
<tr class="separator:accce8085ad2ebc8f3a73a876be03650c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd7538cfa09fb8edf2f4fee4bdb6d8e"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:aacd7538cfa09fb8edf2f4fee4bdb6d8e"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aacd7538cfa09fb8edf2f4fee4bdb6d8e">any_cast</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; *operand) noexcept</td></tr>
<tr class="separator:aacd7538cfa09fb8edf2f4fee4bdb6d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7e59237b8c383ec6b7eb422e20ef6e"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:adf7e59237b8c383ec6b7eb422e20ef6e"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adf7e59237b8c383ec6b7eb422e20ef6e">any_cast</a> (<a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; *operand) noexcept</td></tr>
<tr class="separator:adf7e59237b8c383ec6b7eb422e20ef6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413a264358b2b20fcf4388023a0e1f8d"><td class="memTemplParams" colspan="2">template&lt;class Any , class T , class... Args&gt; </td></tr>
<tr class="memitem:a413a264358b2b20fcf4388023a0e1f8d"><td class="memTemplItemLeft" align="right" valign="top">Any&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a413a264358b2b20fcf4388023a0e1f8d">make_any</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a413a264358b2b20fcf4388023a0e1f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa604c9a7d58c994a56ff6e0ce62e7bd7"><td class="memTemplParams" colspan="2">template&lt;class Any , class T , class U , class... Args&gt; </td></tr>
<tr class="memitem:aa604c9a7d58c994a56ff6e0ce62e7bd7"><td class="memTemplItemLeft" align="right" valign="top">Any&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa604c9a7d58c994a56ff6e0ce62e7bd7">make_any</a> (std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args)</td></tr>
<tr class="separator:aa604c9a7d58c994a56ff6e0ce62e7bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83ce9b88f61a6d39bc6505b04ec6f6e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad83ce9b88f61a6d39bc6505b04ec6f6e">aligned_malloc</a> (size_t size, size_t align)</td></tr>
<tr class="memdesc:ad83ce9b88f61a6d39bc6505b04ec6f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates <em>size</em> bytes. The returned pointer is guaranteed to have <em>align</em> bytes alignment.  <a href="namespaceseq.html#ad83ce9b88f61a6d39bc6505b04ec6f6e">More...</a><br /></td></tr>
<tr class="separator:ad83ce9b88f61a6d39bc6505b04ec6f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04be1ca38e79158feb4755807ef3d08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a04be1ca38e79158feb4755807ef3d08c">aligned_free</a> (void *ptr)</td></tr>
<tr class="memdesc:a04be1ca38e79158feb4755807ef3d08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with aligned_malloc.  <a href="namespaceseq.html#a04be1ca38e79158feb4755807ef3d08c">More...</a><br /></td></tr>
<tr class="separator:a04be1ca38e79158feb4755807ef3d08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93474d742382c06825212a479a720fcb"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a93474d742382c06825212a479a720fcb">popcnt64</a> (std::uint64_t x)</td></tr>
<tr class="separator:a93474d742382c06825212a479a720fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad7cd23d956c6e3205dd20ff1629b3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a08ad7cd23d956c6e3205dd20ff1629b3">popcnt32</a> (uint32_t x)</td></tr>
<tr class="separator:a08ad7cd23d956c6e3205dd20ff1629b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac360f9661dc5c8b69336408b4a96259a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac360f9661dc5c8b69336408b4a96259a">popcnt8</a> (unsigned char value)</td></tr>
<tr class="separator:ac360f9661dc5c8b69336408b4a96259a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9f083253d23d9c760804a87995efe2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2e9f083253d23d9c760804a87995efe2">popcnt16</a> (unsigned short value)</td></tr>
<tr class="separator:a2e9f083253d23d9c760804a87995efe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4aa3fe9c20f97f4f5af93dfa190bbad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae4aa3fe9c20f97f4f5af93dfa190bbad">bit_scan_forward_8</a> (std::uint8_t val)</td></tr>
<tr class="separator:ae4aa3fe9c20f97f4f5af93dfa190bbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4922210860b6f327b5fb7a5138882236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4922210860b6f327b5fb7a5138882236">bit_scan_reverse_8</a> (std::uint8_t val)</td></tr>
<tr class="separator:a4922210860b6f327b5fb7a5138882236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ae84cf43b3822a03c04a4e0762813a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a62ae84cf43b3822a03c04a4e0762813a">bit_scan_forward_32</a> (std::uint32_t val)</td></tr>
<tr class="memdesc:a62ae84cf43b3822a03c04a4e0762813a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest set bit index in <em>val</em> Undefined if val==0.  <a href="namespaceseq.html#a62ae84cf43b3822a03c04a4e0762813a">More...</a><br /></td></tr>
<tr class="separator:a62ae84cf43b3822a03c04a4e0762813a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5a4ec0a40a8275833a0fe25b4dfb23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aab5a4ec0a40a8275833a0fe25b4dfb23">bit_scan_reverse_32</a> (std::uint32_t val)</td></tr>
<tr class="memdesc:aab5a4ec0a40a8275833a0fe25b4dfb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest set bit index in <em>val</em> Undefined if val==0.  <a href="namespaceseq.html#aab5a4ec0a40a8275833a0fe25b4dfb23">More...</a><br /></td></tr>
<tr class="separator:aab5a4ec0a40a8275833a0fe25b4dfb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55187c5046afdf617db98cf0a27f9320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a55187c5046afdf617db98cf0a27f9320">bit_scan_forward_64</a> (std::uint64_t bb) noexcept</td></tr>
<tr class="memdesc:a55187c5046afdf617db98cf0a27f9320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest set bit index in <em>bb</em>. Developed by Kim Walisch (2012). Undefined if bb==0.  <a href="namespaceseq.html#a55187c5046afdf617db98cf0a27f9320">More...</a><br /></td></tr>
<tr class="separator:a55187c5046afdf617db98cf0a27f9320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a7d54aa37d26276cef0ea1ca0a1fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab6a7d54aa37d26276cef0ea1ca0a1fe1">bit_scan_reverse_64</a> (std::uint64_t bb) noexcept</td></tr>
<tr class="memdesc:ab6a7d54aa37d26276cef0ea1ca0a1fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest set bit index in <em>bb</em>. Developed by Kim Walisch, Mark Dickinson. Undefined if bb==0.  <a href="namespaceseq.html#ab6a7d54aa37d26276cef0ea1ca0a1fe1">More...</a><br /></td></tr>
<tr class="separator:ab6a7d54aa37d26276cef0ea1ca0a1fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80de2782447e04cfb1d873736761c04c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a80de2782447e04cfb1d873736761c04c">bit_scan_forward</a> (size_t bb) noexcept</td></tr>
<tr class="memdesc:a80de2782447e04cfb1d873736761c04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest set bit index in <em>bb</em>. Undefined if bb==0.  <a href="namespaceseq.html#a80de2782447e04cfb1d873736761c04c">More...</a><br /></td></tr>
<tr class="separator:a80de2782447e04cfb1d873736761c04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e82ccd4ecac286fcbe78c84dc2bf793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7e82ccd4ecac286fcbe78c84dc2bf793">bit_scan_reverse</a> (size_t bb) noexcept</td></tr>
<tr class="memdesc:a7e82ccd4ecac286fcbe78c84dc2bf793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest set bit index in <em>bb</em>. Undefined if bb==0.  <a href="namespaceseq.html#a7e82ccd4ecac286fcbe78c84dc2bf793">More...</a><br /></td></tr>
<tr class="separator:a7e82ccd4ecac286fcbe78c84dc2bf793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595642727b17c09f8ed3f1902addb13b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a595642727b17c09f8ed3f1902addb13b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a595642727b17c09f8ed3f1902addb13b">count_digits_base_10</a> (T x)</td></tr>
<tr class="separator:a595642727b17c09f8ed3f1902addb13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f848adb0c9d3ac36fb1c523850748b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab2f848adb0c9d3ac36fb1c523850748b">nth_bit_set</a> (std::uint64_t x, unsigned n) noexcept</td></tr>
<tr class="separator:ab2f848adb0c9d3ac36fb1c523850748b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6611a655add0de38badee7fcad961c4b"><td class="memTemplParams" colspan="2">template&lt;size_t ConsecutiveNBits&gt; </td></tr>
<tr class="memitem:a6611a655add0de38badee7fcad961c4b"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6611a655add0de38badee7fcad961c4b">consecutive_N_bits</a> (size_t num)</td></tr>
<tr class="memdesc:a6611a655add0de38badee7fcad961c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first consecutive N bits within <em>num</em>.  <a href="namespaceseq.html#a6611a655add0de38badee7fcad961c4b">More...</a><br /></td></tr>
<tr class="separator:a6611a655add0de38badee7fcad961c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ea7e90ba548509579455f13905d240"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a43ea7e90ba548509579455f13905d240">bswap_16</a> (std::uint16_t value)</td></tr>
<tr class="separator:a43ea7e90ba548509579455f13905d240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b149fbd9ca094cb690819800c9f754e"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8b149fbd9ca094cb690819800c9f754e">bswap_32</a> (std::uint32_t value)</td></tr>
<tr class="separator:a8b149fbd9ca094cb690819800c9f754e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02968f707921c4060800cbfcd96956b"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad02968f707921c4060800cbfcd96956b">bswap_64</a> (std::uint64_t value)</td></tr>
<tr class="separator:ad02968f707921c4060800cbfcd96956b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa0f34c5b9efbaacd24ae215c6ebdfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8aa0f34c5b9efbaacd24ae215c6ebdfe">write_LE_16</a> (void *dst, std::uint16_t value)</td></tr>
<tr class="memdesc:a8aa0f34c5b9efbaacd24ae215c6ebdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 16 bits integer <em>value</em> to <em>dst</em> in little endian order.  <a href="namespaceseq.html#a8aa0f34c5b9efbaacd24ae215c6ebdfe">More...</a><br /></td></tr>
<tr class="separator:a8aa0f34c5b9efbaacd24ae215c6ebdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbce06d3b6c0dd24ef956b3bba564914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abbce06d3b6c0dd24ef956b3bba564914">write_LE_32</a> (void *dst, std::uint32_t value)</td></tr>
<tr class="memdesc:abbce06d3b6c0dd24ef956b3bba564914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32 bits integer <em>value</em> to <em>dst</em> in little endian order.  <a href="namespaceseq.html#abbce06d3b6c0dd24ef956b3bba564914">More...</a><br /></td></tr>
<tr class="separator:abbce06d3b6c0dd24ef956b3bba564914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd16ebc1860bdc316a5f83c8210a361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2dd16ebc1860bdc316a5f83c8210a361">write_LE_64</a> (void *dst, std::uint64_t value)</td></tr>
<tr class="memdesc:a2dd16ebc1860bdc316a5f83c8210a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 64 bits integer <em>value</em> to <em>dst</em> in little endian order.  <a href="namespaceseq.html#a2dd16ebc1860bdc316a5f83c8210a361">More...</a><br /></td></tr>
<tr class="separator:a2dd16ebc1860bdc316a5f83c8210a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61414f482d42dd1e59f8a558d76ff93"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af61414f482d42dd1e59f8a558d76ff93">read_LE_16</a> (const void *src)</td></tr>
<tr class="memdesc:af61414f482d42dd1e59f8a558d76ff93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 16 bits integer from <em>src</em> in little endian order.  <a href="namespaceseq.html#af61414f482d42dd1e59f8a558d76ff93">More...</a><br /></td></tr>
<tr class="separator:af61414f482d42dd1e59f8a558d76ff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3e5f6a4d449a97ac34349d47846aca"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1c3e5f6a4d449a97ac34349d47846aca">read_LE_32</a> (const void *src)</td></tr>
<tr class="memdesc:a1c3e5f6a4d449a97ac34349d47846aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32 bits integer from <em>src</em> in little endian order.  <a href="namespaceseq.html#a1c3e5f6a4d449a97ac34349d47846aca">More...</a><br /></td></tr>
<tr class="separator:a1c3e5f6a4d449a97ac34349d47846aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f80bab6226f672c5ede30f5cce325b4"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6f80bab6226f672c5ede30f5cce325b4">read_LE_64</a> (const void *src)</td></tr>
<tr class="memdesc:a6f80bab6226f672c5ede30f5cce325b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 64 bits integer from <em>src</em> in little endian order.  <a href="namespaceseq.html#a6f80bab6226f672c5ede30f5cce325b4">More...</a><br /></td></tr>
<tr class="separator:a6f80bab6226f672c5ede30f5cce325b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc979c02b15bd647641e83db0cdfd6c"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3dc979c02b15bd647641e83db0cdfd6c">read_16</a> (const void *src)</td></tr>
<tr class="memdesc:a3dc979c02b15bd647641e83db0cdfd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 16 bits integer from <em>src</em>.  <a href="namespaceseq.html#a3dc979c02b15bd647641e83db0cdfd6c">More...</a><br /></td></tr>
<tr class="separator:a3dc979c02b15bd647641e83db0cdfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd204b49f8889e867693b7804ad1377"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3fd204b49f8889e867693b7804ad1377">read_32</a> (const void *src)</td></tr>
<tr class="memdesc:a3fd204b49f8889e867693b7804ad1377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 32 bits integer from <em>src</em>.  <a href="namespaceseq.html#a3fd204b49f8889e867693b7804ad1377">More...</a><br /></td></tr>
<tr class="separator:a3fd204b49f8889e867693b7804ad1377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881c8b8e6500cbc8c9e6dc07b4651633"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a881c8b8e6500cbc8c9e6dc07b4651633">read_64</a> (const void *src)</td></tr>
<tr class="memdesc:a881c8b8e6500cbc8c9e6dc07b4651633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 64 bits integer from <em>src</em>.  <a href="namespaceseq.html#a881c8b8e6500cbc8c9e6dc07b4651633">More...</a><br /></td></tr>
<tr class="separator:a881c8b8e6500cbc8c9e6dc07b4651633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19d29d42a2dde5c53e17ba342ac7828"><td class="memItemLeft" align="right" valign="top">std::uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af19d29d42a2dde5c53e17ba342ac7828">read_ptr_t</a> (const void *src)</td></tr>
<tr class="memdesc:af19d29d42a2dde5c53e17ba342ac7828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads uintptr_t integer from <em>src</em>.  <a href="namespaceseq.html#af19d29d42a2dde5c53e17ba342ac7828">More...</a><br /></td></tr>
<tr class="separator:af19d29d42a2dde5c53e17ba342ac7828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3af9223b2fccb354d936f83997b13f4"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab3af9223b2fccb354d936f83997b13f4">read_BE_16</a> (const void *src)</td></tr>
<tr class="memdesc:ab3af9223b2fccb354d936f83997b13f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 16 bits integer from <em>src</em> in big endian order.  <a href="namespaceseq.html#ab3af9223b2fccb354d936f83997b13f4">More...</a><br /></td></tr>
<tr class="separator:ab3af9223b2fccb354d936f83997b13f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e3a29f545268e8a71e23dbd2da47d7"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad8e3a29f545268e8a71e23dbd2da47d7">read_BE_32</a> (const void *src)</td></tr>
<tr class="memdesc:ad8e3a29f545268e8a71e23dbd2da47d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 32 bits integer from <em>src</em> in big endian order.  <a href="namespaceseq.html#ad8e3a29f545268e8a71e23dbd2da47d7">More...</a><br /></td></tr>
<tr class="separator:ad8e3a29f545268e8a71e23dbd2da47d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82004ca023848af43c197128cfc598f1"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a82004ca023848af43c197128cfc598f1">read_BE_64</a> (const void *src)</td></tr>
<tr class="memdesc:a82004ca023848af43c197128cfc598f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 64 bits integer from <em>src</em> in big endian order.  <a href="namespaceseq.html#a82004ca023848af43c197128cfc598f1">More...</a><br /></td></tr>
<tr class="separator:a82004ca023848af43c197128cfc598f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234f60d7f588e4060eb0d094150cbd46"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a234f60d7f588e4060eb0d094150cbd46">read_size_t</a> (const void *src)</td></tr>
<tr class="memdesc:a234f60d7f588e4060eb0d094150cbd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads size_t object from <em>src</em>.  <a href="namespaceseq.html#a234f60d7f588e4060eb0d094150cbd46">More...</a><br /></td></tr>
<tr class="separator:a234f60d7f588e4060eb0d094150cbd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af540dfc5f9a344a81c4b1c3e1b7fcf95"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af540dfc5f9a344a81c4b1c3e1b7fcf95">read_LE_size_t</a> (const void *src)</td></tr>
<tr class="memdesc:af540dfc5f9a344a81c4b1c3e1b7fcf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads size_t object from <em>src</em> in little endian order.  <a href="namespaceseq.html#af540dfc5f9a344a81c4b1c3e1b7fcf95">More...</a><br /></td></tr>
<tr class="separator:af540dfc5f9a344a81c4b1c3e1b7fcf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3ee7edc45051b7185cbc127044752f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6d3ee7edc45051b7185cbc127044752f">read_BE_size_t</a> (const void *src)</td></tr>
<tr class="memdesc:a6d3ee7edc45051b7185cbc127044752f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads size_t object from <em>src</em> in big endian order.  <a href="namespaceseq.html#a6d3ee7edc45051b7185cbc127044752f">More...</a><br /></td></tr>
<tr class="separator:a6d3ee7edc45051b7185cbc127044752f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd14a20a2e7b03cebe3d48e3ae5e2ff"><td class="memTemplParams" colspan="2">template&lt;class Stream , class T &gt; </td></tr>
<tr class="memitem:a8dd14a20a2e7b03cebe3d48e3ae5e2ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8dd14a20a2e7b03cebe3d48e3ae5e2ff">from_stream</a> (Stream &amp;str, T &amp;value, int base=10)</td></tr>
<tr class="memdesc:a8dd14a20a2e7b03cebe3d48e3ae5e2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an integral value from a <a class="el" href="classseq_1_1basic__input__stream.html" title="Base class for input text streams.">seq::basic_input_stream</a> object.  <a href="namespaceseq.html#a8dd14a20a2e7b03cebe3d48e3ae5e2ff">More...</a><br /></td></tr>
<tr class="separator:a8dd14a20a2e7b03cebe3d48e3ae5e2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74a811757834955b06125e00c5deaed"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:ac74a811757834955b06125e00c5deaed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac74a811757834955b06125e00c5deaed">from_stream</a> (Stream &amp;str, float &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=chars_format::general, char dot='.')</td></tr>
<tr class="memdesc:ac74a811757834955b06125e00c5deaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from a #basic_input_stream object.  <a href="namespaceseq.html#ac74a811757834955b06125e00c5deaed">More...</a><br /></td></tr>
<tr class="separator:ac74a811757834955b06125e00c5deaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a68123ed035fdbc90e3a4dbe10c7017"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a9a68123ed035fdbc90e3a4dbe10c7017"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9a68123ed035fdbc90e3a4dbe10c7017">from_stream</a> (Stream &amp;str, double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=chars_format::general, char dot='.')</td></tr>
<tr class="memdesc:a9a68123ed035fdbc90e3a4dbe10c7017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from a #basic_input_stream object.  <a href="namespaceseq.html#a9a68123ed035fdbc90e3a4dbe10c7017">More...</a><br /></td></tr>
<tr class="separator:a9a68123ed035fdbc90e3a4dbe10c7017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e3d3b18077453a7de1a33feb7d438a"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:ab1e3d3b18077453a7de1a33feb7d438a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab1e3d3b18077453a7de1a33feb7d438a">from_stream</a> (Stream &amp;str, long double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=chars_format::general, char dot='.')</td></tr>
<tr class="memdesc:ab1e3d3b18077453a7de1a33feb7d438a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from a #basic_input_stream object.  <a href="namespaceseq.html#ab1e3d3b18077453a7de1a33feb7d438a">More...</a><br /></td></tr>
<tr class="separator:ab1e3d3b18077453a7de1a33feb7d438a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b8ae631903ebbe7b9a67a8cd5e1c2a"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a73b8ae631903ebbe7b9a67a8cd5e1c2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a73b8ae631903ebbe7b9a67a8cd5e1c2a">from_stream</a> (Stream &amp;str, std::string &amp;value)</td></tr>
<tr class="memdesc:a73b8ae631903ebbe7b9a67a8cd5e1c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a word from a #basic_input_stream object.  <a href="namespaceseq.html#a73b8ae631903ebbe7b9a67a8cd5e1c2a">More...</a><br /></td></tr>
<tr class="separator:a73b8ae631903ebbe7b9a67a8cd5e1c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff00103371136fa3e5dd96eb74a400bb"><td class="memTemplParams" colspan="2">template&lt;class Stream , size_t Ss, class Al &gt; </td></tr>
<tr class="memitem:aff00103371136fa3e5dd96eb74a400bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aff00103371136fa3e5dd96eb74a400bb">from_stream</a> (Stream &amp;str, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Ss, Al &gt; &amp;value)</td></tr>
<tr class="memdesc:aff00103371136fa3e5dd96eb74a400bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a word from a #basic_input_stream object.  <a href="namespaceseq.html#aff00103371136fa3e5dd96eb74a400bb">More...</a><br /></td></tr>
<tr class="separator:aff00103371136fa3e5dd96eb74a400bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe93dbc8ebf7707cd6a49a40efb69516"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:afe93dbc8ebf7707cd6a49a40efb69516"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afe93dbc8ebf7707cd6a49a40efb69516">read_line_from_stream</a> (Stream &amp;str, std::string &amp;value)</td></tr>
<tr class="memdesc:afe93dbc8ebf7707cd6a49a40efb69516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line from a #basic_input_stream object.  <a href="namespaceseq.html#afe93dbc8ebf7707cd6a49a40efb69516">More...</a><br /></td></tr>
<tr class="separator:afe93dbc8ebf7707cd6a49a40efb69516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c61bfb64e7882fc5018cad8cb51fd4"><td class="memTemplParams" colspan="2">template&lt;class Stream , size_t Ss, class Al &gt; </td></tr>
<tr class="memitem:a68c61bfb64e7882fc5018cad8cb51fd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a68c61bfb64e7882fc5018cad8cb51fd4">read_line_from_stream</a> (Stream &amp;str, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Ss, Al &gt; &amp;value)</td></tr>
<tr class="memdesc:a68c61bfb64e7882fc5018cad8cb51fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line from a #basic_input_stream object.  <a href="namespaceseq.html#a68c61bfb64e7882fc5018cad8cb51fd4">More...</a><br /></td></tr>
<tr class="separator:a68c61bfb64e7882fc5018cad8cb51fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f5c92eee4485b984df28c1ceb0f96a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1f5c92eee4485b984df28c1ceb0f96a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad1f5c92eee4485b984df28c1ceb0f96a">from_chars</a> (const char *first, const char *last, T &amp;value, int base=10)</td></tr>
<tr class="memdesc:ad1f5c92eee4485b984df28c1ceb0f96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an integral value from the sequence of characters [first,last).  <a href="namespaceseq.html#ad1f5c92eee4485b984df28c1ceb0f96a">More...</a><br /></td></tr>
<tr class="separator:ad1f5c92eee4485b984df28c1ceb0f96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6fa5dbb2342554b8e0229a2517c05e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aac6fa5dbb2342554b8e0229a2517c05e">from_chars</a> (const char *first, const char *last, float &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">general</a>, char dot='.')</td></tr>
<tr class="memdesc:aac6fa5dbb2342554b8e0229a2517c05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from the sequence of characters [first,last).  <a href="namespaceseq.html#aac6fa5dbb2342554b8e0229a2517c05e">More...</a><br /></td></tr>
<tr class="separator:aac6fa5dbb2342554b8e0229a2517c05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0294caef2f682aa43d45d96a74311dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0294caef2f682aa43d45d96a74311dba">from_chars</a> (const char *first, const char *last, double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">general</a>, char dot='.')</td></tr>
<tr class="memdesc:a0294caef2f682aa43d45d96a74311dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from the sequence of characters [first,last).  <a href="namespaceseq.html#a0294caef2f682aa43d45d96a74311dba">More...</a><br /></td></tr>
<tr class="separator:a0294caef2f682aa43d45d96a74311dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d671aafd486530c5efed00cf8da94ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3d671aafd486530c5efed00cf8da94ba">from_chars</a> (const char *first, const char *last, long double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">general</a>, char dot='.')</td></tr>
<tr class="memdesc:a3d671aafd486530c5efed00cf8da94ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from the sequence of characters [first,last).  <a href="namespaceseq.html#a3d671aafd486530c5efed00cf8da94ba">More...</a><br /></td></tr>
<tr class="separator:a3d671aafd486530c5efed00cf8da94ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80e2e70627dd4598cda06a37b7767b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad80e2e70627dd4598cda06a37b7767b6">to_chars</a> (char *first, char *last, char value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="memdesc:ad80e2e70627dd4598cda06a37b7767b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <a href="namespaceseq.html#ad80e2e70627dd4598cda06a37b7767b6">More...</a><br /></td></tr>
<tr class="separator:ad80e2e70627dd4598cda06a37b7767b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a70b9f25eca44e1a2d0a28b6fce9fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7a70b9f25eca44e1a2d0a28b6fce9fe9">to_chars</a> (char *first, char *last, signed char value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:a7a70b9f25eca44e1a2d0a28b6fce9fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc313ebf8c04e9029d7b04999f018a34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afc313ebf8c04e9029d7b04999f018a34">to_chars</a> (char *first, char *last, unsigned char value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:afc313ebf8c04e9029d7b04999f018a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37387ff734e6cbbd35d075ec4ce97361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a37387ff734e6cbbd35d075ec4ce97361">to_chars</a> (char *first, char *last, short value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:a37387ff734e6cbbd35d075ec4ce97361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c888bf0cbe7fd25536a699a803ce54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a78c888bf0cbe7fd25536a699a803ce54">to_chars</a> (char *first, char *last, unsigned short value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:a78c888bf0cbe7fd25536a699a803ce54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cc32ae6f827f4d47d630c2380391d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa8cc32ae6f827f4d47d630c2380391d7">to_chars</a> (char *first, char *last, int value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:aa8cc32ae6f827f4d47d630c2380391d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fbab5b1b8f89a5bbc1dea15277e3cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a76fbab5b1b8f89a5bbc1dea15277e3cb">to_chars</a> (char *first, char *last, unsigned int value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:a76fbab5b1b8f89a5bbc1dea15277e3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dba7a492de53017a087ddd3dab4580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a86dba7a492de53017a087ddd3dab4580">to_chars</a> (char *first, char *last, long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:a86dba7a492de53017a087ddd3dab4580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67a5a24c6b6a856cf92230bc93bc2ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa67a5a24c6b6a856cf92230bc93bc2ab">to_chars</a> (char *first, char *last, unsigned long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:aa67a5a24c6b6a856cf92230bc93bc2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7892cafa4dd725dee3ee0945aeea1652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7892cafa4dd725dee3ee0945aeea1652">to_chars</a> (char *first, char *last, long long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:a7892cafa4dd725dee3ee0945aeea1652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff467499d43b24b158dbdf27563e6228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aff467499d43b24b158dbdf27563e6228">to_chars</a> (char *first, char *last, unsigned long long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())</td></tr>
<tr class="separator:aff467499d43b24b158dbdf27563e6228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295df44c0aa1b1bd24f09fc99530a445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a295df44c0aa1b1bd24f09fc99530a445">to_chars</a> (char *first, char *last, bool value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>())=delete</td></tr>
<tr class="separator:a295df44c0aa1b1bd24f09fc99530a445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b551a6b9a237e00485171e598b17ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a00b551a6b9a237e00485171e598b17ed">to_chars</a> (char *first, char *last, float value)</td></tr>
<tr class="memdesc:a00b551a6b9a237e00485171e598b17ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <a href="namespaceseq.html#a00b551a6b9a237e00485171e598b17ed">More...</a><br /></td></tr>
<tr class="separator:a00b551a6b9a237e00485171e598b17ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bcd11b01a3f09227c80c355d84c28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a55bcd11b01a3f09227c80c355d84c28d">to_chars</a> (char *first, char *last, double value)</td></tr>
<tr class="separator:a55bcd11b01a3f09227c80c355d84c28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129fc53b61e8c0e747045b23df5d1062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a129fc53b61e8c0e747045b23df5d1062">to_chars</a> (char *first, char *last, long double value)</td></tr>
<tr class="separator:a129fc53b61e8c0e747045b23df5d1062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaa974695ff6a6769addd3a96b41404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9eaa974695ff6a6769addd3a96b41404">to_chars</a> (char *first, char *last, float value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>)</td></tr>
<tr class="separator:a9eaa974695ff6a6769addd3a96b41404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ce07ea09c6b1253bd62111853a01fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa2ce07ea09c6b1253bd62111853a01fc">to_chars</a> (char *first, char *last, double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>)</td></tr>
<tr class="separator:aa2ce07ea09c6b1253bd62111853a01fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e2d522a9be477687ce8a99832f5d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a23e2d522a9be477687ce8a99832f5d9d">to_chars</a> (char *first, char *last, long double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>)</td></tr>
<tr class="separator:a23e2d522a9be477687ce8a99832f5d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f18559369db93f332cd9af2d5a8d49d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8f18559369db93f332cd9af2d5a8d49d">to_chars</a> (char *first, char *last, float value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>, int precision, char dot='.', char exp='e', bool upper=false)</td></tr>
<tr class="separator:a8f18559369db93f332cd9af2d5a8d49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe570a1e00892b6ed78277b2939477fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abe570a1e00892b6ed78277b2939477fd">to_chars</a> (char *first, char *last, double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>, int precision, char dot='.', char exp='e', bool upper=false)</td></tr>
<tr class="separator:abe570a1e00892b6ed78277b2939477fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade72bd4859446d94c240d219e7dd8dc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ade72bd4859446d94c240d219e7dd8dc4">to_chars</a> (char *first, char *last, long double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>, int precision, char dot='.', char exp='e', bool upper=false)</td></tr>
<tr class="separator:ade72bd4859446d94c240d219e7dd8dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f21073ae01bd19e5a6f141f38e5892"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:a28f21073ae01bd19e5a6f141f38e5892"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a28f21073ae01bd19e5a6f141f38e5892">operator==</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, L2, S2, U2 &gt; &amp;s2)</td></tr>
<tr class="memdesc:a28f21073ae01bd19e5a6f141f38e5892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position.  <a href="namespaceseq.html#a28f21073ae01bd19e5a6f141f38e5892">More...</a><br /></td></tr>
<tr class="separator:a28f21073ae01bd19e5a6f141f38e5892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa48d4b3cf1891cd8ae3f021ad3f0e71"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:afa48d4b3cf1891cd8ae3f021ad3f0e71"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afa48d4b3cf1891cd8ae3f021ad3f0e71">operator!=</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, L2, S2, U2 &gt; &amp;s2)</td></tr>
<tr class="memdesc:afa48d4b3cf1891cd8ae3f021ad3f0e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are not equals.  <a href="namespaceseq.html#afa48d4b3cf1891cd8ae3f021ad3f0e71">More...</a><br /></td></tr>
<tr class="separator:afa48d4b3cf1891cd8ae3f021ad3f0e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad635125b29a71d98dd496a619aa2d3fc"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare , class Al1 , LayoutManagement L1, bool S1, bool U1, class Pred &gt; </td></tr>
<tr class="memitem:ad635125b29a71d98dd496a619aa2d3fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad635125b29a71d98dd496a619aa2d3fc">erase_if</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;s1, Pred p)</td></tr>
<tr class="memdesc:ad635125b29a71d98dd496a619aa2d3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="namespaceseq.html#ad635125b29a71d98dd496a619aa2d3fc">More...</a><br /></td></tr>
<tr class="separator:ad635125b29a71d98dd496a619aa2d3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb611395bcf177863d2e3bb53432afc"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:a6eb611395bcf177863d2e3bb53432afc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6eb611395bcf177863d2e3bb53432afc">operator==</a> (const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, L2, S2, U2 &gt; &amp;s2)</td></tr>
<tr class="memdesc:a6eb611395bcf177863d2e3bb53432afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position.  <a href="namespaceseq.html#a6eb611395bcf177863d2e3bb53432afc">More...</a><br /></td></tr>
<tr class="separator:a6eb611395bcf177863d2e3bb53432afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b03a0e86dff59b708f1f20240bcdfdb"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:a4b03a0e86dff59b708f1f20240bcdfdb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4b03a0e86dff59b708f1f20240bcdfdb">operator!=</a> (const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, L2, S2, U2 &gt; &amp;s2)</td></tr>
<tr class="memdesc:a4b03a0e86dff59b708f1f20240bcdfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are not equals.  <a href="namespaceseq.html#a4b03a0e86dff59b708f1f20240bcdfdb">More...</a><br /></td></tr>
<tr class="separator:a4b03a0e86dff59b708f1f20240bcdfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59a95e404977402f0b0cb994189dd4c"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare , class Al1 , LayoutManagement L1, bool S1, bool U1, class Pred &gt; </td></tr>
<tr class="memitem:ab59a95e404977402f0b0cb994189dd4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab59a95e404977402f0b0cb994189dd4c">erase_if</a> (<a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;s1, Pred p)</td></tr>
<tr class="memdesc:ab59a95e404977402f0b0cb994189dd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="namespaceseq.html#ab59a95e404977402f0b0cb994189dd4c">More...</a><br /></td></tr>
<tr class="separator:ab59a95e404977402f0b0cb994189dd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af98bbd3b7d9b7d7cb552f6f3a8d220"><td class="memTemplParams" colspan="2">template&lt;size_t... Ts&gt; </td></tr>
<tr class="memitem:a4af98bbd3b7d9b7d7cb552f6f3a8d220"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a> ()</td></tr>
<tr class="memdesc:a4af98bbd3b7d9b7d7cb552f6f3a8d220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a positional object used either by <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt()</a> or operator() of formatting object.  <a href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">More...</a><br /></td></tr>
<tr class="separator:a4af98bbd3b7d9b7d7cb552f6f3a8d220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b27d9d28ab49b4e36657f9e95013c7"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a21b27d9d28ab49b4e36657f9e95013c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a> (Args &amp;&amp;... args) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), void, Args... &gt;::return_type</td></tr>
<tr class="separator:a21b27d9d28ab49b4e36657f9e95013c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50efcf02fb38933039611940d459ae10"><td class="memTemplParams" colspan="2">template&lt;size_t ... Ts, class ... Args&gt; </td></tr>
<tr class="memitem:a50efcf02fb38933039611940d459ae10"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a50efcf02fb38933039611940d459ae10">fmt</a> (<a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;, Args &amp;&amp;... args) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;, Args... &gt;::return_type</td></tr>
<tr class="separator:a50efcf02fb38933039611940d459ae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7f5113ac0f03f720b3a5cf96c20550"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a1c7f5113ac0f03f720b3a5cf96c20550"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1c7f5113ac0f03f720b3a5cf96c20550">fmt</a> () -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), void, Args... &gt;::return_type</td></tr>
<tr class="separator:a1c7f5113ac0f03f720b3a5cf96c20550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce0a7bad49b2b432d3b0565e5cbc3c4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4ce0a7bad49b2b432d3b0565e5cbc3c4">hash_combine</a> (size_t h1, size_t h2) noexcept</td></tr>
<tr class="memdesc:a4ce0a7bad49b2b432d3b0565e5cbc3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine 2 hash values. Uses either murmurhash2 for 64 bits platform or the boost version for 32 bits platform.  <a href="namespaceseq.html#a4ce0a7bad49b2b432d3b0565e5cbc3c4">More...</a><br /></td></tr>
<tr class="separator:a4ce0a7bad49b2b432d3b0565e5cbc3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c1603678ff859a7ac75a082ecb97b2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a11c1603678ff859a7ac75a082ecb97b2">hash_bytes_murmur64</a> (const std::uint8_t *ptr, size_t len) noexcept</td></tr>
<tr class="memdesc:a11c1603678ff859a7ac75a082ecb97b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash value for input data using the murmurhash2 algorithm.  <a href="namespaceseq.html#a11c1603678ff859a7ac75a082ecb97b2">More...</a><br /></td></tr>
<tr class="separator:a11c1603678ff859a7ac75a082ecb97b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa0a287687aadd2106e1fb1ff32431f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7aa0a287687aadd2106e1fb1ff32431f">hash_bytes_fnv1a</a> (const unsigned char *ptr, size_t size) noexcept</td></tr>
<tr class="memdesc:a7aa0a287687aadd2106e1fb1ff32431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash value for input data using the fnv1a algorithm. This version reads the input buffer by chunks of sizeof(size_t).  <a href="namespaceseq.html#a7aa0a287687aadd2106e1fb1ff32431f">More...</a><br /></td></tr>
<tr class="separator:a7aa0a287687aadd2106e1fb1ff32431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0458b86ee52bc2dd1471917dd424b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aba0458b86ee52bc2dd1471917dd424b8">hash_bytes_fnv1a_slow</a> (const unsigned char *ptr, size_t size) noexcept</td></tr>
<tr class="memdesc:aba0458b86ee52bc2dd1471917dd424b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash value for input data using the fnv1a algorithm.  <a href="namespaceseq.html#aba0458b86ee52bc2dd1471917dd424b8">More...</a><br /></td></tr>
<tr class="separator:aba0458b86ee52bc2dd1471917dd424b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1349a44a2ff37300a5c72a03780780fe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1349a44a2ff37300a5c72a03780780fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1349a44a2ff37300a5c72a03780780fe">unique_ptr_delete</a> (T *p)</td></tr>
<tr class="memdesc:a1349a44a2ff37300a5c72a03780780fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate pointer previously held by a std::unqiue_ptr&lt;T,unique_ptr_deleter&lt;T&gt; &gt;  <a href="namespaceseq.html#a1349a44a2ff37300a5c72a03780780fe">More...</a><br /></td></tr>
<tr class="separator:a1349a44a2ff37300a5c72a03780780fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd24b67e86b93a8639f533415cfd811"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:a6cd24b67e86b93a8639f533415cfd811"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6cd24b67e86b93a8639f533415cfd811">operator==</a> (const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6cd24b67e86b93a8639f533415cfd811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> for equality. Two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> are considered equal if they contain the same keys. Key ordering is not considered.  <a href="namespaceseq.html#a6cd24b67e86b93a8639f533415cfd811">More...</a><br /></td></tr>
<tr class="separator:a6cd24b67e86b93a8639f533415cfd811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818f1ef96eceafb1f80fc069720a99e5"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:a818f1ef96eceafb1f80fc069720a99e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a818f1ef96eceafb1f80fc069720a99e5">operator!=</a> (const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a818f1ef96eceafb1f80fc069720a99e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> for inequality, synthesized from operator==.  <a href="namespaceseq.html#a818f1ef96eceafb1f80fc069720a99e5">More...</a><br /></td></tr>
<tr class="separator:a818f1ef96eceafb1f80fc069720a99e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa186b78abe0024b08ac9417eeb3b67dd"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </td></tr>
<tr class="memitem:aa186b78abe0024b08ac9417eeb3b67dd"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa186b78abe0024b08ac9417eeb3b67dd">erase_if</a> (<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;set, Pred p)</td></tr>
<tr class="memdesc:aa186b78abe0024b08ac9417eeb3b67dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="namespaceseq.html#aa186b78abe0024b08ac9417eeb3b67dd">More...</a><br /></td></tr>
<tr class="separator:aa186b78abe0024b08ac9417eeb3b67dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1661245c4cb91cf0898e0c87fa1160d"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:ad1661245c4cb91cf0898e0c87fa1160d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad1661245c4cb91cf0898e0c87fa1160d">operator==</a> (const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad1661245c4cb91cf0898e0c87fa1160d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> for equality. Two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> are considered equal if they contain the same pairs key-&gt;value. Key ordering is not considered.  <a href="namespaceseq.html#ad1661245c4cb91cf0898e0c87fa1160d">More...</a><br /></td></tr>
<tr class="separator:ad1661245c4cb91cf0898e0c87fa1160d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6912674e5ef451a9f0733279b436113e"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:a6912674e5ef451a9f0733279b436113e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6912674e5ef451a9f0733279b436113e">operator!=</a> (const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6912674e5ef451a9f0733279b436113e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> for inequality, synthesized from operator==.  <a href="namespaceseq.html#a6912674e5ef451a9f0733279b436113e">More...</a><br /></td></tr>
<tr class="separator:a6912674e5ef451a9f0733279b436113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4674d3392bd75ab94dbb6d754a91f7"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </td></tr>
<tr class="memitem:a4a4674d3392bd75ab94dbb6d754a91f7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4a4674d3392bd75ab94dbb6d754a91f7">erase_if</a> (<a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;set, Pred p)</td></tr>
<tr class="memdesc:a4a4674d3392bd75ab94dbb6d754a91f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="namespaceseq.html#a4a4674d3392bd75ab94dbb6d754a91f7">More...</a><br /></td></tr>
<tr class="separator:a4a4674d3392bd75ab94dbb6d754a91f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e09173d3e2cbd2e90fde65284d6a362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7e09173d3e2cbd2e90fde65284d6a362">start_timer</a> (<a class="el" href="namespaceseq.html#ad75714ebe7ef4833c3a3a641d3389e39">high_def_timer</a> *timer)</td></tr>
<tr class="separator:a7e09173d3e2cbd2e90fde65284d6a362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6680f5c7e0d172b1f3cc7334306ed5b"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae6680f5c7e0d172b1f3cc7334306ed5b">elapsed_microseconds</a> (<a class="el" href="namespaceseq.html#ad75714ebe7ef4833c3a3a641d3389e39">high_def_timer</a> *timer)</td></tr>
<tr class="separator:ae6680f5c7e0d172b1f3cc7334306ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad863fcfc143b646f5a2f2362a1327575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a> ()</td></tr>
<tr class="separator:ad863fcfc143b646f5a2f2362a1327575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebacd959a1a167aec6e024961697304"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6ebacd959a1a167aec6e024961697304">tock_us</a> ()</td></tr>
<tr class="separator:a6ebacd959a1a167aec6e024961697304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3fc02a69112af58e297963a9e4c08c"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1c3fc02a69112af58e297963a9e4c08c">tock_ms</a> ()</td></tr>
<tr class="separator:a1c3fc02a69112af58e297963a9e4c08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47d4cfe851a2c80ba696a4b90905c7c"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af47d4cfe851a2c80ba696a4b90905c7c">tock_s</a> ()</td></tr>
<tr class="separator:af47d4cfe851a2c80ba696a4b90905c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabfa3eaf9a03808f516c1c71d521dee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#acabfa3eaf9a03808f516c1c71d521dee">reset_memory_usage</a> ()</td></tr>
<tr class="separator:acabfa3eaf9a03808f516c1c71d521dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e52d40a551ef3e1dc395d1c93349aa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a15e52d40a551ef3e1dc395d1c93349aa">get_memory_usage</a> ()</td></tr>
<tr class="separator:a15e52d40a551ef3e1dc395d1c93349aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b887df093a1fae4487fccd6c1949116"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4b887df093a1fae4487fccd6c1949116"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4b887df093a1fae4487fccd6c1949116">print_null</a> (const T &amp;v)</td></tr>
<tr class="separator:a4b887df093a1fae4487fccd6c1949116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96cdb73265a09784b8f3e8cbc777328"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae96cdb73265a09784b8f3e8cbc777328">to_int</a> (const std::string &amp;v)</td></tr>
<tr class="separator:ae96cdb73265a09784b8f3e8cbc777328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e0fbe51f6e0fd8e54e91864b14ee86"><td class="memTemplParams" colspan="2">template&lt;size_t S, class AL &gt; </td></tr>
<tr class="memitem:a84e0fbe51f6e0fd8e54e91864b14ee86"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a84e0fbe51f6e0fd8e54e91864b14ee86">to_int</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, AL &gt; &amp;v)</td></tr>
<tr class="separator:a84e0fbe51f6e0fd8e54e91864b14ee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a9cdadd4df8f31f3b1fd39cebf350e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae7a9cdadd4df8f31f3b1fd39cebf350e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae7a9cdadd4df8f31f3b1fd39cebf350e">to_int</a> (const T &amp;v)</td></tr>
<tr class="separator:ae7a9cdadd4df8f31f3b1fd39cebf350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf81691741d518d15f0faaf1da2f015a"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aaf81691741d518d15f0faaf1da2f015a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aaf81691741d518d15f0faaf1da2f015a">to_int</a> (const std::pair&lt; T, U &gt; &amp;v)</td></tr>
<tr class="separator:aaf81691741d518d15f0faaf1da2f015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d21556f69c13e311f06e94da75c1792"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a9d21556f69c13e311f06e94da75c1792"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9d21556f69c13e311f06e94da75c1792">to_int</a> (const std::pair&lt; const T, U &gt; &amp;v)</td></tr>
<tr class="separator:a9d21556f69c13e311f06e94da75c1792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5e1bd8af52c82c89100c6146c47e10"><td class="memTemplParams" colspan="2">template&lt;class String &gt; </td></tr>
<tr class="memitem:aca5e1bd8af52c82c89100c6146c47e10"><td class="memTemplItemLeft" align="right" valign="top">String&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aca5e1bd8af52c82c89100c6146c47e10">generate_random_string</a> (int max_size, bool <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682abfc5cfa7d975226254b5443690d9f918">fixed</a>=false)</td></tr>
<tr class="separator:aca5e1bd8af52c82c89100c6146c47e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d27edcb268d2f54a2aea63289ce60fa"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:a9d27edcb268d2f54a2aea63289ce60fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9d27edcb268d2f54a2aea63289ce60fa">operator==</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9d27edcb268d2f54a2aea63289ce60fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d2328b5f70f42feabee51284c0b4f4"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ae2d2328b5f70f42feabee51284c0b4f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae2d2328b5f70f42feabee51284c0b4f4">operator==</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae2d2328b5f70f42feabee51284c0b4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46515296513c942f8ea60c873def0c5"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ab46515296513c942f8ea60c873def0c5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab46515296513c942f8ea60c873def0c5">operator==</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:ab46515296513c942f8ea60c873def0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac06f782d2107c3cc7124399b4eb581"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a1ac06f782d2107c3cc7124399b4eb581"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1ac06f782d2107c3cc7124399b4eb581">operator==</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1ac06f782d2107c3cc7124399b4eb581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f441a6b31df9530605a13ef51c148a"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ae4f441a6b31df9530605a13ef51c148a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae4f441a6b31df9530605a13ef51c148a">operator==</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:ae4f441a6b31df9530605a13ef51c148a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e28e6da6ec3562c1faef9ef00631d6"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:ad9e28e6da6ec3562c1faef9ef00631d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad9e28e6da6ec3562c1faef9ef00631d6">operator!=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad9e28e6da6ec3562c1faef9ef00631d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6a00f67a9341cb4bcc99c107515229"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a3d6a00f67a9341cb4bcc99c107515229"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3d6a00f67a9341cb4bcc99c107515229">operator!=</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3d6a00f67a9341cb4bcc99c107515229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6a796c87305524653d7265ae4da2ff"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a3b6a796c87305524653d7265ae4da2ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3b6a796c87305524653d7265ae4da2ff">operator!=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a3b6a796c87305524653d7265ae4da2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948fa0ea1e3ce1689da9c6b62c096245"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a948fa0ea1e3ce1689da9c6b62c096245"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a948fa0ea1e3ce1689da9c6b62c096245">operator!=</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a948fa0ea1e3ce1689da9c6b62c096245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32bc8987b500a2d007b0a068d48538"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:afe32bc8987b500a2d007b0a068d48538"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afe32bc8987b500a2d007b0a068d48538">operator!=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:afe32bc8987b500a2d007b0a068d48538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6a7ec8e9a4fc0d7eaf0d5f523774ca"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:a3b6a7ec8e9a4fc0d7eaf0d5f523774ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3b6a7ec8e9a4fc0d7eaf0d5f523774ca">operator&lt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3b6a7ec8e9a4fc0d7eaf0d5f523774ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc02f75db7d73bb10c42d71a370c368"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:abfc02f75db7d73bb10c42d71a370c368"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abfc02f75db7d73bb10c42d71a370c368">operator&lt;</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:abfc02f75db7d73bb10c42d71a370c368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4feaa3ec5619d0c601da47ed4245c3"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aea4feaa3ec5619d0c601da47ed4245c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aea4feaa3ec5619d0c601da47ed4245c3">operator&lt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:aea4feaa3ec5619d0c601da47ed4245c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d793a96fc5ac7087c067d0b129662d0"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a1d793a96fc5ac7087c067d0b129662d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1d793a96fc5ac7087c067d0b129662d0">operator&lt;</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1d793a96fc5ac7087c067d0b129662d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7797b9c1954288017fdfe309b554454a"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a7797b9c1954288017fdfe309b554454a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7797b9c1954288017fdfe309b554454a">operator&lt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:a7797b9c1954288017fdfe309b554454a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f6d50f3c32887116c4bae46c3429d4"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:ad8f6d50f3c32887116c4bae46c3429d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad8f6d50f3c32887116c4bae46c3429d4">operator&lt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad8f6d50f3c32887116c4bae46c3429d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edd539db8412668d682cf9ff5e7a070"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a9edd539db8412668d682cf9ff5e7a070"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9edd539db8412668d682cf9ff5e7a070">operator&lt;=</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9edd539db8412668d682cf9ff5e7a070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad008ee24c9386b09b25e912de5d4c1a1"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ad008ee24c9386b09b25e912de5d4c1a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad008ee24c9386b09b25e912de5d4c1a1">operator&lt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:ad008ee24c9386b09b25e912de5d4c1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc2a4ddf5388c2ced30ccb8f562d675"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aedc2a4ddf5388c2ced30ccb8f562d675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aedc2a4ddf5388c2ced30ccb8f562d675">operator&lt;=</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aedc2a4ddf5388c2ced30ccb8f562d675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56068d4d371f671c476f2d48a14c40c4"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a56068d4d371f671c476f2d48a14c40c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a56068d4d371f671c476f2d48a14c40c4">operator&lt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:a56068d4d371f671c476f2d48a14c40c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1833a5b86d9fe7f4aa324dc762ee7f"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:a5e1833a5b86d9fe7f4aa324dc762ee7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5e1833a5b86d9fe7f4aa324dc762ee7f">operator&gt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5e1833a5b86d9fe7f4aa324dc762ee7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3482ce2ab94dc59b5b2b857802906f"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a1f3482ce2ab94dc59b5b2b857802906f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1f3482ce2ab94dc59b5b2b857802906f">operator&gt;</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1f3482ce2ab94dc59b5b2b857802906f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cc10a31374b3edfd99aa9d766ad5c7"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a58cc10a31374b3edfd99aa9d766ad5c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a58cc10a31374b3edfd99aa9d766ad5c7">operator&gt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a58cc10a31374b3edfd99aa9d766ad5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382805c206a702e81be578225f9b2a6c"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a382805c206a702e81be578225f9b2a6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a382805c206a702e81be578225f9b2a6c">operator&gt;</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a382805c206a702e81be578225f9b2a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422ba2ed76ef830f9a768efb0ab264b"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a3422ba2ed76ef830f9a768efb0ab264b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3422ba2ed76ef830f9a768efb0ab264b">operator&gt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:a3422ba2ed76ef830f9a768efb0ab264b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b02d9de4bef32a8048a063ca879338"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:a42b02d9de4bef32a8048a063ca879338"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a42b02d9de4bef32a8048a063ca879338">operator&gt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a42b02d9de4bef32a8048a063ca879338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1652748e87ae34ddb4e4aaee0c1047"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a9d1652748e87ae34ddb4e4aaee0c1047"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9d1652748e87ae34ddb4e4aaee0c1047">operator&gt;=</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9d1652748e87ae34ddb4e4aaee0c1047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0492edc203e24e4f2a815f88b63b6b9c"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a0492edc203e24e4f2a815f88b63b6b9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0492edc203e24e4f2a815f88b63b6b9c">operator&gt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a0492edc203e24e4f2a815f88b63b6b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbd22b85882e325ad2aa30cc80476fa"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aefbd22b85882e325ad2aa30cc80476fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aefbd22b85882e325ad2aa30cc80476fa">operator&gt;=</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aefbd22b85882e325ad2aa30cc80476fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099bb20d7de44b7e830799fea7f7a709"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a099bb20d7de44b7e830799fea7f7a709"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a099bb20d7de44b7e830799fea7f7a709">operator&gt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:a099bb20d7de44b7e830799fea7f7a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da0baa868f02d38d414b2dc1f288549"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:a4da0baa868f02d38d414b2dc1f288549"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4da0baa868f02d38d414b2dc1f288549">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a4da0baa868f02d38d414b2dc1f288549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55661fe2e7792e24a096eb01c961774f"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a55661fe2e7792e24a096eb01c961774f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a55661fe2e7792e24a096eb01c961774f">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="separator:a55661fe2e7792e24a096eb01c961774f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213087903db1d425d09460f104ba12af"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a213087903db1d425d09460f104ba12af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a213087903db1d425d09460f104ba12af">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs)</td></tr>
<tr class="separator:a213087903db1d425d09460f104ba12af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0caf1783a3f82d9cfc9d88e159b8a9"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aed0caf1783a3f82d9cfc9d88e159b8a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aed0caf1783a3f82d9cfc9d88e159b8a9">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, char rhs)</td></tr>
<tr class="separator:aed0caf1783a3f82d9cfc9d88e159b8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7fd51f3cc247331f7ed13b1b1cf4ed"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a6f7fd51f3cc247331f7ed13b1b1cf4ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6f7fd51f3cc247331f7ed13b1b1cf4ed">operator+</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs)</td></tr>
<tr class="separator:a6f7fd51f3cc247331f7ed13b1b1cf4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4daaf1a307da775f3767ab9e300f36a"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ad4daaf1a307da775f3767ab9e300f36a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad4daaf1a307da775f3767ab9e300f36a">operator+</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs)</td></tr>
<tr class="separator:ad4daaf1a307da775f3767ab9e300f36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16ed00cc778ba6a0e21215120dedaf8"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aa16ed00cc778ba6a0e21215120dedaf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa16ed00cc778ba6a0e21215120dedaf8">operator+</a> (char lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs)</td></tr>
<tr class="separator:aa16ed00cc778ba6a0e21215120dedaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78db8ea6da034c3a306ddfda73895cdf"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a78db8ea6da034c3a306ddfda73895cdf">string_data</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a78db8ea6da034c3a306ddfda73895cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3e5871a80d139dfc445702677436d6"><td class="memTemplParams" colspan="2">template&lt;size_t S, class Al &gt; </td></tr>
<tr class="memitem:aeb3e5871a80d139dfc445702677436d6"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aeb3e5871a80d139dfc445702677436d6">string_data</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, Al &gt; &amp;str)</td></tr>
<tr class="separator:aeb3e5871a80d139dfc445702677436d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cfb914c6655f3fac351e92d3467782"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a07cfb914c6655f3fac351e92d3467782">string_data</a> (const char *str)</td></tr>
<tr class="separator:a07cfb914c6655f3fac351e92d3467782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a4e70902832fb7a5b4098d8ea1d7aa"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac0a4e70902832fb7a5b4098d8ea1d7aa">string_data</a> (const <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &amp;str)</td></tr>
<tr class="separator:ac0a4e70902832fb7a5b4098d8ea1d7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ca2f2c8716a04f750b46cda23c9a42"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa8ca2f2c8716a04f750b46cda23c9a42">string_size</a> (const std::string &amp;str)</td></tr>
<tr class="separator:aa8ca2f2c8716a04f750b46cda23c9a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb2edfe41e69b0f8116ffb2e729c680"><td class="memTemplParams" colspan="2">template&lt;size_t S, class Al &gt; </td></tr>
<tr class="memitem:a6eb2edfe41e69b0f8116ffb2e729c680"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6eb2edfe41e69b0f8116ffb2e729c680">string_size</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, Al &gt; &amp;str)</td></tr>
<tr class="separator:a6eb2edfe41e69b0f8116ffb2e729c680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed50f805163eb7f65b9f6b7fadbb2b21"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aed50f805163eb7f65b9f6b7fadbb2b21">string_size</a> (const char *str)</td></tr>
<tr class="separator:aed50f805163eb7f65b9f6b7fadbb2b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184b1c0786a832e217d7c17843cc765a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a184b1c0786a832e217d7c17843cc765a">string_size</a> (const <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &amp;str)</td></tr>
<tr class="separator:a184b1c0786a832e217d7c17843cc765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e43145f833c1fb4c26fbc91e341564"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a97e43145f833c1fb4c26fbc91e341564"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a97e43145f833c1fb4c26fbc91e341564">negate_if_signed</a> (T v)</td></tr>
<tr class="memdesc:a97e43145f833c1fb4c26fbc91e341564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns -v if v is signed, v otherwise.  <a href="namespaceseq.html#a97e43145f833c1fb4c26fbc91e341564">More...</a><br /></td></tr>
<tr class="separator:a97e43145f833c1fb4c26fbc91e341564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ecbace49a8c09bb7de9eac60a97f58"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af7ecbace49a8c09bb7de9eac60a97f58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af7ecbace49a8c09bb7de9eac60a97f58">abs</a> (T v)</td></tr>
<tr class="memdesc:af7ecbace49a8c09bb7de9eac60a97f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns absolute value of v.  <a href="namespaceseq.html#af7ecbace49a8c09bb7de9eac60a97f58">More...</a><br /></td></tr>
<tr class="separator:af7ecbace49a8c09bb7de9eac60a97f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1407693897892cd91dbb31683cf1e200"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1407693897892cd91dbb31683cf1e200"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1407693897892cd91dbb31683cf1e200">operator+</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it, typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type diff) noexcept</td></tr>
<tr class="separator:a1407693897892cd91dbb31683cf1e200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae140a176dbb43c6b695adac9561c01da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae140a176dbb43c6b695adac9561c01da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae140a176dbb43c6b695adac9561c01da">operator-</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it, typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type diff) noexcept</td></tr>
<tr class="separator:ae140a176dbb43c6b695adac9561c01da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edaf549d71732fa081394b43ae7e438"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5edaf549d71732fa081394b43ae7e438"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5edaf549d71732fa081394b43ae7e438">operator-</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept</td></tr>
<tr class="separator:a5edaf549d71732fa081394b43ae7e438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2ac9b96f995fff575fc24a8169cb3d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0c2ac9b96f995fff575fc24a8169cb3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0c2ac9b96f995fff575fc24a8169cb3d">operator&lt;</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept</td></tr>
<tr class="separator:a0c2ac9b96f995fff575fc24a8169cb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73cb013ab8de39759f3188c232bc768"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af73cb013ab8de39759f3188c232bc768"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af73cb013ab8de39759f3188c232bc768">operator&gt;</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept</td></tr>
<tr class="separator:af73cb013ab8de39759f3188c232bc768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bf025c87b50f374d4e581963559c30"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad7bf025c87b50f374d4e581963559c30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad7bf025c87b50f374d4e581963559c30">operator&lt;=</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept</td></tr>
<tr class="separator:ad7bf025c87b50f374d4e581963559c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c78c77d93ada0613a00c80f01fe15da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9c78c77d93ada0613a00c80f01fe15da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9c78c77d93ada0613a00c80f01fe15da">operator&gt;=</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept</td></tr>
<tr class="separator:a9c78c77d93ada0613a00c80f01fe15da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09f4c319b21510f90dae6dc5b7d8656"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae09f4c319b21510f90dae6dc5b7d8656"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae09f4c319b21510f90dae6dc5b7d8656">destroy_ptr</a> (T *p)</td></tr>
<tr class="separator:ae09f4c319b21510f90dae6dc5b7d8656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48515fc69dc7f83f81c6e0715999ba16"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a48515fc69dc7f83f81c6e0715999ba16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a48515fc69dc7f83f81c6e0715999ba16">construct_ptr</a> (T *p, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a48515fc69dc7f83f81c6e0715999ba16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7847ff182c5998204ab1a9f404d175a6"><td class="memTemplParams" colspan="2">template&lt;bool IsL1, class L1 , class L2 , class... Args&gt; </td></tr>
<tr class="memitem:a7847ff182c5998204ab1a9f404d175a6"><td class="memTemplItemLeft" align="right" valign="top">decltype(std::declval&lt; <a class="el" href="structseq_1_1detail_1_1_call_lambda.html">detail::CallLambda</a>&lt; L1, L2, IsL1 &gt; &amp; &gt;()(std::declval&lt; L1 &amp; &gt;(), std::declval&lt; L2 &amp; &gt;(), std::declval&lt; Args &gt;()...))&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7847ff182c5998204ab1a9f404d175a6">constexpr_if</a> (const L1 &amp;l1, const L2 &amp;l2, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a7847ff182c5998204ab1a9f404d175a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a24ef193cef19271b9b18ce6c74fc5b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ef193cef19271b9b18ce6c74fc5b54">&#9670;&nbsp;</a></span>any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">seq::any</a> = typedef <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad75714ebe7ef4833c3a3a641d3389e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75714ebe7ef4833c3a3a641d3389e39">&#9670;&nbsp;</a></span>high_def_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct timespec <a class="el" href="namespaceseq.html#ad75714ebe7ef4833c3a3a641d3389e39">seq::high_def_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d2b0aba572fc96bdcec68b500577b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2b0aba572fc96bdcec68b500577b5b">&#9670;&nbsp;</a></span>max_align_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a6d2b0aba572fc96bdcec68b500577b5b">seq::max_align_t</a> = typedef std::max_align_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ec98840dd82cf3a3207402caa66c73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec98840dd82cf3a3207402caa66c73f">&#9670;&nbsp;</a></span>nh_any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">seq::nh_any</a> = typedef <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;<a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae795f8c3dab753bc7283f542671183d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae795f8c3dab753bc7283f542671183d6">&#9670;&nbsp;</a></span>nullbuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structseq_1_1basic__nullbuf.html">basic_nullbuf</a>&lt;char&gt; <a class="el" href="namespaceseq.html#ae795f8c3dab753bc7283f542671183d6">seq::nullbuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d9a01a2c5a12df6d4baac1d1520d4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9a01a2c5a12df6d4baac1d1520d4b5">&#9670;&nbsp;</a></span>tstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">seq::tstring</a> = typedef <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;0, std::allocator&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base string typedef, similar to std::string. Equivalent to <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a>&lt;0, std::allocator&lt;char&gt;&gt;. </p>

</div>
</div>
<a id="a2bede5ff16f5bb9f856b3b2d78303f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bede5ff16f5bb9f856b3b2d78303f69">&#9670;&nbsp;</a></span>tstring_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">seq::tstring_view</a> = typedef <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;0, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base string view typedef, similar to std::string_view. Equivalent to <a class="el" href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html" title="Specialization of tiny_string for string views. You should use the global typedef tstring_view equiva...">tiny_string&lt;0, view_allocator&gt;</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a20e72bbc46786ab0a7095941c5d09045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e72bbc46786ab0a7095941c5d09045">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants used by #object_pool, #parallel_object_pool and #object_allocator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a20e72bbc46786ab0a7095941c5d09045ad00237c7a57ddcba9f768430524651f2"></a>EnoughForSharedPtr&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a20e72bbc46786ab0a7095941c5d09045a668d551cd99226655e9e973b6d5be517"></a>DefaultAlignment&#160;</td><td class="fielddoc"><p>! MaxObjectsAllocation value for #object_pool and #parallel_object_pool to enable shared_ptr building </p>
</td></tr>
</table>

</div>
</div>
<a id="a19a45e1f866d73140819b9ea2280c682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a45e1f866d73140819b9ea2280c682">&#9670;&nbsp;</a></span>chars_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">seq::chars_format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A BitmaskType used to specify floating-point formatting for <a class="el" href="namespaceseq.html#ad80e2e70627dd4598cda06a37b7767b6" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a>. This is similar to std::chars_format, but without the hex value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a19a45e1f866d73140819b9ea2280c682af715ab801ec116cdbb4a7f7541e46166"></a>scientific&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19a45e1f866d73140819b9ea2280c682abfc5cfa7d975226254b5443690d9f918"></a>fixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d"></a>general&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a04f4e48fbeeb8d86e75555957c4e270c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f4e48fbeeb8d86e75555957c4e270c">&#9670;&nbsp;</a></span>DEVectorFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270c">seq::DEVectorFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag indicating whether the devector is optimized for back insertion, front insertion or both. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04f4e48fbeeb8d86e75555957c4e270ca3d03c9bf4b559787d1de5ac0f9a7882d"></a>OptimizeForPushBack&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04f4e48fbeeb8d86e75555957c4e270caeb903e97e2b97b410b477676babb2653"></a>OptimizeForPushFront&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04f4e48fbeeb8d86e75555957c4e270ca998ccc48808777ad90d4228cd8fb9e84"></a>OptimizeForBothEnds&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a209c3fd2e66f43ecc90862f2ee5e3dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209c3fd2e66f43ecc90862f2ee5e3dd5">&#9670;&nbsp;</a></span>LayoutManagement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5">seq::LayoutManagement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory Layout Management for containers like <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant removal ...">seq::sequence</a> or <a class="el" href="classseq_1_1deque.html" title="seq::deque is a std::deque like container implemented as a tiered-vector.">seq::deque</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a209c3fd2e66f43ecc90862f2ee5e3dd5a83983acd78764ffa023da74a7360670e"></a>OptimizeForSpeed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a209c3fd2e66f43ecc90862f2ee5e3dd5a51407649077d79765e15397347a57432"></a>OptimizeForMemory&#160;</td><td class="fielddoc"><p>Use more memory to favor speed. </p>
<p>Use as few memory as possible </p>
</td></tr>
</table>

</div>
</div>
<a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">&#9670;&nbsp;</a></span>StreamState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">seq::StreamState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream object status for classes inheriting <a class="el" href="classseq_1_1basic__input__stream.html" title="Base class for input text streams.">basic_input_stream</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2adc676c349921535a50db525652b39774"></a>Ok&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d"></a>EndOfFile&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587"></a>BadInputFormat&#160;</td><td class="fielddoc"><p>End of file reached. </p>
<p>Unable to read numerical value </p>
</td></tr>
</table>

</div>
</div>
<a id="affae767f96f2af9924f7c6f3bdd4c72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affae767f96f2af9924f7c6f3bdd4c72a">&#9670;&nbsp;</a></span>TagPointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72a">seq::TagPointerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="affae767f96f2af9924f7c6f3bdd4c72aafb05ed7193c8b361ae6679027a774673"></a>StackPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="affae767f96f2af9924f7c6f3bdd4c72aa818e87f4cf07c4dc2006b54dbd4939e0"></a>HeapPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="affae767f96f2af9924f7c6f3bdd4c72aad297c23409b392745ce5f3024304a8e8"></a>CustomAlignment&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af7ecbace49a8c09bb7de9eac60a97f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ecbace49a8c09bb7de9eac60a97f58">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt;T&gt;::type seq::abs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns absolute value of v. </p>

</div>
</div>
<a id="a04be1ca38e79158feb4755807ef3d08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04be1ca38e79158feb4755807ef3d08c">&#9670;&nbsp;</a></span>aligned_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::aligned_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees memory allocated with aligned_malloc. </p>

</div>
</div>
<a id="ad83ce9b88f61a6d39bc6505b04ec6f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83ce9b88f61a6d39bc6505b04ec6f6e">&#9670;&nbsp;</a></span>aligned_malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* seq::aligned_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates <em>size</em> bytes. The returned pointer is guaranteed to have <em>align</em> bytes alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size in bytes to allocate </td></tr>
    <tr><td class="paramname">align</td><td>alignment of result pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>algned pointer or NULL on error </dd></dl>

</div>
</div>
<a id="a6b963eb589bb722310da16e78278c62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b963eb589bb722310da16e78278c62e">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T seq::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacd7538cfa09fb8edf2f4fee4bdb6d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd7538cfa09fb8edf2f4fee4bdb6d8e">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* seq::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; *&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accce8085ad2ebc8f3a73a876be03650c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accce8085ad2ebc8f3a73a876be03650c">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T seq::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf7e59237b8c383ec6b7eb422e20ef6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7e59237b8c383ec6b7eb422e20ef6e">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* seq::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; *&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80de2782447e04cfb1d873736761c04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80de2782447e04cfb1d873736761c04c">&#9670;&nbsp;</a></span>bit_scan_forward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned seq::bit_scan_forward </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest set bit index in <em>bb</em>. Undefined if bb==0. </p>

</div>
</div>
<a id="a62ae84cf43b3822a03c04a4e0762813a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ae84cf43b3822a03c04a4e0762813a">&#9670;&nbsp;</a></span>bit_scan_forward_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned int seq::bit_scan_forward_32 </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lowest set bit index in <em>val</em> Undefined if val==0. </p>

</div>
</div>
<a id="a55187c5046afdf617db98cf0a27f9320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55187c5046afdf617db98cf0a27f9320">&#9670;&nbsp;</a></span>bit_scan_forward_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned seq::bit_scan_forward_64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest set bit index in <em>bb</em>. Developed by Kim Walisch (2012). Undefined if bb==0. </p>

</div>
</div>
<a id="ae4aa3fe9c20f97f4f5af93dfa190bbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4aa3fe9c20f97f4f5af93dfa190bbad">&#9670;&nbsp;</a></span>bit_scan_forward_8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned int seq::bit_scan_forward_8 </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e82ccd4ecac286fcbe78c84dc2bf793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e82ccd4ecac286fcbe78c84dc2bf793">&#9670;&nbsp;</a></span>bit_scan_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned seq::bit_scan_reverse </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest set bit index in <em>bb</em>. Undefined if bb==0. </p>

</div>
</div>
<a id="aab5a4ec0a40a8275833a0fe25b4dfb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5a4ec0a40a8275833a0fe25b4dfb23">&#9670;&nbsp;</a></span>bit_scan_reverse_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned int seq::bit_scan_reverse_32 </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the highest set bit index in <em>val</em> Undefined if val==0. </p>

</div>
</div>
<a id="ab6a7d54aa37d26276cef0ea1ca0a1fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a7d54aa37d26276cef0ea1ca0a1fe1">&#9670;&nbsp;</a></span>bit_scan_reverse_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned seq::bit_scan_reverse_64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest set bit index in <em>bb</em>. Developed by Kim Walisch, Mark Dickinson. Undefined if bb==0. </p>

</div>
</div>
<a id="a4922210860b6f327b5fb7a5138882236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4922210860b6f327b5fb7a5138882236">&#9670;&nbsp;</a></span>bit_scan_reverse_8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned int seq::bit_scan_reverse_8 </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43ea7e90ba548509579455f13905d240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ea7e90ba548509579455f13905d240">&#9670;&nbsp;</a></span>bswap_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t seq::bswap_16 </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SwapByteOrder_16 - This function returns a byte-swapped representation of the 16-bit argument. </p>

</div>
</div>
<a id="a8b149fbd9ca094cb690819800c9f754e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b149fbd9ca094cb690819800c9f754e">&#9670;&nbsp;</a></span>bswap_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t seq::bswap_32 </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SwapByteOrder_32 - This function returns a byte-swapped representation of the 32-bit argument. </p>

</div>
</div>
<a id="ad02968f707921c4060800cbfcd96956b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02968f707921c4060800cbfcd96956b">&#9670;&nbsp;</a></span>bswap_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::bswap_64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SwapByteOrder_64 - This function returns a byte-swapped representation of the 64-bit argument. </p>

</div>
</div>
<a id="a6611a655add0de38badee7fcad961c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6611a655add0de38badee7fcad961c4b">&#9670;&nbsp;</a></span>consecutive_N_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ConsecutiveNBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned seq::consecutive_N_bits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of the first consecutive N bits within <em>num</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>number of consecutive bits to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first consecutive N bits within <em>num</em> </dd></dl>

</div>
</div>
<a id="a48515fc69dc7f83f81c6e0715999ba16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48515fc69dc7f83f81c6e0715999ba16">&#9670;&nbsp;</a></span>construct_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::construct_ptr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595642727b17c09f8ed3f1902addb13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595642727b17c09f8ed3f1902addb13b">&#9670;&nbsp;</a></span>count_digits_base_10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> unsigned seq::count_digits_base_10 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of digits used to represent an integer in base 10. This function only works for unsigned integral types </p>

</div>
</div>
<a id="ae09f4c319b21510f90dae6dc5b7d8656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09f4c319b21510f90dae6dc5b7d8656">&#9670;&nbsp;</a></span>destroy_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::destroy_ptr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6680f5c7e0d172b1f3cc7334306ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6680f5c7e0d172b1f3cc7334306ed5b">&#9670;&nbsp;</a></span>elapsed_microseconds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::elapsed_microseconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad75714ebe7ef4833c3a3a641d3389e39">high_def_timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab59a95e404977402f0b0cb994189dd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59a95e404977402f0b0cb994189dd4c">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare , class Al1 , LayoutManagement L1, bool S1, bool U1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt;Key, T, Compare, Al1, L1, S1, U1&gt;::size_type seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>

</div>
</div>
<a id="ad635125b29a71d98dd496a619aa2d3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad635125b29a71d98dd496a619aa2d3fc">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare , class Al1 , LayoutManagement L1, bool S1, bool U1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt;Key, Compare, Al1, L1, S1, U1&gt;::size_type seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>

</div>
</div>
<a id="a4a4674d3392bd75ab94dbb6d754a91f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4674d3392bd75ab94dbb6d754a91f7">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>container from which to erase </td></tr>
    <tr><td class="paramname">p</td><td>predicate that returns true if the element should be erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>

</div>
</div>
<a id="aa186b78abe0024b08ac9417eeb3b67dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa186b78abe0024b08ac9417eeb3b67dd">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>container from which to erase </td></tr>
    <tr><td class="paramname">p</td><td>predicate that returns true if the element should be erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>

</div>
</div>
<a id="a1c7f5113ac0f03f720b3a5cf96c20550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7f5113ac0f03f720b3a5cf96c20550">&#9670;&nbsp;</a></span>fmt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), void, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21b27d9d28ab49b4e36657f9e95013c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b27d9d28ab49b4e36657f9e95013c7">&#9670;&nbsp;</a></span>fmt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), void, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50efcf02fb38933039611940d459ae10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50efcf02fb38933039611940d459ae10">&#9670;&nbsp;</a></span>fmt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ... Ts, class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt;Ts...&gt;, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0294caef2f682aa43d45d96a74311dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0294caef2f682aa43d45d96a74311dba">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a> seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a floating point value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>decimal point character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod, and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="aac6fa5dbb2342554b8e0229a2517c05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6fa5dbb2342554b8e0229a2517c05e">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a> seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a floating point value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>decimal point character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod, and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="a3d671aafd486530c5efed00cf8da94ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d671aafd486530c5efed00cf8da94ba">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a> seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a floating point value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>decimal point character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod, and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="ad1f5c92eee4485b984df28c1ceb0f96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f5c92eee4485b984df28c1ceb0f96a">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a> seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an integral value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">base</td><td>integer base (default to 10) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for an integral pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>This function is similar to std::from_chars except for the following situations: </p><pre class="fragment">- For hexadecimal numbers, the (potential) '0x' prefix will be automatically detected and handled.
- Leading spaces are consumed.
- Leading '+' sign is valid.
- If the pattern is a valid integral text representation too large to be stored in a value, the full pattern will still be consumed,
the function will return a 'success' from_chars_result, and value will silently overflow.
- Reading a negative text representation in an unsigned variable is NOT valid.
</pre><p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="a9a68123ed035fdbc90e3a4dbe10c7017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a68123ed035fdbc90e3a4dbe10c7017">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream&amp; seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>chars_format::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a floating point value from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>dot character, usually '.' for 'C' locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an floating point value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>If the parsing fails (no floating point pattern was detected), the stream status will be set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587" title="End of file reached.">BadInputFormat</a> or <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a> depending on the situation, and stream get position will be reverted to its original state.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>This function is usefull when you need to read a huge amount of floating point values of a std::istream object. Internal benchmarks show that using <a class="el" href="namespaceseq.html#a8dd14a20a2e7b03cebe3d48e3ae5e2ff" title="Read an integral value from a seq::basic_input_stream object.">from_stream()</a> is around 20 faster (or more) than using <a class="el" href="namespaceseq.html#a368335418326de8bb38c9fba7642c027">std::istream::operator&gt;&gt;()</a>.</p>
<p><a class="el" href="namespaceseq.html#ad1f5c92eee4485b984df28c1ceb0f96a" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#a8dd14a20a2e7b03cebe3d48e3ae5e2ff" title="Read an integral value from a seq::basic_input_stream object.">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters.">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="ac74a811757834955b06125e00c5deaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74a811757834955b06125e00c5deaed">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream&amp; seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>chars_format::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a floating point value from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>dot character, usually '.' for 'C' locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an floating point value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>If the parsing fails (no floating point pattern was detected), the stream status will be set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587" title="End of file reached.">BadInputFormat</a> or <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a> depending on the situation, and stream get position will be reverted to its original state.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>This function is usefull when you need to read a huge amount of floating point values of a std::istream object. Internal benchmarks show that using <a class="el" href="namespaceseq.html#a8dd14a20a2e7b03cebe3d48e3ae5e2ff" title="Read an integral value from a seq::basic_input_stream object.">from_stream()</a> is around 20 faster (or more) than using <a class="el" href="namespaceseq.html#a368335418326de8bb38c9fba7642c027">std::istream::operator&gt;&gt;()</a>.</p>
<p><a class="el" href="namespaceseq.html#ad1f5c92eee4485b984df28c1ceb0f96a" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#a8dd14a20a2e7b03cebe3d48e3ae5e2ff" title="Read an integral value from a seq::basic_input_stream object.">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters.">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="ab1e3d3b18077453a7de1a33feb7d438a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e3d3b18077453a7de1a33feb7d438a">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream&amp; seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>chars_format::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a floating point value from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>dot character, usually '.' for 'C' locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an floating point value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>If the parsing fails (no floating point pattern was detected), the stream status will be set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587" title="End of file reached.">BadInputFormat</a> or <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a> depending on the situation, and stream get position will be reverted to its original state.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>This function is usefull when you need to read a huge amount of floating point values of a std::istream object. Internal benchmarks show that using <a class="el" href="namespaceseq.html#a8dd14a20a2e7b03cebe3d48e3ae5e2ff" title="Read an integral value from a seq::basic_input_stream object.">from_stream()</a> is around 20 faster (or more) than using <a class="el" href="namespaceseq.html#a368335418326de8bb38c9fba7642c027">std::istream::operator&gt;&gt;()</a>.</p>
<p><a class="el" href="namespaceseq.html#ad1f5c92eee4485b984df28c1ceb0f96a" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#a8dd14a20a2e7b03cebe3d48e3ae5e2ff" title="Read an integral value from a seq::basic_input_stream object.">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters.">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="a73b8ae631903ebbe7b9a67a8cd5e1c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b8ae631903ebbe7b9a67a8cd5e1c2a">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream&amp; seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a word from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full word from a stream object. In a text files, words are delimited by white-space characters (' ', '\t', '<br  />
', '\v', '\f', '\r', EOF). If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a>. </p>

</div>
</div>
<a id="a8dd14a20a2e7b03cebe3d48e3ae5e2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd14a20a2e7b03cebe3d48e3ae5e2ff">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream&amp; seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an integral value from a <a class="el" href="classseq_1_1basic__input__stream.html" title="Base class for input text streams.">seq::basic_input_stream</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">base</td><td>integer base (default to 10) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for an integral pattern. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>For hexadecimal numbers, the (potential) '0x' prefix will be automatically detected and handled. Leading spaces are consumed. If the pattern is a valid integral text representation too large to be stored in a value, the full pattern will still be consumed. Reading a negative text representation in an unsigned variable is not valid.</p>
<p>If the parsing fails (no integral pattern was detected), the stream status will be set to BadInputFormat or EndOfFile depending on the situation.</p>
<p><a class="el" href="namespaceseq.html#ad1f5c92eee4485b984df28c1ceb0f96a" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#a8dd14a20a2e7b03cebe3d48e3ae5e2ff" title="Read an integral value from a seq::basic_input_stream object.">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters.">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="aff00103371136fa3e5dd96eb74a400bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff00103371136fa3e5dd96eb74a400bb">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , size_t Ss, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream&amp; seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Ss, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a word from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full word from a stream object. In a text files, words are delimited by white-space characters (' ', '\t', '<br  />
', '\v', '\f', '\r', EOF). If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a>. </p>

</div>
</div>
<a id="aca5e1bd8af52c82c89100c6146c47e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5e1bd8af52c82c89100c6146c47e10">&#9670;&nbsp;</a></span>generate_random_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class String &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">String seq::generate_random_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15e52d40a551ef3e1dc395d1c93349aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e52d40a551ef3e1dc395d1c93349aa">&#9670;&nbsp;</a></span>get_memory_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::get_memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae671e0f695cb6f085d8255e0de4d2281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae671e0f695cb6f085d8255e0de4d2281">&#9670;&nbsp;</a></span>get_type_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int seq::get_type_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns type Id used by <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> as a unique type identifier. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique Id for type T </dd></dl>

</div>
</div>
<a id="a402011b5f9276ddc9680bc0c2b19b1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402011b5f9276ddc9680bc0c2b19b1ac">&#9670;&nbsp;</a></span>get_type_id&lt; char * &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; char * &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9da3f0204724ddc1fdba5f789bf26ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da3f0204724ddc1fdba5f789bf26ca7">&#9670;&nbsp;</a></span>get_type_id&lt; char &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; char &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22b299fb33498ab4f7ed6fbdd11ab656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b299fb33498ab4f7ed6fbdd11ab656">&#9670;&nbsp;</a></span>get_type_id&lt; const char * &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; const char * &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a287623ba796c4e37c9b4d210469a5848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287623ba796c4e37c9b4d210469a5848">&#9670;&nbsp;</a></span>get_type_id&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af403a261d3b265e926d12e067cbf1b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af403a261d3b265e926d12e067cbf1b14">&#9670;&nbsp;</a></span>get_type_id&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5504596c7066d0670dbb27070fe4108f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5504596c7066d0670dbb27070fe4108f">&#9670;&nbsp;</a></span>get_type_id&lt; int &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; int &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a270f8f53256ccbe680de58e8b295935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270f8f53256ccbe680de58e8b295935c">&#9670;&nbsp;</a></span>get_type_id&lt; long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b631b774d3ead5643468e96c3f75a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b631b774d3ead5643468e96c3f75a1f">&#9670;&nbsp;</a></span>get_type_id&lt; long double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; long double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1b12f8d796c5f68a531312d9013ca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b12f8d796c5f68a531312d9013ca8d">&#9670;&nbsp;</a></span>get_type_id&lt; long long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; long long &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74e66bbdc6a3730d5e1e5773fd873bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e66bbdc6a3730d5e1e5773fd873bd8">&#9670;&nbsp;</a></span>get_type_id&lt; short &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; short &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86bdf469671f96daaeaeae76df1add29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bdf469671f96daaeaeae76df1add29">&#9670;&nbsp;</a></span>get_type_id&lt; signed char &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; signed char &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55463d520234699844e33b644e823021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55463d520234699844e33b644e823021">&#9670;&nbsp;</a></span>get_type_id&lt; std::string &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; std::string &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e35629061325fb26ea45ef1567584ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e35629061325fb26ea45ef1567584ba">&#9670;&nbsp;</a></span>get_type_id&lt; tstring &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; <a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d958fc758855945fbb6e1c4c856aa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d958fc758855945fbb6e1c4c856aa72">&#9670;&nbsp;</a></span>get_type_id&lt; tstring_view &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d7751f74007ee1da9d4c8fad04244aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7751f74007ee1da9d4c8fad04244aa">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned char &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; unsigned char &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbda3cc28bfc463ad92655a81a7e8697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbda3cc28bfc463ad92655a81a7e8697">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned int &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; unsigned int &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d29ec40b45132cad26a58ee35eafbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d29ec40b45132cad26a58ee35eafbc1">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; unsigned long &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b8d3115e942c7ee280db3a773f5b290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8d3115e942c7ee280db3a773f5b290">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned long long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; unsigned long long &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a912a79946b016b195aaae872f3880531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912a79946b016b195aaae872f3880531">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned short &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="namespaceseq.html#ae671e0f695cb6f085d8255e0de4d2281">seq::get_type_id</a>&lt; unsigned short &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7aa0a287687aadd2106e1fb1ff32431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa0a287687aadd2106e1fb1ff32431f">&#9670;&nbsp;</a></span>hash_bytes_fnv1a()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::hash_bytes_fnv1a </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a hash value for input data using the fnv1a algorithm. This version reads the input buffer by chunks of sizeof(size_t). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>input buffer </td></tr>
    <tr><td class="paramname">len</td><td>input buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>computed hash value </dd></dl>

</div>
</div>
<a id="aba0458b86ee52bc2dd1471917dd424b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0458b86ee52bc2dd1471917dd424b8">&#9670;&nbsp;</a></span>hash_bytes_fnv1a_slow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::hash_bytes_fnv1a_slow </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a hash value for input data using the fnv1a algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>input buffer </td></tr>
    <tr><td class="paramname">len</td><td>input buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>computed hash value </dd></dl>

</div>
</div>
<a id="a11c1603678ff859a7ac75a082ecb97b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c1603678ff859a7ac75a082ecb97b2">&#9670;&nbsp;</a></span>hash_bytes_murmur64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::hash_bytes_murmur64 </td>
          <td>(</td>
          <td class="paramtype">const std::uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a hash value for input data using the murmurhash2 algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>input buffer </td></tr>
    <tr><td class="paramname">len</td><td>input buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>computed hash value </dd></dl>

</div>
</div>
<a id="a4ce0a7bad49b2b432d3b0565e5cbc3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce0a7bad49b2b432d3b0565e5cbc3c4">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::hash_combine </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>h2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine 2 hash values. Uses either murmurhash2 for 64 bits platform or the boost version for 32 bits platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h1</td><td>first hash value </td></tr>
    <tr><td class="paramname">h2</td><td>second hash value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combination of both hash value </dd></dl>

</div>
</div>
<a id="a03dcabc115ead85eb0b230c30e401d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dcabc115ead85eb0b230c30e401d20">&#9670;&nbsp;</a></span>is_arithmetic_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::is_arithmetic_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to an arithmetic type (floating point or integral) </p>

</div>
</div>
<a id="a7b388481b03b0e9394311721d0a775a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b388481b03b0e9394311721d0a775a7">&#9670;&nbsp;</a></span>is_floating_point_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::is_floating_point_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to a floating point type. </p>

</div>
</div>
<a id="ac3b539a9956d133181c00c77994436bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b539a9956d133181c00c77994436bf">&#9670;&nbsp;</a></span>is_integral_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::is_integral_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to an integral type. </p>

</div>
</div>
<a id="a6bccbbebeeee8688c45c1df3e9e7e6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bccbbebeeee8688c45c1df3e9e7e6b9">&#9670;&nbsp;</a></span>is_signed_integral_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::is_signed_integral_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to a signed integral type. </p>

</div>
</div>
<a id="a9a0f92caef2894b34d224402ac89c65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0f92caef2894b34d224402ac89c65a">&#9670;&nbsp;</a></span>is_string_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::is_string_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to a string type (std::string, tstring, tstring_view or const char*) </p>

</div>
</div>
<a id="a9db7ee7492e17303be3048c114e4264f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db7ee7492e17303be3048c114e4264f">&#9670;&nbsp;</a></span>is_unsigned_integral_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::is_unsigned_integral_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to an unsigned integral type. </p>

</div>
</div>
<a id="a413a264358b2b20fcf4388023a0e1f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413a264358b2b20fcf4388023a0e1f8d">&#9670;&nbsp;</a></span>make_any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Any , class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Any seq::make_any </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa604c9a7d58c994a56ff6e0ce62e7bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa604c9a7d58c994a56ff6e0ce62e7bd7">&#9670;&nbsp;</a></span>make_any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Any , class T , class U , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Any seq::make_any </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97e43145f833c1fb4c26fbc91e341564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e43145f833c1fb4c26fbc91e341564">&#9670;&nbsp;</a></span>negate_if_signed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt;T&gt;::type seq::negate_if_signed </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns -v if v is signed, v otherwise. </p>

</div>
</div>
<a id="ab2f848adb0c9d3ac36fb1c523850748b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f848adb0c9d3ac36fb1c523850748b">&#9670;&nbsp;</a></span>nth_bit_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned seq::nth_bit_set </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d6a00f67a9341cb4bcc99c107515229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6a00f67a9341cb4bcc99c107515229">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b03a0e86dff59b708f1f20240bcdfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b03a0e86dff59b708f1f20240bcdfdb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, L2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are not equals. </p>

</div>
</div>
<a id="afa48d4b3cf1891cd8ae3f021ad3f0e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa48d4b3cf1891cd8ae3f021ad3f0e71">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, L2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are not equals. </p>

</div>
</div>
<a id="ad0c63e362da26d374ed74adbcf3f6d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c63e362da26d374ed74adbcf3f6d27">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6912674e5ef451a9f0733279b436113e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6912674e5ef451a9f0733279b436113e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> for inequality, synthesized from operator==. </p>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare non equals, false otherwise </dd></dl>

</div>
</div>
<a id="a818f1ef96eceafb1f80fc069720a99e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818f1ef96eceafb1f80fc069720a99e5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> for inequality, synthesized from operator==. </p>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare non equals, false otherwise </dd></dl>

</div>
</div>
<a id="a948fa0ea1e3ce1689da9c6b62c096245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948fa0ea1e3ce1689da9c6b62c096245">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee04bc042e8f3ab7de2fcd2043b83e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee04bc042e8f3ab7de2fcd2043b83e7c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b6a796c87305524653d7265ae4da2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6a796c87305524653d7265ae4da2ff">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe32bc8987b500a2d007b0a068d48538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe32bc8987b500a2d007b0a068d48538">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9e28e6da6ec3562c1faef9ef00631d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e28e6da6ec3562c1faef9ef00631d6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa16ed00cc778ba6a0e21215120dedaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16ed00cc778ba6a0e21215120dedaf8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4daaf1a307da775f3767ab9e300f36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4daaf1a307da775f3767ab9e300f36a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1407693897892cd91dbb31683cf1e200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1407693897892cd91dbb31683cf1e200">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T&gt; seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f7fd51f3cc247331f7ed13b1b1cf4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7fd51f3cc247331f7ed13b1b1cf4ed">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed0caf1783a3f82d9cfc9d88e159b8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0caf1783a3f82d9cfc9d88e159b8a9">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a213087903db1d425d09460f104ba12af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213087903db1d425d09460f104ba12af">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55661fe2e7792e24a096eb01c961774f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55661fe2e7792e24a096eb01c961774f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4da0baa868f02d38d414b2dc1f288549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da0baa868f02d38d414b2dc1f288549">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size2, Al2&gt; &gt;::type seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae140a176dbb43c6b695adac9561c01da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae140a176dbb43c6b695adac9561c01da">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T&gt; seq::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5edaf549d71732fa081394b43ae7e438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edaf549d71732fa081394b43ae7e438">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T&gt;::difference_type seq::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfc02f75db7d73bb10c42d71a370c368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc02f75db7d73bb10c42d71a370c368">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c2ac9b96f995fff575fc24a8169cb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2ac9b96f995fff575fc24a8169cb3d">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7818cfce7c07b43a84c5cd16027c6e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7818cfce7c07b43a84c5cd16027c6e27">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d793a96fc5ac7087c067d0b129662d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d793a96fc5ac7087c067d0b129662d0">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a684e5860e1daf02e4d92177ab58d7e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684e5860e1daf02e4d92177ab58d7e47">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea4feaa3ec5619d0c601da47ed4245c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4feaa3ec5619d0c601da47ed4245c3">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7797b9c1954288017fdfe309b554454a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7797b9c1954288017fdfe309b554454a">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b6a7ec8e9a4fc0d7eaf0d5f523774ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6a7ec8e9a4fc0d7eaf0d5f523774ca">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48d82e80de97f55662208a343727653f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d82e80de97f55662208a343727653f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; seq::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>oss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9edd539db8412668d682cf9ff5e7a070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edd539db8412668d682cf9ff5e7a070">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7bf025c87b50f374d4e581963559c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bf025c87b50f374d4e581963559c30">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add444378c72974b32b72ab9740801e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add444378c72974b32b72ab9740801e30">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aedc2a4ddf5388c2ced30ccb8f562d675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc2a4ddf5388c2ced30ccb8f562d675">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecee5def0e45356420fe839d4492d515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecee5def0e45356420fe839d4492d515">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad008ee24c9386b09b25e912de5d4c1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad008ee24c9386b09b25e912de5d4c1a1">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56068d4d371f671c476f2d48a14c40c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56068d4d371f671c476f2d48a14c40c4">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8f6d50f3c32887116c4bae46c3429d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f6d50f3c32887116c4bae46c3429d4">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2d2328b5f70f42feabee51284c0b4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d2328b5f70f42feabee51284c0b4f4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eb611395bcf177863d2e3bb53432afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb611395bcf177863d2e3bb53432afc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, L2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position. </p>

</div>
</div>
<a id="a28f21073ae01bd19e5a6f141f38e5892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f21073ae01bd19e5a6f141f38e5892">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, L2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position. </p>

</div>
</div>
<a id="ab16afe94ff6844ae0e6a3a03b4aaca97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16afe94ff6844ae0e6a3a03b4aaca97">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1661245c4cb91cf0898e0c87fa1160d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1661245c4cb91cf0898e0c87fa1160d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> for equality. Two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> are considered equal if they contain the same pairs key-&gt;value. Key ordering is not considered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> </td></tr>
    <tr><td class="paramname">rhs</td><td>right <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare equals, false otherwise </dd></dl>

</div>
</div>
<a id="a6cd24b67e86b93a8639f533415cfd811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd24b67e86b93a8639f533415cfd811">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> for equality. Two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> are considered equal if they contain the same keys. Key ordering is not considered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> </td></tr>
    <tr><td class="paramname">rhs</td><td>right <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare equals, false otherwise </dd></dl>

</div>
</div>
<a id="a1ac06f782d2107c3cc7124399b4eb581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac06f782d2107c3cc7124399b4eb581">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a754af04dbc50b9221ab643cb662472cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754af04dbc50b9221ab643cb662472cc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab46515296513c942f8ea60c873def0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46515296513c942f8ea60c873def0c5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4f441a6b31df9530605a13ef51c148a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f441a6b31df9530605a13ef51c148a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d27edcb268d2f54a2aea63289ce60fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d27edcb268d2f54a2aea63289ce60fa">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f3482ce2ab94dc59b5b2b857802906f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3482ce2ab94dc59b5b2b857802906f">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af73cb013ab8de39759f3188c232bc768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73cb013ab8de39759f3188c232bc768">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd2d68d1bbe2979f2be27051a9190bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2d68d1bbe2979f2be27051a9190bc2">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a382805c206a702e81be578225f9b2a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382805c206a702e81be578225f9b2a6c">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29745acf13b1dd0c436e7fb11d39ddad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29745acf13b1dd0c436e7fb11d39ddad">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58cc10a31374b3edfd99aa9d766ad5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cc10a31374b3edfd99aa9d766ad5c7">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3422ba2ed76ef830f9a768efb0ab264b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3422ba2ed76ef830f9a768efb0ab264b">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e1833a5b86d9fe7f4aa324dc762ee7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1833a5b86d9fe7f4aa324dc762ee7f">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d1652748e87ae34ddb4e4aaee0c1047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1652748e87ae34ddb4e4aaee0c1047">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c78c77d93ada0613a00c80f01fe15da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c78c77d93ada0613a00c80f01fe15da">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af627534627450a46af42eae32dbac9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af627534627450a46af42eae32dbac9d6">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefbd22b85882e325ad2aa30cc80476fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbd22b85882e325ad2aa30cc80476fa">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a400d2d1d88be73ebe1ad7548c7242ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400d2d1d88be73ebe1ad7548c7242ee4">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0492edc203e24e4f2a815f88b63b6b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0492edc203e24e4f2a815f88b63b6b9c">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a099bb20d7de44b7e830799fea7f7a709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099bb20d7de44b7e830799fea7f7a709">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42b02d9de4bef32a8048a063ca879338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b02d9de4bef32a8048a063ca879338">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a368335418326de8bb38c9fba7642c027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368335418326de8bb38c9fba7642c027">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; seq::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>iss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e9f083253d23d9c760804a87995efe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9f083253d23d9c760804a87995efe2">&#9670;&nbsp;</a></span>popcnt16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned seq::popcnt16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08ad7cd23d956c6e3205dd20ff1629b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ad7cd23d956c6e3205dd20ff1629b3">&#9670;&nbsp;</a></span>popcnt32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t seq::popcnt32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93474d742382c06825212a479a720fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93474d742382c06825212a479a720fcb">&#9670;&nbsp;</a></span>popcnt64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::popcnt64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac360f9661dc5c8b69336408b4a96259a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac360f9661dc5c8b69336408b4a96259a">&#9670;&nbsp;</a></span>popcnt8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned seq::popcnt8 </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4af98bbd3b7d9b7d7cb552f6f3a8d220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af98bbd3b7d9b7d7cb552f6f3a8d220">&#9670;&nbsp;</a></span>pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt;Ts...&gt; seq::pos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a positional object used either by <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt()</a> or operator() of formatting object. </p>

</div>
</div>
<a id="a4b887df093a1fae4487fccd6c1949116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b887df093a1fae4487fccd6c1949116">&#9670;&nbsp;</a></span>print_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::print_null </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dc979c02b15bd647641e83db0cdfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc979c02b15bd647641e83db0cdfd6c">&#9670;&nbsp;</a></span>read_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t seq::read_16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 16 bits integer from <em>src</em>. </p>

</div>
</div>
<a id="a3fd204b49f8889e867693b7804ad1377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd204b49f8889e867693b7804ad1377">&#9670;&nbsp;</a></span>read_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t seq::read_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 32 bits integer from <em>src</em>. </p>

</div>
</div>
<a id="a881c8b8e6500cbc8c9e6dc07b4651633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881c8b8e6500cbc8c9e6dc07b4651633">&#9670;&nbsp;</a></span>read_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::read_64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 64 bits integer from <em>src</em>. </p>

</div>
</div>
<a id="ab3af9223b2fccb354d936f83997b13f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3af9223b2fccb354d936f83997b13f4">&#9670;&nbsp;</a></span>read_BE_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t seq::read_BE_16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 16 bits integer from <em>src</em> in big endian order. </p>

</div>
</div>
<a id="ad8e3a29f545268e8a71e23dbd2da47d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e3a29f545268e8a71e23dbd2da47d7">&#9670;&nbsp;</a></span>read_BE_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t seq::read_BE_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 32 bits integer from <em>src</em> in big endian order. </p>

</div>
</div>
<a id="a82004ca023848af43c197128cfc598f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82004ca023848af43c197128cfc598f1">&#9670;&nbsp;</a></span>read_BE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::read_BE_64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 64 bits integer from <em>src</em> in big endian order. </p>

</div>
</div>
<a id="a6d3ee7edc45051b7185cbc127044752f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3ee7edc45051b7185cbc127044752f">&#9670;&nbsp;</a></span>read_BE_size_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::read_BE_size_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads size_t object from <em>src</em> in big endian order. </p>

</div>
</div>
<a id="af61414f482d42dd1e59f8a558d76ff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61414f482d42dd1e59f8a558d76ff93">&#9670;&nbsp;</a></span>read_LE_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t seq::read_LE_16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read 16 bits integer from <em>src</em> in little endian order. </p>

</div>
</div>
<a id="a1c3e5f6a4d449a97ac34349d47846aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3e5f6a4d449a97ac34349d47846aca">&#9670;&nbsp;</a></span>read_LE_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t seq::read_LE_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read 32 bits integer from <em>src</em> in little endian order. </p>

</div>
</div>
<a id="a6f80bab6226f672c5ede30f5cce325b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f80bab6226f672c5ede30f5cce325b4">&#9670;&nbsp;</a></span>read_LE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::read_LE_64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read 64 bits integer from <em>src</em> in little endian order. </p>

</div>
</div>
<a id="af540dfc5f9a344a81c4b1c3e1b7fcf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af540dfc5f9a344a81c4b1c3e1b7fcf95">&#9670;&nbsp;</a></span>read_LE_size_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::read_LE_size_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads size_t object from <em>src</em> in little endian order. </p>

</div>
</div>
<a id="afe93dbc8ebf7707cd6a49a40efb69516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe93dbc8ebf7707cd6a49a40efb69516">&#9670;&nbsp;</a></span>read_line_from_stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream&amp; seq::read_line_from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a line from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full line from a stream object. In a text files, lines are delimited by characters '<br  />
', '\r' or EOF. If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a>. </p>

</div>
</div>
<a id="a68c61bfb64e7882fc5018cad8cb51fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c61bfb64e7882fc5018cad8cb51fd4">&#9670;&nbsp;</a></span>read_line_from_stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , size_t Ss, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> Stream&amp; seq::read_line_from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Ss, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a line from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full line from a stream object. In a text files, lines are delimited by characters '<br  />
', '\r' or EOF. If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a>. </p>

</div>
</div>
<a id="af19d29d42a2dde5c53e17ba342ac7828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19d29d42a2dde5c53e17ba342ac7828">&#9670;&nbsp;</a></span>read_ptr_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uintptr_t seq::read_ptr_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads uintptr_t integer from <em>src</em>. </p>

</div>
</div>
<a id="a234f60d7f588e4060eb0d094150cbd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234f60d7f588e4060eb0d094150cbd46">&#9670;&nbsp;</a></span>read_size_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::read_size_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads size_t object from <em>src</em>. </p>

</div>
</div>
<a id="a97851d71ded4c7928aabd76f4280d268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97851d71ded4c7928aabd76f4280d268">&#9670;&nbsp;</a></span>register_any_conversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_conversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7a515ea06834d35cedd4e4f9c4ba1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a515ea06834d35cedd4e4f9c4ba1b0">&#9670;&nbsp;</a></span>register_any_conversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_conversion </td>
          <td>(</td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb61336a531e99a11a888883a46d0f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb61336a531e99a11a888883a46d0f01">&#9670;&nbsp;</a></span>register_any_equal_comparison() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_equal_comparison </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa783de724c82de2264d98a3437294df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa783de724c82de2264d98a3437294df">&#9670;&nbsp;</a></span>register_any_equal_comparison() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_equal_comparison </td>
          <td>(</td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab390e9bf772c9a88f9f48c5bd360d7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab390e9bf772c9a88f9f48c5bd360d7ed">&#9670;&nbsp;</a></span>register_any_less_comparison() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_less_comparison </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b0810417829f24c04037720cfe1cc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0810417829f24c04037720cfe1cc92">&#9670;&nbsp;</a></span>register_any_less_comparison() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_less_comparison </td>
          <td>(</td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acabfa3eaf9a03808f516c1c71d521dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabfa3eaf9a03808f516c1c71d521dee">&#9670;&nbsp;</a></span>reset_memory_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seq::reset_memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e09173d3e2cbd2e90fde65284d6a362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e09173d3e2cbd2e90fde65284d6a362">&#9670;&nbsp;</a></span>start_timer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::start_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad75714ebe7ef4833c3a3a641d3389e39">high_def_timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07cfb914c6655f3fac351e92d3467782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cfb914c6655f3fac351e92d3467782">&#9670;&nbsp;</a></span>string_data() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78db8ea6da034c3a306ddfda73895cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78db8ea6da034c3a306ddfda73895cdf">&#9670;&nbsp;</a></span>string_data() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb3e5871a80d139dfc445702677436d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3e5871a80d139dfc445702677436d6">&#9670;&nbsp;</a></span>string_data() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t S, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char* seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0a4e70902832fb7a5b4098d8ea1d7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a4e70902832fb7a5b4098d8ea1d7aa">&#9670;&nbsp;</a></span>string_data() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed50f805163eb7f65b9f6b7fadbb2b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed50f805163eb7f65b9f6b7fadbb2b21">&#9670;&nbsp;</a></span>string_size() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8ca2f2c8716a04f750b46cda23c9a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ca2f2c8716a04f750b46cda23c9a42">&#9670;&nbsp;</a></span>string_size() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eb2edfe41e69b0f8116ffb2e729c680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb2edfe41e69b0f8116ffb2e729c680">&#9670;&nbsp;</a></span>string_size() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t S, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a184b1c0786a832e217d7c17843cc765a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184b1c0786a832e217d7c17843cc765a">&#9670;&nbsp;</a></span>string_size() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad863fcfc143b646f5a2f2362a1327575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad863fcfc143b646f5a2f2362a1327575">&#9670;&nbsp;</a></span>tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seq::tick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a295df44c0aa1b1bd24f09fc99530a445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295df44c0aa1b1bd24f09fc99530a445">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad80e2e70627dd4598cda06a37b7767b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80e2e70627dd4598cda06a37b7767b6">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first output character </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>input value to convert to string </td></tr>
    <tr><td class="paramname">base</td><td>integer base (default to 10) </td></tr>
    <tr><td class="paramname">fmt</td><td>optional format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">to_chars_result</a> object</dd></dl>
<p>value is converted to a string of digits in the given base (with no redundant leading zeroes by default). Digits in the range 10..35 (inclusive) are represented as lowercase characters a..z by default. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type char as the type of the parameter value. This function produces a similar output as std::to_chars.</p>
<p>Output formatting can be controlled through a #integral_chars_format object:</p><ul>
<li>Digits in the range 10..35 (inclusive) can be represented as uppercase characters A..Z with <a class="el" href="structseq_1_1integral__chars__format.html#acafd17ef17d30b606b9c7087ec7e8d73" title="Output upper characters for hexadecimal numbers.">integral_chars_format::upper_case</a></li>
<li>For base 16, a trailing '0x' can be added with <a class="el" href="structseq_1_1integral__chars__format.html#adbac65c685a9d5c9021e228cee354eed" title="Add &#39;0x&#39; prefix to hexadecimal numbers.">integral_chars_format::hex_prefix</a></li>
<li>A minimum width (in number of digits) can be specified to add leading zeros with <a class="el" href="structseq_1_1integral__chars__format.html#a7fd219f1f9f4a2d0760313d06a378f3a" title="Minimum digits to represent integral types (use zero padding).">integral_chars_format::integral_min_width</a></li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">seq::to_chars_result</a> such that ec equals value-initialized std::errc and ptr is the one-past-the-end pointer of the characters written. Note that the string is not NULL-terminated.</p>
<p>On error, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">seq::to_chars_result</a> holding std::errc::value_too_large in ec, a copy of the value last in ptr, and leaves the contents of the range[first, last) in unspecified state. </p>

</div>
</div>
<a id="a55bcd11b01a3f09227c80c355d84c28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bcd11b01a3f09227c80c355d84c28d">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2ce07ea09c6b1253bd62111853a01fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ce07ea09c6b1253bd62111853a01fc">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe570a1e00892b6ed78277b2939477fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe570a1e00892b6ed78277b2939477fd">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>exp</em> = <code>'e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00b551a6b9a237e00485171e598b17ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b551a6b9a237e00485171e598b17ed">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first output character </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>input value to convert to string </td></tr>
    <tr><td class="paramname">fmt</td><td>floating-point formatting to use, a bitmask of type <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682" title="A BitmaskType used to specify floating-point formatting for seq::to_chars. This is similar to std::ch...">seq::chars_format</a> </td></tr>
    <tr><td class="paramname">precision</td><td>maximum digits after the radix point </td></tr>
    <tr><td class="paramname">fmt</td><td>optional format </td></tr>
    <tr><td class="paramname">dot</td><td>optional decimal point sequence, default to "." </td></tr>
    <tr><td class="paramname">exp</td><td>optional exponential character, default to 'e' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">to_chars_result</a> object</dd></dl>
<p>value is converted to a string as if by std::printf in the default ("C") locale (with some differences, see below). This function DOES NOT provide exact formatting of the input unlike printf familly of functions.</p>
<p>The conversion specifier is 'f' or 'e' (resolving in favor of f in case of a tie), chosen according to the requirement for a shortest representation: the string representation consists of the smallest number of characters such that there is at least one digit before the radix point (if present).</p>
<p>The conversion specified for the as-if printf is 'f' if fmt is seq::chars_format::fixed, 'e' if fmt is seq::chars_format::scientific, and 'g' if fmt is chars_format::general (default).</p>
<p>If the precision is specified by the parameter 'precision', this function will output up-to (but to necessarily exactly) 'precision' digits after the radix point. The default precision is 6. This function will always try to output the smallest possible character sequence. If 'dot' is specified, it will replace the '.' decimal point used by the "C" locale.</p>
<p>If 'exp' is specified, it will replace the 'e' exponent character used by the "C" locale.</p>
<p>NaN and infinit values are handled by this function.</p>
<p>On success, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">seq::to_chars_result</a> such that ec equals value-initialized std::errc and ptr is the one-past-the-end pointer of the characters written. Note that the string is not NULL-terminated.</p>
<p>On error, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">seq::to_chars_result</a> holding std::errc::value_too_large in ec, a copy of the value last in ptr, and leaves the contents of the range[first, last) in unspecified state.</p>
<p>There are currently a lot of different algorithms to provide fast and exact convertion of floating point values to strings: ryu, grisu-exact, dragonbox... This function tries to provide a faster and lighter alternative when exact precision is not a requirement (which is my case). Internal benchmarks show that convertiing double values to string using this function is around 2 times faster than with ryu library for scientific or general formatting, and 3 times faster with fixed formatting.</p>
<p>When converting double values, obtained strings are similar to the result of printf in 100% of the cases when the required precision is below 12. After that, the ratio decreases to 87% of exactitude for a precision of 17. Converting a very high (or very small) value with the 'f' specifier will usually produce slightly different output, especially in the "garbade" digits.</p>
<p>Use this function when you need very fast formatting of a huge amount of floating point values without exact formatting requirement. </p>

</div>
</div>
<a id="a9eaa974695ff6a6769addd3a96b41404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaa974695ff6a6769addd3a96b41404">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f18559369db93f332cd9af2d5a8d49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f18559369db93f332cd9af2d5a8d49d">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>exp</em> = <code>'e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8cc32ae6f827f4d47d630c2380391d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cc32ae6f827f4d47d630c2380391d7">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a129fc53b61e8c0e747045b23df5d1062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129fc53b61e8c0e747045b23df5d1062">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23e2d522a9be477687ce8a99832f5d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e2d522a9be477687ce8a99832f5d9d">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade72bd4859446d94c240d219e7dd8dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade72bd4859446d94c240d219e7dd8dc4">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>exp</em> = <code>'e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7892cafa4dd725dee3ee0945aeea1652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7892cafa4dd725dee3ee0945aeea1652">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86dba7a492de53017a087ddd3dab4580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86dba7a492de53017a087ddd3dab4580">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37387ff734e6cbbd35d075ec4ce97361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37387ff734e6cbbd35d075ec4ce97361">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a70b9f25eca44e1a2d0a28b6fce9fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a70b9f25eca44e1a2d0a28b6fce9fe9">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc313ebf8c04e9029d7b04999f018a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc313ebf8c04e9029d7b04999f018a34">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76fbab5b1b8f89a5bbc1dea15277e3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fbab5b1b8f89a5bbc1dea15277e3cb">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff467499d43b24b158dbdf27563e6228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff467499d43b24b158dbdf27563e6228">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa67a5a24c6b6a856cf92230bc93bc2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67a5a24c6b6a856cf92230bc93bc2ab">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78c888bf0cbe7fd25536a699a803ce54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c888bf0cbe7fd25536a699a803ce54">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a> seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d21556f69c13e311f06e94da75c1792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d21556f69c13e311f06e94da75c1792">&#9670;&nbsp;</a></span>to_int() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::to_int </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; const T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf81691741d518d15f0faaf1da2f015a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf81691741d518d15f0faaf1da2f015a">&#9670;&nbsp;</a></span>to_int() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::to_int </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae96cdb73265a09784b8f3e8cbc777328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96cdb73265a09784b8f3e8cbc777328">&#9670;&nbsp;</a></span>to_int() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::to_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7a9cdadd4df8f31f3b1fd39cebf350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a9cdadd4df8f31f3b1fd39cebf350e">&#9670;&nbsp;</a></span>to_int() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::to_int </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84e0fbe51f6e0fd8e54e91864b14ee86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e0fbe51f6e0fd8e54e91864b14ee86">&#9670;&nbsp;</a></span>to_int() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t S, class AL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t seq::to_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, AL &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c3fc02a69112af58e297963a9e4c08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3fc02a69112af58e297963a9e4c08c">&#9670;&nbsp;</a></span>tock_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::tock_ms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af47d4cfe851a2c80ba696a4b90905c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47d4cfe851a2c80ba696a4b90905c7c">&#9670;&nbsp;</a></span>tock_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::tock_s </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ebacd959a1a167aec6e024961697304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebacd959a1a167aec6e024961697304">&#9670;&nbsp;</a></span>tock_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::tock_us </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1349a44a2ff37300a5c72a03780780fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1349a44a2ff37300a5c72a03780780fe">&#9670;&nbsp;</a></span>unique_ptr_delete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::unique_ptr_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate pointer previously held by a std::unqiue_ptr&lt;T,unique_ptr_deleter&lt;T&gt; &gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aa0f34c5b9efbaacd24ae215c6ebdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa0f34c5b9efbaacd24ae215c6ebdfe">&#9670;&nbsp;</a></span>write_LE_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_LE_16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 16 bits integer <em>value</em> to <em>dst</em> in little endian order. </p>

</div>
</div>
<a id="abbce06d3b6c0dd24ef956b3bba564914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbce06d3b6c0dd24ef956b3bba564914">&#9670;&nbsp;</a></span>write_LE_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_LE_32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 32 bits integer <em>value</em> to <em>dst</em> in little endian order. </p>

</div>
</div>
<a id="a2dd16ebc1860bdc316a5f83c8210a361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd16ebc1860bdc316a5f83c8210a361">&#9670;&nbsp;</a></span>write_LE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_LE_64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 64 bits integer <em>value</em> to <em>dst</em> in little endian order. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7847ff182c5998204ab1a9f404d175a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7847ff182c5998204ab1a9f404d175a6">&#9670;&nbsp;</a></span>constexpr_if</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsL1, class L1 , class L2 , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(std::declval&lt;<a class="el" href="structseq_1_1detail_1_1_call_lambda.html">detail::CallLambda</a>&lt;L1, L2, IsL1&gt;&amp;&gt;()(std::declval&lt;L1&amp;&gt;(), std::declval&lt;L2&amp;&gt;(),std::declval&lt;Args&gt;()...)) seq::constexpr_if(const L1 &amp;l1, const L2 &amp;l2, Args &amp;&amp;... args)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
