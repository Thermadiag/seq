<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceseq.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">seq Namespace Reference<div class="ingroups"><a class="el" href="group__bits.html">Bits: collection of functions for low level bits manipulation.</a> &#124; <a class="el" href="group__charconv.html">Charconv: arithmetic value convertion from/to string</a> &#124; <a class="el" href="group__containers.html">Containers: original STL-like containers</a> &#124; <a class="el" href="group__format.html">Format: Type safe formatting module</a> &#124; <a class="el" href="group__hash.html">Hash: small collection of hash utilities</a> &#124; <a class="el" href="group__memory.html">Memory: collection of tools for memory management</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceseq_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceseq_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in <em>value</em>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator class with custom alignment.  <a href="classseq_1_1aligned__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1aligned__allocator_3_01_t_00_01std_1_1allocator_3_01_t_01_4_00_01_align_01_4.html">aligned_allocator&lt; T, std::allocator&lt; T &gt;, Align &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__base.html">any_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base interface for <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> class.  <a href="structseq_1_1any__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__default__interface.html">any_default_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default interface for <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a>.  <a href="structseq_1_1any__default__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> for non hashable types.  <a href="structseq_1_1any__no__hash__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1any__type__info.html">any_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class representing a type and related functions.  <a href="classseq_1_1any__type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__typed__type__info.html">any_typed_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classseq_1_1any__type__info.html" title="Base class representing a type and related functions.">any_type_info</a> for specific type (Type Erasure)  <a href="structseq_1_1any__typed__type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1assign__alloc.html">assign_alloc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1base__ostream__format.html">base_ostream_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for formatting objects.  <a href="structseq_1_1base__ostream__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1basic__input__stream.html">basic_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for input text streams.  <a href="classseq_1_1basic__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1basic__nullbuf.html">basic_nullbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1block__object__allocation.html">block_object_allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to MaxSize objects by step of BlockSize.  <a href="structseq_1_1block__object__allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1buffer__input__stream.html">buffer_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream working on a sequence of characters.  <a href="classseq_1_1buffer__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1comp__wrapper.html">comp_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary comparison wrapper for using STL algorithm on cvector with custom comparators. Use <a class="el" href="namespaceseq.html#ae02fc574f6876f28fef03044ed31569e" title="Create a comparison functor that can be used by algorithms working on cvector objects.">seq::make_comparator</a> to build &amp; <a class="el" href="structseq_1_1comp__wrapper.html" title="Binary comparison wrapper for using STL algorithm on cvector with custom comparators....">comp_wrapper</a> object.  <a href="structseq_1_1comp__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1context__ratio.html">context_ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the maximum number of decompression contexts a cvector can use. The number of contexts is either a fixed value or a ratio of the cvector bucket count. Use ContextRatio::Fixed to define a fixed number of contexts, or ContextRatio::Ratio to define a fraction of the bucket count. In this case (ratio), the number of contexts is equal to bucket_count/(float)ratio_value.  <a href="classseq_1_1context__ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient random access iterator on a constant value.  <a href="classseq_1_1cvalue__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html">cvector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector like class using compression to store its elements  <a href="classseq_1_1cvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html">devector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-ending vector implementation which can be optimized for several use case.  <a href="classseq_1_1devector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1disable__ostream.html">disable_ostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1external__allocator.html">external_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stl conforming allocator wrapper using an external class to perform the allocation.  <a href="classseq_1_1external__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1file__input__stream.html">file_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream working on a FILE pointer.  <a href="classseq_1_1file__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__map.html">flat_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted associative container that contains key-value pairs with unique keys similar to boost::flat_map with faster insertion/deletion of single values  <a href="classseq_1_1flat__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multimap.html">flat_multimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted container similar to boost::flat_multimap with faster insertion/deletion of single values  <a href="classseq_1_1flat__multimap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values  <a href="classseq_1_1flat__multiset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html">flat_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted container similar to boost::flat_set with faster insertion/deletion of single values  <a href="classseq_1_1flat__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for <a class="el" href="namespaceseq.html#ac422fc75d3e6f011374ffeed3683da55" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> functions, similar to std::from_chars_result.  <a href="structseq_1_1from__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html">hold_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::any like class optimized to build heterogeneous containers.  <a href="classseq_1_1hold__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the return type of <a class="el" href="namespaceseq.html#a7c279fa143d4e6216df953924ce47406" title="Returns -v if v is signed, v otherwise.">seq::negate_if_signed</a> and <a class="el" href="namespaceseq.html#ab6f8f4791e95dce2f0a4298ff8e82797" title="Returns absolute value of v.">seq::abs</a>.  <a href="structseq_1_1integer__abs__return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_011_01_4.html">integer_abs_return&lt; T, true, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_012_01_4.html">integer_abs_return&lt; T, true, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_014_01_4.html">integer_abs_return&lt; T, true, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_018_01_4.html">integer_abs_return&lt; T, true, 8 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__max.html">integer_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integer type maximum value at compile time.  <a href="structseq_1_1integer__max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__max_3_01_t_00_01false_01_4.html">integer_max&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__min.html">integer_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integer type minimum value at compile time.  <a href="structseq_1_1integer__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__min_3_01_t_00_01false_01_4.html">integer_min&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for integer to string conversion using <a class="el" href="namespaceseq.html#a9e1cfb2de75c85497d57702430705b1c" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a>.  <a href="structseq_1_1integral__chars__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string.html">is_allocated_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a>, std::string, but not tstring_view.  <a href="structseq_1_1is__allocated__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string_3_01std_1_1string_01_4.html">is_allocated_string&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string_3_01tiny__string_3_01_s_00_01_al_01_4_01_4.html">is_allocated_string&lt; tiny_string&lt; S, Al &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string_3_01tstring__view_01_4.html">is_allocated_string&lt; tstring_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__equal__comparable.html">is_equal_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type supports equality comparison with operator ==.  <a href="classseq_1_1is__equal__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__formattable.html">is_formattable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given type is formattable using <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt()</a>  <a href="structseq_1_1is__formattable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string.html">is_generic_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect all possible string types (std::string, tstring, tstring_view, std::string_view, const char*, char*.  <a href="structseq_1_1is__generic__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01char_01_5_01_4.html">is_generic_string&lt; char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01const_01char_01_5_01_4.html">is_generic_string&lt; const char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01std_1_1string_01_4.html">is_generic_string&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01tiny__string_3_01_s_00_01_al_01_4_01_4.html">is_generic_string&lt; tiny_string&lt; S, Al &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view.html">is_generic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect generic string view: tstring_view, std::string_view, char*, const char*.  <a href="structseq_1_1is__generic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view_3_01char_01_5_01_4.html">is_generic_string_view&lt; char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view_3_01const_01char_01_5_01_4.html">is_generic_string_view&lt; const char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view_3_01tstring__view_01_4.html">is_generic_string_view&lt; tstring_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__hashable.html">is_hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type is hashable with std::hash. True by default, optimistically assume that all types are hashable. Used by <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">seq::hold_any</a>.  <a href="structseq_1_1is__hashable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__invocable.html">is_invocable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type supports invocation with signature void(Args ...) Equivalent to C++17 std::is_invocable.  <a href="structseq_1_1is__invocable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__invocable__r.html">is_invocable_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type supports invocation with signature R(Args ...) Equivalent to C++17 std::is_invocable_r.  <a href="structseq_1_1is__invocable__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__istreamable.html">is_istreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type can be read from a std::istream object.  <a href="classseq_1_1is__istreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__less__comparable.html">is_less_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type supports comparison with operator &lt;.  <a href="classseq_1_1is__less__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__object__pool.html">is_object_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__object__pool_3_01object__pool_3_01_t_00_01_allocator_00_01_align_00_01object__aa897b5fd959a84c29154e339081634cc.html">is_object_pool&lt; object_pool&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type is an object pool.  <a href="structseq_1_1is__object__pool_3_01object__pool_3_01_t_00_01_allocator_00_01_align_00_01object__aa897b5fd959a84c29154e339081634cc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__ostreamable.html">is_ostreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type can be streamed to a std::ostream object.  <a href="classseq_1_1is__ostreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__parallel__object__pool.html">is_parallel_object_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__parallel__object__pool_3_01parallel__object__pool_3_01_t_00_01_al_00_01_a_00_01_o_00_01_g_01_4_01_4.html">is_parallel_object_pool&lt; parallel_object_pool&lt; T, Al, A, O, G &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable.html">is_relocatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait telling if a class is relocatable or not.  <a href="structseq_1_1is__relocatable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01detail_1_1_store_bucket_3_01_t_00_01_allocator_00_01_value_compdf720ebec973c8da48b23df61e3cbc7a.html">is_relocatable&lt; detail::StoreBucket&lt; T, Allocator, ValueCompare, StoreBackValues, IsArithmetic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01detail_1_1_store_bucket_3_01_t_00_01_allocator_00_01_value_compa4c3de8b1ed892809670dad1cad5c7f7.html">is_relocatable&lt; detail::StoreBucket&lt; T, Allocator, ValueCompare, true, true &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01devector_3_01_t_00_01_alloc_00_01_f_01_4_01_4.html">is_relocatable&lt; devector&lt; T, Alloc, F &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structseq_1_1is__relocatable.html" title="Type trait telling if a class is relocatable or not.">is_relocatable</a> for devector.  <a href="structseq_1_1is__relocatable_3_01devector_3_01_t_00_01_alloc_00_01_f_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01sequence_3_01_t_00_01_al_00_01_l_00_01_a_01_4_01_4.html">is_relocatable&lt; sequence&lt; T, Al, L, A &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structseq_1_1is__relocatable.html" title="Type trait telling if a class is relocatable or not.">is_relocatable</a> for sequence type.  <a href="structseq_1_1is__relocatable_3_01sequence_3_01_t_00_01_al_00_01_l_00_01_a_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1allocator_3_01_t_01_4_01_4.html">is_relocatable&lt; std::allocator&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1pair_3_01_t_00_01_v_01_4_01_4.html">is_relocatable&lt; std::pair&lt; T, V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1shared__ptr_3_01_t_01_4_01_4.html">is_relocatable&lt; std::shared_ptr&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1unique__ptr_3_01_t_00_01_d_01_4_01_4.html">is_relocatable&lt; std::unique_ptr&lt; T, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01tiny__string_3_01_s_00_01_alloc_01_4_01_4.html">is_relocatable&lt; tiny_string&lt; S, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01view__allocator_01_4.html">is_relocatable&lt; view_allocator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__string__view.html">is_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect tstring_view or std::string_view.  <a href="structseq_1_1is__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__string__view_3_01tstring__view_01_4.html">is_string_view&lt; tstring_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__tiny__string.html">is_tiny_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a>.  <a href="structseq_1_1is__tiny__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__tiny__string_3_01tiny__string_3_01_s_00_01_al_01_4_01_4.html">is_tiny_string&lt; tiny_string&lt; S, Al &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__unique__ptr.html">is_unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits std::true_type is T is of type std::unique_ptr&lt;...&gt;, false otherwise.  <a href="structseq_1_1is__unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__unique__ptr_3_01std_1_1unique__ptr_3_01_t_00_01_del_01_4_01_4.html">is_unique_ptr&lt; std::unique_ptr&lt; T, Del &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1linear__object__allocation.html">linear_object_allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to MaxSize objects by step of 1.  <a href="structseq_1_1linear__object__allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1lock__guard.html">lock_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic lock guard class.  <a href="classseq_1_1lock__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1move__alloc.html">move_alloc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1null__format.html">null_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placehoder when reusing a formatting object.  <a href="structseq_1_1null__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1null__lock.html">null_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumy lock class that basically does nothing.  <a href="structseq_1_1null__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1numeric__format.html">numeric_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting options for arithmetic types.  <a href="classseq_1_1numeric__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__allocator.html">object_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stl conforming allocator based on an object pool class.  <a href="classseq_1_1object__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html">object_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object pool class used to allocate objects of type T.  <a href="classseq_1_1object__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1object__pool__stats.html">object_pool_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class gathering statistics for <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">seq::object_pool</a> or <a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool.">seq::parallel_object_pool</a>.  <a href="structseq_1_1object__pool__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__map.html">ordered_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.  <a href="classseq_1_1ordered__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.  <a href="classseq_1_1ordered__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format.html">ostream_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number and string formatting class.  <a href="classseq_1_1ostream__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format_3_01hold__any_3_01_interface_00_01_s_00_01_a_01_4_01_4.html">ostream_format&lt; hold_any&lt; Interface, S, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format_3_01ostream__format_3_01_t_01_4_01_4.html">ostream_format&lt; ostream_format&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class.">ostream_format</a>.  <a href="classseq_1_1ostream__format_3_01ostream__format_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free parallel object pool.  <a href="classseq_1_1parallel__object__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1pow__object__allocation.html">pow_object_allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to MaxSize objects using power of 2 steps.  <a href="structseq_1_1pow__object__allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1random__float__genertor.html">random_float_genertor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, generate random floating point number on the whole representable range (including potential infinit values)  <a href="classseq_1_1random__float__genertor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html">sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sequence is an ordered container supporting constant time insertion at both end and constant time removal anywhere.  <a href="classseq_1_1sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1shared__ptr__allocation.html">shared_ptr_allocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1spinlock.html">spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight and fast spinlock implementation based on <a href="https://rigtorp.se/spinlock/">https://rigtorp.se/spinlock/</a>.  <a href="classseq_1_1spinlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1static__bit__scan__reverse.html">static_bit_scan_reverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of bit_scan_reverse.  <a href="structseq_1_1static__bit__scan__reverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1static__bit__scan__reverse_3_010_u_l_l_01_4.html">static_bit_scan_reverse&lt; 0ULL &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1static__bit__scan__reverse_3_011_01_4.html">static_bit_scan_reverse&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1std__input__stream.html">std_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream working on a std::istream.  <a href="classseq_1_1std__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1streambuf__size.html">streambuf_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streambuf that stores the number of outputed characters.  <a href="classseq_1_1streambuf__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tagged__pointer.html">tagged_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged pointer class.  <a href="classseq_1_1tagged__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tagged__pointer_3_01void_00_01_type_00_01_user_defined_alignment_01_4.html">tagged_pointer&lt; void, Type, UserDefinedAlignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1test__error.html">test_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown for failed tests.  <a href="classseq_1_1test__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector.">seq::tiered_vector</a> is a std::deque like container implemented as a tiered-vector.  <a href="classseq_1_1tiered__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String class with a similar interface and requirements than std::string.  <a href="classseq_1_1tiny__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html">tiny_string&lt; 0, view_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a> for string views. You should use the global typedef tstring_view equivalent to <a class="el" href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html" title="Specialization of tiny_string for string views. You should use the global typedef tstring_view equiva...">tiny_string&lt;0,view_allocator&gt;</a>. Provides a similar interface to std::string_view. See <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a> documentation for more details.  <a href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for <a class="el" href="namespaceseq.html#a9e1cfb2de75c85497d57702430705b1c" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a> functions, similar to std::to_chars_result.  <a href="structseq_1_1to__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1unique__ptr__deleter.html">unique_ptr_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleter class for std::unique_ptr when used with #object_pool or #parallel_object_pool.  <a href="structseq_1_1unique__ptr__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1view__allocator.html">view_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type for tiny string view.  <a href="structseq_1_1view__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1width__format.html">width_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the width formatting for a any formatting object.  <a href="structseq_1_1width__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24ef193cef19271b9b18ce6c74fc5b54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">any</a> = <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;&gt;</td></tr>
<tr class="separator:a24ef193cef19271b9b18ce6c74fc5b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec98840dd82cf3a3207402caa66c73f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">nh_any</a> = <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; <a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a> &gt;</td></tr>
<tr class="separator:a2ec98840dd82cf3a3207402caa66c73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2b0aba572fc96bdcec68b500577b5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6d2b0aba572fc96bdcec68b500577b5b">max_align_t</a> = std::max_align_t</td></tr>
<tr class="separator:a6d2b0aba572fc96bdcec68b500577b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802ef6dd5cb892731a06e6699a27edf8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a802ef6dd5cb892731a06e6699a27edf8">nullbuf</a> = <a class="el" href="structseq_1_1basic__nullbuf.html">basic_nullbuf</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a802ef6dd5cb892731a06e6699a27edf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, alias for null buffer, to be used with c++ iostreams.  <a href="namespaceseq.html#a802ef6dd5cb892731a06e6699a27edf8">More...</a><br /></td></tr>
<tr class="separator:a802ef6dd5cb892731a06e6699a27edf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bede5ff16f5bb9f856b3b2d78303f69"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> = <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; 0, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a> &gt;</td></tr>
<tr class="memdesc:a2bede5ff16f5bb9f856b3b2d78303f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base string view typedef, similar to std::string_view. Equivalent to <a class="el" href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html" title="Specialization of tiny_string for string views. You should use the global typedef tstring_view equiva...">tiny_string&lt;0, view_allocator&gt;</a>.  <a href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">More...</a><br /></td></tr>
<tr class="separator:a2bede5ff16f5bb9f856b3b2d78303f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9a01a2c5a12df6d4baac1d1520d4b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a> = <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; 0, std::allocator&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:a8d9a01a2c5a12df6d4baac1d1520d4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base string typedef, similar to std::string. Equivalent to <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a>&lt;0, std::allocator&lt;char&gt;&gt;.  <a href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">More...</a><br /></td></tr>
<tr class="separator:a8d9a01a2c5a12df6d4baac1d1520d4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a19a45e1f866d73140819b9ea2280c682"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> { <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682af715ab801ec116cdbb4a7f7541e46166">scientific</a> = 0x8000000, 
<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682abfc5cfa7d975226254b5443690d9f918">fixed</a> = 0x10000000, 
<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">general</a> = scientific|fixed
 }</td></tr>
<tr class="memdesc:a19a45e1f866d73140819b9ea2280c682"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BitmaskType used to specify floating-point formatting for <a class="el" href="namespaceseq.html#a9e1cfb2de75c85497d57702430705b1c" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a>. This is similar to std::chars_format, but without the hex value.  <a href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">More...</a><br /></td></tr>
<tr class="separator:a19a45e1f866d73140819b9ea2280c682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d7eb5b00b5c7e90602aaf0e8bd23e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">StreamState</a> { <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2adc676c349921535a50db525652b39774">Ok</a>, 
<a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d">EndOfFile</a>, 
<a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587">BadInputFormat</a>
 }</td></tr>
<tr class="memdesc:ac3d7eb5b00b5c7e90602aaf0e8bd23e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream object status for classes inheriting basic_input_stream.  <a href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">More...</a><br /></td></tr>
<tr class="separator:ac3d7eb5b00b5c7e90602aaf0e8bd23e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3fb67407700bab4c66e60c7f7365c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7">ContextRatio</a> { <a class="el" href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7a82b7b69a7aecf7f511dde4bd663e72f3">Fixed</a>, 
<a class="el" href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7aead4f34f60237cc1a99223296ae6b1ef">Ratio</a>
 }</td></tr>
<tr class="memdesc:a5e3fb67407700bab4c66e60c7f7365c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum type used by context_ratio.  <a href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7">More...</a><br /></td></tr>
<tr class="separator:a5e3fb67407700bab4c66e60c7f7365c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f4e48fbeeb8d86e75555957c4e270c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270c">DEVectorFlag</a> { <a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270ca3d03c9bf4b559787d1de5ac0f9a7882d">OptimizeForPushBack</a>, 
<a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270caeb903e97e2b97b410b477676babb2653">OptimizeForPushFront</a>, 
<a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270ca998ccc48808777ad90d4228cd8fb9e84">OptimizeForBothEnds</a>
 }</td></tr>
<tr class="memdesc:a04f4e48fbeeb8d86e75555957c4e270c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the devector is optimized for back insertion, front insertion or both.  <a href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270c">More...</a><br /></td></tr>
<tr class="separator:a04f4e48fbeeb8d86e75555957c4e270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac07c5c5e3d6da3ebb03f7ddd1e7cde"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespaceseq.html#adac07c5c5e3d6da3ebb03f7ddd1e7cdea668d551cd99226655e9e973b6d5be517">DefaultAlignment</a> = 0
 }</td></tr>
<tr class="memdesc:adac07c5c5e3d6da3ebb03f7ddd1e7cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants used by #object_pool, #parallel_object_pool and #object_allocator.  <a href="namespaceseq.html#adac07c5c5e3d6da3ebb03f7ddd1e7cde">More...</a><br /></td></tr>
<tr class="separator:adac07c5c5e3d6da3ebb03f7ddd1e7cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affae767f96f2af9924f7c6f3bdd4c72a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72a">TagPointerType</a> { <a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72aafb05ed7193c8b361ae6679027a774673">StackPointer</a>, 
<a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72aa818e87f4cf07c4dc2006b54dbd4939e0">HeapPointer</a>, 
<a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72aad297c23409b392745ce5f3024304a8e8">CustomAlignment</a>
 }</td></tr>
<tr class="separator:affae767f96f2af9924f7c6f3bdd4c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209c3fd2e66f43ecc90862f2ee5e3dd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5">LayoutManagement</a> { <a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5a83983acd78764ffa023da74a7360670e">OptimizeForSpeed</a>, 
<a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5a51407649077d79765e15397347a57432">OptimizeForMemory</a>
 }</td></tr>
<tr class="memdesc:a209c3fd2e66f43ecc90862f2ee5e3dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory Layout Management for containers like <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant time rem...">seq::sequence</a> or <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector.">seq::tiered_vector</a>.  <a href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5">More...</a><br /></td></tr>
<tr class="separator:a209c3fd2e66f43ecc90862f2ee5e3dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3ca5fac631207b6d7245eab5a6bfe8b7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3ca5fac631207b6d7245eab5a6bfe8b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">get_type_id</a> () noexcept -&gt; int</td></tr>
<tr class="memdesc:a3ca5fac631207b6d7245eab5a6bfe8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type Id used by <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> as a unique type identifier.  <a href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">More...</a><br /></td></tr>
<tr class="separator:a3ca5fac631207b6d7245eab5a6bfe8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab781597e8779c713676aba4698fd848d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab781597e8779c713676aba4698fd848d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab781597e8779c713676aba4698fd848d">get_type_id&lt; char &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:ab781597e8779c713676aba4698fd848d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e40b1ff9e72e37869e79ff2921c563"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a77e40b1ff9e72e37869e79ff2921c563"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a77e40b1ff9e72e37869e79ff2921c563">get_type_id&lt; signed char &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:a77e40b1ff9e72e37869e79ff2921c563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7f881f13a6b4fa8b73626ff7faf21b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:abb7f881f13a6b4fa8b73626ff7faf21b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abb7f881f13a6b4fa8b73626ff7faf21b">get_type_id&lt; short &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:abb7f881f13a6b4fa8b73626ff7faf21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4477f90c09909b8e9538eb9da5bf7b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afa4477f90c09909b8e9538eb9da5bf7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afa4477f90c09909b8e9538eb9da5bf7b">get_type_id&lt; int &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:afa4477f90c09909b8e9538eb9da5bf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa69056c156aed224619be70f8d1b961"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aaa69056c156aed224619be70f8d1b961"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aaa69056c156aed224619be70f8d1b961">get_type_id&lt; long &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:aaa69056c156aed224619be70f8d1b961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32abbdc5f1a43477d971a281960a1a3f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a32abbdc5f1a43477d971a281960a1a3f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a32abbdc5f1a43477d971a281960a1a3f">get_type_id&lt; long long &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:a32abbdc5f1a43477d971a281960a1a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade528e72270aa996e16dfaaeeb237910"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ade528e72270aa996e16dfaaeeb237910"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ade528e72270aa996e16dfaaeeb237910">get_type_id&lt; unsigned char &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:ade528e72270aa996e16dfaaeeb237910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62471b1db1a49cb2326ca9578bbefd44"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a62471b1db1a49cb2326ca9578bbefd44"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a62471b1db1a49cb2326ca9578bbefd44">get_type_id&lt; unsigned short &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:a62471b1db1a49cb2326ca9578bbefd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30d6a10918be7b27352573cd354d531"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa30d6a10918be7b27352573cd354d531"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa30d6a10918be7b27352573cd354d531">get_type_id&lt; unsigned int &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:aa30d6a10918be7b27352573cd354d531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac045797c9594a025910e27b5fae38485"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac045797c9594a025910e27b5fae38485"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac045797c9594a025910e27b5fae38485">get_type_id&lt; unsigned long &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:ac045797c9594a025910e27b5fae38485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5cd482ca7d194206ec5e87f86a27cd"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7e5cd482ca7d194206ec5e87f86a27cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7e5cd482ca7d194206ec5e87f86a27cd">get_type_id&lt; unsigned long long &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:a7e5cd482ca7d194206ec5e87f86a27cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae96a8959187654c0283d35c91ad47e4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aae96a8959187654c0283d35c91ad47e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aae96a8959187654c0283d35c91ad47e4">get_type_id&lt; float &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:aae96a8959187654c0283d35c91ad47e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165806293492ddc64cdae62b2723a2aa"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a165806293492ddc64cdae62b2723a2aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a165806293492ddc64cdae62b2723a2aa">get_type_id&lt; double &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:a165806293492ddc64cdae62b2723a2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af164b3dca8307e99383ea0577c64e297"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af164b3dca8307e99383ea0577c64e297"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af164b3dca8307e99383ea0577c64e297">get_type_id&lt; long double &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:af164b3dca8307e99383ea0577c64e297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa6092c3c1f1ddbe9254ec3326474b9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:abaa6092c3c1f1ddbe9254ec3326474b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abaa6092c3c1f1ddbe9254ec3326474b9">get_type_id&lt; std::string &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:abaa6092c3c1f1ddbe9254ec3326474b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072571a60a39d5dc2506197b72999018"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a072571a60a39d5dc2506197b72999018"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a072571a60a39d5dc2506197b72999018">get_type_id&lt; tstring &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:a072571a60a39d5dc2506197b72999018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac186905c09880c418c0b7ba68e1fcfa0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac186905c09880c418c0b7ba68e1fcfa0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac186905c09880c418c0b7ba68e1fcfa0">get_type_id&lt; tstring_view &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:ac186905c09880c418c0b7ba68e1fcfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3ce56c553ccd79e26f7f2e5ff6a5d6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8a3ce56c553ccd79e26f7f2e5ff6a5d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8a3ce56c553ccd79e26f7f2e5ff6a5d6">get_type_id&lt; const char * &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:a8a3ce56c553ccd79e26f7f2e5ff6a5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa535bb70de1e29e29171a70f2c6d4c4d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa535bb70de1e29e29171a70f2c6d4c4d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa535bb70de1e29e29171a70f2c6d4c4d">get_type_id&lt; char * &gt;</a> () noexcept -&gt; int</td></tr>
<tr class="separator:aa535bb70de1e29e29171a70f2c6d4c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78953b53d9255df1c87a82bb8a7ecd4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa78953b53d9255df1c87a82bb8a7ecd4">is_signed_integral_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:aa78953b53d9255df1c87a82bb8a7ecd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to a signed integral type.  <a href="namespaceseq.html#aa78953b53d9255df1c87a82bb8a7ecd4">More...</a><br /></td></tr>
<tr class="separator:aa78953b53d9255df1c87a82bb8a7ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e891e43f7fe2c2737322a9b273d4a06"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5e891e43f7fe2c2737322a9b273d4a06">is_unsigned_integral_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a5e891e43f7fe2c2737322a9b273d4a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to an unsigned integral type.  <a href="namespaceseq.html#a5e891e43f7fe2c2737322a9b273d4a06">More...</a><br /></td></tr>
<tr class="separator:a5e891e43f7fe2c2737322a9b273d4a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f9511e243d78950b21507f5a4fe896"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a29f9511e243d78950b21507f5a4fe896">is_integral_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a29f9511e243d78950b21507f5a4fe896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to an integral type.  <a href="namespaceseq.html#a29f9511e243d78950b21507f5a4fe896">More...</a><br /></td></tr>
<tr class="separator:a29f9511e243d78950b21507f5a4fe896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ee2f93a9ebfb47e00fb2a353c26627"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa2ee2f93a9ebfb47e00fb2a353c26627">is_floating_point_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:aa2ee2f93a9ebfb47e00fb2a353c26627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to a floating point type.  <a href="namespaceseq.html#aa2ee2f93a9ebfb47e00fb2a353c26627">More...</a><br /></td></tr>
<tr class="separator:aa2ee2f93a9ebfb47e00fb2a353c26627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5af289596de39f1073e3071263a644"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abb5af289596de39f1073e3071263a644">is_arithmetic_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:abb5af289596de39f1073e3071263a644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to an arithmetic type (floating point or integral)  <a href="namespaceseq.html#abb5af289596de39f1073e3071263a644">More...</a><br /></td></tr>
<tr class="separator:abb5af289596de39f1073e3071263a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a34e6330b33a12e7e645c50d6d50a84"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9a34e6330b33a12e7e645c50d6d50a84">is_string_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a9a34e6330b33a12e7e645c50d6d50a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to a string type (std::string, tstring, tstring_view or const char*)  <a href="namespaceseq.html#a9a34e6330b33a12e7e645c50d6d50a84">More...</a><br /></td></tr>
<tr class="separator:a9a34e6330b33a12e7e645c50d6d50a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97851d71ded4c7928aabd76f4280d268"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a97851d71ded4c7928aabd76f4280d268"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a97851d71ded4c7928aabd76f4280d268">register_any_conversion</a> ()</td></tr>
<tr class="memdesc:a97851d71ded4c7928aabd76f4280d268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function based on explicit conversion from type T to type U.  <a href="namespaceseq.html#a97851d71ded4c7928aabd76f4280d268">More...</a><br /></td></tr>
<tr class="separator:a97851d71ded4c7928aabd76f4280d268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Fun &gt; </td></tr>
<tr class="memitem:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad7a515ea06834d35cedd4e4f9c4ba1b0">register_any_conversion</a> (Fun fun)</td></tr>
<tr class="memdesc:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function using given functor.  <a href="namespaceseq.html#ad7a515ea06834d35cedd4e4f9c4ba1b0">More...</a><br /></td></tr>
<tr class="separator:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab390e9bf772c9a88f9f48c5bd360d7ed">register_any_less_comparison</a> ()</td></tr>
<tr class="memdesc:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the comparison function <a class="el" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T()</a> &lt; U()  <a href="namespaceseq.html#ab390e9bf772c9a88f9f48c5bd360d7ed">More...</a><br /></td></tr>
<tr class="separator:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0810417829f24c04037720cfe1cc92"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Fun &gt; </td></tr>
<tr class="memitem:a0b0810417829f24c04037720cfe1cc92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0b0810417829f24c04037720cfe1cc92">register_any_less_comparison</a> (Fun fun)</td></tr>
<tr class="memdesc:a0b0810417829f24c04037720cfe1cc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a comparison function between types T and U based on given functor.  <a href="namespaceseq.html#a0b0810417829f24c04037720cfe1cc92">More...</a><br /></td></tr>
<tr class="separator:a0b0810417829f24c04037720cfe1cc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb61336a531e99a11a888883a46d0f01"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:adb61336a531e99a11a888883a46d0f01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adb61336a531e99a11a888883a46d0f01">register_any_equal_comparison</a> ()</td></tr>
<tr class="memdesc:adb61336a531e99a11a888883a46d0f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the comparison function <a class="el" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T()</a> == U()  <a href="namespaceseq.html#adb61336a531e99a11a888883a46d0f01">More...</a><br /></td></tr>
<tr class="separator:adb61336a531e99a11a888883a46d0f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa783de724c82de2264d98a3437294df"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Fun &gt; </td></tr>
<tr class="memitem:aaa783de724c82de2264d98a3437294df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aaa783de724c82de2264d98a3437294df">register_any_equal_comparison</a> (Fun fun)</td></tr>
<tr class="memdesc:aaa783de724c82de2264d98a3437294df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a comparison function between types T and U based on given functor.  <a href="namespaceseq.html#aaa783de724c82de2264d98a3437294df">More...</a><br /></td></tr>
<tr class="separator:aaa783de724c82de2264d98a3437294df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93974cf840383439da3212e3c79d7c1"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:ae93974cf840383439da3212e3c79d7c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae93974cf840383439da3212e3c79d7c1">operator==</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:ae93974cf840383439da3212e3c79d7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87776b63812842147b01988b45038dc3"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a87776b63812842147b01988b45038dc3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a87776b63812842147b01988b45038dc3">operator==</a> (const T &amp;b, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a) -&gt; bool</td></tr>
<tr class="separator:a87776b63812842147b01988b45038dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d70682ae06526dec970a65e5a5444af"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a4d70682ae06526dec970a65e5a5444af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4d70682ae06526dec970a65e5a5444af">operator!=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:a4d70682ae06526dec970a65e5a5444af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6648c56dd5562d5fe6a6deada5215c6"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:ac6648c56dd5562d5fe6a6deada5215c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac6648c56dd5562d5fe6a6deada5215c6">operator!=</a> (const T &amp;b, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a) -&gt; bool</td></tr>
<tr class="separator:ac6648c56dd5562d5fe6a6deada5215c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9d6f4841a2e0a530497f5d0033aaed"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a7b9d6f4841a2e0a530497f5d0033aaed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7b9d6f4841a2e0a530497f5d0033aaed">operator&lt;</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:a7b9d6f4841a2e0a530497f5d0033aaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d755e83159497ccb56faf6cee44920"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:ae5d755e83159497ccb56faf6cee44920"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae5d755e83159497ccb56faf6cee44920">operator&gt;</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:ae5d755e83159497ccb56faf6cee44920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31a8a06b8bf8a14af3fdea25e05fdb5"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:ad31a8a06b8bf8a14af3fdea25e05fdb5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad31a8a06b8bf8a14af3fdea25e05fdb5">operator&lt;=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:ad31a8a06b8bf8a14af3fdea25e05fdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb735dd312cf970ea6818037bfbf4928"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:acb735dd312cf970ea6818037bfbf4928"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#acb735dd312cf970ea6818037bfbf4928">operator&gt;=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:acb735dd312cf970ea6818037bfbf4928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795abf0d602c2dabb457d4ca67f35879"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a795abf0d602c2dabb457d4ca67f35879"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a795abf0d602c2dabb457d4ca67f35879">operator&lt;</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:a795abf0d602c2dabb457d4ca67f35879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dc0d9ce34c9cc16bf0480f4d21eb8c"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a89dc0d9ce34c9cc16bf0480f4d21eb8c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a89dc0d9ce34c9cc16bf0480f4d21eb8c">operator&gt;</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:a89dc0d9ce34c9cc16bf0480f4d21eb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac504522396fae94ad4b6b1ccc15f913"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:aac504522396fae94ad4b6b1ccc15f913"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aac504522396fae94ad4b6b1ccc15f913">operator&lt;=</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:aac504522396fae94ad4b6b1ccc15f913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5263b4df259430eb4336f6b1348871c1"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, class T &gt; </td></tr>
<tr class="memitem:a5263b4df259430eb4336f6b1348871c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5263b4df259430eb4336f6b1348871c1">operator&gt;=</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:a5263b4df259430eb4336f6b1348871c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110ce7828a4cf726d001fe58fa6983cf"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:a110ce7828a4cf726d001fe58fa6983cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a110ce7828a4cf726d001fe58fa6983cf">operator&lt;&lt;</a> (std::ostream &amp;oss, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a) -&gt; std::ostream &amp;</td></tr>
<tr class="separator:a110ce7828a4cf726d001fe58fa6983cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7083aa58832400e4ec4cd4baaf5b39d0"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:a7083aa58832400e4ec4cd4baaf5b39d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7083aa58832400e4ec4cd4baaf5b39d0">operator&gt;&gt;</a> (std::istream &amp;iss, <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;a) -&gt; std::istream &amp;</td></tr>
<tr class="separator:a7083aa58832400e4ec4cd4baaf5b39d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568a9b05cad11abae721e6b2a1a64942"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:a568a9b05cad11abae721e6b2a1a64942"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a568a9b05cad11abae721e6b2a1a64942">any_cast</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;operand) -&gt; T</td></tr>
<tr class="separator:a568a9b05cad11abae721e6b2a1a64942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29793524765b2a285801f76d14d3d533"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:a29793524765b2a285801f76d14d3d533"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a29793524765b2a285801f76d14d3d533">any_cast</a> (<a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;operand) -&gt; T</td></tr>
<tr class="separator:a29793524765b2a285801f76d14d3d533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd49ffe5d359d4957e5582db143a888c"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:afd49ffe5d359d4957e5582db143a888c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afd49ffe5d359d4957e5582db143a888c">any_cast</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; *operand) noexcept -&gt; const T *</td></tr>
<tr class="separator:afd49ffe5d359d4957e5582db143a888c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5aa9ffb02d2ace2ddd1584f03f5ed6"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A&gt; </td></tr>
<tr class="memitem:abc5aa9ffb02d2ace2ddd1584f03f5ed6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abc5aa9ffb02d2ace2ddd1584f03f5ed6">any_cast</a> (<a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; *operand) noexcept -&gt; T *</td></tr>
<tr class="separator:abc5aa9ffb02d2ace2ddd1584f03f5ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2b63f4cea16071daccd0ab528b695e"><td class="memTemplParams" colspan="2">template&lt;class Any , class T , class... Args&gt; </td></tr>
<tr class="memitem:adf2b63f4cea16071daccd0ab528b695e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adf2b63f4cea16071daccd0ab528b695e">make_any</a> (Args &amp;&amp;... args) -&gt; Any</td></tr>
<tr class="separator:adf2b63f4cea16071daccd0ab528b695e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5417e4eca78972288f212c355f07923"><td class="memTemplParams" colspan="2">template&lt;class Any , class T , class U , class... Args&gt; </td></tr>
<tr class="memitem:ab5417e4eca78972288f212c355f07923"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab5417e4eca78972288f212c355f07923">make_any</a> (std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args) -&gt; Any</td></tr>
<tr class="separator:ab5417e4eca78972288f212c355f07923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67ee9a9d6039de2b50c631129a0a1bc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac67ee9a9d6039de2b50c631129a0a1bc">aligned_malloc</a> (size_t size, size_t align) -&gt; void *</td></tr>
<tr class="memdesc:ac67ee9a9d6039de2b50c631129a0a1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates <em>size</em> bytes. The returned pointer is guaranteed to have <em>align</em> bytes alignment.  <a href="namespaceseq.html#ac67ee9a9d6039de2b50c631129a0a1bc">More...</a><br /></td></tr>
<tr class="separator:ac67ee9a9d6039de2b50c631129a0a1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04be1ca38e79158feb4755807ef3d08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a04be1ca38e79158feb4755807ef3d08c">aligned_free</a> (void *ptr)</td></tr>
<tr class="memdesc:a04be1ca38e79158feb4755807ef3d08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with aligned_malloc.  <a href="namespaceseq.html#a04be1ca38e79158feb4755807ef3d08c">More...</a><br /></td></tr>
<tr class="separator:a04be1ca38e79158feb4755807ef3d08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93474d742382c06825212a479a720fcb"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a93474d742382c06825212a479a720fcb">popcnt64</a> (std::uint64_t x)</td></tr>
<tr class="separator:a93474d742382c06825212a479a720fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad7cd23d956c6e3205dd20ff1629b3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a08ad7cd23d956c6e3205dd20ff1629b3">popcnt32</a> (uint32_t x)</td></tr>
<tr class="separator:a08ad7cd23d956c6e3205dd20ff1629b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cd15c1c849768be9995bcb1fd1733a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af2cd15c1c849768be9995bcb1fd1733a">popcnt8</a> (unsigned char value) -&gt; unsigned</td></tr>
<tr class="separator:af2cd15c1c849768be9995bcb1fd1733a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348cf02b3ab7947f01df82985d741138"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a348cf02b3ab7947f01df82985d741138">popcnt16</a> (unsigned short value) -&gt; unsigned</td></tr>
<tr class="separator:a348cf02b3ab7947f01df82985d741138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b62146c2dc50a03ca53b97ace8bd99"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a33b62146c2dc50a03ca53b97ace8bd99">bit_scan_forward_8</a> (std::uint8_t val) -&gt; unsigned int</td></tr>
<tr class="separator:a33b62146c2dc50a03ca53b97ace8bd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbee1b71b206139ba062e72ec88de1cf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adbee1b71b206139ba062e72ec88de1cf">bit_scan_reverse_8</a> (std::uint8_t val) -&gt; unsigned int</td></tr>
<tr class="separator:adbee1b71b206139ba062e72ec88de1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaee03ba305545aff518038a6037813b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adaee03ba305545aff518038a6037813b">bit_scan_forward_32</a> (std::uint32_t val) -&gt; unsigned int</td></tr>
<tr class="memdesc:adaee03ba305545aff518038a6037813b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest set bit index in <em>val</em> Undefined if val==0.  <a href="namespaceseq.html#adaee03ba305545aff518038a6037813b">More...</a><br /></td></tr>
<tr class="separator:adaee03ba305545aff518038a6037813b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b01e43cd0234954034486359baa02f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a89b01e43cd0234954034486359baa02f">bit_scan_reverse_32</a> (std::uint32_t val) -&gt; unsigned int</td></tr>
<tr class="memdesc:a89b01e43cd0234954034486359baa02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest set bit index in <em>val</em> Undefined if val==0.  <a href="namespaceseq.html#a89b01e43cd0234954034486359baa02f">More...</a><br /></td></tr>
<tr class="separator:a89b01e43cd0234954034486359baa02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea82743e4a07a05aad9c2226c85c5925"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aea82743e4a07a05aad9c2226c85c5925">bit_scan_forward_64</a> (std::uint64_t bb) noexcept -&gt; unsigned</td></tr>
<tr class="memdesc:aea82743e4a07a05aad9c2226c85c5925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest set bit index in <em>bb</em>. Developed by Kim Walisch (2012). Undefined if bb==0.  <a href="namespaceseq.html#aea82743e4a07a05aad9c2226c85c5925">More...</a><br /></td></tr>
<tr class="separator:aea82743e4a07a05aad9c2226c85c5925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea603fed30d1318a1a13ee9a6181c1a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aaea603fed30d1318a1a13ee9a6181c1a">bit_scan_reverse_64</a> (std::uint64_t bb) noexcept -&gt; unsigned</td></tr>
<tr class="memdesc:aaea603fed30d1318a1a13ee9a6181c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest set bit index in <em>bb</em>. Developed by Kim Walisch, Mark Dickinson. Undefined if bb==0.  <a href="namespaceseq.html#aaea603fed30d1318a1a13ee9a6181c1a">More...</a><br /></td></tr>
<tr class="separator:aaea603fed30d1318a1a13ee9a6181c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb73db39e1609aef776bd9499a838c85"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aeb73db39e1609aef776bd9499a838c85">bit_scan_forward</a> (size_t bb) noexcept -&gt; unsigned</td></tr>
<tr class="memdesc:aeb73db39e1609aef776bd9499a838c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest set bit index in <em>bb</em>. Undefined if bb==0.  <a href="namespaceseq.html#aeb73db39e1609aef776bd9499a838c85">More...</a><br /></td></tr>
<tr class="separator:aeb73db39e1609aef776bd9499a838c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a4aaad9e6e5b58b9ae8bc9a0a8df09"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab2a4aaad9e6e5b58b9ae8bc9a0a8df09">bit_scan_reverse</a> (size_t bb) noexcept -&gt; unsigned</td></tr>
<tr class="memdesc:ab2a4aaad9e6e5b58b9ae8bc9a0a8df09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest set bit index in <em>bb</em>. Undefined if bb==0.  <a href="namespaceseq.html#ab2a4aaad9e6e5b58b9ae8bc9a0a8df09">More...</a><br /></td></tr>
<tr class="separator:ab2a4aaad9e6e5b58b9ae8bc9a0a8df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad229ce51d8085cde156a70f274f2dce2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad229ce51d8085cde156a70f274f2dce2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad229ce51d8085cde156a70f274f2dce2">count_digits_base_10</a> (T x) -&gt; unsigned</td></tr>
<tr class="separator:ad229ce51d8085cde156a70f274f2dce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f848adb0c9d3ac36fb1c523850748b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab2f848adb0c9d3ac36fb1c523850748b">nth_bit_set</a> (std::uint64_t x, unsigned n) noexcept</td></tr>
<tr class="separator:ab2f848adb0c9d3ac36fb1c523850748b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01a2e9b3b57b882c04f41e155e7d640"><td class="memTemplParams" colspan="2">template&lt;size_t ConsecutiveNBits&gt; </td></tr>
<tr class="memitem:aa01a2e9b3b57b882c04f41e155e7d640"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa01a2e9b3b57b882c04f41e155e7d640">consecutive_N_bits</a> (size_t num) -&gt; unsigned</td></tr>
<tr class="memdesc:aa01a2e9b3b57b882c04f41e155e7d640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first consecutive N bits within <em>num</em>.  <a href="namespaceseq.html#aa01a2e9b3b57b882c04f41e155e7d640">More...</a><br /></td></tr>
<tr class="separator:aa01a2e9b3b57b882c04f41e155e7d640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae245e0eac231291e4870473d50563333"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae245e0eac231291e4870473d50563333">byte_swap_16</a> (std::uint16_t value) -&gt; std::uint16_t</td></tr>
<tr class="memdesc:ae245e0eac231291e4870473d50563333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte-swapped representation of the 16-bit argument.  <a href="namespaceseq.html#ae245e0eac231291e4870473d50563333">More...</a><br /></td></tr>
<tr class="separator:ae245e0eac231291e4870473d50563333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcd590a0f658c7717ac3295ce0ebd6c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6bcd590a0f658c7717ac3295ce0ebd6c">byte_swap_32</a> (std::uint32_t value) -&gt; std::uint32_t</td></tr>
<tr class="memdesc:a6bcd590a0f658c7717ac3295ce0ebd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte-swapped representation of the 32-bit argument.  <a href="namespaceseq.html#a6bcd590a0f658c7717ac3295ce0ebd6c">More...</a><br /></td></tr>
<tr class="separator:a6bcd590a0f658c7717ac3295ce0ebd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a2ecccd735e2c51aed1c52d39e57ec"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a07a2ecccd735e2c51aed1c52d39e57ec">byte_swap_64</a> (std::uint64_t value) -&gt; std::uint64_t</td></tr>
<tr class="memdesc:a07a2ecccd735e2c51aed1c52d39e57ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte-swapped representation of the 64-bit argument.  <a href="namespaceseq.html#a07a2ecccd735e2c51aed1c52d39e57ec">More...</a><br /></td></tr>
<tr class="separator:a07a2ecccd735e2c51aed1c52d39e57ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa0f34c5b9efbaacd24ae215c6ebdfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8aa0f34c5b9efbaacd24ae215c6ebdfe">write_LE_16</a> (void *dst, std::uint16_t value)</td></tr>
<tr class="memdesc:a8aa0f34c5b9efbaacd24ae215c6ebdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 16 bits integer value to dst in little endian order.  <a href="namespaceseq.html#a8aa0f34c5b9efbaacd24ae215c6ebdfe">More...</a><br /></td></tr>
<tr class="separator:a8aa0f34c5b9efbaacd24ae215c6ebdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbce06d3b6c0dd24ef956b3bba564914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abbce06d3b6c0dd24ef956b3bba564914">write_LE_32</a> (void *dst, std::uint32_t value)</td></tr>
<tr class="memdesc:abbce06d3b6c0dd24ef956b3bba564914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32 bits integer value to dst in little endian order.  <a href="namespaceseq.html#abbce06d3b6c0dd24ef956b3bba564914">More...</a><br /></td></tr>
<tr class="separator:abbce06d3b6c0dd24ef956b3bba564914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd16ebc1860bdc316a5f83c8210a361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2dd16ebc1860bdc316a5f83c8210a361">write_LE_64</a> (void *dst, std::uint64_t value)</td></tr>
<tr class="memdesc:a2dd16ebc1860bdc316a5f83c8210a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 64 bits integer value to dst in little endian order.  <a href="namespaceseq.html#a2dd16ebc1860bdc316a5f83c8210a361">More...</a><br /></td></tr>
<tr class="separator:a2dd16ebc1860bdc316a5f83c8210a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2480216425c6423b34df46e854b9764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac2480216425c6423b34df46e854b9764">write_BE_64</a> (void *dst, std::uint64_t value)</td></tr>
<tr class="memdesc:ac2480216425c6423b34df46e854b9764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 64 bits integer value to dst in big endian order.  <a href="namespaceseq.html#ac2480216425c6423b34df46e854b9764">More...</a><br /></td></tr>
<tr class="separator:ac2480216425c6423b34df46e854b9764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052b75a0721954d5497ff1753315e997"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a052b75a0721954d5497ff1753315e997">read_LE_16</a> (const void *src) -&gt; std::uint16_t</td></tr>
<tr class="memdesc:a052b75a0721954d5497ff1753315e997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 16 bits integer from src in little endian order.  <a href="namespaceseq.html#a052b75a0721954d5497ff1753315e997">More...</a><br /></td></tr>
<tr class="separator:a052b75a0721954d5497ff1753315e997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a00bc4c5f354e2350bab137e35c0ceb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1a00bc4c5f354e2350bab137e35c0ceb">read_LE_32</a> (const void *src) -&gt; std::uint32_t</td></tr>
<tr class="memdesc:a1a00bc4c5f354e2350bab137e35c0ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32 bits integer from src in little endian order.  <a href="namespaceseq.html#a1a00bc4c5f354e2350bab137e35c0ceb">More...</a><br /></td></tr>
<tr class="separator:a1a00bc4c5f354e2350bab137e35c0ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee33b43276433d62551712f283741546"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aee33b43276433d62551712f283741546">read_LE_64</a> (const void *src) -&gt; std::uint64_t</td></tr>
<tr class="memdesc:aee33b43276433d62551712f283741546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 64 bits integer from src in little endian order.  <a href="namespaceseq.html#aee33b43276433d62551712f283741546">More...</a><br /></td></tr>
<tr class="separator:aee33b43276433d62551712f283741546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f46b0218710a8c5534b5795ce95b2e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a20f46b0218710a8c5534b5795ce95b2e">read_16</a> (const void *src) -&gt; std::uint16_t</td></tr>
<tr class="memdesc:a20f46b0218710a8c5534b5795ce95b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 16 bits integer from src.  <a href="namespaceseq.html#a20f46b0218710a8c5534b5795ce95b2e">More...</a><br /></td></tr>
<tr class="separator:a20f46b0218710a8c5534b5795ce95b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b48ff10138ee36cd0f4949f01a23f1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a36b48ff10138ee36cd0f4949f01a23f1">read_32</a> (const void *src) -&gt; std::uint32_t</td></tr>
<tr class="memdesc:a36b48ff10138ee36cd0f4949f01a23f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 32 bits integer from src.  <a href="namespaceseq.html#a36b48ff10138ee36cd0f4949f01a23f1">More...</a><br /></td></tr>
<tr class="separator:a36b48ff10138ee36cd0f4949f01a23f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53674d0482ead92a98023ed0d7c57dd1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a53674d0482ead92a98023ed0d7c57dd1">read_64</a> (const void *src) -&gt; std::uint64_t</td></tr>
<tr class="memdesc:a53674d0482ead92a98023ed0d7c57dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 64 bits integer from src.  <a href="namespaceseq.html#a53674d0482ead92a98023ed0d7c57dd1">More...</a><br /></td></tr>
<tr class="separator:a53674d0482ead92a98023ed0d7c57dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07d1a9758d3ce39924f26eff332f759"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae07d1a9758d3ce39924f26eff332f759">read_ptr_t</a> (const void *src) -&gt; std::uintptr_t</td></tr>
<tr class="memdesc:ae07d1a9758d3ce39924f26eff332f759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads uintptr_t integer from src.  <a href="namespaceseq.html#ae07d1a9758d3ce39924f26eff332f759">More...</a><br /></td></tr>
<tr class="separator:ae07d1a9758d3ce39924f26eff332f759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f9f34cc361321151e13951ccad2ac4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa1f9f34cc361321151e13951ccad2ac4">read_BE_16</a> (const void *src) -&gt; std::uint16_t</td></tr>
<tr class="memdesc:aa1f9f34cc361321151e13951ccad2ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 16 bits integer from src in big endian order.  <a href="namespaceseq.html#aa1f9f34cc361321151e13951ccad2ac4">More...</a><br /></td></tr>
<tr class="separator:aa1f9f34cc361321151e13951ccad2ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccead2b857599b0e675267609e5120f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adccead2b857599b0e675267609e5120f">read_BE_32</a> (const void *src) -&gt; std::uint32_t</td></tr>
<tr class="memdesc:adccead2b857599b0e675267609e5120f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 32 bits integer from src in big endian order.  <a href="namespaceseq.html#adccead2b857599b0e675267609e5120f">More...</a><br /></td></tr>
<tr class="separator:adccead2b857599b0e675267609e5120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3778777f10583618f958211656aec2b4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3778777f10583618f958211656aec2b4">read_BE_64</a> (const void *src) -&gt; std::uint64_t</td></tr>
<tr class="memdesc:a3778777f10583618f958211656aec2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 64 bits integer from src in big endian order.  <a href="namespaceseq.html#a3778777f10583618f958211656aec2b4">More...</a><br /></td></tr>
<tr class="separator:a3778777f10583618f958211656aec2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adb2cb36973f3d571f0984dffb68d87"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2adb2cb36973f3d571f0984dffb68d87">read_size_t</a> (const void *src) -&gt; size_t</td></tr>
<tr class="memdesc:a2adb2cb36973f3d571f0984dffb68d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads size_t object from src.  <a href="namespaceseq.html#a2adb2cb36973f3d571f0984dffb68d87">More...</a><br /></td></tr>
<tr class="separator:a2adb2cb36973f3d571f0984dffb68d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f5bd629161aaad113175e3b0217f29"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa1f5bd629161aaad113175e3b0217f29">read_LE_size_t</a> (const void *src) -&gt; size_t</td></tr>
<tr class="memdesc:aa1f5bd629161aaad113175e3b0217f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads size_t object from src in little endian order.  <a href="namespaceseq.html#aa1f5bd629161aaad113175e3b0217f29">More...</a><br /></td></tr>
<tr class="separator:aa1f5bd629161aaad113175e3b0217f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fbedb52aef41b37b7b243497ead642"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a79fbedb52aef41b37b7b243497ead642">read_BE_size_t</a> (const void *src) -&gt; size_t</td></tr>
<tr class="memdesc:a79fbedb52aef41b37b7b243497ead642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads size_t object from src in big endian order.  <a href="namespaceseq.html#a79fbedb52aef41b37b7b243497ead642">More...</a><br /></td></tr>
<tr class="separator:a79fbedb52aef41b37b7b243497ead642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade167dcc6d29b420964a6be1498889ac"><td class="memTemplParams" colspan="2">template&lt;class Stream , class T &gt; </td></tr>
<tr class="memitem:ade167dcc6d29b420964a6be1498889ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac">from_stream</a> (Stream &amp;str, T &amp;value, int base=10) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:ade167dcc6d29b420964a6be1498889ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an integral value from a <a class="el" href="classseq_1_1basic__input__stream.html" title="Base class for input text streams.">seq::basic_input_stream</a> object.  <a href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac">More...</a><br /></td></tr>
<tr class="separator:ade167dcc6d29b420964a6be1498889ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0031c82ad3d33c5094644a8c07f5464"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:af0031c82ad3d33c5094644a8c07f5464"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af0031c82ad3d33c5094644a8c07f5464">from_stream</a> (Stream &amp;str, float &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; Stream &amp;</td></tr>
<tr class="memdesc:af0031c82ad3d33c5094644a8c07f5464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from a #basic_input_stream object.  <a href="namespaceseq.html#af0031c82ad3d33c5094644a8c07f5464">More...</a><br /></td></tr>
<tr class="separator:af0031c82ad3d33c5094644a8c07f5464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0581674bf80cd428f3680506119eb7d8"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a0581674bf80cd428f3680506119eb7d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0581674bf80cd428f3680506119eb7d8">from_stream</a> (Stream &amp;str, double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; Stream &amp;</td></tr>
<tr class="memdesc:a0581674bf80cd428f3680506119eb7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from a #basic_input_stream object.  <a href="namespaceseq.html#a0581674bf80cd428f3680506119eb7d8">More...</a><br /></td></tr>
<tr class="separator:a0581674bf80cd428f3680506119eb7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36637d3bd7fde2e315ed4a5d1bc29f35"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a36637d3bd7fde2e315ed4a5d1bc29f35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a36637d3bd7fde2e315ed4a5d1bc29f35">from_stream</a> (Stream &amp;str, long double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; Stream &amp;</td></tr>
<tr class="memdesc:a36637d3bd7fde2e315ed4a5d1bc29f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from a #basic_input_stream object.  <a href="namespaceseq.html#a36637d3bd7fde2e315ed4a5d1bc29f35">More...</a><br /></td></tr>
<tr class="separator:a36637d3bd7fde2e315ed4a5d1bc29f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53df224196282a50a8e3c99d4bd5ff5c"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a53df224196282a50a8e3c99d4bd5ff5c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a53df224196282a50a8e3c99d4bd5ff5c">from_stream</a> (Stream &amp;str, std::string &amp;value) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:a53df224196282a50a8e3c99d4bd5ff5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a word from a #basic_input_stream object.  <a href="namespaceseq.html#a53df224196282a50a8e3c99d4bd5ff5c">More...</a><br /></td></tr>
<tr class="separator:a53df224196282a50a8e3c99d4bd5ff5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d0cf3592690ba5924d6eb3f5cf48a8"><td class="memTemplParams" colspan="2">template&lt;class Stream , size_t Ss, class Al &gt; </td></tr>
<tr class="memitem:ac2d0cf3592690ba5924d6eb3f5cf48a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac2d0cf3592690ba5924d6eb3f5cf48a8">from_stream</a> (Stream &amp;str, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Ss, Al &gt; &amp;value) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:ac2d0cf3592690ba5924d6eb3f5cf48a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a word from a #basic_input_stream object.  <a href="namespaceseq.html#ac2d0cf3592690ba5924d6eb3f5cf48a8">More...</a><br /></td></tr>
<tr class="separator:ac2d0cf3592690ba5924d6eb3f5cf48a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add85486f09f54fba24d5f3cc4737474c"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:add85486f09f54fba24d5f3cc4737474c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#add85486f09f54fba24d5f3cc4737474c">read_line_from_stream</a> (Stream &amp;str, std::string &amp;value) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:add85486f09f54fba24d5f3cc4737474c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line from a #basic_input_stream object.  <a href="namespaceseq.html#add85486f09f54fba24d5f3cc4737474c">More...</a><br /></td></tr>
<tr class="separator:add85486f09f54fba24d5f3cc4737474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac4d359a9469e24e86016201d1cb5fb"><td class="memTemplParams" colspan="2">template&lt;class Stream , size_t Ss, class Al &gt; </td></tr>
<tr class="memitem:a6ac4d359a9469e24e86016201d1cb5fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6ac4d359a9469e24e86016201d1cb5fb">read_line_from_stream</a> (Stream &amp;str, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Ss, Al &gt; &amp;value) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:a6ac4d359a9469e24e86016201d1cb5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line from a #basic_input_stream object.  <a href="namespaceseq.html#a6ac4d359a9469e24e86016201d1cb5fb">More...</a><br /></td></tr>
<tr class="separator:a6ac4d359a9469e24e86016201d1cb5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac422fc75d3e6f011374ffeed3683da55"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac422fc75d3e6f011374ffeed3683da55"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac422fc75d3e6f011374ffeed3683da55">from_chars</a> (const char *first, const char *last, T &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:ac422fc75d3e6f011374ffeed3683da55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an integral value from the sequence of characters [first,last).  <a href="namespaceseq.html#ac422fc75d3e6f011374ffeed3683da55">More...</a><br /></td></tr>
<tr class="separator:ac422fc75d3e6f011374ffeed3683da55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c70e7cd5c0dcd224133d857a04cbf29"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0c70e7cd5c0dcd224133d857a04cbf29">from_chars</a> (const char *first, const char *last, float &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:a0c70e7cd5c0dcd224133d857a04cbf29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from the sequence of characters [first,last).  <a href="namespaceseq.html#a0c70e7cd5c0dcd224133d857a04cbf29">More...</a><br /></td></tr>
<tr class="separator:a0c70e7cd5c0dcd224133d857a04cbf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67d56a308c331001d4ac7d93c9b5961"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad67d56a308c331001d4ac7d93c9b5961">from_chars</a> (const char *first, const char *last, double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:ad67d56a308c331001d4ac7d93c9b5961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from the sequence of characters [first,last).  <a href="namespaceseq.html#ad67d56a308c331001d4ac7d93c9b5961">More...</a><br /></td></tr>
<tr class="separator:ad67d56a308c331001d4ac7d93c9b5961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884e66071e34d4d2d05f532e5373cdc8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a884e66071e34d4d2d05f532e5373cdc8">from_chars</a> (const char *first, const char *last, long double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:a884e66071e34d4d2d05f532e5373cdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from the sequence of characters [first,last).  <a href="namespaceseq.html#a884e66071e34d4d2d05f532e5373cdc8">More...</a><br /></td></tr>
<tr class="separator:a884e66071e34d4d2d05f532e5373cdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1cfb2de75c85497d57702430705b1c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9e1cfb2de75c85497d57702430705b1c">to_chars</a> (char *first, char *last, char value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:a9e1cfb2de75c85497d57702430705b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <a href="namespaceseq.html#a9e1cfb2de75c85497d57702430705b1c">More...</a><br /></td></tr>
<tr class="separator:a9e1cfb2de75c85497d57702430705b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa334d76820ca19ea006395faa17aab9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aaa334d76820ca19ea006395faa17aab9">to_chars</a> (char *first, char *last, signed char value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:aaa334d76820ca19ea006395faa17aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81169e9865167e86562c956fe54ad9c6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a81169e9865167e86562c956fe54ad9c6">to_chars</a> (char *first, char *last, unsigned char value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a81169e9865167e86562c956fe54ad9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b59d6549285b87fc972d4fcf94a6b3e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2b59d6549285b87fc972d4fcf94a6b3e">to_chars</a> (char *first, char *last, short value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a2b59d6549285b87fc972d4fcf94a6b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfcd6e33f7e1ea6fbf6135d9cf70a71"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abcfcd6e33f7e1ea6fbf6135d9cf70a71">to_chars</a> (char *first, char *last, unsigned short value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:abcfcd6e33f7e1ea6fbf6135d9cf70a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c3c78201587dd15f2d262c1cbb22a5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac6c3c78201587dd15f2d262c1cbb22a5">to_chars</a> (char *first, char *last, int value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:ac6c3c78201587dd15f2d262c1cbb22a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eed3d5531ee31256046a546bdab4ff"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae1eed3d5531ee31256046a546bdab4ff">to_chars</a> (char *first, char *last, unsigned int value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:ae1eed3d5531ee31256046a546bdab4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa81a642c601963cc3705f245d5993c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#acfa81a642c601963cc3705f245d5993c">to_chars</a> (char *first, char *last, long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:acfa81a642c601963cc3705f245d5993c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520ffd9d059e63286f7eb2608e1a03fa"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a520ffd9d059e63286f7eb2608e1a03fa">to_chars</a> (char *first, char *last, unsigned long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a520ffd9d059e63286f7eb2608e1a03fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f5172bb6410a2f26155289919b94ca"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab1f5172bb6410a2f26155289919b94ca">to_chars</a> (char *first, char *last, long long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:ab1f5172bb6410a2f26155289919b94ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ce6d36a38f1b4d27d34b155a3b21f9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a32ce6d36a38f1b4d27d34b155a3b21f9">to_chars</a> (char *first, char *last, unsigned long long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a32ce6d36a38f1b4d27d34b155a3b21f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac778d2e1714b0bc1a988a8ef573fed6e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac778d2e1714b0bc1a988a8ef573fed6e">to_chars</a> (char *first, char *last, bool value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>=delete</td></tr>
<tr class="separator:ac778d2e1714b0bc1a988a8ef573fed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c75fd24d42eb6c6470210805c3798c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a44c75fd24d42eb6c6470210805c3798c">to_chars</a> (char *first, char *last, float value) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:a44c75fd24d42eb6c6470210805c3798c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <a href="namespaceseq.html#a44c75fd24d42eb6c6470210805c3798c">More...</a><br /></td></tr>
<tr class="separator:a44c75fd24d42eb6c6470210805c3798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85aae92558690a191bd6e300ce27d78c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a85aae92558690a191bd6e300ce27d78c">to_chars</a> (char *first, char *last, double value) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a85aae92558690a191bd6e300ce27d78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69f4f092c96147e027be85bc3620e3d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa69f4f092c96147e027be85bc3620e3d">to_chars</a> (char *first, char *last, long double value) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:aa69f4f092c96147e027be85bc3620e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e61035b14149d9c984d7b6dfbf6681"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad4e61035b14149d9c984d7b6dfbf6681">to_chars</a> (char *first, char *last, float value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:ad4e61035b14149d9c984d7b6dfbf6681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c373f2fadfaefd16b35d3656717208a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5c373f2fadfaefd16b35d3656717208a">to_chars</a> (char *first, char *last, double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a5c373f2fadfaefd16b35d3656717208a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae446ea1d0a68784bccf7027fc9273bcd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae446ea1d0a68784bccf7027fc9273bcd">to_chars</a> (char *first, char *last, long double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:ae446ea1d0a68784bccf7027fc9273bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895eff859309c7eb594f6efce61df9b8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a895eff859309c7eb594f6efce61df9b8">to_chars</a> (char *first, char *last, float value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>, int precision, char dot='.', char exp='e', bool upper=false) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a895eff859309c7eb594f6efce61df9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac4ff8894fc503318b23b05b28365ce"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adac4ff8894fc503318b23b05b28365ce">to_chars</a> (char *first, char *last, double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>, int precision, char dot='.', char exp='e', bool upper=false) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:adac4ff8894fc503318b23b05b28365ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6347c0acfbf3ae451b414e8faaf26b21"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6347c0acfbf3ae451b414e8faaf26b21">to_chars</a> (char *first, char *last, long double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>, int precision, char dot='.', char exp='e', bool upper=false) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a6347c0acfbf3ae451b414e8faaf26b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e7a0c600427f614ba162d86c3c4362"><td class="memTemplParams" colspan="2">template&lt;class Lock &gt; </td></tr>
<tr class="memitem:a32e7a0c600427f614ba162d86c3c4362"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a32e7a0c600427f614ba162d86c3c4362">make_lock_guard</a> (Lock &amp;l) -&gt; <a class="el" href="classseq_1_1lock__guard.html">lock_guard</a>&lt; Lock &gt;</td></tr>
<tr class="memdesc:a32e7a0c600427f614ba162d86c3c4362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lock guard around l. Use copy elison to avoid creating copies and locking twice the lock object.  <a href="namespaceseq.html#a32e7a0c600427f614ba162d86c3c4362">More...</a><br /></td></tr>
<tr class="separator:a32e7a0c600427f614ba162d86c3c4362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02fc574f6876f28fef03044ed31569e"><td class="memTemplParams" colspan="2">template&lt;class Comp &gt; </td></tr>
<tr class="memitem:ae02fc574f6876f28fef03044ed31569e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae02fc574f6876f28fef03044ed31569e">make_comparator</a> (const Comp &amp;comp) -&gt; <a class="el" href="structseq_1_1comp__wrapper.html">comp_wrapper</a>&lt; Comp &gt;</td></tr>
<tr class="memdesc:ae02fc574f6876f28fef03044ed31569e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a comparison functor that can be used by algorithms working on cvector objects.  <a href="namespaceseq.html#ae02fc574f6876f28fef03044ed31569e">More...</a><br /></td></tr>
<tr class="separator:ae02fc574f6876f28fef03044ed31569e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dadf0da6e85313800689b619a18843"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:aa5dadf0da6e85313800689b619a18843"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa5dadf0da6e85313800689b619a18843">operator==</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, L2, S2, U2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:aa5dadf0da6e85313800689b619a18843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position.  <a href="namespaceseq.html#aa5dadf0da6e85313800689b619a18843">More...</a><br /></td></tr>
<tr class="separator:aa5dadf0da6e85313800689b619a18843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9d8109fa888ce35b35ace5c02e0521"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:a1b9d8109fa888ce35b35ace5c02e0521"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1b9d8109fa888ce35b35ace5c02e0521">operator!=</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, L2, S2, U2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a1b9d8109fa888ce35b35ace5c02e0521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are not equals.  <a href="namespaceseq.html#a1b9d8109fa888ce35b35ace5c02e0521">More...</a><br /></td></tr>
<tr class="separator:a1b9d8109fa888ce35b35ace5c02e0521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fe75172eeb16489daf9f52abb2a459"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare , class Al1 , LayoutManagement L1, bool S1, bool U1, class Pred &gt; </td></tr>
<tr class="memitem:a02fe75172eeb16489daf9f52abb2a459"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a02fe75172eeb16489daf9f52abb2a459">erase_if</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;s1, Pred p) -&gt; typename <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt;::size_type</td></tr>
<tr class="memdesc:a02fe75172eeb16489daf9f52abb2a459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="namespaceseq.html#a02fe75172eeb16489daf9f52abb2a459">More...</a><br /></td></tr>
<tr class="separator:a02fe75172eeb16489daf9f52abb2a459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66772d69054d5e2792a3e2e2ceee8d44"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:a66772d69054d5e2792a3e2e2ceee8d44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a66772d69054d5e2792a3e2e2ceee8d44">operator==</a> (const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, L2, S2, U2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a66772d69054d5e2792a3e2e2ceee8d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position.  <a href="namespaceseq.html#a66772d69054d5e2792a3e2e2ceee8d44">More...</a><br /></td></tr>
<tr class="separator:a66772d69054d5e2792a3e2e2ceee8d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa17cb52d5ec33df7205c8bca8e2f76e"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:afa17cb52d5ec33df7205c8bca8e2f76e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afa17cb52d5ec33df7205c8bca8e2f76e">operator!=</a> (const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, L2, S2, U2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:afa17cb52d5ec33df7205c8bca8e2f76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are not equals.  <a href="namespaceseq.html#afa17cb52d5ec33df7205c8bca8e2f76e">More...</a><br /></td></tr>
<tr class="separator:afa17cb52d5ec33df7205c8bca8e2f76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5904267252712a43d887d06c8c75aaaa"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare , class Al1 , LayoutManagement L1, bool S1, bool U1, class Pred &gt; </td></tr>
<tr class="memitem:a5904267252712a43d887d06c8c75aaaa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5904267252712a43d887d06c8c75aaaa">erase_if</a> (<a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;s1, Pred p) -&gt; typename <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt;::size_type</td></tr>
<tr class="memdesc:a5904267252712a43d887d06c8c75aaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="namespaceseq.html#a5904267252712a43d887d06c8c75aaaa">More...</a><br /></td></tr>
<tr class="separator:a5904267252712a43d887d06c8c75aaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892fa27ee42cd6f34066d399a9e7d317"><td class="memTemplParams" colspan="2">template&lt;class Elem , class Traits , class T &gt; </td></tr>
<tr class="memitem:a892fa27ee42cd6f34066d399a9e7d317"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a892fa27ee42cd6f34066d399a9e7d317">operator&lt;&lt;</a> (std::basic_ostream&lt; Elem, Traits &gt; &amp;oss, const <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T &gt; &amp;val) -&gt; std::basic_ostream&lt; Elem, Traits &gt; &amp;</td></tr>
<tr class="memdesc:a892fa27ee42cd6f34066d399a9e7d317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class.">ostream_format</a> object to a std::ostream.  <a href="namespaceseq.html#a892fa27ee42cd6f34066d399a9e7d317">More...</a><br /></td></tr>
<tr class="separator:a892fa27ee42cd6f34066d399a9e7d317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab534e8a0f6ac376f61e976fe7cd65457"><td class="memTemplParams" colspan="2">template&lt;size_t... Ts&gt; </td></tr>
<tr class="memitem:ab534e8a0f6ac376f61e976fe7cd65457"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a> () -&gt; <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;</td></tr>
<tr class="memdesc:ab534e8a0f6ac376f61e976fe7cd65457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a positional object used either by <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt()</a> or operator() of formatting object.  <a href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">More...</a><br /></td></tr>
<tr class="separator:ab534e8a0f6ac376f61e976fe7cd65457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b27d9d28ab49b4e36657f9e95013c7"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a21b27d9d28ab49b4e36657f9e95013c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a> (Args &amp;&amp;... args) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), void, Args... &gt;::return_type</td></tr>
<tr class="separator:a21b27d9d28ab49b4e36657f9e95013c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50efcf02fb38933039611940d459ae10"><td class="memTemplParams" colspan="2">template&lt;size_t ... Ts, class ... Args&gt; </td></tr>
<tr class="memitem:a50efcf02fb38933039611940d459ae10"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a50efcf02fb38933039611940d459ae10">fmt</a> (<a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;, Args &amp;&amp;... args) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;, Args... &gt;::return_type</td></tr>
<tr class="separator:a50efcf02fb38933039611940d459ae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7f5113ac0f03f720b3a5cf96c20550"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a1c7f5113ac0f03f720b3a5cf96c20550"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1c7f5113ac0f03f720b3a5cf96c20550">fmt</a> () -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), void, Args... &gt;::return_type</td></tr>
<tr class="separator:a1c7f5113ac0f03f720b3a5cf96c20550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1390c60d480ef706cb933a10356b9245"><td class="memTemplParams" colspan="2">template&lt;class Elem , class Traits , class T , class P &gt; </td></tr>
<tr class="memitem:a1390c60d480ef706cb933a10356b9245"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1390c60d480ef706cb933a10356b9245">operator&lt;&lt;</a> (std::basic_ostream&lt; Elem, Traits &gt; &amp;oss, const <a class="el" href="structseq_1_1detail_1_1mutli__ostream__format.html">detail::mutli_ostream_format</a>&lt; T, P &gt; &amp;val) -&gt; std::basic_ostream&lt; Elem, Traits &gt; &amp;</td></tr>
<tr class="memdesc:a1390c60d480ef706cb933a10356b9245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class.">ostream_format</a> object to a std::ostream object.  <a href="namespaceseq.html#a1390c60d480ef706cb933a10356b9245">More...</a><br /></td></tr>
<tr class="separator:a1390c60d480ef706cb933a10356b9245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e75ac2752560b9441e25dbeb0a37035"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1e75ac2752560b9441e25dbeb0a37035">hash_combine</a> (size_t h1, size_t h2) noexcept -&gt; size_t</td></tr>
<tr class="memdesc:a1e75ac2752560b9441e25dbeb0a37035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine 2 hash values. Uses either murmurhash2 for 64 bits platform or the boost version for 32 bits platform.  <a href="namespaceseq.html#a1e75ac2752560b9441e25dbeb0a37035">More...</a><br /></td></tr>
<tr class="separator:a1e75ac2752560b9441e25dbeb0a37035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b21f8567341968f120686ab59a18a86"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7b21f8567341968f120686ab59a18a86">hash_bytes_murmur64</a> (const std::uint8_t *ptr, size_t len) noexcept -&gt; size_t</td></tr>
<tr class="memdesc:a7b21f8567341968f120686ab59a18a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash value for input data using the murmurhash2 algorithm.  <a href="namespaceseq.html#a7b21f8567341968f120686ab59a18a86">More...</a><br /></td></tr>
<tr class="separator:a7b21f8567341968f120686ab59a18a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d5414cdd66534c903b9667391934f2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a08d5414cdd66534c903b9667391934f2">hash_bytes_fnv1a</a> (const unsigned char *ptr, size_t size) noexcept -&gt; size_t</td></tr>
<tr class="memdesc:a08d5414cdd66534c903b9667391934f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash value for input data using the fnv1a algorithm. This version reads the input buffer by chunks of sizeof(size_t).  <a href="namespaceseq.html#a08d5414cdd66534c903b9667391934f2">More...</a><br /></td></tr>
<tr class="separator:a08d5414cdd66534c903b9667391934f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48356b6277c4d0a4eae3e8df71928e9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab48356b6277c4d0a4eae3e8df71928e9">hash_bytes_fnv1a_slow</a> (const unsigned char *ptr, size_t size) noexcept -&gt; size_t</td></tr>
<tr class="memdesc:ab48356b6277c4d0a4eae3e8df71928e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash value for input data using the fnv1a algorithm.  <a href="namespaceseq.html#ab48356b6277c4d0a4eae3e8df71928e9">More...</a><br /></td></tr>
<tr class="separator:ab48356b6277c4d0a4eae3e8df71928e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1349a44a2ff37300a5c72a03780780fe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1349a44a2ff37300a5c72a03780780fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1349a44a2ff37300a5c72a03780780fe">unique_ptr_delete</a> (T *p)</td></tr>
<tr class="memdesc:a1349a44a2ff37300a5c72a03780780fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate pointer previously held by a std::unqiue_ptr&lt;T,unique_ptr_deleter&lt;T&gt; &gt;  <a href="namespaceseq.html#a1349a44a2ff37300a5c72a03780780fe">More...</a><br /></td></tr>
<tr class="separator:a1349a44a2ff37300a5c72a03780780fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4308e82af69325da59bf1abe2e9b30d1"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:a4308e82af69325da59bf1abe2e9b30d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4308e82af69325da59bf1abe2e9b30d1">operator==</a> (const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a4308e82af69325da59bf1abe2e9b30d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> for equality. Two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> are considered equal if they contain the same keys. Key ordering is not considered.  <a href="namespaceseq.html#a4308e82af69325da59bf1abe2e9b30d1">More...</a><br /></td></tr>
<tr class="separator:a4308e82af69325da59bf1abe2e9b30d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a8e4ca5bdbbf2cd53645c2733449d0"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:a12a8e4ca5bdbbf2cd53645c2733449d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a12a8e4ca5bdbbf2cd53645c2733449d0">operator!=</a> (const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a12a8e4ca5bdbbf2cd53645c2733449d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> for inequality, synthesized from operator==.  <a href="namespaceseq.html#a12a8e4ca5bdbbf2cd53645c2733449d0">More...</a><br /></td></tr>
<tr class="separator:a12a8e4ca5bdbbf2cd53645c2733449d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c9030a8049270841c9d1ceb949ed16"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </td></tr>
<tr class="memitem:ac8c9030a8049270841c9d1ceb949ed16"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac8c9030a8049270841c9d1ceb949ed16">erase_if</a> (<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;set, Pred p) -&gt; size_t</td></tr>
<tr class="memdesc:ac8c9030a8049270841c9d1ceb949ed16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="namespaceseq.html#ac8c9030a8049270841c9d1ceb949ed16">More...</a><br /></td></tr>
<tr class="separator:ac8c9030a8049270841c9d1ceb949ed16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3debed99e1f30055ff02d9d0ee009727"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:a3debed99e1f30055ff02d9d0ee009727"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3debed99e1f30055ff02d9d0ee009727">operator==</a> (const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a3debed99e1f30055ff02d9d0ee009727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> for equality. Two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> are considered equal if they contain the same pairs key-&gt;value. Key ordering is not considered.  <a href="namespaceseq.html#a3debed99e1f30055ff02d9d0ee009727">More...</a><br /></td></tr>
<tr class="separator:a3debed99e1f30055ff02d9d0ee009727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a77517d376eeb44fc2615040f226b3"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:ac8a77517d376eeb44fc2615040f226b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac8a77517d376eeb44fc2615040f226b3">operator!=</a> (const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ac8a77517d376eeb44fc2615040f226b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> for inequality, synthesized from operator==.  <a href="namespaceseq.html#ac8a77517d376eeb44fc2615040f226b3">More...</a><br /></td></tr>
<tr class="separator:ac8a77517d376eeb44fc2615040f226b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345460864d8e607d34f3547e6d1e01fd"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </td></tr>
<tr class="memitem:a345460864d8e607d34f3547e6d1e01fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a345460864d8e607d34f3547e6d1e01fd">erase_if</a> (<a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;set, Pred p) -&gt; size_t</td></tr>
<tr class="memdesc:a345460864d8e607d34f3547e6d1e01fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="namespaceseq.html#a345460864d8e607d34f3547e6d1e01fd">More...</a><br /></td></tr>
<tr class="separator:a345460864d8e607d34f3547e6d1e01fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad863fcfc143b646f5a2f2362a1327575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a> ()</td></tr>
<tr class="memdesc:ad863fcfc143b646f5a2f2362a1327575"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, reset timer for calling thread.  <a href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">More...</a><br /></td></tr>
<tr class="separator:ad863fcfc143b646f5a2f2362a1327575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa113bfd5dcde4ed36475a4f3ba164e54"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa113bfd5dcde4ed36475a4f3ba164e54">tock_us</a> () -&gt; std::uint64_t</td></tr>
<tr class="memdesc:aa113bfd5dcde4ed36475a4f3ba164e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, returns elapsed microseconds since last call to <a class="el" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575" title="For tests only, reset timer for calling thread.">tick()</a>  <a href="namespaceseq.html#aa113bfd5dcde4ed36475a4f3ba164e54">More...</a><br /></td></tr>
<tr class="separator:aa113bfd5dcde4ed36475a4f3ba164e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576ae74a514ded550299e48e4c32cc64"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a> () -&gt; std::uint64_t</td></tr>
<tr class="memdesc:a576ae74a514ded550299e48e4c32cc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, returns elapsed milliseconds since last call to <a class="el" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575" title="For tests only, reset timer for calling thread.">tick()</a>  <a href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">More...</a><br /></td></tr>
<tr class="separator:a576ae74a514ded550299e48e4c32cc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b268bc53b846426ab17a84bb756fab"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ad8b268bc53b846426ab17a84bb756fab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad8b268bc53b846426ab17a84bb756fab">random_shuffle</a> (Iter begin, Iter end, uint_fast32_t seed=0)</td></tr>
<tr class="memdesc:ad8b268bc53b846426ab17a84bb756fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to C++11 (and deprecated) std::random_shuffle.  <a href="namespaceseq.html#ad8b268bc53b846426ab17a84bb756fab">More...</a><br /></td></tr>
<tr class="separator:ad8b268bc53b846426ab17a84bb756fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabfa3eaf9a03808f516c1c71d521dee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#acabfa3eaf9a03808f516c1c71d521dee">reset_memory_usage</a> ()</td></tr>
<tr class="separator:acabfa3eaf9a03808f516c1c71d521dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30368dcf14dfdddd428c9ac9ec675b6f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a30368dcf14dfdddd428c9ac9ec675b6f">get_memory_usage</a> () -&gt; size_t</td></tr>
<tr class="separator:a30368dcf14dfdddd428c9ac9ec675b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b887df093a1fae4487fccd6c1949116"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4b887df093a1fae4487fccd6c1949116"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4b887df093a1fae4487fccd6c1949116">print_null</a> (const T &amp;v)</td></tr>
<tr class="separator:a4b887df093a1fae4487fccd6c1949116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad0247ee4ca62ff368c30bea8e49dfb"><td class="memTemplParams" colspan="2">template&lt;class String &gt; </td></tr>
<tr class="memitem:a8ad0247ee4ca62ff368c30bea8e49dfb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8ad0247ee4ca62ff368c30bea8e49dfb">generate_random_string</a> (int max_size, bool <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682abfc5cfa7d975226254b5443690d9f918">fixed</a>=false) -&gt; String</td></tr>
<tr class="memdesc:a8ad0247ee4ca62ff368c30bea8e49dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, generate a random string of given max size.  <a href="namespaceseq.html#a8ad0247ee4ca62ff368c30bea8e49dfb">More...</a><br /></td></tr>
<tr class="separator:a8ad0247ee4ca62ff368c30bea8e49dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67d4f6b5e7766ac1cc45a0e5842e1a1"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:af67d4f6b5e7766ac1cc45a0e5842e1a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af67d4f6b5e7766ac1cc45a0e5842e1a1">operator==</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:af67d4f6b5e7766ac1cc45a0e5842e1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56c6d64eb04a963a9812c8b7f9714ee"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aa56c6d64eb04a963a9812c8b7f9714ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa56c6d64eb04a963a9812c8b7f9714ee">operator==</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:aa56c6d64eb04a963a9812c8b7f9714ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861414ba0c42c6e112aacd979592b13c"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a861414ba0c42c6e112aacd979592b13c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a861414ba0c42c6e112aacd979592b13c">operator==</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a861414ba0c42c6e112aacd979592b13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea7559047b3040872cdd1c38315df2e"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a6ea7559047b3040872cdd1c38315df2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6ea7559047b3040872cdd1c38315df2e">operator==</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a6ea7559047b3040872cdd1c38315df2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b61cb7cf1085d47e734de14233ef20"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a72b61cb7cf1085d47e734de14233ef20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a72b61cb7cf1085d47e734de14233ef20">operator==</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a72b61cb7cf1085d47e734de14233ef20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e28e6da6ec3562c1faef9ef00631d6"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:ad9e28e6da6ec3562c1faef9ef00631d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad9e28e6da6ec3562c1faef9ef00631d6">operator!=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad9e28e6da6ec3562c1faef9ef00631d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6a00f67a9341cb4bcc99c107515229"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a3d6a00f67a9341cb4bcc99c107515229"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3d6a00f67a9341cb4bcc99c107515229">operator!=</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3d6a00f67a9341cb4bcc99c107515229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6a796c87305524653d7265ae4da2ff"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a3b6a796c87305524653d7265ae4da2ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3b6a796c87305524653d7265ae4da2ff">operator!=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a3b6a796c87305524653d7265ae4da2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948fa0ea1e3ce1689da9c6b62c096245"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a948fa0ea1e3ce1689da9c6b62c096245"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a948fa0ea1e3ce1689da9c6b62c096245">operator!=</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a948fa0ea1e3ce1689da9c6b62c096245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32bc8987b500a2d007b0a068d48538"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:afe32bc8987b500a2d007b0a068d48538"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afe32bc8987b500a2d007b0a068d48538">operator!=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:afe32bc8987b500a2d007b0a068d48538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6a7ec8e9a4fc0d7eaf0d5f523774ca"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:a3b6a7ec8e9a4fc0d7eaf0d5f523774ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3b6a7ec8e9a4fc0d7eaf0d5f523774ca">operator&lt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3b6a7ec8e9a4fc0d7eaf0d5f523774ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc02f75db7d73bb10c42d71a370c368"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:abfc02f75db7d73bb10c42d71a370c368"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abfc02f75db7d73bb10c42d71a370c368">operator&lt;</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:abfc02f75db7d73bb10c42d71a370c368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4feaa3ec5619d0c601da47ed4245c3"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aea4feaa3ec5619d0c601da47ed4245c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aea4feaa3ec5619d0c601da47ed4245c3">operator&lt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:aea4feaa3ec5619d0c601da47ed4245c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d793a96fc5ac7087c067d0b129662d0"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a1d793a96fc5ac7087c067d0b129662d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1d793a96fc5ac7087c067d0b129662d0">operator&lt;</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1d793a96fc5ac7087c067d0b129662d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7797b9c1954288017fdfe309b554454a"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a7797b9c1954288017fdfe309b554454a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7797b9c1954288017fdfe309b554454a">operator&lt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:a7797b9c1954288017fdfe309b554454a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f6d50f3c32887116c4bae46c3429d4"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:ad8f6d50f3c32887116c4bae46c3429d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad8f6d50f3c32887116c4bae46c3429d4">operator&lt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad8f6d50f3c32887116c4bae46c3429d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edd539db8412668d682cf9ff5e7a070"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a9edd539db8412668d682cf9ff5e7a070"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9edd539db8412668d682cf9ff5e7a070">operator&lt;=</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9edd539db8412668d682cf9ff5e7a070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad008ee24c9386b09b25e912de5d4c1a1"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ad008ee24c9386b09b25e912de5d4c1a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad008ee24c9386b09b25e912de5d4c1a1">operator&lt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:ad008ee24c9386b09b25e912de5d4c1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc2a4ddf5388c2ced30ccb8f562d675"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aedc2a4ddf5388c2ced30ccb8f562d675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aedc2a4ddf5388c2ced30ccb8f562d675">operator&lt;=</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aedc2a4ddf5388c2ced30ccb8f562d675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56068d4d371f671c476f2d48a14c40c4"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a56068d4d371f671c476f2d48a14c40c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a56068d4d371f671c476f2d48a14c40c4">operator&lt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:a56068d4d371f671c476f2d48a14c40c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1833a5b86d9fe7f4aa324dc762ee7f"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:a5e1833a5b86d9fe7f4aa324dc762ee7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5e1833a5b86d9fe7f4aa324dc762ee7f">operator&gt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5e1833a5b86d9fe7f4aa324dc762ee7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3482ce2ab94dc59b5b2b857802906f"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a1f3482ce2ab94dc59b5b2b857802906f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1f3482ce2ab94dc59b5b2b857802906f">operator&gt;</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1f3482ce2ab94dc59b5b2b857802906f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cc10a31374b3edfd99aa9d766ad5c7"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a58cc10a31374b3edfd99aa9d766ad5c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a58cc10a31374b3edfd99aa9d766ad5c7">operator&gt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a58cc10a31374b3edfd99aa9d766ad5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382805c206a702e81be578225f9b2a6c"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a382805c206a702e81be578225f9b2a6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a382805c206a702e81be578225f9b2a6c">operator&gt;</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a382805c206a702e81be578225f9b2a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422ba2ed76ef830f9a768efb0ab264b"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a3422ba2ed76ef830f9a768efb0ab264b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3422ba2ed76ef830f9a768efb0ab264b">operator&gt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:a3422ba2ed76ef830f9a768efb0ab264b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b02d9de4bef32a8048a063ca879338"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:a42b02d9de4bef32a8048a063ca879338"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a42b02d9de4bef32a8048a063ca879338">operator&gt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a42b02d9de4bef32a8048a063ca879338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1652748e87ae34ddb4e4aaee0c1047"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a9d1652748e87ae34ddb4e4aaee0c1047"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9d1652748e87ae34ddb4e4aaee0c1047">operator&gt;=</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9d1652748e87ae34ddb4e4aaee0c1047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0492edc203e24e4f2a815f88b63b6b9c"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a0492edc203e24e4f2a815f88b63b6b9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0492edc203e24e4f2a815f88b63b6b9c">operator&gt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) noexcept</td></tr>
<tr class="separator:a0492edc203e24e4f2a815f88b63b6b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbd22b85882e325ad2aa30cc80476fa"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aefbd22b85882e325ad2aa30cc80476fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aefbd22b85882e325ad2aa30cc80476fa">operator&gt;=</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aefbd22b85882e325ad2aa30cc80476fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099bb20d7de44b7e830799fea7f7a709"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a099bb20d7de44b7e830799fea7f7a709"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a099bb20d7de44b7e830799fea7f7a709">operator&gt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) noexcept</td></tr>
<tr class="separator:a099bb20d7de44b7e830799fea7f7a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1d95a792c4df40a9942662ab573ff"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </td></tr>
<tr class="memitem:a0bb1d95a792c4df40a9942662ab573ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0bb1d95a792c4df40a9942662ab573ff">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &gt;::type</td></tr>
<tr class="separator:a0bb1d95a792c4df40a9942662ab573ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8056fc410913073144c5fa466cbc690"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:aa8056fc410913073144c5fa466cbc690"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa8056fc410913073144c5fa466cbc690">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const std::string &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type</td></tr>
<tr class="separator:aa8056fc410913073144c5fa466cbc690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6610e8513f7ab68233cdd6d46151209"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ae6610e8513f7ab68233cdd6d46151209"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae6610e8513f7ab68233cdd6d46151209">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, const char *rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type</td></tr>
<tr class="separator:ae6610e8513f7ab68233cdd6d46151209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdee63e1144180cadb75be9d1730787"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:abbdee63e1144180cadb75be9d1730787"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abbdee63e1144180cadb75be9d1730787">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;lhs, char rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type</td></tr>
<tr class="separator:abbdee63e1144180cadb75be9d1730787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cec60fd49b0943f3f8501fcec57676"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a97cec60fd49b0943f3f8501fcec57676"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a97cec60fd49b0943f3f8501fcec57676">operator+</a> (const std::string &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type</td></tr>
<tr class="separator:a97cec60fd49b0943f3f8501fcec57676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae509e47a7299cf5e9eaa6d2bb386db1f"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ae509e47a7299cf5e9eaa6d2bb386db1f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae509e47a7299cf5e9eaa6d2bb386db1f">operator+</a> (const char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type</td></tr>
<tr class="separator:ae509e47a7299cf5e9eaa6d2bb386db1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68147f1f9efe66da434919961feed1f0"><td class="memTemplParams" colspan="2">template&lt;size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a68147f1f9efe66da434919961feed1f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a68147f1f9efe66da434919961feed1f0">operator+</a> (char lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &gt;::type</td></tr>
<tr class="separator:a68147f1f9efe66da434919961feed1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacbb14fd705709e8f7d3d9b77daeea3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abacbb14fd705709e8f7d3d9b77daeea3">string_data</a> (const std::string &amp;str) -&gt; const char *</td></tr>
<tr class="memdesc:abacbb14fd705709e8f7d3d9b77daeea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string data (const char*) for given string object.  <a href="namespaceseq.html#abacbb14fd705709e8f7d3d9b77daeea3">More...</a><br /></td></tr>
<tr class="separator:abacbb14fd705709e8f7d3d9b77daeea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883e44e91646300fed68720e2e9e7c90"><td class="memTemplParams" colspan="2">template&lt;size_t S, class Al &gt; </td></tr>
<tr class="memitem:a883e44e91646300fed68720e2e9e7c90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a883e44e91646300fed68720e2e9e7c90">string_data</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, Al &gt; &amp;str) -&gt; const char *</td></tr>
<tr class="separator:a883e44e91646300fed68720e2e9e7c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759ced44c9584918c6302fe6562ba950"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a759ced44c9584918c6302fe6562ba950">string_data</a> (const char *str) -&gt; const char *</td></tr>
<tr class="separator:a759ced44c9584918c6302fe6562ba950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0218c72afdb6220de9da3a069dc3efa"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac0218c72afdb6220de9da3a069dc3efa">string_data</a> (const <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &amp;str) -&gt; const char *</td></tr>
<tr class="separator:ac0218c72afdb6220de9da3a069dc3efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb962f97eeea267d9b1e420879eb1ff"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8cb962f97eeea267d9b1e420879eb1ff">string_size</a> (const std::string &amp;str) -&gt; size_t</td></tr>
<tr class="memdesc:a8cb962f97eeea267d9b1e420879eb1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string size for given string object.  <a href="namespaceseq.html#a8cb962f97eeea267d9b1e420879eb1ff">More...</a><br /></td></tr>
<tr class="separator:a8cb962f97eeea267d9b1e420879eb1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9baf42d336da7e5368e05ecd5d2515"><td class="memTemplParams" colspan="2">template&lt;size_t S, class Al &gt; </td></tr>
<tr class="memitem:abf9baf42d336da7e5368e05ecd5d2515"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abf9baf42d336da7e5368e05ecd5d2515">string_size</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, Al &gt; &amp;str) -&gt; size_t</td></tr>
<tr class="separator:abf9baf42d336da7e5368e05ecd5d2515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac404d9958f2200e3e6588b5601759b1c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac404d9958f2200e3e6588b5601759b1c">string_size</a> (const char *str) -&gt; size_t</td></tr>
<tr class="separator:ac404d9958f2200e3e6588b5601759b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0db3e95c769979401e3c88ec361613"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ada0db3e95c769979401e3c88ec361613">string_size</a> (const <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &amp;str) -&gt; size_t</td></tr>
<tr class="separator:ada0db3e95c769979401e3c88ec361613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc51a3f40a4cee1e71e1d831ee8dc681"><td class="memTemplParams" colspan="2">template&lt;class Elem , class Traits , size_t Size, class Alloc &gt; </td></tr>
<tr class="memitem:afc51a3f40a4cee1e71e1d831ee8dc681"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afc51a3f40a4cee1e71e1d831ee8dc681">operator&gt;&gt;</a> (std::basic_istream&lt; Elem, Traits &gt; &amp;iss, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Alloc &gt; &amp;str) -&gt; typename std::enable_if&lt;!std::is_same&lt; Alloc, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a> &gt;::value, std::basic_istream&lt; Elem, Traits &gt; &gt;::type &amp;</td></tr>
<tr class="separator:afc51a3f40a4cee1e71e1d831ee8dc681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc6f1dda9c576a66b148a346792a983"><td class="memTemplParams" colspan="2">template&lt;class Elem , class Traits , size_t Size, class Alloc &gt; </td></tr>
<tr class="memitem:a9bc6f1dda9c576a66b148a346792a983"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9bc6f1dda9c576a66b148a346792a983">operator&lt;&lt;</a> (std::basic_ostream&lt; Elem, Traits &gt; &amp;oss, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Alloc &gt; &amp;str) -&gt; std::basic_ostream&lt; Elem, Traits &gt; &amp;</td></tr>
<tr class="separator:a9bc6f1dda9c576a66b148a346792a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c279fa143d4e6216df953924ce47406"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7c279fa143d4e6216df953924ce47406"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7c279fa143d4e6216df953924ce47406">negate_if_signed</a> (T v) -&gt; typename <a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a7c279fa143d4e6216df953924ce47406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns -v if v is signed, v otherwise.  <a href="namespaceseq.html#a7c279fa143d4e6216df953924ce47406">More...</a><br /></td></tr>
<tr class="separator:a7c279fa143d4e6216df953924ce47406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f8f4791e95dce2f0a4298ff8e82797"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab6f8f4791e95dce2f0a4298ff8e82797"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab6f8f4791e95dce2f0a4298ff8e82797">abs</a> (T v) -&gt; typename <a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab6f8f4791e95dce2f0a4298ff8e82797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns absolute value of v.  <a href="namespaceseq.html#ab6f8f4791e95dce2f0a4298ff8e82797">More...</a><br /></td></tr>
<tr class="separator:ab6f8f4791e95dce2f0a4298ff8e82797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a83c380ba3efb861a6d64bd87360c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a57a83c380ba3efb861a6d64bd87360c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a57a83c380ba3efb861a6d64bd87360c1">operator+</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it, typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type diff) noexcept -&gt; <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;</td></tr>
<tr class="separator:a57a83c380ba3efb861a6d64bd87360c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa242d97b0138a72bd07cabe76a62ef17"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa242d97b0138a72bd07cabe76a62ef17"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa242d97b0138a72bd07cabe76a62ef17">operator-</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it, typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type diff) noexcept -&gt; <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;</td></tr>
<tr class="separator:aa242d97b0138a72bd07cabe76a62ef17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3dab51febe50dfd60f7bd4fe46154f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8a3dab51febe50dfd60f7bd4fe46154f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8a3dab51febe50dfd60f7bd4fe46154f">operator-</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type</td></tr>
<tr class="separator:a8a3dab51febe50dfd60f7bd4fe46154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4cb9a01f8408e24f5cf3b5874876f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2c4cb9a01f8408e24f5cf3b5874876f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2c4cb9a01f8408e24f5cf3b5874876f9">operator&lt;</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; bool</td></tr>
<tr class="separator:a2c4cb9a01f8408e24f5cf3b5874876f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e24e00cf888c85c3bc16fa9a8f8dfbf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0e24e00cf888c85c3bc16fa9a8f8dfbf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0e24e00cf888c85c3bc16fa9a8f8dfbf">operator&gt;</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; bool</td></tr>
<tr class="separator:a0e24e00cf888c85c3bc16fa9a8f8dfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6920a1594333ae1cb5a606a699e2fa7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac6920a1594333ae1cb5a606a699e2fa7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac6920a1594333ae1cb5a606a699e2fa7">operator&lt;=</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; bool</td></tr>
<tr class="separator:ac6920a1594333ae1cb5a606a699e2fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bda8a7271df48555e68fe9d51ebf37"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a93bda8a7271df48555e68fe9d51ebf37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a93bda8a7271df48555e68fe9d51ebf37">operator&gt;=</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; bool</td></tr>
<tr class="separator:a93bda8a7271df48555e68fe9d51ebf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09f4c319b21510f90dae6dc5b7d8656"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae09f4c319b21510f90dae6dc5b7d8656"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae09f4c319b21510f90dae6dc5b7d8656">destroy_ptr</a> (T *p)</td></tr>
<tr class="memdesc:ae09f4c319b21510f90dae6dc5b7d8656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply call p-&gt;~T(), used as a replacement to std::allocator::destroy() which was removed in C++20.  <a href="namespaceseq.html#ae09f4c319b21510f90dae6dc5b7d8656">More...</a><br /></td></tr>
<tr class="separator:ae09f4c319b21510f90dae6dc5b7d8656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48515fc69dc7f83f81c6e0715999ba16"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a48515fc69dc7f83f81c6e0715999ba16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a48515fc69dc7f83f81c6e0715999ba16">construct_ptr</a> (T *p, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a48515fc69dc7f83f81c6e0715999ba16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply call new (p) T(...), used as a replacement to std::allocator::construct() which was removed in C++20.  <a href="namespaceseq.html#a48515fc69dc7f83f81c6e0715999ba16">More...</a><br /></td></tr>
<tr class="separator:a48515fc69dc7f83f81c6e0715999ba16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0670d7b308c6a99a75f4d112934aa3f"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ae0670d7b308c6a99a75f4d112934aa3f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae0670d7b308c6a99a75f4d112934aa3f">distance</a> (const Iter &amp;first, const Iter &amp;last) noexcept -&gt; std::ptrdiff_t</td></tr>
<tr class="memdesc:ae0670d7b308c6a99a75f4d112934aa3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between first and last iterators for random access iterator category, 0 otherwise.  <a href="namespaceseq.html#ae0670d7b308c6a99a75f4d112934aa3f">More...</a><br /></td></tr>
<tr class="separator:ae0670d7b308c6a99a75f4d112934aa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b1a14cbf28e77e92a346892ef8531c"><td class="memTemplParams" colspan="2">template&lt;bool IsL1, class L1 , class L2 , class... Args&gt; </td></tr>
<tr class="memitem:a60b1a14cbf28e77e92a346892ef8531c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a60b1a14cbf28e77e92a346892ef8531c">constexpr_if</a> (const L1 &amp;l1, const L2 &amp;l2, Args &amp;&amp;... args) -&gt; decltype(std::declval&lt; <a class="el" href="structseq_1_1detail_1_1_call_lambda.html">detail::CallLambda</a>&lt; L1, L2, IsL1 &gt; &amp; &gt;()(std::declval&lt; L1 &amp; &gt;(), std::declval&lt; L2 &amp; &gt;(), std::declval&lt; Args &gt;()...))</td></tr>
<tr class="memdesc:a60b1a14cbf28e77e92a346892ef8531c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulation of C++17 if constexpr.  <a href="namespaceseq.html#a60b1a14cbf28e77e92a346892ef8531c">More...</a><br /></td></tr>
<tr class="separator:a60b1a14cbf28e77e92a346892ef8531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79240f9c8c5a8da1a3c5770d18b44f0"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:ab79240f9c8c5a8da1a3c5770d18b44f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab79240f9c8c5a8da1a3c5770d18b44f0">copy_allocator</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:ab79240f9c8c5a8da1a3c5770d18b44f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy allocator for container copy constructor.  <a href="namespaceseq.html#ab79240f9c8c5a8da1a3c5770d18b44f0">More...</a><br /></td></tr>
<tr class="separator:ab79240f9c8c5a8da1a3c5770d18b44f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e83b922f85075d41cf05cbf365dc07"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a76e83b922f85075d41cf05cbf365dc07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a76e83b922f85075d41cf05cbf365dc07">swap_allocator</a> (Allocator &amp;left, Allocator &amp;right) noexcept</td></tr>
<tr class="memdesc:a76e83b922f85075d41cf05cbf365dc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap allocators for container.swap member.  <a href="namespaceseq.html#a76e83b922f85075d41cf05cbf365dc07">More...</a><br /></td></tr>
<tr class="separator:a76e83b922f85075d41cf05cbf365dc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed508491a96866338895cf1b5900292"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a3ed508491a96866338895cf1b5900292"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3ed508491a96866338895cf1b5900292">assign_allocator</a> (Allocator &amp;left, const Allocator &amp;right) noexcept</td></tr>
<tr class="memdesc:a3ed508491a96866338895cf1b5900292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign allocator for container copy operator.  <a href="namespaceseq.html#a3ed508491a96866338895cf1b5900292">More...</a><br /></td></tr>
<tr class="separator:a3ed508491a96866338895cf1b5900292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81932472ffd88a08d7b6f0aaf2c123e9"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a81932472ffd88a08d7b6f0aaf2c123e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a81932472ffd88a08d7b6f0aaf2c123e9">move_allocator</a> (Allocator &amp;left, Allocator &amp;right) noexcept</td></tr>
<tr class="memdesc:a81932472ffd88a08d7b6f0aaf2c123e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move allocator for container move assignment.  <a href="namespaceseq.html#a81932472ffd88a08d7b6f0aaf2c123e9">More...</a><br /></td></tr>
<tr class="separator:a81932472ffd88a08d7b6f0aaf2c123e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>MIT License</p>
<p>Copyright (c) 2022 Victor Moncada <a href="#" onclick="location.href='mai'+'lto:'+'vtr'+'.m'+'onc'+'ad'+'a@g'+'ma'+'il.'+'co'+'m'; return false;">vtr.m<span style="display: none;">.nosp@m.</span>onca<span style="display: none;">.nosp@m.</span>da@gm<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>com</a></p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a24ef193cef19271b9b18ce6c74fc5b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ef193cef19271b9b18ce6c74fc5b54">&#9670;&nbsp;</a></span>any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">seq::any</a> = typedef <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d2b0aba572fc96bdcec68b500577b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2b0aba572fc96bdcec68b500577b5b">&#9670;&nbsp;</a></span>max_align_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a6d2b0aba572fc96bdcec68b500577b5b">seq::max_align_t</a> = typedef std::max_align_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ec98840dd82cf3a3207402caa66c73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec98840dd82cf3a3207402caa66c73f">&#9670;&nbsp;</a></span>nh_any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">seq::nh_any</a> = typedef <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;<a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a802ef6dd5cb892731a06e6699a27edf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802ef6dd5cb892731a06e6699a27edf8">&#9670;&nbsp;</a></span>nullbuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a802ef6dd5cb892731a06e6699a27edf8">seq::nullbuf</a> = typedef <a class="el" href="structseq_1_1basic__nullbuf.html">basic_nullbuf</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For tests only, alias for null buffer, to be used with c++ iostreams. </p>

</div>
</div>
<a id="a8d9a01a2c5a12df6d4baac1d1520d4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9a01a2c5a12df6d4baac1d1520d4b5">&#9670;&nbsp;</a></span>tstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">seq::tstring</a> = typedef <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;0, std::allocator&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base string typedef, similar to std::string. Equivalent to <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">tiny_string</a>&lt;0, std::allocator&lt;char&gt;&gt;. </p>

</div>
</div>
<a id="a2bede5ff16f5bb9f856b3b2d78303f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bede5ff16f5bb9f856b3b2d78303f69">&#9670;&nbsp;</a></span>tstring_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">seq::tstring_view</a> = typedef <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;0, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base string view typedef, similar to std::string_view. Equivalent to <a class="el" href="structseq_1_1tiny__string_3_010_00_01view__allocator_01_4.html" title="Specialization of tiny_string for string views. You should use the global typedef tstring_view equiva...">tiny_string&lt;0, view_allocator&gt;</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adac07c5c5e3d6da3ebb03f7ddd1e7cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac07c5c5e3d6da3ebb03f7ddd1e7cde">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants used by #object_pool, #parallel_object_pool and #object_allocator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adac07c5c5e3d6da3ebb03f7ddd1e7cdea668d551cd99226655e9e973b6d5be517"></a>DefaultAlignment&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a19a45e1f866d73140819b9ea2280c682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a45e1f866d73140819b9ea2280c682">&#9670;&nbsp;</a></span>chars_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">seq::chars_format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A BitmaskType used to specify floating-point formatting for <a class="el" href="namespaceseq.html#a9e1cfb2de75c85497d57702430705b1c" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a>. This is similar to std::chars_format, but without the hex value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a19a45e1f866d73140819b9ea2280c682af715ab801ec116cdbb4a7f7541e46166"></a>scientific&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19a45e1f866d73140819b9ea2280c682abfc5cfa7d975226254b5443690d9f918"></a>fixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d"></a>general&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5e3fb67407700bab4c66e60c7f7365c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3fb67407700bab4c66e60c7f7365c7">&#9670;&nbsp;</a></span>ContextRatio</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7">seq::ContextRatio</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum type used by <a class="el" href="classseq_1_1context__ratio.html" title="Define the maximum number of decompression contexts a cvector can use. The number of contexts is eith...">context_ratio</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e3fb67407700bab4c66e60c7f7365c7a82b7b69a7aecf7f511dde4bd663e72f3"></a>Fixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5e3fb67407700bab4c66e60c7f7365c7aead4f34f60237cc1a99223296ae6b1ef"></a>Ratio&#160;</td><td class="fielddoc"><p>Fixed number of decompression context. </p>
<p>Ratio of total number of chunks </p>
</td></tr>
</table>

</div>
</div>
<a id="a04f4e48fbeeb8d86e75555957c4e270c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f4e48fbeeb8d86e75555957c4e270c">&#9670;&nbsp;</a></span>DEVectorFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270c">seq::DEVectorFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag indicating whether the devector is optimized for back insertion, front insertion or both. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04f4e48fbeeb8d86e75555957c4e270ca3d03c9bf4b559787d1de5ac0f9a7882d"></a>OptimizeForPushBack&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04f4e48fbeeb8d86e75555957c4e270caeb903e97e2b97b410b477676babb2653"></a>OptimizeForPushFront&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04f4e48fbeeb8d86e75555957c4e270ca998ccc48808777ad90d4228cd8fb9e84"></a>OptimizeForBothEnds&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a209c3fd2e66f43ecc90862f2ee5e3dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209c3fd2e66f43ecc90862f2ee5e3dd5">&#9670;&nbsp;</a></span>LayoutManagement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5">seq::LayoutManagement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory Layout Management for containers like <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant time rem...">seq::sequence</a> or <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector.">seq::tiered_vector</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a209c3fd2e66f43ecc90862f2ee5e3dd5a83983acd78764ffa023da74a7360670e"></a>OptimizeForSpeed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a209c3fd2e66f43ecc90862f2ee5e3dd5a51407649077d79765e15397347a57432"></a>OptimizeForMemory&#160;</td><td class="fielddoc"><p>Use more memory to favor speed. </p>
<p>Use as few memory as possible </p>
</td></tr>
</table>

</div>
</div>
<a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">&#9670;&nbsp;</a></span>StreamState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">seq::StreamState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream object status for classes inheriting <a class="el" href="classseq_1_1basic__input__stream.html" title="Base class for input text streams.">basic_input_stream</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2adc676c349921535a50db525652b39774"></a>Ok&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d"></a>EndOfFile&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587"></a>BadInputFormat&#160;</td><td class="fielddoc"><p>End of file reached. </p>
<p>Unable to read numerical value </p>
</td></tr>
</table>

</div>
</div>
<a id="affae767f96f2af9924f7c6f3bdd4c72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affae767f96f2af9924f7c6f3bdd4c72a">&#9670;&nbsp;</a></span>TagPointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72a">seq::TagPointerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="affae767f96f2af9924f7c6f3bdd4c72aafb05ed7193c8b361ae6679027a774673"></a>StackPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="affae767f96f2af9924f7c6f3bdd4c72aa818e87f4cf07c4dc2006b54dbd4939e0"></a>HeapPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="affae767f96f2af9924f7c6f3bdd4c72aad297c23409b392745ce5f3024304a8e8"></a>CustomAlignment&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab6f8f4791e95dce2f0a4298ff8e82797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f8f4791e95dce2f0a4298ff8e82797">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::abs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt;T&gt;::type </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns absolute value of v. </p>

</div>
</div>
<a id="a04be1ca38e79158feb4755807ef3d08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04be1ca38e79158feb4755807ef3d08c">&#9670;&nbsp;</a></span>aligned_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::aligned_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees memory allocated with aligned_malloc. </p>

</div>
</div>
<a id="ac67ee9a9d6039de2b50c631129a0a1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67ee9a9d6039de2b50c631129a0a1bc">&#9670;&nbsp;</a></span>aligned_malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::aligned_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates <em>size</em> bytes. The returned pointer is guaranteed to have <em>align</em> bytes alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size in bytes to allocate </td></tr>
    <tr><td class="paramname">align</td><td>alignment of result pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>algned pointer or NULL on error </dd></dl>

</div>
</div>
<a id="a568a9b05cad11abae721e6b2a1a64942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568a9b05cad11abae721e6b2a1a64942">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td> -&gt; T
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd49ffe5d359d4957e5582db143a888c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd49ffe5d359d4957e5582db143a888c">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; *&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td> -&gt; const T*
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29793524765b2a285801f76d14d3d533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29793524765b2a285801f76d14d3d533">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td> -&gt; T
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc5aa9ffb02d2ace2ddd1584f03f5ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5aa9ffb02d2ace2ddd1584f03f5ed6">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; *&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td> -&gt; T*
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ed508491a96866338895cf1b5900292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed508491a96866338895cf1b5900292">&#9670;&nbsp;</a></span>assign_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::assign_allocator </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign allocator for container copy operator. </p>

</div>
</div>
<a id="aeb73db39e1609aef776bd9499a838c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb73db39e1609aef776bd9499a838c85">&#9670;&nbsp;</a></span>bit_scan_forward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_forward </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest set bit index in <em>bb</em>. Undefined if bb==0. </p>

</div>
</div>
<a id="adaee03ba305545aff518038a6037813b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaee03ba305545aff518038a6037813b">&#9670;&nbsp;</a></span>bit_scan_forward_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_forward_32 </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; unsigned int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest set bit index in <em>val</em> Undefined if val==0. </p>

</div>
</div>
<a id="aea82743e4a07a05aad9c2226c85c5925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea82743e4a07a05aad9c2226c85c5925">&#9670;&nbsp;</a></span>bit_scan_forward_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_forward_64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest set bit index in <em>bb</em>. Developed by Kim Walisch (2012). Undefined if bb==0. </p>

</div>
</div>
<a id="a33b62146c2dc50a03ca53b97ace8bd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b62146c2dc50a03ca53b97ace8bd99">&#9670;&nbsp;</a></span>bit_scan_forward_8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_forward_8 </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; unsigned int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2a4aaad9e6e5b58b9ae8bc9a0a8df09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a4aaad9e6e5b58b9ae8bc9a0a8df09">&#9670;&nbsp;</a></span>bit_scan_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_reverse </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest set bit index in <em>bb</em>. Undefined if bb==0. </p>

</div>
</div>
<a id="a89b01e43cd0234954034486359baa02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b01e43cd0234954034486359baa02f">&#9670;&nbsp;</a></span>bit_scan_reverse_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_reverse_32 </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; unsigned int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest set bit index in <em>val</em> Undefined if val==0. </p>

</div>
</div>
<a id="aaea603fed30d1318a1a13ee9a6181c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea603fed30d1318a1a13ee9a6181c1a">&#9670;&nbsp;</a></span>bit_scan_reverse_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_reverse_64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest set bit index in <em>bb</em>. Developed by Kim Walisch, Mark Dickinson. Undefined if bb==0. </p>

</div>
</div>
<a id="adbee1b71b206139ba062e72ec88de1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbee1b71b206139ba062e72ec88de1cf">&#9670;&nbsp;</a></span>bit_scan_reverse_8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_reverse_8 </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; unsigned int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae245e0eac231291e4870473d50563333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae245e0eac231291e4870473d50563333">&#9670;&nbsp;</a></span>byte_swap_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::byte_swap_16 </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::uint16_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a byte-swapped representation of the 16-bit argument. </p>

</div>
</div>
<a id="a6bcd590a0f658c7717ac3295ce0ebd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcd590a0f658c7717ac3295ce0ebd6c">&#9670;&nbsp;</a></span>byte_swap_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::byte_swap_32 </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::uint32_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a byte-swapped representation of the 32-bit argument. </p>

</div>
</div>
<a id="a07a2ecccd735e2c51aed1c52d39e57ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a2ecccd735e2c51aed1c52d39e57ec">&#9670;&nbsp;</a></span>byte_swap_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::byte_swap_64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::uint64_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a byte-swapped representation of the 64-bit argument. </p>

</div>
</div>
<a id="aa01a2e9b3b57b882c04f41e155e7d640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01a2e9b3b57b882c04f41e155e7d640">&#9670;&nbsp;</a></span>consecutive_N_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ConsecutiveNBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::consecutive_N_bits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of the first consecutive N bits within <em>num</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>number of consecutive bits to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first consecutive N bits within <em>num</em> </dd></dl>

</div>
</div>
<a id="a60b1a14cbf28e77e92a346892ef8531c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b1a14cbf28e77e92a346892ef8531c">&#9670;&nbsp;</a></span>constexpr_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsL1, class L1 , class L2 , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::constexpr_if </td>
          <td>(</td>
          <td class="paramtype">const L1 &amp;&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L2 &amp;&#160;</td>
          <td class="paramname"><em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::declval&lt;<a class="el" href="structseq_1_1detail_1_1_call_lambda.html">detail::CallLambda</a>&lt;L1, L2, IsL1&gt;&amp;&gt;()(std::declval&lt;L1&amp;&gt;(), std::declval&lt;L2&amp;&gt;(),std::declval&lt;Args&gt;()...))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulation of C++17 if constexpr. </p>

</div>
</div>
<a id="a48515fc69dc7f83f81c6e0715999ba16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48515fc69dc7f83f81c6e0715999ba16">&#9670;&nbsp;</a></span>construct_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::construct_ptr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simply call new (p) T(...), used as a replacement to std::allocator::construct() which was removed in C++20. </p>

</div>
</div>
<a id="ab79240f9c8c5a8da1a3c5770d18b44f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79240f9c8c5a8da1a3c5770d18b44f0">&#9670;&nbsp;</a></span>copy_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::copy_allocator </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy allocator for container copy constructor. </p>

</div>
</div>
<a id="ad229ce51d8085cde156a70f274f2dce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad229ce51d8085cde156a70f274f2dce2">&#9670;&nbsp;</a></span>count_digits_base_10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::count_digits_base_10 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of digits used to represent an integer in base 10. This function only works for unsigned integral types </p>

</div>
</div>
<a id="ae09f4c319b21510f90dae6dc5b7d8656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09f4c319b21510f90dae6dc5b7d8656">&#9670;&nbsp;</a></span>destroy_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::destroy_ptr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simply call p-&gt;~T(), used as a replacement to std::allocator::destroy() which was removed in C++20. </p>

</div>
</div>
<a id="ae0670d7b308c6a99a75f4d112934aa3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0670d7b308c6a99a75f4d112934aa3f">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::distance </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::ptrdiff_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between first and last iterators for random access iterator category, 0 otherwise. </p>

</div>
</div>
<a id="a5904267252712a43d887d06c8c75aaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5904267252712a43d887d06c8c75aaaa">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare , class Al1 , LayoutManagement L1, bool S1, bool U1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt;Key, T, Compare, Al1, L1, S1, U1&gt;::size_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>

</div>
</div>
<a id="a02fe75172eeb16489daf9f52abb2a459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fe75172eeb16489daf9f52abb2a459">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare , class Al1 , LayoutManagement L1, bool S1, bool U1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt;Key, Compare, Al1, L1, S1, U1&gt;::size_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>

</div>
</div>
<a id="a345460864d8e607d34f3547e6d1e01fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345460864d8e607d34f3547e6d1e01fd">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>container from which to erase </td></tr>
    <tr><td class="paramname">p</td><td>predicate that returns true if the element should be erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>

</div>
</div>
<a id="ac8c9030a8049270841c9d1ceb949ed16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c9030a8049270841c9d1ceb949ed16">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>container from which to erase </td></tr>
    <tr><td class="paramname">p</td><td>predicate that returns true if the element should be erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>

</div>
</div>
<a id="a1c7f5113ac0f03f720b3a5cf96c20550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7f5113ac0f03f720b3a5cf96c20550">&#9670;&nbsp;</a></span>fmt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), void, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21b27d9d28ab49b4e36657f9e95013c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b27d9d28ab49b4e36657f9e95013c7">&#9670;&nbsp;</a></span>fmt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), void, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50efcf02fb38933039611940d459ae10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50efcf02fb38933039611940d459ae10">&#9670;&nbsp;</a></span>fmt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ... Ts, class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt;Ts...&gt;, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad67d56a308c331001d4ac7d93c9b5961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67d56a308c331001d4ac7d93c9b5961">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a floating point value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>decimal point character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod, and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="a0c70e7cd5c0dcd224133d857a04cbf29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c70e7cd5c0dcd224133d857a04cbf29">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a floating point value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>decimal point character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod, and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="a884e66071e34d4d2d05f532e5373cdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884e66071e34d4d2d05f532e5373cdc8">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a floating point value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>decimal point character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod, and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="ac422fc75d3e6f011374ffeed3683da55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac422fc75d3e6f011374ffeed3683da55">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an integral value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">base</td><td>integer base (default to 10) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for an integral pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>This function is similar to std::from_chars except for the following situations: </p><pre class="fragment">- For hexadecimal numbers, the (potential) '0x' prefix will be automatically detected and handled.
- Leading spaces are consumed.
- Leading '+' sign is valid.
- If the pattern is a valid integral text representation too large to be stored in a value, the full pattern will still be consumed,
the function will return a 'success' from_chars_result, and value will silently overflow.
- Reading a negative text representation in an unsigned variable is NOT valid.
</pre><p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result.">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="a0581674bf80cd428f3680506119eb7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0581674bf80cd428f3680506119eb7d8">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a floating point value from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>dot character, usually '.' for 'C' locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an floating point value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>If the parsing fails (no floating point pattern was detected), the stream status will be set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587" title="End of file reached.">BadInputFormat</a> or <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a> depending on the situation, and stream get position will be reverted to its original state.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>This function is usefull when you need to read a huge amount of floating point values of a std::istream object. Internal benchmarks show that using <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object.">from_stream()</a> is around 20 faster (or more) than using <a class="el" href="namespaceseq.html#a7083aa58832400e4ec4cd4baaf5b39d0">std::istream::operator&gt;&gt;()</a>.</p>
<p><a class="el" href="namespaceseq.html#ac422fc75d3e6f011374ffeed3683da55" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object.">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters.">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="af0031c82ad3d33c5094644a8c07f5464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0031c82ad3d33c5094644a8c07f5464">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a floating point value from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>dot character, usually '.' for 'C' locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an floating point value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>If the parsing fails (no floating point pattern was detected), the stream status will be set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587" title="End of file reached.">BadInputFormat</a> or <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a> depending on the situation, and stream get position will be reverted to its original state.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>This function is usefull when you need to read a huge amount of floating point values of a std::istream object. Internal benchmarks show that using <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object.">from_stream()</a> is around 20 faster (or more) than using <a class="el" href="namespaceseq.html#a7083aa58832400e4ec4cd4baaf5b39d0">std::istream::operator&gt;&gt;()</a>.</p>
<p><a class="el" href="namespaceseq.html#ac422fc75d3e6f011374ffeed3683da55" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object.">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters.">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="a36637d3bd7fde2e315ed4a5d1bc29f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36637d3bd7fde2e315ed4a5d1bc29f35">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a floating point value from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>dot character, usually '.' for 'C' locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an floating point value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>If the parsing fails (no floating point pattern was detected), the stream status will be set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587" title="End of file reached.">BadInputFormat</a> or <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a> depending on the situation, and stream get position will be reverted to its original state.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>This function is usefull when you need to read a huge amount of floating point values of a std::istream object. Internal benchmarks show that using <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object.">from_stream()</a> is around 20 faster (or more) than using <a class="el" href="namespaceseq.html#a7083aa58832400e4ec4cd4baaf5b39d0">std::istream::operator&gt;&gt;()</a>.</p>
<p><a class="el" href="namespaceseq.html#ac422fc75d3e6f011374ffeed3683da55" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object.">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters.">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="a53df224196282a50a8e3c99d4bd5ff5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53df224196282a50a8e3c99d4bd5ff5c">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a word from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full word from a stream object. In a text files, words are delimited by white-space characters (' ', '\t', '<br  />
', '\v', '\f', '\r', EOF). If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a>. </p>

</div>
</div>
<a id="ade167dcc6d29b420964a6be1498889ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade167dcc6d29b420964a6be1498889ac">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an integral value from a <a class="el" href="classseq_1_1basic__input__stream.html" title="Base class for input text streams.">seq::basic_input_stream</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">base</td><td>integer base (default to 10) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for an integral pattern. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>For hexadecimal numbers, the (potential) '0x' prefix will be automatically detected and handled. Leading spaces are consumed. If the pattern is a valid integral text representation too large to be stored in a value, the full pattern will still be consumed. Reading a negative text representation in an unsigned variable is not valid.</p>
<p>If the parsing fails (no integral pattern was detected), the stream status will be set to BadInputFormat or EndOfFile depending on the situation.</p>
<p><a class="el" href="namespaceseq.html#ac422fc75d3e6f011374ffeed3683da55" title="Read an integral value from the sequence of characters [first,last).">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object.">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters.">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="ac2d0cf3592690ba5924d6eb3f5cf48a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d0cf3592690ba5924d6eb3f5cf48a8">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , size_t Ss, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Ss, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a word from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full word from a stream object. In a text files, words are delimited by white-space characters (' ', '\t', '<br  />
', '\v', '\f', '\r', EOF). If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a>. </p>

</div>
</div>
<a id="a8ad0247ee4ca62ff368c30bea8e49dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad0247ee4ca62ff368c30bea8e49dfb">&#9670;&nbsp;</a></span>generate_random_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class String &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::generate_random_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; String
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For tests only, generate a random string of given max size. </p>

</div>
</div>
<a id="a30368dcf14dfdddd428c9ac9ec675b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30368dcf14dfdddd428c9ac9ec675b6f">&#9670;&nbsp;</a></span>get_memory_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::get_memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; size_t
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ca5fac631207b6d7245eab5a6bfe8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca5fac631207b6d7245eab5a6bfe8b7">&#9670;&nbsp;</a></span>get_type_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::get_type_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns type Id used by <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers.">hold_any</a> as a unique type identifier. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique Id for type T </dd></dl>

</div>
</div>
<a id="aa535bb70de1e29e29171a70f2c6d4c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa535bb70de1e29e29171a70f2c6d4c4d">&#9670;&nbsp;</a></span>get_type_id&lt; char * &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; char * &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab781597e8779c713676aba4698fd848d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab781597e8779c713676aba4698fd848d">&#9670;&nbsp;</a></span>get_type_id&lt; char &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; char &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a3ce56c553ccd79e26f7f2e5ff6a5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3ce56c553ccd79e26f7f2e5ff6a5d6">&#9670;&nbsp;</a></span>get_type_id&lt; const char * &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; const char * &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a165806293492ddc64cdae62b2723a2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165806293492ddc64cdae62b2723a2aa">&#9670;&nbsp;</a></span>get_type_id&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae96a8959187654c0283d35c91ad47e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae96a8959187654c0283d35c91ad47e4">&#9670;&nbsp;</a></span>get_type_id&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa4477f90c09909b8e9538eb9da5bf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4477f90c09909b8e9538eb9da5bf7b">&#9670;&nbsp;</a></span>get_type_id&lt; int &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; int &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa69056c156aed224619be70f8d1b961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa69056c156aed224619be70f8d1b961">&#9670;&nbsp;</a></span>get_type_id&lt; long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af164b3dca8307e99383ea0577c64e297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af164b3dca8307e99383ea0577c64e297">&#9670;&nbsp;</a></span>get_type_id&lt; long double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; long double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32abbdc5f1a43477d971a281960a1a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32abbdc5f1a43477d971a281960a1a3f">&#9670;&nbsp;</a></span>get_type_id&lt; long long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; long long &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb7f881f13a6b4fa8b73626ff7faf21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7f881f13a6b4fa8b73626ff7faf21b">&#9670;&nbsp;</a></span>get_type_id&lt; short &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; short &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77e40b1ff9e72e37869e79ff2921c563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e40b1ff9e72e37869e79ff2921c563">&#9670;&nbsp;</a></span>get_type_id&lt; signed char &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; signed char &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abaa6092c3c1f1ddbe9254ec3326474b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa6092c3c1f1ddbe9254ec3326474b9">&#9670;&nbsp;</a></span>get_type_id&lt; std::string &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; std::string &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a072571a60a39d5dc2506197b72999018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072571a60a39d5dc2506197b72999018">&#9670;&nbsp;</a></span>get_type_id&lt; tstring &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; <a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac186905c09880c418c0b7ba68e1fcfa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac186905c09880c418c0b7ba68e1fcfa0">&#9670;&nbsp;</a></span>get_type_id&lt; tstring_view &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade528e72270aa996e16dfaaeeb237910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade528e72270aa996e16dfaaeeb237910">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned char &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; unsigned char &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa30d6a10918be7b27352573cd354d531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30d6a10918be7b27352573cd354d531">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned int &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; unsigned int &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac045797c9594a025910e27b5fae38485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac045797c9594a025910e27b5fae38485">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; unsigned long &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e5cd482ca7d194206ec5e87f86a27cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5cd482ca7d194206ec5e87f86a27cd">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned long long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; unsigned long long &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62471b1db1a49cb2326ca9578bbefd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62471b1db1a49cb2326ca9578bbefd44">&#9670;&nbsp;</a></span>get_type_id&lt; unsigned short &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">seq::get_type_id</a>&lt; unsigned short &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08d5414cdd66534c903b9667391934f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d5414cdd66534c903b9667391934f2">&#9670;&nbsp;</a></span>hash_bytes_fnv1a()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::hash_bytes_fnv1a </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a hash value for input data using the fnv1a algorithm. This version reads the input buffer by chunks of sizeof(size_t). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>input buffer </td></tr>
    <tr><td class="paramname">len</td><td>input buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>computed hash value </dd></dl>

</div>
</div>
<a id="ab48356b6277c4d0a4eae3e8df71928e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48356b6277c4d0a4eae3e8df71928e9">&#9670;&nbsp;</a></span>hash_bytes_fnv1a_slow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::hash_bytes_fnv1a_slow </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a hash value for input data using the fnv1a algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>input buffer </td></tr>
    <tr><td class="paramname">len</td><td>input buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>computed hash value </dd></dl>

</div>
</div>
<a id="a7b21f8567341968f120686ab59a18a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b21f8567341968f120686ab59a18a86">&#9670;&nbsp;</a></span>hash_bytes_murmur64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::hash_bytes_murmur64 </td>
          <td>(</td>
          <td class="paramtype">const std::uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a hash value for input data using the murmurhash2 algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>input buffer </td></tr>
    <tr><td class="paramname">len</td><td>input buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>computed hash value </dd></dl>

</div>
</div>
<a id="a1e75ac2752560b9441e25dbeb0a37035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e75ac2752560b9441e25dbeb0a37035">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::hash_combine </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>h2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine 2 hash values. Uses either murmurhash2 for 64 bits platform or the boost version for 32 bits platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h1</td><td>first hash value </td></tr>
    <tr><td class="paramname">h2</td><td>second hash value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combination of both hash value </dd></dl>

</div>
</div>
<a id="abb5af289596de39f1073e3071263a644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5af289596de39f1073e3071263a644">&#9670;&nbsp;</a></span>is_arithmetic_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_arithmetic_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to an arithmetic type (floating point or integral) </p>

</div>
</div>
<a id="aa2ee2f93a9ebfb47e00fb2a353c26627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ee2f93a9ebfb47e00fb2a353c26627">&#9670;&nbsp;</a></span>is_floating_point_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_floating_point_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to a floating point type. </p>

</div>
</div>
<a id="a29f9511e243d78950b21507f5a4fe896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f9511e243d78950b21507f5a4fe896">&#9670;&nbsp;</a></span>is_integral_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_integral_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to an integral type. </p>

</div>
</div>
<a id="aa78953b53d9255df1c87a82bb8a7ecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78953b53d9255df1c87a82bb8a7ecd4">&#9670;&nbsp;</a></span>is_signed_integral_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_signed_integral_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to a signed integral type. </p>

</div>
</div>
<a id="a9a34e6330b33a12e7e645c50d6d50a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a34e6330b33a12e7e645c50d6d50a84">&#9670;&nbsp;</a></span>is_string_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_string_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to a string type (std::string, tstring, tstring_view or const char*) </p>

</div>
</div>
<a id="a5e891e43f7fe2c2737322a9b273d4a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e891e43f7fe2c2737322a9b273d4a06">&#9670;&nbsp;</a></span>is_unsigned_integral_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_unsigned_integral_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to an unsigned integral type. </p>

</div>
</div>
<a id="adf2b63f4cea16071daccd0ab528b695e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2b63f4cea16071daccd0ab528b695e">&#9670;&nbsp;</a></span>make_any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Any , class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::make_any </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; Any
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5417e4eca78972288f212c355f07923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5417e4eca78972288f212c355f07923">&#9670;&nbsp;</a></span>make_any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Any , class T , class U , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::make_any </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Any
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae02fc574f6876f28fef03044ed31569e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02fc574f6876f28fef03044ed31569e">&#9670;&nbsp;</a></span>make_comparator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::make_comparator </td>
          <td>(</td>
          <td class="paramtype">const Comp &amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structseq_1_1comp__wrapper.html">comp_wrapper</a>&lt;Comp&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a comparison functor that can be used by algorithms working on cvector objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Comp</td><td>actual comparison function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>comparison function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>comparison wrapper </dd></dl>

</div>
</div>
<a id="a32e7a0c600427f614ba162d86c3c4362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e7a0c600427f614ba162d86c3c4362">&#9670;&nbsp;</a></span>make_lock_guard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::make_lock_guard </td>
          <td>(</td>
          <td class="paramtype">Lock &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1lock__guard.html">lock_guard</a>&lt;Lock&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a lock guard around l. Use copy elison to avoid creating copies and locking twice the lock object. </p>

</div>
</div>
<a id="a81932472ffd88a08d7b6f0aaf2c123e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81932472ffd88a08d7b6f0aaf2c123e9">&#9670;&nbsp;</a></span>move_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::move_allocator </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move allocator for container move assignment. </p>

</div>
</div>
<a id="a7c279fa143d4e6216df953924ce47406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c279fa143d4e6216df953924ce47406">&#9670;&nbsp;</a></span>negate_if_signed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::negate_if_signed </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt;T&gt;::type </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns -v if v is signed, v otherwise. </p>

</div>
</div>
<a id="ab2f848adb0c9d3ac36fb1c523850748b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f848adb0c9d3ac36fb1c523850748b">&#9670;&nbsp;</a></span>nth_bit_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned seq::nth_bit_set </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d6a00f67a9341cb4bcc99c107515229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6a00f67a9341cb4bcc99c107515229">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa17cb52d5ec33df7205c8bca8e2f76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa17cb52d5ec33df7205c8bca8e2f76e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, L2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are not equals. </p>

</div>
</div>
<a id="a1b9d8109fa888ce35b35ace5c02e0521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9d8109fa888ce35b35ace5c02e0521">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, L2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are not equals. </p>

</div>
</div>
<a id="a4d70682ae06526dec970a65e5a5444af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d70682ae06526dec970a65e5a5444af">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8a77517d376eeb44fc2615040f226b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a77517d376eeb44fc2615040f226b3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> for inequality, synthesized from operator==. </p>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare non equals, false otherwise </dd></dl>

</div>
</div>
<a id="a12a8e4ca5bdbbf2cd53645c2733449d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a8e4ca5bdbbf2cd53645c2733449d0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> for inequality, synthesized from operator==. </p>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare non equals, false otherwise </dd></dl>

</div>
</div>
<a id="a948fa0ea1e3ce1689da9c6b62c096245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948fa0ea1e3ce1689da9c6b62c096245">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6648c56dd5562d5fe6a6deada5215c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6648c56dd5562d5fe6a6deada5215c6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b6a796c87305524653d7265ae4da2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6a796c87305524653d7265ae4da2ff">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe32bc8987b500a2d007b0a068d48538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe32bc8987b500a2d007b0a068d48538">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9e28e6da6ec3562c1faef9ef00631d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e28e6da6ec3562c1faef9ef00631d6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68147f1f9efe66da434919961feed1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68147f1f9efe66da434919961feed1f0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae509e47a7299cf5e9eaa6d2bb386db1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae509e47a7299cf5e9eaa6d2bb386db1f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57a83c380ba3efb861a6d64bd87360c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a83c380ba3efb861a6d64bd87360c1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97cec60fd49b0943f3f8501fcec57676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cec60fd49b0943f3f8501fcec57676">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbdee63e1144180cadb75be9d1730787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdee63e1144180cadb75be9d1730787">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6610e8513f7ab68233cdd6d46151209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6610e8513f7ab68233cdd6d46151209">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8056fc410913073144c5fa466cbc690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8056fc410913073144c5fa466cbc690">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bb1d95a792c4df40a9942662ab573ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb1d95a792c4df40a9942662ab573ff">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size, Al&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Size2, Al2&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa242d97b0138a72bd07cabe76a62ef17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa242d97b0138a72bd07cabe76a62ef17">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a3dab51febe50dfd60f7bd4fe46154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3dab51febe50dfd60f7bd4fe46154f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T&gt;::difference_type </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfc02f75db7d73bb10c42d71a370c368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc02f75db7d73bb10c42d71a370c368">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c4cb9a01f8408e24f5cf3b5874876f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4cb9a01f8408e24f5cf3b5874876f9">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b9d6f4841a2e0a530497f5d0033aaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9d6f4841a2e0a530497f5d0033aaed">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d793a96fc5ac7087c067d0b129662d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d793a96fc5ac7087c067d0b129662d0">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a795abf0d602c2dabb457d4ca67f35879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795abf0d602c2dabb457d4ca67f35879">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea4feaa3ec5619d0c601da47ed4245c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4feaa3ec5619d0c601da47ed4245c3">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7797b9c1954288017fdfe309b554454a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7797b9c1954288017fdfe309b554454a">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b6a7ec8e9a4fc0d7eaf0d5f523774ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6a7ec8e9a4fc0d7eaf0d5f523774ca">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1390c60d480ef706cb933a10356b9245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1390c60d480ef706cb933a10356b9245">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Elem , class Traits , class T , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>oss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1detail_1_1mutli__ostream__format.html">detail::mutli_ostream_format</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::basic_ostream&lt;Elem, Traits&gt;&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class.">ostream_format</a> object to a std::ostream object. </p>

</div>
</div>
<a id="a892fa27ee42cd6f34066d399a9e7d317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892fa27ee42cd6f34066d399a9e7d317">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Elem , class Traits , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>oss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::basic_ostream&lt;Elem, Traits&gt;&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class.">ostream_format</a> object to a std::ostream. </p>

</div>
</div>
<a id="a9bc6f1dda9c576a66b148a346792a983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc6f1dda9c576a66b148a346792a983">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Elem , class Traits , size_t Size, class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>oss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::basic_ostream&lt;Elem, Traits&gt;&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a110ce7828a4cf726d001fe58fa6983cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110ce7828a4cf726d001fe58fa6983cf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>oss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::ostream&amp; 
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9edd539db8412668d682cf9ff5e7a070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edd539db8412668d682cf9ff5e7a070">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6920a1594333ae1cb5a606a699e2fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6920a1594333ae1cb5a606a699e2fa7">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad31a8a06b8bf8a14af3fdea25e05fdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31a8a06b8bf8a14af3fdea25e05fdb5">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aedc2a4ddf5388c2ced30ccb8f562d675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc2a4ddf5388c2ced30ccb8f562d675">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac504522396fae94ad4b6b1ccc15f913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac504522396fae94ad4b6b1ccc15f913">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad008ee24c9386b09b25e912de5d4c1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad008ee24c9386b09b25e912de5d4c1a1">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56068d4d371f671c476f2d48a14c40c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56068d4d371f671c476f2d48a14c40c4">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8f6d50f3c32887116c4bae46c3429d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f6d50f3c32887116c4bae46c3429d4">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa56c6d64eb04a963a9812c8b7f9714ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56c6d64eb04a963a9812c8b7f9714ee">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66772d69054d5e2792a3e2e2ceee8d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66772d69054d5e2792a3e2e2ceee8d44">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, L2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position. </p>

</div>
</div>
<a id="aa5dadf0da6e85313800689b619a18843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5dadf0da6e85313800689b619a18843">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare , class Al1 , class Al2 , LayoutManagement L1, LayoutManagement L2, bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, L1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, L2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position. </p>

</div>
</div>
<a id="ae93974cf840383439da3212e3c79d7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93974cf840383439da3212e3c79d7c1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3debed99e1f30055ff02d9d0ee009727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3debed99e1f30055ff02d9d0ee009727">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> for equality. Two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> are considered equal if they contain the same pairs key-&gt;value. Key ordering is not considered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> </td></tr>
    <tr><td class="paramname">rhs</td><td>right <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">ordered_map</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare equals, false otherwise </dd></dl>

</div>
</div>
<a id="a4308e82af69325da59bf1abe2e9b30d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4308e82af69325da59bf1abe2e9b30d1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> for equality. Two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> are considered equal if they contain the same keys. Key ordering is not considered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> </td></tr>
    <tr><td class="paramname">rhs</td><td>right <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare equals, false otherwise </dd></dl>

</div>
</div>
<a id="a6ea7559047b3040872cdd1c38315df2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea7559047b3040872cdd1c38315df2e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87776b63812842147b01988b45038dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87776b63812842147b01988b45038dc3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a861414ba0c42c6e112aacd979592b13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861414ba0c42c6e112aacd979592b13c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72b61cb7cf1085d47e734de14233ef20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b61cb7cf1085d47e734de14233ef20">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af67d4f6b5e7766ac1cc45a0e5842e1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67d4f6b5e7766ac1cc45a0e5842e1a1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f3482ce2ab94dc59b5b2b857802906f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3482ce2ab94dc59b5b2b857802906f">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e24e00cf888c85c3bc16fa9a8f8dfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e24e00cf888c85c3bc16fa9a8f8dfbf">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5d755e83159497ccb56faf6cee44920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d755e83159497ccb56faf6cee44920">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a382805c206a702e81be578225f9b2a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382805c206a702e81be578225f9b2a6c">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89dc0d9ce34c9cc16bf0480f4d21eb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dc0d9ce34c9cc16bf0480f4d21eb8c">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58cc10a31374b3edfd99aa9d766ad5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cc10a31374b3edfd99aa9d766ad5c7">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3422ba2ed76ef830f9a768efb0ab264b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3422ba2ed76ef830f9a768efb0ab264b">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e1833a5b86d9fe7f4aa324dc762ee7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1833a5b86d9fe7f4aa324dc762ee7f">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d1652748e87ae34ddb4e4aaee0c1047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1652748e87ae34ddb4e4aaee0c1047">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93bda8a7271df48555e68fe9d51ebf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bda8a7271df48555e68fe9d51ebf37">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb735dd312cf970ea6818037bfbf4928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb735dd312cf970ea6818037bfbf4928">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefbd22b85882e325ad2aa30cc80476fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbd22b85882e325ad2aa30cc80476fa">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5263b4df259430eb4336f6b1348871c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5263b4df259430eb4336f6b1348871c1">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0492edc203e24e4f2a815f88b63b6b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0492edc203e24e4f2a815f88b63b6b9c">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a099bb20d7de44b7e830799fea7f7a709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099bb20d7de44b7e830799fea7f7a709">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42b02d9de4bef32a8048a063ca879338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b02d9de4bef32a8048a063ca879338">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, class Al , size_t Size2, class Al2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size2, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc51a3f40a4cee1e71e1d831ee8dc681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc51a3f40a4cee1e71e1d831ee8dc681">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Elem , class Traits , size_t Size, class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>iss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Size, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;!std::is_same&lt;Alloc, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a>&gt;::value, std::basic_istream&lt;Elem, Traits&gt; &gt;::type	&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7083aa58832400e4ec4cd4baaf5b39d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7083aa58832400e4ec4cd4baaf5b39d0">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>iss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::istream&amp;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a348cf02b3ab7947f01df82985d741138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348cf02b3ab7947f01df82985d741138">&#9670;&nbsp;</a></span>popcnt16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::popcnt16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; unsigned
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08ad7cd23d956c6e3205dd20ff1629b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ad7cd23d956c6e3205dd20ff1629b3">&#9670;&nbsp;</a></span>popcnt32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t seq::popcnt32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93474d742382c06825212a479a720fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93474d742382c06825212a479a720fcb">&#9670;&nbsp;</a></span>popcnt64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::popcnt64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2cd15c1c849768be9995bcb1fd1733a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cd15c1c849768be9995bcb1fd1733a">&#9670;&nbsp;</a></span>popcnt8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::popcnt8 </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; unsigned
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab534e8a0f6ac376f61e976fe7cd65457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab534e8a0f6ac376f61e976fe7cd65457">&#9670;&nbsp;</a></span>pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::pos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt;Ts...&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a positional object used either by <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt()</a> or operator() of formatting object. </p>

</div>
</div>
<a id="a4b887df093a1fae4487fccd6c1949116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b887df093a1fae4487fccd6c1949116">&#9670;&nbsp;</a></span>print_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::print_null </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8b268bc53b846426ab17a84bb756fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b268bc53b846426ab17a84bb756fab">&#9670;&nbsp;</a></span>random_shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::random_shuffle </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to C++11 (and deprecated) std::random_shuffle. </p>

</div>
</div>
<a id="a20f46b0218710a8c5534b5795ce95b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f46b0218710a8c5534b5795ce95b2e">&#9670;&nbsp;</a></span>read_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint16_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 16 bits integer from src. </p>

</div>
</div>
<a id="a36b48ff10138ee36cd0f4949f01a23f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b48ff10138ee36cd0f4949f01a23f1">&#9670;&nbsp;</a></span>read_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint32_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 32 bits integer from src. </p>

</div>
</div>
<a id="a53674d0482ead92a98023ed0d7c57dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53674d0482ead92a98023ed0d7c57dd1">&#9670;&nbsp;</a></span>read_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint64_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 64 bits integer from src. </p>

</div>
</div>
<a id="aa1f9f34cc361321151e13951ccad2ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f9f34cc361321151e13951ccad2ac4">&#9670;&nbsp;</a></span>read_BE_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_BE_16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint16_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 16 bits integer from src in big endian order. </p>

</div>
</div>
<a id="adccead2b857599b0e675267609e5120f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccead2b857599b0e675267609e5120f">&#9670;&nbsp;</a></span>read_BE_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_BE_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint32_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 32 bits integer from src in big endian order. </p>

</div>
</div>
<a id="a3778777f10583618f958211656aec2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3778777f10583618f958211656aec2b4">&#9670;&nbsp;</a></span>read_BE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_BE_64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint64_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 64 bits integer from src in big endian order. </p>

</div>
</div>
<a id="a79fbedb52aef41b37b7b243497ead642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fbedb52aef41b37b7b243497ead642">&#9670;&nbsp;</a></span>read_BE_size_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_BE_size_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads size_t object from src in big endian order. </p>

</div>
</div>
<a id="a052b75a0721954d5497ff1753315e997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052b75a0721954d5497ff1753315e997">&#9670;&nbsp;</a></span>read_LE_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_LE_16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint16_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read 16 bits integer from src in little endian order. </p>

</div>
</div>
<a id="a1a00bc4c5f354e2350bab137e35c0ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a00bc4c5f354e2350bab137e35c0ceb">&#9670;&nbsp;</a></span>read_LE_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_LE_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint32_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read 32 bits integer from src in little endian order. </p>

</div>
</div>
<a id="aee33b43276433d62551712f283741546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee33b43276433d62551712f283741546">&#9670;&nbsp;</a></span>read_LE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_LE_64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint64_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read 64 bits integer from src in little endian order. </p>

</div>
</div>
<a id="aa1f5bd629161aaad113175e3b0217f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f5bd629161aaad113175e3b0217f29">&#9670;&nbsp;</a></span>read_LE_size_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_LE_size_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads size_t object from src in little endian order. </p>

</div>
</div>
<a id="add85486f09f54fba24d5f3cc4737474c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add85486f09f54fba24d5f3cc4737474c">&#9670;&nbsp;</a></span>read_line_from_stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_line_from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a line from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full line from a stream object. In a text files, lines are delimited by characters '<br  />
', '\r' or EOF. If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a>. </p>

</div>
</div>
<a id="a6ac4d359a9469e24e86016201d1cb5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac4d359a9469e24e86016201d1cb5fb">&#9670;&nbsp;</a></span>read_line_from_stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , size_t Ss, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_line_from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Ss, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a line from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full line from a stream object. In a text files, lines are delimited by characters '<br  />
', '\r' or EOF. If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error.">EndOfFile</a>. </p>

</div>
</div>
<a id="ae07d1a9758d3ce39924f26eff332f759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07d1a9758d3ce39924f26eff332f759">&#9670;&nbsp;</a></span>read_ptr_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_ptr_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uintptr_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads uintptr_t integer from src. </p>

</div>
</div>
<a id="a2adb2cb36973f3d571f0984dffb68d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adb2cb36973f3d571f0984dffb68d87">&#9670;&nbsp;</a></span>read_size_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_size_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads size_t object from src. </p>

</div>
</div>
<a id="a97851d71ded4c7928aabd76f4280d268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97851d71ded4c7928aabd76f4280d268">&#9670;&nbsp;</a></span>register_any_conversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_conversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a conversion function based on explicit conversion from type T to type U. </p>

</div>
</div>
<a id="ad7a515ea06834d35cedd4e4f9c4ba1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a515ea06834d35cedd4e4f9c4ba1b0">&#9670;&nbsp;</a></span>register_any_conversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_conversion </td>
          <td>(</td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a conversion function using given functor. </p>

</div>
</div>
<a id="adb61336a531e99a11a888883a46d0f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb61336a531e99a11a888883a46d0f01">&#9670;&nbsp;</a></span>register_any_equal_comparison() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_equal_comparison </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the comparison function <a class="el" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T()</a> == U() </p>

</div>
</div>
<a id="aaa783de724c82de2264d98a3437294df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa783de724c82de2264d98a3437294df">&#9670;&nbsp;</a></span>register_any_equal_comparison() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_equal_comparison </td>
          <td>(</td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a comparison function between types T and U based on given functor. </p>

</div>
</div>
<a id="ab390e9bf772c9a88f9f48c5bd360d7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab390e9bf772c9a88f9f48c5bd360d7ed">&#9670;&nbsp;</a></span>register_any_less_comparison() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_less_comparison </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the comparison function <a class="el" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T()</a> &lt; U() </p>

</div>
</div>
<a id="a0b0810417829f24c04037720cfe1cc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0810417829f24c04037720cfe1cc92">&#9670;&nbsp;</a></span>register_any_less_comparison() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_less_comparison </td>
          <td>(</td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a comparison function between types T and U based on given functor. </p>

</div>
</div>
<a id="acabfa3eaf9a03808f516c1c71d521dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabfa3eaf9a03808f516c1c71d521dee">&#9670;&nbsp;</a></span>reset_memory_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seq::reset_memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a759ced44c9584918c6302fe6562ba950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759ced44c9584918c6302fe6562ba950">&#9670;&nbsp;</a></span>string_data() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; const char* </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abacbb14fd705709e8f7d3d9b77daeea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacbb14fd705709e8f7d3d9b77daeea3">&#9670;&nbsp;</a></span>string_data() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; const char* </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string data (const char*) for given string object. </p>

</div>
</div>
<a id="a883e44e91646300fed68720e2e9e7c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883e44e91646300fed68720e2e9e7c90">&#9670;&nbsp;</a></span>string_data() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t S, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; const char* </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0218c72afdb6220de9da3a069dc3efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0218c72afdb6220de9da3a069dc3efa">&#9670;&nbsp;</a></span>string_data() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; const char* </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac404d9958f2200e3e6588b5601759b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac404d9958f2200e3e6588b5601759b1c">&#9670;&nbsp;</a></span>string_size() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cb962f97eeea267d9b1e420879eb1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb962f97eeea267d9b1e420879eb1ff">&#9670;&nbsp;</a></span>string_size() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string size for given string object. </p>

</div>
</div>
<a id="abf9baf42d336da7e5368e05ecd5d2515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9baf42d336da7e5368e05ecd5d2515">&#9670;&nbsp;</a></span>string_size() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t S, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; S, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada0db3e95c769979401e3c88ec361613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0db3e95c769979401e3c88ec361613">&#9670;&nbsp;</a></span>string_size() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceseq.html#a2bede5ff16f5bb9f856b3b2d78303f69">tstring_view</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76e83b922f85075d41cf05cbf365dc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e83b922f85075d41cf05cbf365dc07">&#9670;&nbsp;</a></span>swap_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::swap_allocator </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap allocators for container.swap member. </p>

</div>
</div>
<a id="ad863fcfc143b646f5a2f2362a1327575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad863fcfc143b646f5a2f2362a1327575">&#9670;&nbsp;</a></span>tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seq::tick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For tests only, reset timer for calling thread. </p>

</div>
</div>
<a id="ac778d2e1714b0bc1a988a8ef573fed6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac778d2e1714b0bc1a988a8ef573fed6e">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e1cfb2de75c85497d57702430705b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1cfb2de75c85497d57702430705b1c">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first output character </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>input value to convert to string </td></tr>
    <tr><td class="paramname">base</td><td>integer base (default to 10) </td></tr>
    <tr><td class="paramname">fmt</td><td>optional format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">to_chars_result</a> object</dd></dl>
<p>value is converted to a string of digits in the given base (with no redundant leading zeroes by default). Digits in the range 10..35 (inclusive) are represented as lowercase characters a..z by default. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type char as the type of the parameter value. This function produces a similar output as std::to_chars.</p>
<p>Output formatting can be controlled through a #integral_chars_format object:</p><ul>
<li>Digits in the range 10..35 (inclusive) can be represented as uppercase characters A..Z with <a class="el" href="structseq_1_1integral__chars__format.html#acafd17ef17d30b606b9c7087ec7e8d73" title="Output upper characters for hexadecimal numbers.">integral_chars_format::upper_case</a></li>
<li>For base 16, a trailing '0x' can be added with <a class="el" href="structseq_1_1integral__chars__format.html#adbac65c685a9d5c9021e228cee354eed" title="Add &#39;0x&#39; prefix to hexadecimal numbers.">integral_chars_format::hex_prefix</a></li>
<li>A minimum width (in number of digits) can be specified to add leading zeros with <a class="el" href="structseq_1_1integral__chars__format.html#a7fd219f1f9f4a2d0760313d06a378f3a" title="Minimum digits to represent integral types (use zero padding).">integral_chars_format::integral_min_width</a></li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">seq::to_chars_result</a> such that ec equals value-initialized std::errc and ptr is the one-past-the-end pointer of the characters written. Note that the string is not NULL-terminated.</p>
<p>On error, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">seq::to_chars_result</a> holding std::errc::value_too_large in ec, a copy of the value last in ptr, and leaves the contents of the range[first, last) in unspecified state. </p>

</div>
</div>
<a id="a85aae92558690a191bd6e300ce27d78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85aae92558690a191bd6e300ce27d78c">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c373f2fadfaefd16b35d3656717208a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c373f2fadfaefd16b35d3656717208a">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adac4ff8894fc503318b23b05b28365ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac4ff8894fc503318b23b05b28365ce">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>exp</em> = <code>'e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44c75fd24d42eb6c6470210805c3798c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c75fd24d42eb6c6470210805c3798c">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first output character </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>input value to convert to string </td></tr>
    <tr><td class="paramname">fmt</td><td>floating-point formatting to use, a bitmask of type <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682" title="A BitmaskType used to specify floating-point formatting for seq::to_chars. This is similar to std::ch...">seq::chars_format</a> </td></tr>
    <tr><td class="paramname">precision</td><td>maximum digits after the radix point </td></tr>
    <tr><td class="paramname">fmt</td><td>optional format </td></tr>
    <tr><td class="paramname">dot</td><td>optional decimal point sequence, default to "." </td></tr>
    <tr><td class="paramname">exp</td><td>optional exponential character, default to 'e' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">to_chars_result</a> object</dd></dl>
<p>value is converted to a string as if by std::printf in the default ("C") locale (with some differences, see below). This function DOES NOT provide exact formatting of the input unlike printf familly of functions.</p>
<p>The conversion specifier is 'f' or 'e' (resolving in favor of f in case of a tie), chosen according to the requirement for a shortest representation: the string representation consists of the smallest number of characters such that there is at least one digit before the radix point (if present).</p>
<p>The conversion specified for the as-if printf is 'f' if fmt is seq::chars_format::fixed, 'e' if fmt is seq::chars_format::scientific, and 'g' if fmt is chars_format::general (default).</p>
<p>If the precision is specified by the parameter 'precision', this function will output up-to (but to necessarily exactly) 'precision' digits after the radix point. The default precision is 6. This function will always try to output the smallest possible character sequence. If 'dot' is specified, it will replace the '.' decimal point used by the "C" locale.</p>
<p>If 'exp' is specified, it will replace the 'e' exponent character used by the "C" locale.</p>
<p>NaN and infinit values are handled by this function.</p>
<p>On success, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">seq::to_chars_result</a> such that ec equals value-initialized std::errc and ptr is the one-past-the-end pointer of the characters written. Note that the string is not NULL-terminated.</p>
<p>On error, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result.">seq::to_chars_result</a> holding std::errc::value_too_large in ec, a copy of the value last in ptr, and leaves the contents of the range[first, last) in unspecified state.</p>
<p>There are currently a lot of different algorithms to provide fast and exact convertion of floating point values to strings: ryu, grisu-exact, dragonbox... This function tries to provide a faster and lighter alternative when exact precision is not a requirement (which is my case). Internal benchmarks show that convertiing double values to string using this function is around 2 times faster than with ryu library for scientific or general formatting, and 3 times faster with fixed formatting.</p>
<p>When converting double values, obtained strings are similar to the result of printf in 100% of the cases when the required precision is below 12. After that, the ratio decreases to 87% of exactitude for a precision of 17. Converting a very high (or very small) value with the 'f' specifier will usually produce slightly different output, especially in the "garbade" digits.</p>
<p>Use this function when you need very fast formatting of a huge amount of floating point values without exact formatting requirement. </p>

</div>
</div>
<a id="ad4e61035b14149d9c984d7b6dfbf6681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e61035b14149d9c984d7b6dfbf6681">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a895eff859309c7eb594f6efce61df9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895eff859309c7eb594f6efce61df9b8">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>exp</em> = <code>'e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6c3c78201587dd15f2d262c1cbb22a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c3c78201587dd15f2d262c1cbb22a5">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa69f4f092c96147e027be85bc3620e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69f4f092c96147e027be85bc3620e3d">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae446ea1d0a68784bccf7027fc9273bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae446ea1d0a68784bccf7027fc9273bcd">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6347c0acfbf3ae451b414e8faaf26b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6347c0acfbf3ae451b414e8faaf26b21">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>exp</em> = <code>'e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1f5172bb6410a2f26155289919b94ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f5172bb6410a2f26155289919b94ca">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfa81a642c601963cc3705f245d5993c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa81a642c601963cc3705f245d5993c">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b59d6549285b87fc972d4fcf94a6b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b59d6549285b87fc972d4fcf94a6b3e">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa334d76820ca19ea006395faa17aab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa334d76820ca19ea006395faa17aab9">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81169e9865167e86562c956fe54ad9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81169e9865167e86562c956fe54ad9c6">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1eed3d5531ee31256046a546bdab4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1eed3d5531ee31256046a546bdab4ff">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32ce6d36a38f1b4d27d34b155a3b21f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ce6d36a38f1b4d27d34b155a3b21f9">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a520ffd9d059e63286f7eb2608e1a03fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520ffd9d059e63286f7eb2608e1a03fa">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abcfcd6e33f7e1ea6fbf6135d9cf70a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfcd6e33f7e1ea6fbf6135d9cf70a71">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a576ae74a514ded550299e48e4c32cc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576ae74a514ded550299e48e4c32cc64">&#9670;&nbsp;</a></span>tock_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::tock_ms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::uint64_t
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For tests only, returns elapsed milliseconds since last call to <a class="el" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575" title="For tests only, reset timer for calling thread.">tick()</a> </p>

</div>
</div>
<a id="aa113bfd5dcde4ed36475a4f3ba164e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa113bfd5dcde4ed36475a4f3ba164e54">&#9670;&nbsp;</a></span>tock_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::tock_us </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::uint64_t
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For tests only, returns elapsed microseconds since last call to <a class="el" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575" title="For tests only, reset timer for calling thread.">tick()</a> </p>

</div>
</div>
<a id="a1349a44a2ff37300a5c72a03780780fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1349a44a2ff37300a5c72a03780780fe">&#9670;&nbsp;</a></span>unique_ptr_delete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::unique_ptr_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate pointer previously held by a std::unqiue_ptr&lt;T,unique_ptr_deleter&lt;T&gt; &gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2480216425c6423b34df46e854b9764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2480216425c6423b34df46e854b9764">&#9670;&nbsp;</a></span>write_BE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_BE_64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 64 bits integer value to dst in big endian order. </p>

</div>
</div>
<a id="a8aa0f34c5b9efbaacd24ae215c6ebdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa0f34c5b9efbaacd24ae215c6ebdfe">&#9670;&nbsp;</a></span>write_LE_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_LE_16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 16 bits integer value to dst in little endian order. </p>

</div>
</div>
<a id="abbce06d3b6c0dd24ef956b3bba564914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbce06d3b6c0dd24ef956b3bba564914">&#9670;&nbsp;</a></span>write_LE_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_LE_32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 32 bits integer value to dst in little endian order. </p>

</div>
</div>
<a id="a2dd16ebc1860bdc316a5f83c8210a361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd16ebc1860bdc316a5f83c8210a361">&#9670;&nbsp;</a></span>write_LE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_LE_64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 64 bits integer value to dst in little endian order. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
