<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceseq.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">seq Namespace Reference<div class="ingroups"><a class="el" href="group__bits.html">Bits: collection of functions for low level bits manipulation.</a> &#124; <a class="el" href="group__charconv.html">Charconv: arithmetic value convertion from/to string</a> &#124; <a class="el" href="group__containers.html">Containers: original STL-like containers</a> &#124; <a class="el" href="group__format.html">Format: Type safe formatting module</a> &#124; <a class="el" href="group__hash.html">Hash: small collection of hash utilities</a> &#124; <a class="el" href="group__memory.html">Memory: collection of tools for memory management</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceseq_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceseq_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of set bits in <em>value</em>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator class with custom alignment.  <a href="classseq_1_1aligned__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1aligned__allocator_3_01_t_00_01std_1_1allocator_3_01_t_01_4_00_01_align_01_4.html">aligned_allocator&lt; T, std::allocator&lt; T &gt;, Align &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__base.html">any_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base interface for <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers. ">hold_any</a> class.  <a href="structseq_1_1any__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__default__interface.html">any_default_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default interface for <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers. ">hold_any</a>.  <a href="structseq_1_1any__default__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers. ">hold_any</a> for non hashable types.  <a href="structseq_1_1any__no__hash__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1any__type__info.html">any_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class representing a type and related functions.  <a href="classseq_1_1any__type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1any__typed__type__info.html">any_typed_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classseq_1_1any__type__info.html" title="Base class representing a type and related functions. ">any_type_info</a> for specific type (Type Erasure)  <a href="structseq_1_1any__typed__type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1assign__alloc.html">assign_alloc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1bad__any__function__call.html">bad_any_function_call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class similar to std::bad_function_call but storing a custom message.  <a href="classseq_1_1bad__any__function__call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1base__ostream__format.html">base_ostream_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for formatting objects.  <a href="structseq_1_1base__ostream__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1basic__input__stream.html">basic_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for input text streams.  <a href="classseq_1_1basic__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1basic__nullbuf.html">basic_nullbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1block__object__allocation.html">block_object_allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to MaxSize objects by step of BlockSize.  <a href="structseq_1_1block__object__allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1buffer__input__stream.html">buffer_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream working on a sequence of characters.  <a href="classseq_1_1buffer__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1by__any__char.html">by_any_char</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String matcher used by <a class="el" href="namespaceseq.html#a563c78745a64d62dffe9db8ead6c59b3">split()</a> function, match any of given set of characters.  <a href="structseq_1_1by__any__char.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1by__char.html">by_char</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String matcher used by <a class="el" href="namespaceseq.html#a563c78745a64d62dffe9db8ead6c59b3">split()</a> function, match a single character.  <a href="structseq_1_1by__char.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1by__not__any__char.html">by_not_any_char</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String matcher used by <a class="el" href="namespaceseq.html#a563c78745a64d62dffe9db8ead6c59b3">split()</a> function, match any character not present in given set of characters.  <a href="structseq_1_1by__not__any__char.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1by__string.html">by_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String matcher used by <a class="el" href="namespaceseq.html#a563c78745a64d62dffe9db8ead6c59b3">split()</a> function.  <a href="structseq_1_1by__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1by__word.html">by_word</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String matcher used by <a class="el" href="namespaceseq.html#a563c78745a64d62dffe9db8ead6c59b3">split()</a> function, match word break. Should be used in conjunction with <a class="el" href="structseq_1_1skip__empty.html" title="Skip empty strings. ">skip_empty</a> to extract words from text content.  <a href="structseq_1_1by__word.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1comp__wrapper.html">comp_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary comparison wrapper for using STL algorithm on cvector with custom comparators. Use <a class="el" href="namespaceseq.html#ae02fc574f6876f28fef03044ed31569e" title="Create a comparison functor that can be used by algorithms working on cvector objects. ">seq::make_comparator</a> to build &amp; <a class="el" href="structseq_1_1comp__wrapper.html" title="Binary comparison wrapper for using STL algorithm on cvector with custom comparators. Use seq::make_comparator to build &amp; comp_wrapper object. ">comp_wrapper</a> object.  <a href="structseq_1_1comp__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1context__ratio.html">context_ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the maximum number of decompression contexts a cvector can use. The number of contexts is either a fixed value or a ratio of the cvector bucket count. Use ContextRatio::Fixed to define a fixed number of contexts, or ContextRatio::Ratio to define a fraction of the bucket count. In this case (ratio), the number of contexts is equal to bucket_count/(float)ratio_value.  <a href="classseq_1_1context__ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient random access iterator on a constant value.  <a href="classseq_1_1cvalue__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html">cvector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector like class using compression to store its elements  <a href="classseq_1_1cvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html">devector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-ending vector implementation which can be optimized for several use case.  <a href="classseq_1_1devector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1disable__ostream.html">disable_ostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1equal__to.html">equal_to</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1equal__to_3_01void_01_4.html">equal_to&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1external__allocator.html">external_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stl conforming allocator wrapper using an external class to perform the allocation.  <a href="classseq_1_1external__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1file__input__stream.html">file_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream working on a FILE pointer.  <a href="classseq_1_1file__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1filler.html">filler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filler character.  <a href="structseq_1_1filler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__map.html">flat_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted associative container that contains key-value pairs with unique keys similar to boost::flat_map with faster insertion/deletion of single values  <a href="classseq_1_1flat__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multimap.html">flat_multimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted container similar to boost::flat_multimap with faster insertion/deletion of single values  <a href="classseq_1_1flat__multimap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values  <a href="classseq_1_1flat__multiset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html">flat_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flat sorted container similar to boost::flat_set with faster insertion/deletion of single values  <a href="classseq_1_1flat__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for <a class="el" href="namespaceseq.html#aa1718699b0708da31869470b90309a5b" title="Read an integral value from the sequence of characters [first,last). ">seq::from_chars</a> functions, similar to std::from_chars_result.  <a href="structseq_1_1from__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1greater.html">greater</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1greater_3_01void_01_4.html">greater&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1hold__any.html">hold_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::any like class optimized to build heterogeneous containers.  <a href="classseq_1_1hold__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the return type of <a class="el" href="namespaceseq.html#a7c279fa143d4e6216df953924ce47406" title="Returns -v if v is signed, v otherwise. ">seq::negate_if_signed</a> and <a class="el" href="namespaceseq.html#ab6f8f4791e95dce2f0a4298ff8e82797" title="Returns absolute value of v. ">seq::abs</a>.  <a href="structseq_1_1integer__abs__return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_011_01_4.html">integer_abs_return&lt; T, true, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_012_01_4.html">integer_abs_return&lt; T, true, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_014_01_4.html">integer_abs_return&lt; T, true, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__abs__return_3_01_t_00_01true_00_018_01_4.html">integer_abs_return&lt; T, true, 8 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__max.html">integer_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integer type maximum value at compile time.  <a href="structseq_1_1integer__max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__max_3_01_t_00_01false_01_4.html">integer_max&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__min.html">integer_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integer type minimum value at compile time.  <a href="structseq_1_1integer__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integer__min_3_01_t_00_01false_01_4.html">integer_min&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for integer to string conversion using <a class="el" href="namespaceseq.html#aaade1f4ec092684337563886384d3aaf" title="Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. ">seq::to_chars</a>.  <a href="structseq_1_1integral__chars__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string.html">is_allocated_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string. ">tiny_string</a>, std::string, but not tstring_view.  <a href="structseq_1_1is__allocated__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string_3_01std_1_1basic__string_3_01_char_00_01_traits_00_01_allocator_01_4_01_4.html">is_allocated_string&lt; std::basic_string&lt; Char, Traits, Allocator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__allocated__string_3_01tiny__string_3_01_char_00_01_traits_00_01_al_00_01_s_01_4_01_4.html">is_allocated_string&lt; tiny_string&lt; Char, Traits, Al, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__char.html">is_char</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__equal__comparable.html">is_equal_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type supports equality comparison with operator ==.  <a href="classseq_1_1is__equal__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__formattable.html">is_formattable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given type is formattable using <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">seq::fmt()</a>  <a href="structseq_1_1is__formattable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__char__string.html">is_generic_char_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect all possible string types (std::string, tstring, tstring_view, std::string_view, const char*, char*.  <a href="structseq_1_1is__generic__char__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__char__string_3_01char_01_5_01_4.html">is_generic_char_string&lt; char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__char__string_3_01const_01char_01_5_01_4.html">is_generic_char_string&lt; const char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__char__string_3_01std_1_1basic__string_3_01char_00_01_traits_00_01_allocator_01_4_01_4.html">is_generic_char_string&lt; std::basic_string&lt; char, Traits, Allocator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__char__string_3_01tiny__string_3_01char_00_01_traits_00_01_al_00_01_s_01_4_01_4.html">is_generic_char_string&lt; tiny_string&lt; char, Traits, Al, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string.html">is_generic_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect all possible string types (std::string, tstring, tstring_view, std::string_view, const char*, char*.  <a href="structseq_1_1is__generic__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01const_01_t_01_5_01_4.html">is_generic_string&lt; const T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01std_1_1basic__string_3_01_char_00_01_traits_00_01_allocator_01_4_01_4.html">is_generic_string&lt; std::basic_string&lt; Char, Traits, Allocator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01_t_01_5_01_4.html">is_generic_string&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string_3_01tiny__string_3_01_char_00_01_traits_00_01_al_00_01_s_01_4_01_4.html">is_generic_string&lt; tiny_string&lt; Char, Traits, Al, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view.html">is_generic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect generic string view: tstring_view, std::string_view, char*, const char*.  <a href="structseq_1_1is__generic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view_3_01_char_01_5_01_4.html">is_generic_string_view&lt; Char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view_3_01const_01_char_01_5_01_4.html">is_generic_string_view&lt; const Char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__generic__string__view_3_01tiny__string_3_01_char_00_01_traits_00_01view__alloca96954f50d5be4be59052683771cf237c.html">is_generic_string_view&lt; tiny_string&lt; Char, Traits, view_allocator&lt; Char &gt;, 0 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__hashable.html">is_hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type is hashable with std::hash. True by default, optimistically assume that all types are hashable. Used by <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers. ">seq::hold_any</a>.  <a href="structseq_1_1is__hashable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__hashable_3_01detail_1_1_const_value_wrapper_3_01_compressed_01_4_01_4.html">is_hashable&lt; detail::ConstValueWrapper&lt; Compressed &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__hashable_3_01detail_1_1_value_wrapper_3_01_compressed_01_4_01_4.html">is_hashable&lt; detail::ValueWrapper&lt; Compressed &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__hold__any.html">is_hold_any</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__hold__any_3_01hold__any_3_01_interface_00_01_s_00_01_a_00_01_r_01_4_01_4.html">is_hold_any&lt; hold_any&lt; Interface, S, A, R &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__invocable.html">is_invocable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type supports invocation with signature void(Args ...) Equivalent to C++17 std::is_invocable.  <a href="structseq_1_1is__invocable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__invocable__r.html">is_invocable_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type supports invocation with signature R(Args ...) Equivalent to C++17 std::is_invocable_r.  <a href="structseq_1_1is__invocable__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__istreamable.html">is_istreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type can be read from a std::istream object.  <a href="classseq_1_1is__istreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__iterable.html">is_iterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__less__comparable.html">is_less_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type supports comparison with operator &lt;.  <a href="classseq_1_1is__less__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__object__pool.html">is_object_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__object__pool_3_01object__pool_3_01_t_00_01_allocator_00_01_align_00_01object__aa897b5fd959a84c29154e339081634cc.html">is_object_pool&lt; object_pool&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type is an object pool.  <a href="structseq_1_1is__object__pool_3_01object__pool_3_01_t_00_01_allocator_00_01_align_00_01object__aa897b5fd959a84c29154e339081634cc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1is__ostreamable.html">is_ostreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given type can be streamed to a std::ostream object.  <a href="classseq_1_1is__ostreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__parallel__object__pool.html">is_parallel_object_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__parallel__object__pool_3_01parallel__object__pool_3_01_t_00_01_al_00_01_a_00_01_o_00_01_g_01_4_01_4.html">is_parallel_object_pool&lt; parallel_object_pool&lt; T, Al, A, O, G &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable.html">is_relocatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait telling if a class is relocatable or not.  <a href="structseq_1_1is__relocatable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01detail_1_1_store_bucket_3_01_t_00_01_allocator_00_01_value_compdf720ebec973c8da48b23df61e3cbc7a.html">is_relocatable&lt; detail::StoreBucket&lt; T, Allocator, ValueCompare, StoreBackValues, IsArithmetic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01detail_1_1_store_bucket_3_01_t_00_01_allocator_00_01_value_compa4c3de8b1ed892809670dad1cad5c7f7.html">is_relocatable&lt; detail::StoreBucket&lt; T, Allocator, ValueCompare, true, true &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01devector_3_01_t_00_01_alloc_00_01_f_01_4_01_4.html">is_relocatable&lt; devector&lt; T, Alloc, F &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structseq_1_1is__relocatable.html" title="Type trait telling if a class is relocatable or not. ">is_relocatable</a> for devector.  <a href="structseq_1_1is__relocatable_3_01devector_3_01_t_00_01_alloc_00_01_f_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01hold__any_3_01_interface_00_01_s_00_01_a_00_01_r_01_4_01_4.html">is_relocatable&lt; hold_any&lt; Interface, S, A, R &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01sequence_3_01_t_00_01_al_00_01_l_00_01_a_01_4_01_4.html">is_relocatable&lt; sequence&lt; T, Al, L, A &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structseq_1_1is__relocatable.html" title="Type trait telling if a class is relocatable or not. ">is_relocatable</a> for sequence type.  <a href="structseq_1_1is__relocatable_3_01sequence_3_01_t_00_01_al_00_01_l_00_01_a_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1allocator_3_01_t_01_4_01_4.html">is_relocatable&lt; std::allocator&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1pair_3_01_t_00_01_v_01_4_01_4.html">is_relocatable&lt; std::pair&lt; T, V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1shared__ptr_3_01_t_01_4_01_4.html">is_relocatable&lt; std::shared_ptr&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01std_1_1unique__ptr_3_01_t_00_01_d_01_4_01_4.html">is_relocatable&lt; std::unique_ptr&lt; T, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01tiny__string_3_01_char_00_01_traits_00_01_al_00_01_s_01_4_01_4.html">is_relocatable&lt; tiny_string&lt; Char, Traits, Al, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__relocatable_3_01view__allocator_3_01_char_01_4_01_4.html">is_relocatable&lt; view_allocator&lt; Char &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__string__view.html">is_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect tstring_view or std::string_view.  <a href="structseq_1_1is__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__string__view_3_01tiny__string_3_01_char_00_01_traits_00_01view__allocator_3_01_char_01_4_00_010_01_4_01_4.html">is_string_view&lt; tiny_string&lt; Char, Traits, view_allocator&lt; Char &gt;, 0 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__tiny__string.html">is_tiny_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string. ">tiny_string</a>.  <a href="structseq_1_1is__tiny__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__tiny__string_3_01tiny__string_3_01_char_00_01_traits_00_01_al_00_01_s_01_4_01_4.html">is_tiny_string&lt; tiny_string&lt; Char, Traits, Al, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__unique__ptr.html">is_unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits std::true_type is T is of type std::unique_ptr&lt;...&gt;, false otherwise.  <a href="structseq_1_1is__unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1is__unique__ptr_3_01std_1_1unique__ptr_3_01_t_00_01_del_01_4_01_4.html">is_unique_ptr&lt; std::unique_ptr&lt; T, Del &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1iterator__range.html">iterator_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classseq_1_1iterator__range.html" title="iterator_range class used to join iterables ">iterator_range</a> class used to join iterables  <a href="classseq_1_1iterator__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1less.html">less</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1less_3_01void_01_4.html">less&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1linear__object__allocation.html">linear_object_allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to MaxSize objects by step of 1.  <a href="structseq_1_1linear__object__allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1lock__guard.html">lock_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic lock guard class.  <a href="classseq_1_1lock__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1match__base.html">match_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for match finders used by <a class="el" href="namespaceseq.html#a563c78745a64d62dffe9db8ead6c59b3">split()</a> function.  <a href="structseq_1_1match__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1move__alloc.html">move_alloc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1no__skip.html">no_skip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip function used by <a class="el" href="namespaceseq.html#a563c78745a64d62dffe9db8ead6c59b3">split()</a> function.  <a href="structseq_1_1no__skip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1null__format.html">null_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placehoder when reusing a formatting object.  <a href="structseq_1_1null__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1null__lock.html">null_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumy lock class that basically does nothing.  <a href="structseq_1_1null__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1numeric__format.html">numeric_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting options for arithmetic types.  <a href="classseq_1_1numeric__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__allocator.html">object_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stl conforming allocator based on an object pool class.  <a href="classseq_1_1object__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html">object_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object pool class used to allocate objects of type T.  <a href="classseq_1_1object__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1object__pool__stats.html">object_pool_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class gathering statistics for <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">seq::object_pool</a> or <a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool. ">seq::parallel_object_pool</a>.  <a href="structseq_1_1object__pool__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__map.html">ordered_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.  <a href="classseq_1_1ordered__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.  <a href="classseq_1_1ordered__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format.html">ostream_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number and string formatting class.  <a href="classseq_1_1ostream__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format_3_01detail_1_1_iterable_3_01_t_01_4_00_01_slot_01_4.html">ostream_format&lt; detail::Iterable&lt; T &gt;, Slot &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class. ">ostream_format</a> for <a class="el" href="structseq_1_1detail_1_1_iterable.html" title="Used to specialize ostream_format for iterable types. ">detail::Iterable</a> to provide a <a class="el" href="namespaceseq.html#ae5c696025e12d6de56084a2d64214b40">join()</a> function working on iterables.  <a href="classseq_1_1ostream__format_3_01detail_1_1_iterable_3_01_t_01_4_00_01_slot_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format_3_01hold__any_3_01_interface_00_01_s_00_01_a_00_01_r_01_4_00_01_slot_01_4.html">ostream_format&lt; hold_any&lt; Interface, S, A, R &gt;, Slot &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ostream__format_3_01ostream__format_3_01_t_00_01_s1_01_4_00_01_s2_01_4.html">ostream_format&lt; ostream_format&lt; T, S1 &gt;, S2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class. ">ostream_format</a>.  <a href="classseq_1_1ostream__format_3_01ostream__format_3_01_t_00_01_s1_01_4_00_01_s2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free parallel object pool.  <a href="classseq_1_1parallel__object__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1pow__object__allocation.html">pow_object_allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to MaxSize objects using power of 2 steps.  <a href="structseq_1_1pow__object__allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__hash__map.html">radix_hash_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::unordered_map.  <a href="classseq_1_1radix__hash__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__hash__set.html">radix_hash_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::unordered_set.  <a href="classseq_1_1radix__hash__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__map.html">radix_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::map.  <a href="classseq_1_1radix__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html">radix_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::set.  <a href="classseq_1_1radix__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1random__float__genertor.html">random_float_genertor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, generate random floating point number on the whole representable range (including potential infinit values)  <a href="classseq_1_1random__float__genertor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html">sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sequence is an ordered container supporting constant time insertion at both end and constant time removal anywhere.  <a href="classseq_1_1sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1shared__ptr__allocation.html">shared_ptr_allocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1skip__empty.html">skip_empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip empty strings.  <a href="structseq_1_1skip__empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1skip__space.html">skip_space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip empty strings and spaces (' ', '', '<br />
', '', '', '');.  <a href="structseq_1_1skip__space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1skip__whitespace.html">skip_whitespace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip empty strings and whitespaces.  <a href="structseq_1_1skip__whitespace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1spinlock.html">spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight and fast spinlock implementation based on <a href="https://rigtorp.se/spinlock/">https://rigtorp.se/spinlock/</a>.  <a href="classseq_1_1spinlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1static__bit__scan__reverse.html">static_bit_scan_reverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of bit_scan_reverse.  <a href="structseq_1_1static__bit__scan__reverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1static__bit__scan__reverse_3_010_u_l_l_01_4.html">static_bit_scan_reverse&lt; 0ULL &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1static__bit__scan__reverse_3_011_01_4.html">static_bit_scan_reverse&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1std__input__stream.html">std_input_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream working on a std::istream.  <a href="classseq_1_1std__input__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1streambuf__size.html">streambuf_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streambuf that stores the number of outputed characters.  <a href="classseq_1_1streambuf__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tagged__pointer.html">tagged_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged pointer class.  <a href="classseq_1_1tagged__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tagged__pointer_3_01void_00_01_type_00_01_user_defined_alignment_01_4.html">tagged_pointer&lt; void, Type, UserDefinedAlignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1test__error.html">test_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown for failed tests.  <a href="classseq_1_1test__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> is a std::deque like container implemented as a tiered-vector.  <a href="classseq_1_1tiered__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String class with a similar interface and requirements than std::string.  <a href="classseq_1_1tiny__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1tiny__string_3_01_char_00_01_traits_00_01view__allocator_3_01_char_01_4_00_010_01_4.html">tiny_string&lt; Char, Traits, view_allocator&lt; Char &gt;, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string. ">tiny_string</a> for string views. You should use the global typedef tstring_view equivalent to tiny_string&lt;0,view_allocator&gt;. Provides a similar interface to std::string_view. See <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string. ">tiny_string</a> documentation for more details.  <a href="structseq_1_1tiny__string_3_01_char_00_01_traits_00_01view__allocator_3_01_char_01_4_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for <a class="el" href="namespaceseq.html#aaade1f4ec092684337563886384d3aaf" title="Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. ">seq::to_chars</a> functions, similar to std::to_chars_result.  <a href="structseq_1_1to__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1unique__ptr__deleter.html">unique_ptr_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleter class for std::unique_ptr when used with #object_pool or #parallel_object_pool.  <a href="structseq_1_1unique__ptr__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1view__allocator.html">view_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type for tiny string view.  <a href="structseq_1_1view__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1width__format.html">width_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the width formatting for a any formatting object.  <a href="structseq_1_1width__format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24ef193cef19271b9b18ce6c74fc5b54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">any</a> = <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;&gt;</td></tr>
<tr class="separator:a24ef193cef19271b9b18ce6c74fc5b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a76752e1ad984a96eb9ad080fe8b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad40a76752e1ad984a96eb9ad080fe8b5">r_any</a> = <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; <a class="el" href="structseq_1_1any__default__interface.html">any_default_interface</a>, sizeof(double), alignof(double), true &gt;</td></tr>
<tr class="separator:ad40a76752e1ad984a96eb9ad080fe8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec98840dd82cf3a3207402caa66c73f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">nh_any</a> = <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; <a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a> &gt;</td></tr>
<tr class="separator:a2ec98840dd82cf3a3207402caa66c73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ef7b667be012ddd3ce16cf0b28bbd6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a74ef7b667be012ddd3ce16cf0b28bbd6">r_nh_any</a> = <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; <a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a>, sizeof(double), alignof(double), true &gt;</td></tr>
<tr class="separator:a74ef7b667be012ddd3ce16cf0b28bbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2b0aba572fc96bdcec68b500577b5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6d2b0aba572fc96bdcec68b500577b5b">max_align_t</a> = std::max_align_t</td></tr>
<tr class="separator:a6d2b0aba572fc96bdcec68b500577b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802ef6dd5cb892731a06e6699a27edf8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a802ef6dd5cb892731a06e6699a27edf8">nullbuf</a> = <a class="el" href="structseq_1_1basic__nullbuf.html">basic_nullbuf</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a802ef6dd5cb892731a06e6699a27edf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, alias for null buffer, to be used with c++ iostreams.  <a href="#a802ef6dd5cb892731a06e6699a27edf8">More...</a><br /></td></tr>
<tr class="separator:a802ef6dd5cb892731a06e6699a27edf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853b19a4c230b9bda51396e407f64bda"><td class="memTemplParams" colspan="2">template&lt;class Char &gt; </td></tr>
<tr class="memitem:a853b19a4c230b9bda51396e407f64bda"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a853b19a4c230b9bda51396e407f64bda">basic_tstring_view</a> = <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, std::char_traits&lt; Char &gt;, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a>&lt; Char &gt;, 0 &gt;</td></tr>
<tr class="separator:a853b19a4c230b9bda51396e407f64bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49cae5f5b0deacb82496c90c7953388"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> = <a class="el" href="namespaceseq.html#a853b19a4c230b9bda51396e407f64bda">basic_tstring_view</a>&lt; char &gt;</td></tr>
<tr class="memdesc:ad49cae5f5b0deacb82496c90c7953388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base string view typedef, similar to std::string_view.  <a href="#ad49cae5f5b0deacb82496c90c7953388">More...</a><br /></td></tr>
<tr class="separator:ad49cae5f5b0deacb82496c90c7953388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b1f17e00c3af6be1fa41a4546c801a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a88b1f17e00c3af6be1fa41a4546c801a">wtstring_view</a> = <a class="el" href="namespaceseq.html#a853b19a4c230b9bda51396e407f64bda">basic_tstring_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a88b1f17e00c3af6be1fa41a4546c801a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe7cbd216aa93afb6c62a1bc4d39ba5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aebe7cbd216aa93afb6c62a1bc4d39ba5">tstring</a> = <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; char, std::char_traits&lt; char &gt;, std::allocator&lt; char &gt;, 0 &gt;</td></tr>
<tr class="memdesc:aebe7cbd216aa93afb6c62a1bc4d39ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base string typedef, similar to std::string. Equivalent to <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string. ">tiny_string</a>&lt;0, std::allocator&lt;char&gt;&gt;.  <a href="#aebe7cbd216aa93afb6c62a1bc4d39ba5">More...</a><br /></td></tr>
<tr class="separator:aebe7cbd216aa93afb6c62a1bc4d39ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827314866bb33dc9d380b0c894f5be2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a827314866bb33dc9d380b0c894f5be2b">wtstring</a> = <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, std::allocator&lt; wchar_t &gt;, 0 &gt;</td></tr>
<tr class="separator:a827314866bb33dc9d380b0c894f5be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a19a45e1f866d73140819b9ea2280c682"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> { <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682af715ab801ec116cdbb4a7f7541e46166">scientific</a> = 0x8000000, 
<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682abfc5cfa7d975226254b5443690d9f918">fixed</a> = 0x10000000, 
<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">general</a> = scientific|fixed
 }<tr class="memdesc:a19a45e1f866d73140819b9ea2280c682"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BitmaskType used to specify floating-point formatting for <a class="el" href="namespaceseq.html#aaade1f4ec092684337563886384d3aaf" title="Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. ">seq::to_chars</a>. This is similar to std::chars_format, but without the hex value.  <a href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a19a45e1f866d73140819b9ea2280c682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d7eb5b00b5c7e90602aaf0e8bd23e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">StreamState</a> { <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2adc676c349921535a50db525652b39774">Ok</a>, 
<a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d">EndOfFile</a>, 
<a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587">BadInputFormat</a>
 }<tr class="memdesc:ac3d7eb5b00b5c7e90602aaf0e8bd23e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream object status for classes inheriting basic_input_stream.  <a href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac3d7eb5b00b5c7e90602aaf0e8bd23e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3fb67407700bab4c66e60c7f7365c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7">ContextRatio</a> { <a class="el" href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7a82b7b69a7aecf7f511dde4bd663e72f3">Fixed</a>, 
<a class="el" href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7aead4f34f60237cc1a99223296ae6b1ef">Ratio</a>
 }<tr class="memdesc:a5e3fb67407700bab4c66e60c7f7365c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum type used by context_ratio.  <a href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a5e3fb67407700bab4c66e60c7f7365c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f4e48fbeeb8d86e75555957c4e270c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270c">DEVectorFlag</a> { <a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270ca3d03c9bf4b559787d1de5ac0f9a7882d">OptimizeForPushBack</a>, 
<a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270caeb903e97e2b97b410b477676babb2653">OptimizeForPushFront</a>, 
<a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270ca998ccc48808777ad90d4228cd8fb9e84">OptimizeForBothEnds</a>
 }<tr class="memdesc:a04f4e48fbeeb8d86e75555957c4e270c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the devector is optimized for back insertion, front insertion or both.  <a href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a04f4e48fbeeb8d86e75555957c4e270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac07c5c5e3d6da3ebb03f7ddd1e7cde"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespaceseq.html#adac07c5c5e3d6da3ebb03f7ddd1e7cdea668d551cd99226655e9e973b6d5be517">DefaultAlignment</a> = 0
 }<tr class="memdesc:adac07c5c5e3d6da3ebb03f7ddd1e7cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants used by #object_pool, #parallel_object_pool and #object_allocator.  <a href="namespaceseq.html#adac07c5c5e3d6da3ebb03f7ddd1e7cde">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adac07c5c5e3d6da3ebb03f7ddd1e7cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affae767f96f2af9924f7c6f3bdd4c72a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72a">TagPointerType</a> { <a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72aafb05ed7193c8b361ae6679027a774673">StackPointer</a>, 
<a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72aa818e87f4cf07c4dc2006b54dbd4939e0">HeapPointer</a>, 
<a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72aad297c23409b392745ce5f3024304a8e8">CustomAlignment</a>
 }</td></tr>
<tr class="separator:affae767f96f2af9924f7c6f3bdd4c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209c3fd2e66f43ecc90862f2ee5e3dd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5">LayoutManagement</a> { <a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5a83983acd78764ffa023da74a7360670e">OptimizeForSpeed</a>, 
<a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5a51407649077d79765e15397347a57432">OptimizeForMemory</a>
 }<tr class="memdesc:a209c3fd2e66f43ecc90862f2ee5e3dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory Layout Management for containers like <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant time rem...">seq::sequence</a> or <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a>.  <a href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a209c3fd2e66f43ecc90862f2ee5e3dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3ca5fac631207b6d7245eab5a6bfe8b7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3ca5fac631207b6d7245eab5a6bfe8b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3ca5fac631207b6d7245eab5a6bfe8b7">get_type_id</a> () noexcept -&gt; int</td></tr>
<tr class="memdesc:a3ca5fac631207b6d7245eab5a6bfe8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type Id used by <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers. ">hold_any</a> as a unique type identifier.  <a href="#a3ca5fac631207b6d7245eab5a6bfe8b7">More...</a><br /></td></tr>
<tr class="separator:a3ca5fac631207b6d7245eab5a6bfe8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78953b53d9255df1c87a82bb8a7ecd4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa78953b53d9255df1c87a82bb8a7ecd4">is_signed_integral_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:aa78953b53d9255df1c87a82bb8a7ecd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to a signed integral type.  <a href="#aa78953b53d9255df1c87a82bb8a7ecd4">More...</a><br /></td></tr>
<tr class="separator:aa78953b53d9255df1c87a82bb8a7ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e891e43f7fe2c2737322a9b273d4a06"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5e891e43f7fe2c2737322a9b273d4a06">is_unsigned_integral_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a5e891e43f7fe2c2737322a9b273d4a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to an unsigned integral type.  <a href="#a5e891e43f7fe2c2737322a9b273d4a06">More...</a><br /></td></tr>
<tr class="separator:a5e891e43f7fe2c2737322a9b273d4a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f9511e243d78950b21507f5a4fe896"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a29f9511e243d78950b21507f5a4fe896">is_integral_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a29f9511e243d78950b21507f5a4fe896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to an integral type.  <a href="#a29f9511e243d78950b21507f5a4fe896">More...</a><br /></td></tr>
<tr class="separator:a29f9511e243d78950b21507f5a4fe896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ee2f93a9ebfb47e00fb2a353c26627"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa2ee2f93a9ebfb47e00fb2a353c26627">is_floating_point_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:aa2ee2f93a9ebfb47e00fb2a353c26627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to a floating point type.  <a href="#aa2ee2f93a9ebfb47e00fb2a353c26627">More...</a><br /></td></tr>
<tr class="separator:aa2ee2f93a9ebfb47e00fb2a353c26627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5af289596de39f1073e3071263a644"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abb5af289596de39f1073e3071263a644">is_arithmetic_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:abb5af289596de39f1073e3071263a644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to an arithmetic type (floating point or integral)  <a href="#abb5af289596de39f1073e3071263a644">More...</a><br /></td></tr>
<tr class="separator:abb5af289596de39f1073e3071263a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a34e6330b33a12e7e645c50d6d50a84"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9a34e6330b33a12e7e645c50d6d50a84">is_string_type</a> (int id) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a9a34e6330b33a12e7e645c50d6d50a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if given type id corresponds to a string type (std::string, tstring, tstring_view or const char*)  <a href="#a9a34e6330b33a12e7e645c50d6d50a84">More...</a><br /></td></tr>
<tr class="separator:a9a34e6330b33a12e7e645c50d6d50a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97851d71ded4c7928aabd76f4280d268"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a97851d71ded4c7928aabd76f4280d268"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a97851d71ded4c7928aabd76f4280d268">register_any_conversion</a> ()</td></tr>
<tr class="memdesc:a97851d71ded4c7928aabd76f4280d268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function based on explicit conversion from type T to type U.  <a href="#a97851d71ded4c7928aabd76f4280d268">More...</a><br /></td></tr>
<tr class="separator:a97851d71ded4c7928aabd76f4280d268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Fun &gt; </td></tr>
<tr class="memitem:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad7a515ea06834d35cedd4e4f9c4ba1b0">register_any_conversion</a> (Fun fun)</td></tr>
<tr class="memdesc:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function using given functor.  <a href="#ad7a515ea06834d35cedd4e4f9c4ba1b0">More...</a><br /></td></tr>
<tr class="separator:ad7a515ea06834d35cedd4e4f9c4ba1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab390e9bf772c9a88f9f48c5bd360d7ed">register_any_less_comparison</a> ()</td></tr>
<tr class="memdesc:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the comparison function <a class="el" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T()</a> &lt; U()  <a href="#ab390e9bf772c9a88f9f48c5bd360d7ed">More...</a><br /></td></tr>
<tr class="separator:ab390e9bf772c9a88f9f48c5bd360d7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0810417829f24c04037720cfe1cc92"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Fun &gt; </td></tr>
<tr class="memitem:a0b0810417829f24c04037720cfe1cc92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0b0810417829f24c04037720cfe1cc92">register_any_less_comparison</a> (Fun fun)</td></tr>
<tr class="memdesc:a0b0810417829f24c04037720cfe1cc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a comparison function between types T and U based on given functor.  <a href="#a0b0810417829f24c04037720cfe1cc92">More...</a><br /></td></tr>
<tr class="separator:a0b0810417829f24c04037720cfe1cc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb61336a531e99a11a888883a46d0f01"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:adb61336a531e99a11a888883a46d0f01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adb61336a531e99a11a888883a46d0f01">register_any_equal_comparison</a> ()</td></tr>
<tr class="memdesc:adb61336a531e99a11a888883a46d0f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the comparison function <a class="el" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T()</a> == U()  <a href="#adb61336a531e99a11a888883a46d0f01">More...</a><br /></td></tr>
<tr class="separator:adb61336a531e99a11a888883a46d0f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa783de724c82de2264d98a3437294df"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Fun &gt; </td></tr>
<tr class="memitem:aaa783de724c82de2264d98a3437294df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aaa783de724c82de2264d98a3437294df">register_any_equal_comparison</a> (Fun fun)</td></tr>
<tr class="memdesc:aaa783de724c82de2264d98a3437294df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a comparison function between types T and U based on given functor.  <a href="#aaa783de724c82de2264d98a3437294df">More...</a><br /></td></tr>
<tr class="separator:aaa783de724c82de2264d98a3437294df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d60e85edea2233f085bdf747bddcff2"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value,void&gt;::type&gt; </td></tr>
<tr class="memitem:a8d60e85edea2233f085bdf747bddcff2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8d60e85edea2233f085bdf747bddcff2">operator==</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:a8d60e85edea2233f085bdf747bddcff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724b3d5a01fe3634b25679520b5ef76f"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a724b3d5a01fe3634b25679520b5ef76f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a724b3d5a01fe3634b25679520b5ef76f">operator==</a> (const T &amp;b, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a) -&gt; bool</td></tr>
<tr class="separator:a724b3d5a01fe3634b25679520b5ef76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec93819ac321959ed7b44ddc8ea2c52"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a2ec93819ac321959ed7b44ddc8ea2c52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2ec93819ac321959ed7b44ddc8ea2c52">operator!=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:a2ec93819ac321959ed7b44ddc8ea2c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479608f726adc057d8d2cfa5816fcaf2"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a479608f726adc057d8d2cfa5816fcaf2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a479608f726adc057d8d2cfa5816fcaf2">operator!=</a> (const T &amp;b, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a) -&gt; bool</td></tr>
<tr class="separator:a479608f726adc057d8d2cfa5816fcaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff27313847123eef67c0de05797b758"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:aeff27313847123eef67c0de05797b758"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aeff27313847123eef67c0de05797b758">operator&lt;</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:aeff27313847123eef67c0de05797b758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3915ca3d10e71950f65df48b17962b5d"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a3915ca3d10e71950f65df48b17962b5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3915ca3d10e71950f65df48b17962b5d">operator&gt;</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:a3915ca3d10e71950f65df48b17962b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2393e534f64f957e7bb215f856ca74d3"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a2393e534f64f957e7bb215f856ca74d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2393e534f64f957e7bb215f856ca74d3">operator&lt;=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:a2393e534f64f957e7bb215f856ca74d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bca4bc401423cdc7201aea937ead6c"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a94bca4bc401423cdc7201aea937ead6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a94bca4bc401423cdc7201aea937ead6c">operator&gt;=</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a, const T &amp;b) -&gt; bool</td></tr>
<tr class="separator:a94bca4bc401423cdc7201aea937ead6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72706e2b2834a21aa430d177b624546d"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a72706e2b2834a21aa430d177b624546d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a72706e2b2834a21aa430d177b624546d">operator&lt;</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:a72706e2b2834a21aa430d177b624546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa57e12b70dcecd63e46910892ef654"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:aeaa57e12b70dcecd63e46910892ef654"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aeaa57e12b70dcecd63e46910892ef654">operator&gt;</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:aeaa57e12b70dcecd63e46910892ef654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f089e3cd1b684f11f0e31e6ac49a1b"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a10f089e3cd1b684f11f0e31e6ac49a1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a10f089e3cd1b684f11f0e31e6ac49a1b">operator&lt;=</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:a10f089e3cd1b684f11f0e31e6ac49a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d9c6b0597c2f1faf898ec6de1092c7"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a95d9c6b0597c2f1faf898ec6de1092c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a95d9c6b0597c2f1faf898ec6de1092c7">operator&gt;=</a> (const T &amp;a, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:a95d9c6b0597c2f1faf898ec6de1092c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f2b4c519aa50f2b808e7401a502bc5"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R&gt; </td></tr>
<tr class="memitem:ad6f2b4c519aa50f2b808e7401a502bc5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad6f2b4c519aa50f2b808e7401a502bc5">operator&lt;&lt;</a> (std::ostream &amp;oss, const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a) -&gt; std::ostream &amp;</td></tr>
<tr class="separator:ad6f2b4c519aa50f2b808e7401a502bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63e912eb6011acc4393a84d8a70da27"><td class="memTemplParams" colspan="2">template&lt;class Interface , size_t S, size_t A, bool R&gt; </td></tr>
<tr class="memitem:af63e912eb6011acc4393a84d8a70da27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af63e912eb6011acc4393a84d8a70da27">operator&gt;&gt;</a> (std::istream &amp;iss, <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;a) -&gt; std::istream &amp;</td></tr>
<tr class="separator:af63e912eb6011acc4393a84d8a70da27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656aad880c48ac0ae0f8aa7db0786158"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A, bool R&gt; </td></tr>
<tr class="memitem:a656aad880c48ac0ae0f8aa7db0786158"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a656aad880c48ac0ae0f8aa7db0786158">any_cast</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;operand) -&gt; T</td></tr>
<tr class="separator:a656aad880c48ac0ae0f8aa7db0786158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304b476587f21b36fe2fad1337834a5f"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A, bool R&gt; </td></tr>
<tr class="memitem:a304b476587f21b36fe2fad1337834a5f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a304b476587f21b36fe2fad1337834a5f">any_cast</a> (<a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;operand) -&gt; T</td></tr>
<tr class="separator:a304b476587f21b36fe2fad1337834a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3528d854cdb917df17252d633ecbf72"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A, bool R&gt; </td></tr>
<tr class="memitem:ae3528d854cdb917df17252d633ecbf72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae3528d854cdb917df17252d633ecbf72">any_cast</a> (const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; *operand) noexcept -&gt; const T *</td></tr>
<tr class="separator:ae3528d854cdb917df17252d633ecbf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ed8ba94329f4980574e2c22e293da2"><td class="memTemplParams" colspan="2">template&lt;class T , class Interface , size_t S, size_t A, bool R&gt; </td></tr>
<tr class="memitem:a64ed8ba94329f4980574e2c22e293da2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a64ed8ba94329f4980574e2c22e293da2">any_cast</a> (<a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; *operand) noexcept -&gt; T *</td></tr>
<tr class="separator:a64ed8ba94329f4980574e2c22e293da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2b63f4cea16071daccd0ab528b695e"><td class="memTemplParams" colspan="2">template&lt;class Any , class T , class... Args&gt; </td></tr>
<tr class="memitem:adf2b63f4cea16071daccd0ab528b695e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adf2b63f4cea16071daccd0ab528b695e">make_any</a> (Args &amp;&amp;... args) -&gt; Any</td></tr>
<tr class="separator:adf2b63f4cea16071daccd0ab528b695e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5417e4eca78972288f212c355f07923"><td class="memTemplParams" colspan="2">template&lt;class Any , class T , class U , class... Args&gt; </td></tr>
<tr class="memitem:ab5417e4eca78972288f212c355f07923"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab5417e4eca78972288f212c355f07923">make_any</a> (std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args) -&gt; Any</td></tr>
<tr class="separator:ab5417e4eca78972288f212c355f07923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6841d57616cc1144f3347fe0113f82"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0e6841d57616cc1144f3347fe0113f82">_any</a> () -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">nh_any</a>, true &gt;</td></tr>
<tr class="memdesc:a0e6841d57616cc1144f3347fe0113f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create placeholder for any type for the formatting module.  <a href="#a0e6841d57616cc1144f3347fe0113f82">More...</a><br /></td></tr>
<tr class="separator:a0e6841d57616cc1144f3347fe0113f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0653a43b827bc896829c70bfb47ab9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aef0653a43b827bc896829c70bfb47ab9">_a</a> () -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">nh_any</a>, true &gt;</td></tr>
<tr class="separator:aef0653a43b827bc896829c70bfb47ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67ee9a9d6039de2b50c631129a0a1bc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac67ee9a9d6039de2b50c631129a0a1bc">aligned_malloc</a> (size_t size, size_t align) -&gt; void *</td></tr>
<tr class="memdesc:ac67ee9a9d6039de2b50c631129a0a1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates <em>size</em> bytes. The returned pointer is guaranteed to have <em>align</em> bytes alignment.  <a href="#ac67ee9a9d6039de2b50c631129a0a1bc">More...</a><br /></td></tr>
<tr class="separator:ac67ee9a9d6039de2b50c631129a0a1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04be1ca38e79158feb4755807ef3d08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a04be1ca38e79158feb4755807ef3d08c">aligned_free</a> (void *ptr)</td></tr>
<tr class="memdesc:a04be1ca38e79158feb4755807ef3d08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with aligned_malloc.  <a href="#a04be1ca38e79158feb4755807ef3d08c">More...</a><br /></td></tr>
<tr class="separator:a04be1ca38e79158feb4755807ef3d08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93474d742382c06825212a479a720fcb"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a93474d742382c06825212a479a720fcb">popcnt64</a> (std::uint64_t x)</td></tr>
<tr class="separator:a93474d742382c06825212a479a720fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad7cd23d956c6e3205dd20ff1629b3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a08ad7cd23d956c6e3205dd20ff1629b3">popcnt32</a> (uint32_t x)</td></tr>
<tr class="separator:a08ad7cd23d956c6e3205dd20ff1629b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cd15c1c849768be9995bcb1fd1733a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af2cd15c1c849768be9995bcb1fd1733a">popcnt8</a> (unsigned char value) -&gt; unsigned</td></tr>
<tr class="separator:af2cd15c1c849768be9995bcb1fd1733a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348cf02b3ab7947f01df82985d741138"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a348cf02b3ab7947f01df82985d741138">popcnt16</a> (unsigned short value) -&gt; unsigned</td></tr>
<tr class="separator:a348cf02b3ab7947f01df82985d741138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b62146c2dc50a03ca53b97ace8bd99"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a33b62146c2dc50a03ca53b97ace8bd99">bit_scan_forward_8</a> (std::uint8_t val) -&gt; unsigned int</td></tr>
<tr class="separator:a33b62146c2dc50a03ca53b97ace8bd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbee1b71b206139ba062e72ec88de1cf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adbee1b71b206139ba062e72ec88de1cf">bit_scan_reverse_8</a> (std::uint8_t val) -&gt; unsigned int</td></tr>
<tr class="separator:adbee1b71b206139ba062e72ec88de1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaee03ba305545aff518038a6037813b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adaee03ba305545aff518038a6037813b">bit_scan_forward_32</a> (std::uint32_t val) -&gt; unsigned int</td></tr>
<tr class="memdesc:adaee03ba305545aff518038a6037813b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest set bit index in <em>val</em> Undefined if val==0.  <a href="#adaee03ba305545aff518038a6037813b">More...</a><br /></td></tr>
<tr class="separator:adaee03ba305545aff518038a6037813b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b01e43cd0234954034486359baa02f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a89b01e43cd0234954034486359baa02f">bit_scan_reverse_32</a> (std::uint32_t val) -&gt; unsigned int</td></tr>
<tr class="memdesc:a89b01e43cd0234954034486359baa02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest set bit index in <em>val</em> Undefined if val==0.  <a href="#a89b01e43cd0234954034486359baa02f">More...</a><br /></td></tr>
<tr class="separator:a89b01e43cd0234954034486359baa02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea82743e4a07a05aad9c2226c85c5925"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aea82743e4a07a05aad9c2226c85c5925">bit_scan_forward_64</a> (std::uint64_t bb) noexcept -&gt; unsigned</td></tr>
<tr class="memdesc:aea82743e4a07a05aad9c2226c85c5925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest set bit index in <em>bb</em>. Developed by Kim Walisch (2012). Undefined if bb==0.  <a href="#aea82743e4a07a05aad9c2226c85c5925">More...</a><br /></td></tr>
<tr class="separator:aea82743e4a07a05aad9c2226c85c5925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea603fed30d1318a1a13ee9a6181c1a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aaea603fed30d1318a1a13ee9a6181c1a">bit_scan_reverse_64</a> (std::uint64_t bb) noexcept -&gt; unsigned</td></tr>
<tr class="memdesc:aaea603fed30d1318a1a13ee9a6181c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest set bit index in <em>bb</em>. Developed by Kim Walisch, Mark Dickinson. Undefined if bb==0.  <a href="#aaea603fed30d1318a1a13ee9a6181c1a">More...</a><br /></td></tr>
<tr class="separator:aaea603fed30d1318a1a13ee9a6181c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb73db39e1609aef776bd9499a838c85"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aeb73db39e1609aef776bd9499a838c85">bit_scan_forward</a> (size_t bb) noexcept -&gt; unsigned</td></tr>
<tr class="memdesc:aeb73db39e1609aef776bd9499a838c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest set bit index in <em>bb</em>. Undefined if bb==0.  <a href="#aeb73db39e1609aef776bd9499a838c85">More...</a><br /></td></tr>
<tr class="separator:aeb73db39e1609aef776bd9499a838c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a4aaad9e6e5b58b9ae8bc9a0a8df09"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab2a4aaad9e6e5b58b9ae8bc9a0a8df09">bit_scan_reverse</a> (size_t bb) noexcept -&gt; unsigned</td></tr>
<tr class="memdesc:ab2a4aaad9e6e5b58b9ae8bc9a0a8df09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest set bit index in <em>bb</em>. Undefined if bb==0.  <a href="#ab2a4aaad9e6e5b58b9ae8bc9a0a8df09">More...</a><br /></td></tr>
<tr class="separator:ab2a4aaad9e6e5b58b9ae8bc9a0a8df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad229ce51d8085cde156a70f274f2dce2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad229ce51d8085cde156a70f274f2dce2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad229ce51d8085cde156a70f274f2dce2">count_digits_base_10</a> (T x) -&gt; unsigned</td></tr>
<tr class="separator:ad229ce51d8085cde156a70f274f2dce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f848adb0c9d3ac36fb1c523850748b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab2f848adb0c9d3ac36fb1c523850748b">nth_bit_set</a> (std::uint64_t x, unsigned n) noexcept</td></tr>
<tr class="separator:ab2f848adb0c9d3ac36fb1c523850748b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01a2e9b3b57b882c04f41e155e7d640"><td class="memTemplParams" colspan="2">template&lt;size_t ConsecutiveNBits&gt; </td></tr>
<tr class="memitem:aa01a2e9b3b57b882c04f41e155e7d640"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa01a2e9b3b57b882c04f41e155e7d640">consecutive_N_bits</a> (size_t num) -&gt; unsigned</td></tr>
<tr class="memdesc:aa01a2e9b3b57b882c04f41e155e7d640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first consecutive N bits within <em>num</em>.  <a href="#aa01a2e9b3b57b882c04f41e155e7d640">More...</a><br /></td></tr>
<tr class="separator:aa01a2e9b3b57b882c04f41e155e7d640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2104e47803d88e9c325e90e895abf654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2104e47803d88e9c325e90e895abf654">byte_swap_16</a> (std::uint16_t value) -&gt; std::uint16_t</td></tr>
<tr class="memdesc:a2104e47803d88e9c325e90e895abf654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte-swapped representation of the 16-bit argument.  <a href="#a2104e47803d88e9c325e90e895abf654">More...</a><br /></td></tr>
<tr class="separator:a2104e47803d88e9c325e90e895abf654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5f3b912efdb92047bc111745cbcefd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0e5f3b912efdb92047bc111745cbcefd">byte_swap_32</a> (std::uint32_t value) -&gt; std::uint32_t</td></tr>
<tr class="memdesc:a0e5f3b912efdb92047bc111745cbcefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte-swapped representation of the 32-bit argument.  <a href="#a0e5f3b912efdb92047bc111745cbcefd">More...</a><br /></td></tr>
<tr class="separator:a0e5f3b912efdb92047bc111745cbcefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e177ac4ac8797c494c39b28e639d3c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1e177ac4ac8797c494c39b28e639d3c9">byte_swap_64</a> (std::uint64_t value) -&gt; std::uint64_t</td></tr>
<tr class="memdesc:a1e177ac4ac8797c494c39b28e639d3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte-swapped representation of the 64-bit argument.  <a href="#a1e177ac4ac8797c494c39b28e639d3c9">More...</a><br /></td></tr>
<tr class="separator:a1e177ac4ac8797c494c39b28e639d3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa0f34c5b9efbaacd24ae215c6ebdfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8aa0f34c5b9efbaacd24ae215c6ebdfe">write_LE_16</a> (void *dst, std::uint16_t value)</td></tr>
<tr class="memdesc:a8aa0f34c5b9efbaacd24ae215c6ebdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 16 bits integer value to dst in little endian order.  <a href="#a8aa0f34c5b9efbaacd24ae215c6ebdfe">More...</a><br /></td></tr>
<tr class="separator:a8aa0f34c5b9efbaacd24ae215c6ebdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbce06d3b6c0dd24ef956b3bba564914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abbce06d3b6c0dd24ef956b3bba564914">write_LE_32</a> (void *dst, std::uint32_t value)</td></tr>
<tr class="memdesc:abbce06d3b6c0dd24ef956b3bba564914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32 bits integer value to dst in little endian order.  <a href="#abbce06d3b6c0dd24ef956b3bba564914">More...</a><br /></td></tr>
<tr class="separator:abbce06d3b6c0dd24ef956b3bba564914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd16ebc1860bdc316a5f83c8210a361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2dd16ebc1860bdc316a5f83c8210a361">write_LE_64</a> (void *dst, std::uint64_t value)</td></tr>
<tr class="memdesc:a2dd16ebc1860bdc316a5f83c8210a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 64 bits integer value to dst in little endian order.  <a href="#a2dd16ebc1860bdc316a5f83c8210a361">More...</a><br /></td></tr>
<tr class="separator:a2dd16ebc1860bdc316a5f83c8210a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2480216425c6423b34df46e854b9764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac2480216425c6423b34df46e854b9764">write_BE_64</a> (void *dst, std::uint64_t value)</td></tr>
<tr class="memdesc:ac2480216425c6423b34df46e854b9764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 64 bits integer value to dst in big endian order.  <a href="#ac2480216425c6423b34df46e854b9764">More...</a><br /></td></tr>
<tr class="separator:ac2480216425c6423b34df46e854b9764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052b75a0721954d5497ff1753315e997"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a052b75a0721954d5497ff1753315e997">read_LE_16</a> (const void *src) -&gt; std::uint16_t</td></tr>
<tr class="memdesc:a052b75a0721954d5497ff1753315e997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 16 bits integer from src in little endian order.  <a href="#a052b75a0721954d5497ff1753315e997">More...</a><br /></td></tr>
<tr class="separator:a052b75a0721954d5497ff1753315e997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a00bc4c5f354e2350bab137e35c0ceb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1a00bc4c5f354e2350bab137e35c0ceb">read_LE_32</a> (const void *src) -&gt; std::uint32_t</td></tr>
<tr class="memdesc:a1a00bc4c5f354e2350bab137e35c0ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32 bits integer from src in little endian order.  <a href="#a1a00bc4c5f354e2350bab137e35c0ceb">More...</a><br /></td></tr>
<tr class="separator:a1a00bc4c5f354e2350bab137e35c0ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee33b43276433d62551712f283741546"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aee33b43276433d62551712f283741546">read_LE_64</a> (const void *src) -&gt; std::uint64_t</td></tr>
<tr class="memdesc:aee33b43276433d62551712f283741546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 64 bits integer from src in little endian order.  <a href="#aee33b43276433d62551712f283741546">More...</a><br /></td></tr>
<tr class="separator:aee33b43276433d62551712f283741546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f46b0218710a8c5534b5795ce95b2e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a20f46b0218710a8c5534b5795ce95b2e">read_16</a> (const void *src) -&gt; std::uint16_t</td></tr>
<tr class="memdesc:a20f46b0218710a8c5534b5795ce95b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 16 bits integer from src.  <a href="#a20f46b0218710a8c5534b5795ce95b2e">More...</a><br /></td></tr>
<tr class="separator:a20f46b0218710a8c5534b5795ce95b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b48ff10138ee36cd0f4949f01a23f1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a36b48ff10138ee36cd0f4949f01a23f1">read_32</a> (const void *src) -&gt; std::uint32_t</td></tr>
<tr class="memdesc:a36b48ff10138ee36cd0f4949f01a23f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 32 bits integer from src.  <a href="#a36b48ff10138ee36cd0f4949f01a23f1">More...</a><br /></td></tr>
<tr class="separator:a36b48ff10138ee36cd0f4949f01a23f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53674d0482ead92a98023ed0d7c57dd1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a53674d0482ead92a98023ed0d7c57dd1">read_64</a> (const void *src) -&gt; std::uint64_t</td></tr>
<tr class="memdesc:a53674d0482ead92a98023ed0d7c57dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 64 bits integer from src.  <a href="#a53674d0482ead92a98023ed0d7c57dd1">More...</a><br /></td></tr>
<tr class="separator:a53674d0482ead92a98023ed0d7c57dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07d1a9758d3ce39924f26eff332f759"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae07d1a9758d3ce39924f26eff332f759">read_ptr_t</a> (const void *src) -&gt; std::uintptr_t</td></tr>
<tr class="memdesc:ae07d1a9758d3ce39924f26eff332f759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads uintptr_t integer from src.  <a href="#ae07d1a9758d3ce39924f26eff332f759">More...</a><br /></td></tr>
<tr class="separator:ae07d1a9758d3ce39924f26eff332f759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f9f34cc361321151e13951ccad2ac4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa1f9f34cc361321151e13951ccad2ac4">read_BE_16</a> (const void *src) -&gt; std::uint16_t</td></tr>
<tr class="memdesc:aa1f9f34cc361321151e13951ccad2ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 16 bits integer from src in big endian order.  <a href="#aa1f9f34cc361321151e13951ccad2ac4">More...</a><br /></td></tr>
<tr class="separator:aa1f9f34cc361321151e13951ccad2ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccead2b857599b0e675267609e5120f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adccead2b857599b0e675267609e5120f">read_BE_32</a> (const void *src) -&gt; std::uint32_t</td></tr>
<tr class="memdesc:adccead2b857599b0e675267609e5120f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 32 bits integer from src in big endian order.  <a href="#adccead2b857599b0e675267609e5120f">More...</a><br /></td></tr>
<tr class="separator:adccead2b857599b0e675267609e5120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3778777f10583618f958211656aec2b4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3778777f10583618f958211656aec2b4">read_BE_64</a> (const void *src) -&gt; std::uint64_t</td></tr>
<tr class="memdesc:a3778777f10583618f958211656aec2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 64 bits integer from src in big endian order.  <a href="#a3778777f10583618f958211656aec2b4">More...</a><br /></td></tr>
<tr class="separator:a3778777f10583618f958211656aec2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adb2cb36973f3d571f0984dffb68d87"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2adb2cb36973f3d571f0984dffb68d87">read_size_t</a> (const void *src) -&gt; size_t</td></tr>
<tr class="memdesc:a2adb2cb36973f3d571f0984dffb68d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads size_t object from src.  <a href="#a2adb2cb36973f3d571f0984dffb68d87">More...</a><br /></td></tr>
<tr class="separator:a2adb2cb36973f3d571f0984dffb68d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f5bd629161aaad113175e3b0217f29"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa1f5bd629161aaad113175e3b0217f29">read_LE_size_t</a> (const void *src) -&gt; size_t</td></tr>
<tr class="memdesc:aa1f5bd629161aaad113175e3b0217f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads size_t object from src in little endian order.  <a href="#aa1f5bd629161aaad113175e3b0217f29">More...</a><br /></td></tr>
<tr class="separator:aa1f5bd629161aaad113175e3b0217f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fbedb52aef41b37b7b243497ead642"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a79fbedb52aef41b37b7b243497ead642">read_BE_size_t</a> (const void *src) -&gt; size_t</td></tr>
<tr class="memdesc:a79fbedb52aef41b37b7b243497ead642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads size_t object from src in big endian order.  <a href="#a79fbedb52aef41b37b7b243497ead642">More...</a><br /></td></tr>
<tr class="separator:a79fbedb52aef41b37b7b243497ead642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1452eb51c66f96eff698c862bca8631"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1452eb51c66f96eff698c862bca8631"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae1452eb51c66f96eff698c862bca8631">reverse_bits</a> (T n)</td></tr>
<tr class="separator:ae1452eb51c66f96eff698c862bca8631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c8fd38b49f17879d09232a8e640bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa6c8fd38b49f17879d09232a8e640bbb">print_features</a> ()</td></tr>
<tr class="separator:aa6c8fd38b49f17879d09232a8e640bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade167dcc6d29b420964a6be1498889ac"><td class="memTemplParams" colspan="2">template&lt;class Stream , class T &gt; </td></tr>
<tr class="memitem:ade167dcc6d29b420964a6be1498889ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac">from_stream</a> (Stream &amp;str, T &amp;value, int base=10) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:ade167dcc6d29b420964a6be1498889ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an integral value from a <a class="el" href="classseq_1_1basic__input__stream.html" title="Base class for input text streams. ">seq::basic_input_stream</a> object.  <a href="#ade167dcc6d29b420964a6be1498889ac">More...</a><br /></td></tr>
<tr class="separator:ade167dcc6d29b420964a6be1498889ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0031c82ad3d33c5094644a8c07f5464"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:af0031c82ad3d33c5094644a8c07f5464"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af0031c82ad3d33c5094644a8c07f5464">from_stream</a> (Stream &amp;str, float &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; Stream &amp;</td></tr>
<tr class="memdesc:af0031c82ad3d33c5094644a8c07f5464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from a #basic_input_stream object.  <a href="#af0031c82ad3d33c5094644a8c07f5464">More...</a><br /></td></tr>
<tr class="separator:af0031c82ad3d33c5094644a8c07f5464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0581674bf80cd428f3680506119eb7d8"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a0581674bf80cd428f3680506119eb7d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0581674bf80cd428f3680506119eb7d8">from_stream</a> (Stream &amp;str, double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; Stream &amp;</td></tr>
<tr class="memdesc:a0581674bf80cd428f3680506119eb7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from a #basic_input_stream object.  <a href="#a0581674bf80cd428f3680506119eb7d8">More...</a><br /></td></tr>
<tr class="separator:a0581674bf80cd428f3680506119eb7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36637d3bd7fde2e315ed4a5d1bc29f35"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a36637d3bd7fde2e315ed4a5d1bc29f35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a36637d3bd7fde2e315ed4a5d1bc29f35">from_stream</a> (Stream &amp;str, long double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; Stream &amp;</td></tr>
<tr class="memdesc:a36637d3bd7fde2e315ed4a5d1bc29f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from a #basic_input_stream object.  <a href="#a36637d3bd7fde2e315ed4a5d1bc29f35">More...</a><br /></td></tr>
<tr class="separator:a36637d3bd7fde2e315ed4a5d1bc29f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a713df989fd498a0a680d4b7cc673cb"><td class="memTemplParams" colspan="2">template&lt;class Stream , class Traits , class Al &gt; </td></tr>
<tr class="memitem:a7a713df989fd498a0a680d4b7cc673cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7a713df989fd498a0a680d4b7cc673cb">from_stream</a> (Stream &amp;str, std::basic_string&lt; char, Traits, Al &gt; &amp;value) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:a7a713df989fd498a0a680d4b7cc673cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a word from a #basic_input_stream object.  <a href="#a7a713df989fd498a0a680d4b7cc673cb">More...</a><br /></td></tr>
<tr class="separator:a7a713df989fd498a0a680d4b7cc673cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0e5ed9d968a2eb03774cfacb2a4001"><td class="memTemplParams" colspan="2">template&lt;class Stream , class Traits , size_t Ss, class Al &gt; </td></tr>
<tr class="memitem:a0e0e5ed9d968a2eb03774cfacb2a4001"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0e0e5ed9d968a2eb03774cfacb2a4001">from_stream</a> (Stream &amp;str, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; char, Traits, Al, Ss &gt; &amp;value) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:a0e0e5ed9d968a2eb03774cfacb2a4001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a word from a #basic_input_stream object.  <a href="#a0e0e5ed9d968a2eb03774cfacb2a4001">More...</a><br /></td></tr>
<tr class="separator:a0e0e5ed9d968a2eb03774cfacb2a4001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbab83476e9a93ab4a0fe3626a3c27ab"><td class="memTemplParams" colspan="2">template&lt;class Stream , class Traits , class Al &gt; </td></tr>
<tr class="memitem:acbab83476e9a93ab4a0fe3626a3c27ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#acbab83476e9a93ab4a0fe3626a3c27ab">read_line_from_stream</a> (Stream &amp;str, std::basic_string&lt; char, Traits, Al &gt; &amp;value) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:acbab83476e9a93ab4a0fe3626a3c27ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line from a #basic_input_stream object.  <a href="#acbab83476e9a93ab4a0fe3626a3c27ab">More...</a><br /></td></tr>
<tr class="separator:acbab83476e9a93ab4a0fe3626a3c27ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49d64c12c56026d4476c0e97ea9230c"><td class="memTemplParams" colspan="2">template&lt;class Stream , class Traits , size_t Ss, class Al &gt; </td></tr>
<tr class="memitem:ae49d64c12c56026d4476c0e97ea9230c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae49d64c12c56026d4476c0e97ea9230c">read_line_from_stream</a> (Stream &amp;str, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; char, Traits, Al, Ss &gt; &amp;value) -&gt; Stream &amp;</td></tr>
<tr class="memdesc:ae49d64c12c56026d4476c0e97ea9230c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line from a #basic_input_stream object.  <a href="#ae49d64c12c56026d4476c0e97ea9230c">More...</a><br /></td></tr>
<tr class="separator:ae49d64c12c56026d4476c0e97ea9230c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1718699b0708da31869470b90309a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa1718699b0708da31869470b90309a5b">from_chars</a> (const char *first, const char *last, char &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:aa1718699b0708da31869470b90309a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an integral value from the sequence of characters [first,last).  <a href="#aa1718699b0708da31869470b90309a5b">More...</a><br /></td></tr>
<tr class="separator:aa1718699b0708da31869470b90309a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad3302058c1fd1dfd687ecdece61c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af7ad3302058c1fd1dfd687ecdece61c1">from_chars</a> (const char *first, const char *last, signed char &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:af7ad3302058c1fd1dfd687ecdece61c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812bd0d28d7c1255c96653a7166665b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a812bd0d28d7c1255c96653a7166665b8">from_chars</a> (const char *first, const char *last, unsigned char &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:a812bd0d28d7c1255c96653a7166665b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad334f8a7ca660e93f0ef55bc886b78b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad334f8a7ca660e93f0ef55bc886b78b1">from_chars</a> (const char *first, const char *last, short &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:ad334f8a7ca660e93f0ef55bc886b78b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4f5cdcd5b7105e50e1d01e9dd32331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ace4f5cdcd5b7105e50e1d01e9dd32331">from_chars</a> (const char *first, const char *last, unsigned short &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:ace4f5cdcd5b7105e50e1d01e9dd32331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e197ee8175965cf95fb0ddcf0871b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad0e197ee8175965cf95fb0ddcf0871b0">from_chars</a> (const char *first, const char *last, int &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:ad0e197ee8175965cf95fb0ddcf0871b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d50a7d5d36ca43975d8d76528740bb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0d50a7d5d36ca43975d8d76528740bb0">from_chars</a> (const char *first, const char *last, unsigned int &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:a0d50a7d5d36ca43975d8d76528740bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5d4ddc227721feec149a82f85f73cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3a5d4ddc227721feec149a82f85f73cd">from_chars</a> (const char *first, const char *last, long &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:a3a5d4ddc227721feec149a82f85f73cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4596a80118fe7670d639ebc1266c878e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4596a80118fe7670d639ebc1266c878e">from_chars</a> (const char *first, const char *last, unsigned long &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:a4596a80118fe7670d639ebc1266c878e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1108c21e3ed098d6e134e1856f672ac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1108c21e3ed098d6e134e1856f672ac9">from_chars</a> (const char *first, const char *last, long long &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:a1108c21e3ed098d6e134e1856f672ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a4bc6bba17141d6258f6220e42c868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa1a4bc6bba17141d6258f6220e42c868">from_chars</a> (const char *first, const char *last, unsigned long long &amp;value, int base=10) -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="separator:aa1a4bc6bba17141d6258f6220e42c868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a4b7fe569864c695641332f004acec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa6a4b7fe569864c695641332f004acec">from_chars</a> (const char *first, const char *last, float &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:aa6a4b7fe569864c695641332f004acec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from the sequence of characters [first,last).  <a href="#aa6a4b7fe569864c695641332f004acec">More...</a><br /></td></tr>
<tr class="separator:aa6a4b7fe569864c695641332f004acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b35225d5a96bc5ac0774b9238b6efa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2b35225d5a96bc5ac0774b9238b6efa2">from_chars</a> (const char *first, const char *last, double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:a2b35225d5a96bc5ac0774b9238b6efa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from the sequence of characters [first,last).  <a href="#a2b35225d5a96bc5ac0774b9238b6efa2">More...</a><br /></td></tr>
<tr class="separator:a2b35225d5a96bc5ac0774b9238b6efa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad918ef5a661c096e650809b91fc5e1cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad918ef5a661c096e650809b91fc5e1cc">from_chars</a> (const char *first, const char *last, long double &amp;value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a>, char dot='.') -&gt; <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:ad918ef5a661c096e650809b91fc5e1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a floating point value from the sequence of characters [first,last).  <a href="#ad918ef5a661c096e650809b91fc5e1cc">More...</a><br /></td></tr>
<tr class="separator:ad918ef5a661c096e650809b91fc5e1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaade1f4ec092684337563886384d3aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aaade1f4ec092684337563886384d3aaf">to_chars</a> (char *first, char *last, char value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:aaade1f4ec092684337563886384d3aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <a href="#aaade1f4ec092684337563886384d3aaf">More...</a><br /></td></tr>
<tr class="separator:aaade1f4ec092684337563886384d3aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099d83f326c156da30ad657ad718ea4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a099d83f326c156da30ad657ad718ea4c">to_chars</a> (char *first, char *last, signed char value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a099d83f326c156da30ad657ad718ea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25c9658376d453f2a56a173746672c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad25c9658376d453f2a56a173746672c9">to_chars</a> (char *first, char *last, unsigned char value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:ad25c9658376d453f2a56a173746672c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd334ad81488273a36930fece9304ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afcd334ad81488273a36930fece9304ed">to_chars</a> (char *first, char *last, short value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:afcd334ad81488273a36930fece9304ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed606c84f8e4c850d5b68a054ce0a15e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aed606c84f8e4c850d5b68a054ce0a15e">to_chars</a> (char *first, char *last, unsigned short value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:aed606c84f8e4c850d5b68a054ce0a15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaab1e86cd0b413375e5e592efa851fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aeaab1e86cd0b413375e5e592efa851fe">to_chars</a> (char *first, char *last, int value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:aeaab1e86cd0b413375e5e592efa851fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab247e78aa5765ba115078d0224c49c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab247e78aa5765ba115078d0224c49c16">to_chars</a> (char *first, char *last, unsigned int value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:ab247e78aa5765ba115078d0224c49c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0956a6e8b7a3bbf55aa5457d39119f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7d0956a6e8b7a3bbf55aa5457d39119f">to_chars</a> (char *first, char *last, long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a7d0956a6e8b7a3bbf55aa5457d39119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fce5d7e14a9d6daf2307355d4c396ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3fce5d7e14a9d6daf2307355d4c396ad">to_chars</a> (char *first, char *last, unsigned long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a3fce5d7e14a9d6daf2307355d4c396ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefccfef5bd4c953871f7d35dd07bd43d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aefccfef5bd4c953871f7d35dd07bd43d">to_chars</a> (char *first, char *last, long long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:aefccfef5bd4c953871f7d35dd07bd43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd91e37c46eb88e41f560947130f5473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abd91e37c46eb88e41f560947130f5473">to_chars</a> (char *first, char *last, unsigned long long value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:abd91e37c46eb88e41f560947130f5473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9848bd29c3454546f0851b641a010741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9848bd29c3454546f0851b641a010741">to_chars</a> (char *first, char *last, float value) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:a9848bd29c3454546f0851b641a010741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <a href="#a9848bd29c3454546f0851b641a010741">More...</a><br /></td></tr>
<tr class="separator:a9848bd29c3454546f0851b641a010741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0180d389d8f3068a5df2e6d5dfc803"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5b0180d389d8f3068a5df2e6d5dfc803">to_chars</a> (char *first, char *last, double value) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a5b0180d389d8f3068a5df2e6d5dfc803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e708206c2575bd63ab6b4d52e58a78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a62e708206c2575bd63ab6b4d52e58a78">to_chars</a> (char *first, char *last, long double value) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a62e708206c2575bd63ab6b4d52e58a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ccb0a2e6e282ce1c7c5176a32274da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad1ccb0a2e6e282ce1c7c5176a32274da">to_chars</a> (char *first, char *last, float value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:ad1ccb0a2e6e282ce1c7c5176a32274da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8eb39bb928f38502c5a6433d1478c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2c8eb39bb928f38502c5a6433d1478c2">to_chars</a> (char *first, char *last, double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a2c8eb39bb928f38502c5a6433d1478c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cbe0f00262b2bbd898d26c35a15f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab6cbe0f00262b2bbd898d26c35a15f05">to_chars</a> (char *first, char *last, long double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:ab6cbe0f00262b2bbd898d26c35a15f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774b42dc254e78ac416a8466308c4dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a774b42dc254e78ac416a8466308c4dc3">to_chars</a> (char *first, char *last, float value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>, int precision, char dot='.', char exp='e', bool upper=false) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a774b42dc254e78ac416a8466308c4dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8fd1f2d9c6c556f7a8057230c2969b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0d8fd1f2d9c6c556f7a8057230c2969b">to_chars</a> (char *first, char *last, double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>, int precision, char dot='.', char exp='e', bool upper=false) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a0d8fd1f2d9c6c556f7a8057230c2969b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ec4de73a0ecf29b16cf62709e1c3a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a25ec4de73a0ecf29b16cf62709e1c3a8">to_chars</a> (char *first, char *last, long double value, <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a> <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>, int precision, char dot='.', char exp='e', bool upper=false) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="separator:a25ec4de73a0ecf29b16cf62709e1c3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac778d2e1714b0bc1a988a8ef573fed6e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac778d2e1714b0bc1a988a8ef573fed6e">to_chars</a> (char *first, char *last, bool value, int base=10, const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;<a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a>=<a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()) -&gt; <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>=delete</td></tr>
<tr class="separator:ac778d2e1714b0bc1a988a8ef573fed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e7a0c600427f614ba162d86c3c4362"><td class="memTemplParams" colspan="2">template&lt;class Lock &gt; </td></tr>
<tr class="memitem:a32e7a0c600427f614ba162d86c3c4362"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a32e7a0c600427f614ba162d86c3c4362">make_lock_guard</a> (Lock &amp;l) -&gt; <a class="el" href="classseq_1_1lock__guard.html">lock_guard</a>&lt; Lock &gt;</td></tr>
<tr class="memdesc:a32e7a0c600427f614ba162d86c3c4362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lock guard around l. Use copy elison to avoid creating copies and locking twice the lock object.  <a href="#a32e7a0c600427f614ba162d86c3c4362">More...</a><br /></td></tr>
<tr class="separator:a32e7a0c600427f614ba162d86c3c4362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02fc574f6876f28fef03044ed31569e"><td class="memTemplParams" colspan="2">template&lt;class Comp &gt; </td></tr>
<tr class="memitem:ae02fc574f6876f28fef03044ed31569e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae02fc574f6876f28fef03044ed31569e">make_comparator</a> (const Comp &amp;comp) -&gt; <a class="el" href="structseq_1_1comp__wrapper.html">comp_wrapper</a>&lt; Comp &gt;</td></tr>
<tr class="memdesc:ae02fc574f6876f28fef03044ed31569e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a comparison functor that can be used by algorithms working on cvector objects.  <a href="#ae02fc574f6876f28fef03044ed31569e">More...</a><br /></td></tr>
<tr class="separator:ae02fc574f6876f28fef03044ed31569e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa312ea998bfce36889d0f3d89a0253"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare , class Al1 , class Al2 , bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:a2aa312ea998bfce36889d0f3d89a0253"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2aa312ea998bfce36889d0f3d89a0253">operator==</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, S2, U2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a2aa312ea998bfce36889d0f3d89a0253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position.  <a href="#a2aa312ea998bfce36889d0f3d89a0253">More...</a><br /></td></tr>
<tr class="separator:a2aa312ea998bfce36889d0f3d89a0253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d26e806617c5a8c647633ca26c48ced"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare , class Al1 , class Al2 , bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:a0d26e806617c5a8c647633ca26c48ced"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0d26e806617c5a8c647633ca26c48ced">operator!=</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, S2, U2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a0d26e806617c5a8c647633ca26c48ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are not equals.  <a href="#a0d26e806617c5a8c647633ca26c48ced">More...</a><br /></td></tr>
<tr class="separator:a0d26e806617c5a8c647633ca26c48ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bde7d21b0fd6405cd671441c6ab4bab"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare , class Al1 , bool S1, bool U1, class Pred &gt; </td></tr>
<tr class="memitem:a2bde7d21b0fd6405cd671441c6ab4bab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2bde7d21b0fd6405cd671441c6ab4bab">erase_if</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, S1, U1 &gt; &amp;s1, Pred p) -&gt; typename <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, S1, U1 &gt;::size_type</td></tr>
<tr class="memdesc:a2bde7d21b0fd6405cd671441c6ab4bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="#a2bde7d21b0fd6405cd671441c6ab4bab">More...</a><br /></td></tr>
<tr class="separator:a2bde7d21b0fd6405cd671441c6ab4bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a694c998ffa1289077fa7cc28524990"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare , class Al1 , class Al2 , bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:a5a694c998ffa1289077fa7cc28524990"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5a694c998ffa1289077fa7cc28524990">operator==</a> (const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, S2, U2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a5a694c998ffa1289077fa7cc28524990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position.  <a href="#a5a694c998ffa1289077fa7cc28524990">More...</a><br /></td></tr>
<tr class="separator:a5a694c998ffa1289077fa7cc28524990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44254caec914e25dbb9f365648101280"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare , class Al1 , class Al2 , bool S1, bool S2, bool U1, bool U2&gt; </td></tr>
<tr class="memitem:a44254caec914e25dbb9f365648101280"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a44254caec914e25dbb9f365648101280">operator!=</a> (const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, S1, U1 &gt; &amp;s1, const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, S2, U2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a44254caec914e25dbb9f365648101280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are not equals.  <a href="#a44254caec914e25dbb9f365648101280">More...</a><br /></td></tr>
<tr class="separator:a44254caec914e25dbb9f365648101280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b4884322c989de0cfb165cf2ab41ba"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare , class Al1 , bool S1, bool U1, class Pred &gt; </td></tr>
<tr class="memitem:ac7b4884322c989de0cfb165cf2ab41ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac7b4884322c989de0cfb165cf2ab41ba">erase_if</a> (<a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, S1, U1 &gt; &amp;s1, Pred p) -&gt; typename <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, S1, U1 &gt;::size_type</td></tr>
<tr class="memdesc:ac7b4884322c989de0cfb165cf2ab41ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="#ac7b4884322c989de0cfb165cf2ab41ba">More...</a><br /></td></tr>
<tr class="separator:ac7b4884322c989de0cfb165cf2ab41ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03816e7c3b50a05fea57bc0934de320f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structseq_1_1filler.html">filler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a03816e7c3b50a05fea57bc0934de320f">fill</a> (char c)</td></tr>
<tr class="memdesc:a03816e7c3b50a05fea57bc0934de320f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a filler object used to fill a string slot within a formatting expression.  <a href="#a03816e7c3b50a05fea57bc0934de320f">More...</a><br /></td></tr>
<tr class="separator:a03816e7c3b50a05fea57bc0934de320f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa905511e61ee9e449a5ed9e38f89ca"><td class="memTemplParams" colspan="2">template&lt;class Elem , class Traits , class T , bool S&gt; </td></tr>
<tr class="memitem:a3fa905511e61ee9e449a5ed9e38f89ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3fa905511e61ee9e449a5ed9e38f89ca">operator&lt;&lt;</a> (std::basic_ostream&lt; Elem, Traits &gt; &amp;oss, const <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;val) -&gt; std::basic_ostream&lt; Elem, Traits &gt; &amp;</td></tr>
<tr class="memdesc:a3fa905511e61ee9e449a5ed9e38f89ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class. ">ostream_format</a> object to a std::ostream.  <a href="#a3fa905511e61ee9e449a5ed9e38f89ca">More...</a><br /></td></tr>
<tr class="separator:a3fa905511e61ee9e449a5ed9e38f89ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab534e8a0f6ac376f61e976fe7cd65457"><td class="memTemplParams" colspan="2">template&lt;size_t... Ts&gt; </td></tr>
<tr class="memitem:ab534e8a0f6ac376f61e976fe7cd65457"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a> () -&gt; <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;</td></tr>
<tr class="memdesc:ab534e8a0f6ac376f61e976fe7cd65457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a positional object used either by <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">seq::fmt()</a> or operator() of formatting object.  <a href="#ab534e8a0f6ac376f61e976fe7cd65457">More...</a><br /></td></tr>
<tr class="separator:ab534e8a0f6ac376f61e976fe7cd65457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6121df4185303d9c1babf573d914e4d1"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a6121df4185303d9c1babf573d914e4d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">fmt</a> (Args &amp;&amp;... args) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), false, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt; Args... &gt;::type, false, Args... &gt;::return_type</td></tr>
<tr class="separator:a6121df4185303d9c1babf573d914e4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb0eb956da2343b3354867d5f5cd27"><td class="memTemplParams" colspan="2">template&lt;size_t ... Ts, class ... Args&gt; </td></tr>
<tr class="memitem:ad3fb0eb956da2343b3354867d5f5cd27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad3fb0eb956da2343b3354867d5f5cd27">fmt</a> (<a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;, Args &amp;&amp;... args) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), false, <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;, false, Args... &gt;::return_type</td></tr>
<tr class="separator:ad3fb0eb956da2343b3354867d5f5cd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1285ca30ab2e5fe9794f18b2d0e3df"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a3e1285ca30ab2e5fe9794f18b2d0e3df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3e1285ca30ab2e5fe9794f18b2d0e3df">fmt</a> () -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), false, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt; Args... &gt;::type, false, Args... &gt;::return_type</td></tr>
<tr class="separator:a3e1285ca30ab2e5fe9794f18b2d0e3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6f65f0b0ecf8d8214d8bbfdef74935"><td class="memTemplParams" colspan="2">template&lt;class T , bool S&gt; </td></tr>
<tr class="memitem:a5d6f65f0b0ecf8d8214d8bbfdef74935"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5d6f65f0b0ecf8d8214d8bbfdef74935">fmt</a> (<a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;&amp;o) -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt;, false &gt;</td></tr>
<tr class="separator:a5d6f65f0b0ecf8d8214d8bbfdef74935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef86982e406fd6777fec657b967b27a"><td class="memTemplParams" colspan="2">template&lt;class T , bool S&gt; </td></tr>
<tr class="memitem:a1ef86982e406fd6777fec657b967b27a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1ef86982e406fd6777fec657b967b27a">fmt</a> (<a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;o) -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt;, false &gt;</td></tr>
<tr class="separator:a1ef86982e406fd6777fec657b967b27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191cf765becd8f118827fc7329aecb76"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a191cf765becd8f118827fc7329aecb76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a191cf765becd8f118827fc7329aecb76">_fmt</a> (Args &amp;&amp;... args) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), false, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt; Args... &gt;::type, true, Args... &gt;::return_type</td></tr>
<tr class="separator:a191cf765becd8f118827fc7329aecb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfe91dbf0ec2b4565fedd6d93097645"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:afbfe91dbf0ec2b4565fedd6d93097645"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afbfe91dbf0ec2b4565fedd6d93097645">_fmt</a> () -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), false, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt; Args... &gt;::type, true, Args... &gt;::return_type</td></tr>
<tr class="separator:afbfe91dbf0ec2b4565fedd6d93097645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c696025e12d6de56084a2d64214b40"><td class="memTemplParams" colspan="2">template&lt;class ... Args, class K  = typename std::enable_if&lt;!detail::IsFirstIterable&lt;Args...&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:ae5c696025e12d6de56084a2d64214b40"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae5c696025e12d6de56084a2d64214b40">join</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> sep, Args &amp;&amp;... args) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), true, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt; Args... &gt;::type, false, Args... &gt;::return_type</td></tr>
<tr class="separator:ae5c696025e12d6de56084a2d64214b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa223aa54b2ea58cdd86897555de5caa6"><td class="memTemplParams" colspan="2">template&lt;class IterRange &gt; </td></tr>
<tr class="memitem:aa223aa54b2ea58cdd86897555de5caa6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa223aa54b2ea58cdd86897555de5caa6">join</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> sep, const IterRange &amp;c) noexcept -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="structseq_1_1detail_1_1_iterable.html">detail::Iterable</a>&lt; IterRange &gt; &gt;</td></tr>
<tr class="separator:aa223aa54b2ea58cdd86897555de5caa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410a01fc0326543b86b969ed66cea960"><td class="memTemplParams" colspan="2">template&lt;class IterRange , class T , bool S&gt; </td></tr>
<tr class="memitem:a410a01fc0326543b86b969ed66cea960"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a410a01fc0326543b86b969ed66cea960">join</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> sep, const IterRange &amp;c, const <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;wf) noexcept -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="structseq_1_1detail_1_1_iterable.html">detail::Iterable</a>&lt; IterRange &gt; &gt;</td></tr>
<tr class="separator:a410a01fc0326543b86b969ed66cea960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dca10eb469071a8f8264b8f567b4da5"><td class="memTemplParams" colspan="2">template&lt;class ... Args, class K  = typename std::enable_if&lt;!detail::IsFirstIterable&lt;Args...&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a1dca10eb469071a8f8264b8f567b4da5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1dca10eb469071a8f8264b8f567b4da5">_join</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> sep, Args &amp;&amp;... args) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), true, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt; Args... &gt;::type, true, Args... &gt;::return_type</td></tr>
<tr class="separator:a1dca10eb469071a8f8264b8f567b4da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf9bdd5513aeeb0ddb7ff2b3a1aa3c0"><td class="memTemplParams" colspan="2">template&lt;class IterRange &gt; </td></tr>
<tr class="memitem:afbf9bdd5513aeeb0ddb7ff2b3a1aa3c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afbf9bdd5513aeeb0ddb7ff2b3a1aa3c0">_join</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> sep, const IterRange &amp;c) noexcept -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="structseq_1_1detail_1_1_iterable.html">detail::Iterable</a>&lt; IterRange &gt;, true &gt;</td></tr>
<tr class="separator:afbf9bdd5513aeeb0ddb7ff2b3a1aa3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900c6edb6afef4c5681f9bf11a20cb4f"><td class="memTemplParams" colspan="2">template&lt;class IterRange , class T , bool S&gt; </td></tr>
<tr class="memitem:a900c6edb6afef4c5681f9bf11a20cb4f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a900c6edb6afef4c5681f9bf11a20cb4f">_join</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> sep, const IterRange &amp;c, const <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;wf) noexcept -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="structseq_1_1detail_1_1_iterable.html">detail::Iterable</a>&lt; IterRange &gt;, true &gt;</td></tr>
<tr class="separator:a900c6edb6afef4c5681f9bf11a20cb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a3ddd798c88bc1b4e22d2d35ddea5f"><td class="memTemplParams" colspan="2">template&lt;class Elem , class Traits , class T , bool HS, class P , bool S&gt; </td></tr>
<tr class="memitem:a88a3ddd798c88bc1b4e22d2d35ddea5f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a88a3ddd798c88bc1b4e22d2d35ddea5f">operator&lt;&lt;</a> (std::basic_ostream&lt; Elem, Traits &gt; &amp;oss, const <a class="el" href="structseq_1_1detail_1_1mutli__ostream__format.html">detail::mutli_ostream_format</a>&lt; T, HS, P, S &gt; &amp;val) -&gt; std::basic_ostream&lt; Elem, Traits &gt; &amp;</td></tr>
<tr class="memdesc:a88a3ddd798c88bc1b4e22d2d35ddea5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class. ">ostream_format</a> object to a std::ostream object.  <a href="#a88a3ddd798c88bc1b4e22d2d35ddea5f">More...</a><br /></td></tr>
<tr class="separator:a88a3ddd798c88bc1b4e22d2d35ddea5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563c78745a64d62dffe9db8ead6c59b3"><td class="memTemplParams" colspan="2">template&lt;class Skip  = no_skip&gt; </td></tr>
<tr class="memitem:a563c78745a64d62dffe9db8ead6c59b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a563c78745a64d62dffe9db8ead6c59b3">split</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> str, <a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> match, Skip skip=Skip()) -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_split_iter.html">detail::SplitIter</a>&lt; <a class="el" href="structseq_1_1by__string.html">by_string</a>, Skip &gt; &gt;</td></tr>
<tr class="separator:a563c78745a64d62dffe9db8ead6c59b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b811191ca77f9bf39346b6d30ae4d0"><td class="memTemplParams" colspan="2">template&lt;class Skip  = no_skip&gt; </td></tr>
<tr class="memitem:a18b811191ca77f9bf39346b6d30ae4d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a18b811191ca77f9bf39346b6d30ae4d0">split</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> str, char match, Skip skip=Skip()) -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_split_iter.html">detail::SplitIter</a>&lt; <a class="el" href="structseq_1_1by__char.html">by_char</a>, Skip &gt; &gt;</td></tr>
<tr class="separator:a18b811191ca77f9bf39346b6d30ae4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36473c179443ac54eaec04624d16fe1d"><td class="memTemplParams" colspan="2">template&lt;class Match , class Skip  = no_skip&gt; </td></tr>
<tr class="memitem:a36473c179443ac54eaec04624d16fe1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a36473c179443ac54eaec04624d16fe1d">split</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> str, const <a class="el" href="structseq_1_1match__base.html">match_base</a>&lt; Match &gt; &amp;match, Skip skip=Skip()) -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_split_iter.html">detail::SplitIter</a>&lt; Match, Skip &gt; &gt;</td></tr>
<tr class="separator:a36473c179443ac54eaec04624d16fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d14b24f21161f7a7188e36b3ed8549"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a65d14b24f21161f7a7188e36b3ed8549">replace</a> (<a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> src, <a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> match, <a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a> _new) -&gt; std::string</td></tr>
<tr class="separator:a65d14b24f21161f7a7188e36b3ed8549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e75ac2752560b9441e25dbeb0a37035"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1e75ac2752560b9441e25dbeb0a37035">hash_combine</a> (size_t h1, size_t h2) noexcept -&gt; size_t</td></tr>
<tr class="memdesc:a1e75ac2752560b9441e25dbeb0a37035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine 2 hash values. Uses either murmurhash2 for 64 bits platform or the boost version for 32 bits platform.  <a href="#a1e75ac2752560b9441e25dbeb0a37035">More...</a><br /></td></tr>
<tr class="separator:a1e75ac2752560b9441e25dbeb0a37035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d484b65f61026ac2f11b34b371cce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a73d484b65f61026ac2f11b34b371cce1">hash_bytes_murmur64</a> (const std::uint8_t *ptr, size_t len) noexcept -&gt; size_t</td></tr>
<tr class="separator:a73d484b65f61026ac2f11b34b371cce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa143c1836c024422e735b68350a8c58d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa143c1836c024422e735b68350a8c58d">hash_bytes_fnv1a</a> (const unsigned char *ptr, size_t size) noexcept -&gt; size_t</td></tr>
<tr class="separator:aa143c1836c024422e735b68350a8c58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1349a44a2ff37300a5c72a03780780fe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1349a44a2ff37300a5c72a03780780fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1349a44a2ff37300a5c72a03780780fe">unique_ptr_delete</a> (T *p)</td></tr>
<tr class="memdesc:a1349a44a2ff37300a5c72a03780780fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate pointer previously held by a std::unqiue_ptr&lt;T,unique_ptr_deleter&lt;T&gt; &gt;  <a href="#a1349a44a2ff37300a5c72a03780780fe">More...</a><br /></td></tr>
<tr class="separator:a1349a44a2ff37300a5c72a03780780fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4308e82af69325da59bf1abe2e9b30d1"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:a4308e82af69325da59bf1abe2e9b30d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4308e82af69325da59bf1abe2e9b30d1">operator==</a> (const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a4308e82af69325da59bf1abe2e9b30d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. ">ordered_set</a> for equality. Two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. ">ordered_set</a> are considered equal if they contain the same keys. Key ordering is not considered.  <a href="#a4308e82af69325da59bf1abe2e9b30d1">More...</a><br /></td></tr>
<tr class="separator:a4308e82af69325da59bf1abe2e9b30d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a8e4ca5bdbbf2cd53645c2733449d0"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:a12a8e4ca5bdbbf2cd53645c2733449d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a12a8e4ca5bdbbf2cd53645c2733449d0">operator!=</a> (const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a12a8e4ca5bdbbf2cd53645c2733449d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. ">ordered_set</a> for inequality, synthesized from operator==.  <a href="#a12a8e4ca5bdbbf2cd53645c2733449d0">More...</a><br /></td></tr>
<tr class="separator:a12a8e4ca5bdbbf2cd53645c2733449d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c9030a8049270841c9d1ceb949ed16"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </td></tr>
<tr class="memitem:ac8c9030a8049270841c9d1ceb949ed16"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac8c9030a8049270841c9d1ceb949ed16">erase_if</a> (<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;set, Pred p) -&gt; size_t</td></tr>
<tr class="memdesc:ac8c9030a8049270841c9d1ceb949ed16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="#ac8c9030a8049270841c9d1ceb949ed16">More...</a><br /></td></tr>
<tr class="separator:ac8c9030a8049270841c9d1ceb949ed16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3debed99e1f30055ff02d9d0ee009727"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:a3debed99e1f30055ff02d9d0ee009727"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3debed99e1f30055ff02d9d0ee009727">operator==</a> (const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a3debed99e1f30055ff02d9d0ee009727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. ">ordered_map</a> for equality. Two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. ">ordered_map</a> are considered equal if they contain the same pairs key-&gt;value. Key ordering is not considered.  <a href="#a3debed99e1f30055ff02d9d0ee009727">More...</a><br /></td></tr>
<tr class="separator:a3debed99e1f30055ff02d9d0ee009727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a77517d376eeb44fc2615040f226b3"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </td></tr>
<tr class="memitem:ac8a77517d376eeb44fc2615040f226b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac8a77517d376eeb44fc2615040f226b3">operator!=</a> (const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ac8a77517d376eeb44fc2615040f226b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. ">ordered_map</a> for inequality, synthesized from operator==.  <a href="#ac8a77517d376eeb44fc2615040f226b3">More...</a><br /></td></tr>
<tr class="separator:ac8a77517d376eeb44fc2615040f226b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345460864d8e607d34f3547e6d1e01fd"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </td></tr>
<tr class="memitem:a345460864d8e607d34f3547e6d1e01fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a345460864d8e607d34f3547e6d1e01fd">erase_if</a> (<a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;set, Pred p) -&gt; size_t</td></tr>
<tr class="memdesc:a345460864d8e607d34f3547e6d1e01fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="#a345460864d8e607d34f3547e6d1e01fd">More...</a><br /></td></tr>
<tr class="separator:a345460864d8e607d34f3547e6d1e01fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0aca828820ed7f1be01fe23f56640f0"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , class Less1 , class Less2 &gt; </td></tr>
<tr class="memitem:gac0aca828820ed7f1be01fe23f56640f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__containers.html#gac0aca828820ed7f1be01fe23f56640f0">operator==</a> (const <a class="el" href="classseq_1_1radix__hash__set.html">radix_hash_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Less1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1radix__hash__set.html">radix_hash_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Less2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:gac0aca828820ed7f1be01fe23f56640f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1radix__hash__set.html" title="Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::unordered...">radix_hash_set</a> for equality. Two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. ">ordered_set</a> are considered equal if they contain the same keys. Key ordering is not considered.  <a href="group__containers.html#gac0aca828820ed7f1be01fe23f56640f0">More...</a><br /></td></tr>
<tr class="separator:gac0aca828820ed7f1be01fe23f56640f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad21c147c0232f8d6c2334a450a0ef56"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , class Less1 , class Less2 &gt; </td></tr>
<tr class="memitem:gaad21c147c0232f8d6c2334a450a0ef56"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__containers.html#gaad21c147c0232f8d6c2334a450a0ef56">operator!=</a> (const <a class="el" href="classseq_1_1radix__hash__set.html">radix_hash_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Less1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1radix__hash__set.html">radix_hash_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Less2 &gt; &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:gaad21c147c0232f8d6c2334a450a0ef56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classseq_1_1radix__hash__set.html" title="Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::unordered...">radix_hash_set</a> for inequality, synthesized from operator==.  <a href="group__containers.html#gaad21c147c0232f8d6c2334a450a0ef56">More...</a><br /></td></tr>
<tr class="separator:gaad21c147c0232f8d6c2334a450a0ef56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c25e60bf0fd1358215e081bbe4a9e89"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash1 , class KeyEqual , class Allocator1 , class Less , class Pred &gt; </td></tr>
<tr class="memitem:ga7c25e60bf0fd1358215e081bbe4a9e89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__containers.html#ga7c25e60bf0fd1358215e081bbe4a9e89">erase_if</a> (<a class="el" href="classseq_1_1radix__hash__set.html">radix_hash_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Less &gt; &amp;s, Pred p) -&gt; size_t</td></tr>
<tr class="memdesc:ga7c25e60bf0fd1358215e081bbe4a9e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="group__containers.html#ga7c25e60bf0fd1358215e081bbe4a9e89">More...</a><br /></td></tr>
<tr class="separator:ga7c25e60bf0fd1358215e081bbe4a9e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c16e0913dbd7cbf538d082342b64483"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash , class Equal , class L1 , class L2 , class Al1 , class Al2 &gt; </td></tr>
<tr class="memitem:ga6c16e0913dbd7cbf538d082342b64483"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__containers.html#ga6c16e0913dbd7cbf538d082342b64483">operator==</a> (const <a class="el" href="classseq_1_1radix__hash__map.html">radix_hash_map</a>&lt; Key, T, Hash, Equal, Al1, L1 &gt; &amp;s1, const <a class="el" href="classseq_1_1radix__hash__map.html">radix_hash_map</a>&lt; Key, T, Hash, Equal, Al2, L2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:ga6c16e0913dbd7cbf538d082342b64483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position.  <a href="group__containers.html#ga6c16e0913dbd7cbf538d082342b64483">More...</a><br /></td></tr>
<tr class="separator:ga6c16e0913dbd7cbf538d082342b64483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a28b54b14c4be05e5a267de68937e72"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash , class Equal , class L1 , class L2 , class Al1 , class Al2 &gt; </td></tr>
<tr class="memitem:ga2a28b54b14c4be05e5a267de68937e72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__containers.html#ga2a28b54b14c4be05e5a267de68937e72">operator!=</a> (const <a class="el" href="classseq_1_1radix__hash__map.html">radix_hash_map</a>&lt; Key, T, Hash, Equal, Al1, L1 &gt; &amp;s1, const <a class="el" href="classseq_1_1radix__hash__map.html">radix_hash_map</a>&lt; Key, T, Hash, Equal, Al2, L2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:ga2a28b54b14c4be05e5a267de68937e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are not equals.  <a href="group__containers.html#ga2a28b54b14c4be05e5a267de68937e72">More...</a><br /></td></tr>
<tr class="separator:ga2a28b54b14c4be05e5a267de68937e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f5d05351316415d9455876fbfb18db"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash , class Equal , class Al , class Less , class Pred &gt; </td></tr>
<tr class="memitem:ga01f5d05351316415d9455876fbfb18db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__containers.html#ga01f5d05351316415d9455876fbfb18db">erase_if</a> (<a class="el" href="classseq_1_1radix__hash__map.html">radix_hash_map</a>&lt; Key, T, Hash, Equal, Al, Less &gt; &amp;s, Pred p) -&gt; typename <a class="el" href="classseq_1_1radix__hash__map.html">radix_hash_map</a>&lt; Key, T, Hash, Equal, Al, Less &gt;::size_type</td></tr>
<tr class="memdesc:ga01f5d05351316415d9455876fbfb18db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="group__containers.html#ga01f5d05351316415d9455876fbfb18db">More...</a><br /></td></tr>
<tr class="separator:ga01f5d05351316415d9455876fbfb18db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02812cee981693bc33614eecea8d45dc"><td class="memTemplParams" colspan="2">template&lt;class Key , class ExtractKey , class Al1 , class Al2 &gt; </td></tr>
<tr class="memitem:a02812cee981693bc33614eecea8d45dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a02812cee981693bc33614eecea8d45dc">operator==</a> (const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al1 &gt; &amp;s1, const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a02812cee981693bc33614eecea8d45dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position.  <a href="#a02812cee981693bc33614eecea8d45dc">More...</a><br /></td></tr>
<tr class="separator:a02812cee981693bc33614eecea8d45dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa1c88afedd41ee32a953675e55e7d3"><td class="memTemplParams" colspan="2">template&lt;class Key , class ExtractKey , class Al1 , class Al2 &gt; </td></tr>
<tr class="memitem:a3fa1c88afedd41ee32a953675e55e7d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3fa1c88afedd41ee32a953675e55e7d3">operator!=</a> (const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al1 &gt; &amp;s1, const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a3fa1c88afedd41ee32a953675e55e7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are not equals.  <a href="#a3fa1c88afedd41ee32a953675e55e7d3">More...</a><br /></td></tr>
<tr class="separator:a3fa1c88afedd41ee32a953675e55e7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425af004809cddd3a0b99a627039e2f8"><td class="memTemplParams" colspan="2">template&lt;class Key , class ExtractKey , class Al , class Pred &gt; </td></tr>
<tr class="memitem:a425af004809cddd3a0b99a627039e2f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a425af004809cddd3a0b99a627039e2f8">erase_if</a> (<a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al &gt; &amp;s, Pred p) -&gt; typename <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al &gt;::size_type</td></tr>
<tr class="memdesc:a425af004809cddd3a0b99a627039e2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="#a425af004809cddd3a0b99a627039e2f8">More...</a><br /></td></tr>
<tr class="separator:a425af004809cddd3a0b99a627039e2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f30bf51b65c1dda85a65bb995a6090a"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class ExtractKey , class Al1 , class Al2 &gt; </td></tr>
<tr class="memitem:a8f30bf51b65c1dda85a65bb995a6090a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8f30bf51b65c1dda85a65bb995a6090a">operator==</a> (const <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al1 &gt; &amp;s1, const <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a8f30bf51b65c1dda85a65bb995a6090a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position.  <a href="#a8f30bf51b65c1dda85a65bb995a6090a">More...</a><br /></td></tr>
<tr class="separator:a8f30bf51b65c1dda85a65bb995a6090a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400e9d7037a613d14f9a38347563be82"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class ExtractKey , class Al1 , class Al2 &gt; </td></tr>
<tr class="memitem:a400e9d7037a613d14f9a38347563be82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a400e9d7037a613d14f9a38347563be82">operator!=</a> (const <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al1 &gt; &amp;s1, const <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al2 &gt; &amp;s2) -&gt; bool</td></tr>
<tr class="memdesc:a400e9d7037a613d14f9a38347563be82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of s1 and s2 are not equals.  <a href="#a400e9d7037a613d14f9a38347563be82">More...</a><br /></td></tr>
<tr class="separator:a400e9d7037a613d14f9a38347563be82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272bfe364a7c543ae0d7475f3defd7cb"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class ExtractKey , class Al , class Pred &gt; </td></tr>
<tr class="memitem:a272bfe364a7c543ae0d7475f3defd7cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a272bfe364a7c543ae0d7475f3defd7cb">erase_if</a> (<a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al &gt; &amp;s, Pred p) -&gt; typename <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al &gt;::size_type</td></tr>
<tr class="memdesc:a272bfe364a7c543ae0d7475f3defd7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate p from the container.  <a href="#a272bfe364a7c543ae0d7475f3defd7cb">More...</a><br /></td></tr>
<tr class="separator:a272bfe364a7c543ae0d7475f3defd7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2727f596361adeef66d2054dc80df83a"><td class="memTemplParams" colspan="2">template&lt;class Iter , class  = typename std::enable_if&lt;!std::is_arithmetic&lt;Iter&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a2727f596361adeef66d2054dc80df83a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2727f596361adeef66d2054dc80df83a">range</a> (Iter first, Iter last) noexcept -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; Iter &gt;</td></tr>
<tr class="memdesc:a2727f596361adeef66d2054dc80df83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and return an iterable object over the range [first,last)  <a href="#a2727f596361adeef66d2054dc80df83a">More...</a><br /></td></tr>
<tr class="separator:a2727f596361adeef66d2054dc80df83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b67dafb70204550191674aa9eefdc6f"><td class="memTemplParams" colspan="2">template&lt;class Iter , class  = typename std::enable_if&lt;!std::is_arithmetic&lt;Iter&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a0b67dafb70204550191674aa9eefdc6f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0b67dafb70204550191674aa9eefdc6f">range</a> (Iter first, Iter last, size_t count) noexcept -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_n_iterator.html">detail::NIterator</a>&lt; Iter &gt;&gt;</td></tr>
<tr class="memdesc:a0b67dafb70204550191674aa9eefdc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and return an iterable object over the range [first, min(first + count, last))  <a href="#a0b67dafb70204550191674aa9eefdc6f">More...</a><br /></td></tr>
<tr class="separator:a0b67dafb70204550191674aa9eefdc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b689643e0744253bef536676346a3e5"><td class="memTemplParams" colspan="2">template&lt;class Iter , class  = typename std::enable_if&lt;!std::is_arithmetic&lt;Iter&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a1b689643e0744253bef536676346a3e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1b689643e0744253bef536676346a3e5">range_p</a> (Iter *first, Iter *last, size_t count) noexcept -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_n_iterator_ref.html">detail::NIteratorRef</a>&lt; Iter &gt;&gt;</td></tr>
<tr class="memdesc:a1b689643e0744253bef536676346a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and return an iterable object over the range [first, min(first + count, last))  <a href="#a1b689643e0744253bef536676346a3e5">More...</a><br /></td></tr>
<tr class="separator:a1b689643e0744253bef536676346a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676294ca64f6638e227f31c79b040251"><td class="memTemplParams" colspan="2">template&lt;class Integral , class  = typename std::enable_if&lt;std::is_integral&lt;Integral&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a676294ca64f6638e227f31c79b040251"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a676294ca64f6638e227f31c79b040251">range</a> (Integral first, Integral last) noexcept -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_integral_iterator.html">detail::IntegralIterator</a>&lt; Integral &gt; &gt;</td></tr>
<tr class="memdesc:a676294ca64f6638e227f31c79b040251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and return an iterable object over the integral range [first, last) with a step of 1.  <a href="#a676294ca64f6638e227f31c79b040251">More...</a><br /></td></tr>
<tr class="separator:a676294ca64f6638e227f31c79b040251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d76f074323f27c200f338aba629d85b"><td class="memTemplParams" colspan="2">template&lt;class Arithmetic , class  = typename std::enable_if&lt;std::is_arithmetic&lt;Arithmetic&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a7d76f074323f27c200f338aba629d85b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7d76f074323f27c200f338aba629d85b">range</a> (Arithmetic first, Arithmetic last, Arithmetic step) noexcept -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_arithmetic_iterator.html">detail::ArithmeticIterator</a>&lt; Arithmetic &gt; &gt;</td></tr>
<tr class="memdesc:a7d76f074323f27c200f338aba629d85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and return an iterable object over the integral range [first, last) with given step.  <a href="#a7d76f074323f27c200f338aba629d85b">More...</a><br /></td></tr>
<tr class="separator:a7d76f074323f27c200f338aba629d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90e9a81c26ca4cf0f9fd3cd2ba30b57"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:af90e9a81c26ca4cf0f9fd3cd2ba30b57"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af90e9a81c26ca4cf0f9fd3cd2ba30b57">range</a> (const Container &amp;c) noexcept -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; typename Container::const_iterator &gt;</td></tr>
<tr class="memdesc:af90e9a81c26ca4cf0f9fd3cd2ba30b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and return an iterable object over the range [c.begin(), c.end())  <a href="#af90e9a81c26ca4cf0f9fd3cd2ba30b57">More...</a><br /></td></tr>
<tr class="separator:af90e9a81c26ca4cf0f9fd3cd2ba30b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf4f36570fe474a4970d306b7ccdb40"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afaf4f36570fe474a4970d306b7ccdb40"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afaf4f36570fe474a4970d306b7ccdb40">range</a> (std::initializer_list&lt; T &gt; lst) noexcept -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; const T *&gt;</td></tr>
<tr class="memdesc:afaf4f36570fe474a4970d306b7ccdb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and return an iterable object over the range [lst.begin(), lst.end())  <a href="#afaf4f36570fe474a4970d306b7ccdb40">More...</a><br /></td></tr>
<tr class="separator:afaf4f36570fe474a4970d306b7ccdb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f60f564f232ca6fda3fe28fe03d364a"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a8f60f564f232ca6fda3fe28fe03d364a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8f60f564f232ca6fda3fe28fe03d364a">range</a> (const <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; Iter &gt; &amp;r) -&gt; const <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; Iter &gt; &amp;</td></tr>
<tr class="memdesc:a8f60f564f232ca6fda3fe28fe03d364a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just to avoid deeply nested <a class="el" href="classseq_1_1iterator__range.html" title="iterator_range class used to join iterables ">iterator_range</a> objects.  <a href="#a8f60f564f232ca6fda3fe28fe03d364a">More...</a><br /></td></tr>
<tr class="separator:a8f60f564f232ca6fda3fe28fe03d364a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ff14a56a7dc2b518fbc19b289b6ca2"><td class="memTemplParams" colspan="2">template&lt;class Iterable1 , class Iterable2 &gt; </td></tr>
<tr class="memitem:ac2ff14a56a7dc2b518fbc19b289b6ca2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac2ff14a56a7dc2b518fbc19b289b6ca2">zip</a> (const Iterable1 &amp;r1, const Iterable2 &amp;r2) -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_zip_iterator.html">detail::ZipIterator</a>&lt; typename Iterable1::const_iterator, typename Iterable2::const_iterator &gt;&gt;</td></tr>
<tr class="separator:ac2ff14a56a7dc2b518fbc19b289b6ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18560ed6fb98b9e4159f5a246a0a8708"><td class="memTemplParams" colspan="2">template&lt;class Iterable &gt; </td></tr>
<tr class="memitem:a18560ed6fb98b9e4159f5a246a0a8708"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a18560ed6fb98b9e4159f5a246a0a8708">cycle</a> (const Iterable &amp;r, size_t count) -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_n_iterator_wrap.html">detail::NIteratorWrap</a>&lt; typename Iterable::const_iterator &gt;&gt;</td></tr>
<tr class="separator:a18560ed6fb98b9e4159f5a246a0a8708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6c3cb07d1db3914b73700e871982c3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4a6c3cb07d1db3914b73700e871982c3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4a6c3cb07d1db3914b73700e871982c3">repeat</a> (T &amp;&amp;value, size_t count) -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_n_iterator_repeat.html">detail::NIteratorRepeat</a>&lt; typename std::decay&lt; T &gt;::type &gt; &gt;</td></tr>
<tr class="separator:a4a6c3cb07d1db3914b73700e871982c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad460325f27b703c618b5757fefa4a0"><td class="memTemplParams" colspan="2">template&lt;class Iterable &gt; </td></tr>
<tr class="memitem:abad460325f27b703c618b5757fefa4a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#abad460325f27b703c618b5757fefa4a0">flatten</a> (const Iterable &amp;r) -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_flatten_pair.html">detail::FlattenPair</a>&lt; typename Iterable::const_iterator &gt; &gt;</td></tr>
<tr class="separator:abad460325f27b703c618b5757fefa4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad863fcfc143b646f5a2f2362a1327575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a> ()</td></tr>
<tr class="memdesc:ad863fcfc143b646f5a2f2362a1327575"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, reset timer for calling thread.  <a href="#ad863fcfc143b646f5a2f2362a1327575">More...</a><br /></td></tr>
<tr class="separator:ad863fcfc143b646f5a2f2362a1327575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576ae74a514ded550299e48e4c32cc64"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a> () -&gt; std::uint64_t</td></tr>
<tr class="memdesc:a576ae74a514ded550299e48e4c32cc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, returns elapsed milliseconds since last call to <a class="el" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575" title="For tests only, reset timer for calling thread. ">tick()</a>  <a href="#a576ae74a514ded550299e48e4c32cc64">More...</a><br /></td></tr>
<tr class="separator:a576ae74a514ded550299e48e4c32cc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b268bc53b846426ab17a84bb756fab"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ad8b268bc53b846426ab17a84bb756fab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ad8b268bc53b846426ab17a84bb756fab">random_shuffle</a> (Iter begin, Iter end, uint_fast32_t seed=0)</td></tr>
<tr class="memdesc:ad8b268bc53b846426ab17a84bb756fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to C++11 (and deprecated) std::random_shuffle.  <a href="#ad8b268bc53b846426ab17a84bb756fab">More...</a><br /></td></tr>
<tr class="separator:ad8b268bc53b846426ab17a84bb756fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c99841240cccf7ffccabb7ba9d0649c"><td class="memTemplParams" colspan="2">template&lt;class Iter1 , class Iter2 , class BinaryPredicate &gt; </td></tr>
<tr class="memitem:a2c99841240cccf7ffccabb7ba9d0649c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2c99841240cccf7ffccabb7ba9d0649c">equal</a> (Iter1 first, Iter1 last, Iter2 first2, Iter2 last2, BinaryPredicate pred)</td></tr>
<tr class="memdesc:a2c99841240cccf7ffccabb7ba9d0649c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to C++14 std::equal.  <a href="#a2c99841240cccf7ffccabb7ba9d0649c">More...</a><br /></td></tr>
<tr class="separator:a2c99841240cccf7ffccabb7ba9d0649c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af145a6e5a5152d63e95d0cdca95423ba"><td class="memTemplParams" colspan="2">template&lt;class Iter1 , class Iter2 &gt; </td></tr>
<tr class="memitem:af145a6e5a5152d63e95d0cdca95423ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af145a6e5a5152d63e95d0cdca95423ba">equal</a> (Iter1 first, Iter1 last, Iter2 first2, Iter2 last2)</td></tr>
<tr class="separator:af145a6e5a5152d63e95d0cdca95423ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9a3cabcec0a1c739817cf3b66f2196"><td class="memTemplParams" colspan="2">template&lt;class Iter1 , class Iter2 &gt; </td></tr>
<tr class="memitem:ade9a3cabcec0a1c739817cf3b66f2196"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ade9a3cabcec0a1c739817cf3b66f2196">equal</a> (Iter1 first, Iter1 last, Iter2 first2)</td></tr>
<tr class="separator:ade9a3cabcec0a1c739817cf3b66f2196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabfa3eaf9a03808f516c1c71d521dee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#acabfa3eaf9a03808f516c1c71d521dee">reset_memory_usage</a> ()</td></tr>
<tr class="separator:acabfa3eaf9a03808f516c1c71d521dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30368dcf14dfdddd428c9ac9ec675b6f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a30368dcf14dfdddd428c9ac9ec675b6f">get_memory_usage</a> () -&gt; size_t</td></tr>
<tr class="separator:a30368dcf14dfdddd428c9ac9ec675b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b887df093a1fae4487fccd6c1949116"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4b887df093a1fae4487fccd6c1949116"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4b887df093a1fae4487fccd6c1949116">print_null</a> (const T &amp;v)</td></tr>
<tr class="separator:a4b887df093a1fae4487fccd6c1949116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad0247ee4ca62ff368c30bea8e49dfb"><td class="memTemplParams" colspan="2">template&lt;class String &gt; </td></tr>
<tr class="memitem:a8ad0247ee4ca62ff368c30bea8e49dfb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8ad0247ee4ca62ff368c30bea8e49dfb">generate_random_string</a> (int max_size, bool <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682abfc5cfa7d975226254b5443690d9f918">fixed</a>=false) -&gt; String</td></tr>
<tr class="memdesc:a8ad0247ee4ca62ff368c30bea8e49dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For tests only, generate a random string of given max size.  <a href="#a8ad0247ee4ca62ff368c30bea8e49dfb">More...</a><br /></td></tr>
<tr class="separator:a8ad0247ee4ca62ff368c30bea8e49dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c865c483c552fe56c66cbcca0e4c8b6"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </td></tr>
<tr class="memitem:a1c865c483c552fe56c66cbcca0e4c8b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1c865c483c552fe56c66cbcca0e4c8b6">operator==</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a1c865c483c552fe56c66cbcca0e4c8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b1b3b672400626cabfbaaba0a8e507"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a78b1b3b672400626cabfbaaba0a8e507"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a78b1b3b672400626cabfbaaba0a8e507">operator==</a> (const Char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a78b1b3b672400626cabfbaaba0a8e507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be59e11b72f7a46f60a25341e142c87"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a0be59e11b72f7a46f60a25341e142c87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0be59e11b72f7a46f60a25341e142c87">operator==</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;lhs, const Char *rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a0be59e11b72f7a46f60a25341e142c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68868ab059ceff25f0420a62dbe398d8"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:a68868ab059ceff25f0420a62dbe398d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a68868ab059ceff25f0420a62dbe398d8">operator==</a> (const std::basic_string&lt; Char, Traits, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a68868ab059ceff25f0420a62dbe398d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb690b643ff25719baadcb15d9c84cd5"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:adb690b643ff25719baadcb15d9c84cd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adb690b643ff25719baadcb15d9c84cd5">operator==</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;lhs, const std::basic_string&lt; Char, Traits, Al &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:adb690b643ff25719baadcb15d9c84cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695c2c18ca374da34a369b7442739926"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </td></tr>
<tr class="memitem:a695c2c18ca374da34a369b7442739926"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a695c2c18ca374da34a369b7442739926">operator!=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a695c2c18ca374da34a369b7442739926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaae058a01e3f15f70f326b4f408647"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a0eaae058a01e3f15f70f326b4f408647"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0eaae058a01e3f15f70f326b4f408647">operator!=</a> (const Char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a0eaae058a01e3f15f70f326b4f408647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6880991b301072bed5280b0de2a43cd2"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a6880991b301072bed5280b0de2a43cd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6880991b301072bed5280b0de2a43cd2">operator!=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;lhs, const Char *rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a6880991b301072bed5280b0de2a43cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa03268dd5a041a606080a6d72cc21a"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:a1aa03268dd5a041a606080a6d72cc21a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a1aa03268dd5a041a606080a6d72cc21a">operator!=</a> (const std::basic_string&lt; Char, Traits, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a1aa03268dd5a041a606080a6d72cc21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a4e8aff8fcd9bf5c4fe0a07a08ad78"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:ae7a4e8aff8fcd9bf5c4fe0a07a08ad78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae7a4e8aff8fcd9bf5c4fe0a07a08ad78">operator!=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;lhs, const std::basic_string&lt; Char, Traits, Al &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:ae7a4e8aff8fcd9bf5c4fe0a07a08ad78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46652d2852e9aac603339e0b26d62d2"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </td></tr>
<tr class="memitem:aa46652d2852e9aac603339e0b26d62d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa46652d2852e9aac603339e0b26d62d2">operator&lt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:aa46652d2852e9aac603339e0b26d62d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2fb7bf890a492b43f052bd519affd8"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:aba2fb7bf890a492b43f052bd519affd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aba2fb7bf890a492b43f052bd519affd8">operator&lt;</a> (const Char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:aba2fb7bf890a492b43f052bd519affd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29f73ad0bfc1e18397989ced44eb5c5"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:ae29f73ad0bfc1e18397989ced44eb5c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae29f73ad0bfc1e18397989ced44eb5c5">operator&lt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;lhs, const Char *rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:ae29f73ad0bfc1e18397989ced44eb5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413f7e38de30c96a31b79b5ac0bef6c6"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:a413f7e38de30c96a31b79b5ac0bef6c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a413f7e38de30c96a31b79b5ac0bef6c6">operator&lt;</a> (const std::basic_string&lt; Char, Traits, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a413f7e38de30c96a31b79b5ac0bef6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dd527886084b02b47a73633a84c1f8"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:a61dd527886084b02b47a73633a84c1f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a61dd527886084b02b47a73633a84c1f8">operator&lt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;lhs, const std::basic_string&lt; Char, Traits, Al &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a61dd527886084b02b47a73633a84c1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e742b5a5a114e04415b13bc9d4eb6a"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </td></tr>
<tr class="memitem:a47e742b5a5a114e04415b13bc9d4eb6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a47e742b5a5a114e04415b13bc9d4eb6a">operator&lt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a47e742b5a5a114e04415b13bc9d4eb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c3512c9a7056ec428f9c5b816cadf"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a7a5c3512c9a7056ec428f9c5b816cadf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7a5c3512c9a7056ec428f9c5b816cadf">operator&lt;=</a> (const Char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a7a5c3512c9a7056ec428f9c5b816cadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e9a9ae93c0e92495830af1b8147a74"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a11e9a9ae93c0e92495830af1b8147a74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a11e9a9ae93c0e92495830af1b8147a74">operator&lt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;lhs, const Char *rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a11e9a9ae93c0e92495830af1b8147a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1caec84127a30e15fbcbeec5e3907a"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:a5c1caec84127a30e15fbcbeec5e3907a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5c1caec84127a30e15fbcbeec5e3907a">operator&lt;=</a> (const std::basic_string&lt; Char, Traits, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a5c1caec84127a30e15fbcbeec5e3907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7732b5a0475169a15f4386b74ce6bc41"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:a7732b5a0475169a15f4386b74ce6bc41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7732b5a0475169a15f4386b74ce6bc41">operator&lt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;lhs, const std::basic_string&lt; Char, Traits, Al &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a7732b5a0475169a15f4386b74ce6bc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aee0f0e155eb9f313a4e7bbec575953"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </td></tr>
<tr class="memitem:a5aee0f0e155eb9f313a4e7bbec575953"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5aee0f0e155eb9f313a4e7bbec575953">operator&gt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a5aee0f0e155eb9f313a4e7bbec575953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd06fe0ed32777597cb1b94f6be7c5f"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a6bd06fe0ed32777597cb1b94f6be7c5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6bd06fe0ed32777597cb1b94f6be7c5f">operator&gt;</a> (const Char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a6bd06fe0ed32777597cb1b94f6be7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e339fbd9e7c56cd07e91717c65b1678"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a4e339fbd9e7c56cd07e91717c65b1678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4e339fbd9e7c56cd07e91717c65b1678">operator&gt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;lhs, const Char *rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a4e339fbd9e7c56cd07e91717c65b1678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab614ebb908519b061eb878082c381eb6"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:ab614ebb908519b061eb878082c381eb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab614ebb908519b061eb878082c381eb6">operator&gt;</a> (const std::basic_string&lt; Char, Traits, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:ab614ebb908519b061eb878082c381eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c08fc3f8c6e1c4a66d8980e719ee2a"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:a87c08fc3f8c6e1c4a66d8980e719ee2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a87c08fc3f8c6e1c4a66d8980e719ee2a">operator&gt;</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;lhs, const std::basic_string&lt; Char, Traits, Al &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a87c08fc3f8c6e1c4a66d8980e719ee2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d37adacf6c3e89a8a92fe212afdac5d"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </td></tr>
<tr class="memitem:a7d37adacf6c3e89a8a92fe212afdac5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7d37adacf6c3e89a8a92fe212afdac5d">operator&gt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a7d37adacf6c3e89a8a92fe212afdac5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4303c700d412ca7164d682a810349995"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a4303c700d412ca7164d682a810349995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4303c700d412ca7164d682a810349995">operator&gt;=</a> (const Char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a4303c700d412ca7164d682a810349995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ee63226848240d8926aaf45caf2bd0"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a02ee63226848240d8926aaf45caf2bd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a02ee63226848240d8926aaf45caf2bd0">operator&gt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;lhs, const Char *rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a02ee63226848240d8926aaf45caf2bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed49e9ad09fafea07ddabecdeba9f77e"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:aed49e9ad09fafea07ddabecdeba9f77e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aed49e9ad09fafea07ddabecdeba9f77e">operator&gt;=</a> (const std::basic_string&lt; Char, Traits, Al &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:aed49e9ad09fafea07ddabecdeba9f77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8666fcc971ce7730bf6d673fd9b42b71"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </td></tr>
<tr class="memitem:a8666fcc971ce7730bf6d673fd9b42b71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8666fcc971ce7730bf6d673fd9b42b71">operator&gt;=</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;lhs, const std::basic_string&lt; Char, Traits, Al &gt; &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a8666fcc971ce7730bf6d673fd9b42b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bedc7bafaa1c5ef1e97d86389a1787e"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t Size, class Al2 , size_t Size2&gt; </td></tr>
<tr class="memitem:a8bedc7bafaa1c5ef1e97d86389a1787e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8bedc7bafaa1c5ef1e97d86389a1787e">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, Size2 &gt; &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, Size2 &gt; &gt;::type</td></tr>
<tr class="separator:a8bedc7bafaa1c5ef1e97d86389a1787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa472516527bb96b93aa7a2cfb8d04bf"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , size_t Size, class Al , class Al2 &gt; </td></tr>
<tr class="memitem:afa472516527bb96b93aa7a2cfb8d04bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afa472516527bb96b93aa7a2cfb8d04bf">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;lhs, const std::basic_string&lt; Char, Traits, Al2 &gt; &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &gt;::type</td></tr>
<tr class="separator:afa472516527bb96b93aa7a2cfb8d04bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ca569981586168d5487cb1cf7c4cce"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ab8ca569981586168d5487cb1cf7c4cce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab8ca569981586168d5487cb1cf7c4cce">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;lhs, const Char *rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &gt;::type</td></tr>
<tr class="separator:ab8ca569981586168d5487cb1cf7c4cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47108e7f89821a328dc8b0743be4b16"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , size_t Size, class Al &gt; </td></tr>
<tr class="memitem:ac47108e7f89821a328dc8b0743be4b16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac47108e7f89821a328dc8b0743be4b16">operator+</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;lhs, char rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &gt;::type</td></tr>
<tr class="separator:ac47108e7f89821a328dc8b0743be4b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7685a1feb8ff18e4b9313d03a3e13d7"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , size_t Size, class Al , class Al2 &gt; </td></tr>
<tr class="memitem:ae7685a1feb8ff18e4b9313d03a3e13d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ae7685a1feb8ff18e4b9313d03a3e13d7">operator+</a> (const std::basic_string&lt; Char, Traits, Al2 &gt; &amp;lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &gt;::type</td></tr>
<tr class="separator:ae7685a1feb8ff18e4b9313d03a3e13d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc25ee31d1f47913986e3c67b7ce808"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a0bc25ee31d1f47913986e3c67b7ce808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0bc25ee31d1f47913986e3c67b7ce808">operator+</a> (const Char *lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &gt;::type</td></tr>
<tr class="separator:a0bc25ee31d1f47913986e3c67b7ce808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7f01f72c0ee9fc492828807b5eb66e"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , size_t Size, class Al &gt; </td></tr>
<tr class="memitem:a5e7f01f72c0ee9fc492828807b5eb66e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5e7f01f72c0ee9fc492828807b5eb66e">operator+</a> (Char lhs, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;rhs) -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt; Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &gt;::type</td></tr>
<tr class="separator:a5e7f01f72c0ee9fc492828807b5eb66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd2941446a52e1c8ea5894d0a6ddbdc"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al &gt; </td></tr>
<tr class="memitem:addd2941446a52e1c8ea5894d0a6ddbdc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#addd2941446a52e1c8ea5894d0a6ddbdc">string_data</a> (const std::basic_string&lt; Char, Traits, Al &gt; &amp;str) -&gt; const Char *</td></tr>
<tr class="memdesc:addd2941446a52e1c8ea5894d0a6ddbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string data (const char*) for given string object.  <a href="#addd2941446a52e1c8ea5894d0a6ddbdc">More...</a><br /></td></tr>
<tr class="separator:addd2941446a52e1c8ea5894d0a6ddbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaa959e4bd65e5c34ce50d52eaed781"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a7aaa959e4bd65e5c34ce50d52eaed781"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7aaa959e4bd65e5c34ce50d52eaed781">string_data</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;str) -&gt; const Char *</td></tr>
<tr class="separator:a7aaa959e4bd65e5c34ce50d52eaed781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7319f4efbdf6e6e22bf008804fa59c"><td class="memTemplParams" colspan="2">template&lt;class Char &gt; </td></tr>
<tr class="memitem:a2f7319f4efbdf6e6e22bf008804fa59c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2f7319f4efbdf6e6e22bf008804fa59c">string_data</a> (const Char *str) -&gt; const Char *</td></tr>
<tr class="separator:a2f7319f4efbdf6e6e22bf008804fa59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7003288989da375f3058bee852965ad0"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al &gt; </td></tr>
<tr class="memitem:a7003288989da375f3058bee852965ad0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7003288989da375f3058bee852965ad0">string_size</a> (const std::basic_string&lt; Char, Traits, Al &gt; &amp;str) -&gt; size_t</td></tr>
<tr class="memdesc:a7003288989da375f3058bee852965ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string size for given string object.  <a href="#a7003288989da375f3058bee852965ad0">More...</a><br /></td></tr>
<tr class="separator:a7003288989da375f3058bee852965ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4cd270107200e9e64fbe2e74a0066f"><td class="memTemplParams" colspan="2">template&lt;class Char , class Traits , class Al , size_t S&gt; </td></tr>
<tr class="memitem:a5e4cd270107200e9e64fbe2e74a0066f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a5e4cd270107200e9e64fbe2e74a0066f">string_size</a> (const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;str) -&gt; size_t</td></tr>
<tr class="separator:a5e4cd270107200e9e64fbe2e74a0066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48302925a280dbce105cd46f7677f8ab"><td class="memTemplParams" colspan="2">template&lt;class Char &gt; </td></tr>
<tr class="memitem:a48302925a280dbce105cd46f7677f8ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a48302925a280dbce105cd46f7677f8ab">string_size</a> (const Char *str) -&gt; size_t</td></tr>
<tr class="separator:a48302925a280dbce105cd46f7677f8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd17142bbec3b3cdc22b32952feee534"><td class="memTemplParams" colspan="2">template&lt;class Elem , class Traits , size_t Size, class Alloc &gt; </td></tr>
<tr class="memitem:afd17142bbec3b3cdc22b32952feee534"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#afd17142bbec3b3cdc22b32952feee534">operator&gt;&gt;</a> (std::basic_istream&lt; Elem, Traits &gt; &amp;iss, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Elem, Traits, Alloc, Size &gt; &amp;str) -&gt; typename std::enable_if&lt;!std::is_same&lt; Alloc, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a>&lt; Elem &gt; &gt;::value, std::basic_istream&lt; Elem, Traits &gt; &gt;::type &amp;</td></tr>
<tr class="separator:afd17142bbec3b3cdc22b32952feee534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8658c17ae7ad6e45721ab470d0dd2c0"><td class="memTemplParams" colspan="2">template&lt;class Elem , class Traits , size_t Size, class Alloc &gt; </td></tr>
<tr class="memitem:ac8658c17ae7ad6e45721ab470d0dd2c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac8658c17ae7ad6e45721ab470d0dd2c0">operator&lt;&lt;</a> (std::basic_ostream&lt; Elem, Traits &gt; &amp;oss, const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Elem, Traits, Alloc, Size &gt; &amp;str) -&gt; std::basic_ostream&lt; Elem, Traits &gt; &amp;</td></tr>
<tr class="separator:ac8658c17ae7ad6e45721ab470d0dd2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c279fa143d4e6216df953924ce47406"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7c279fa143d4e6216df953924ce47406"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a7c279fa143d4e6216df953924ce47406">negate_if_signed</a> (T v) -&gt; typename <a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a7c279fa143d4e6216df953924ce47406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns -v if v is signed, v otherwise.  <a href="#a7c279fa143d4e6216df953924ce47406">More...</a><br /></td></tr>
<tr class="separator:a7c279fa143d4e6216df953924ce47406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f8f4791e95dce2f0a4298ff8e82797"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab6f8f4791e95dce2f0a4298ff8e82797"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ab6f8f4791e95dce2f0a4298ff8e82797">abs</a> (T v) -&gt; typename <a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab6f8f4791e95dce2f0a4298ff8e82797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns absolute value of v.  <a href="#ab6f8f4791e95dce2f0a4298ff8e82797">More...</a><br /></td></tr>
<tr class="separator:ab6f8f4791e95dce2f0a4298ff8e82797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a83c380ba3efb861a6d64bd87360c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a57a83c380ba3efb861a6d64bd87360c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a57a83c380ba3efb861a6d64bd87360c1">operator+</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it, typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type diff) noexcept -&gt; <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;</td></tr>
<tr class="separator:a57a83c380ba3efb861a6d64bd87360c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa242d97b0138a72bd07cabe76a62ef17"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa242d97b0138a72bd07cabe76a62ef17"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#aa242d97b0138a72bd07cabe76a62ef17">operator-</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it, typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type diff) noexcept -&gt; <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;</td></tr>
<tr class="separator:aa242d97b0138a72bd07cabe76a62ef17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3dab51febe50dfd60f7bd4fe46154f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8a3dab51febe50dfd60f7bd4fe46154f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a8a3dab51febe50dfd60f7bd4fe46154f">operator-</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type</td></tr>
<tr class="separator:a8a3dab51febe50dfd60f7bd4fe46154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4cb9a01f8408e24f5cf3b5874876f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2c4cb9a01f8408e24f5cf3b5874876f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a2c4cb9a01f8408e24f5cf3b5874876f9">operator&lt;</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; bool</td></tr>
<tr class="separator:a2c4cb9a01f8408e24f5cf3b5874876f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e24e00cf888c85c3bc16fa9a8f8dfbf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0e24e00cf888c85c3bc16fa9a8f8dfbf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0e24e00cf888c85c3bc16fa9a8f8dfbf">operator&gt;</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; bool</td></tr>
<tr class="separator:a0e24e00cf888c85c3bc16fa9a8f8dfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6920a1594333ae1cb5a606a699e2fa7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac6920a1594333ae1cb5a606a699e2fa7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#ac6920a1594333ae1cb5a606a699e2fa7">operator&lt;=</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; bool</td></tr>
<tr class="separator:ac6920a1594333ae1cb5a606a699e2fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bda8a7271df48555e68fe9d51ebf37"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a93bda8a7271df48555e68fe9d51ebf37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a93bda8a7271df48555e68fe9d51ebf37">operator&gt;=</a> (const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it1, const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;it2) noexcept -&gt; bool</td></tr>
<tr class="separator:a93bda8a7271df48555e68fe9d51ebf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4059063640bce7cc2340cfbaae099c1a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4059063640bce7cc2340cfbaae099c1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a4059063640bce7cc2340cfbaae099c1a">destroy_ptr</a> (T *p)</td></tr>
<tr class="memdesc:a4059063640bce7cc2340cfbaae099c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply call p-&gt;~T(), used as a replacement to std::allocator::destroy() which was removed in C++20.  <a href="#a4059063640bce7cc2340cfbaae099c1a">More...</a><br /></td></tr>
<tr class="separator:a4059063640bce7cc2340cfbaae099c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3434a259385c92c1f7654356a66b4e"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a3c3434a259385c92c1f7654356a66b4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3c3434a259385c92c1f7654356a66b4e">construct_ptr</a> (T *p, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3c3434a259385c92c1f7654356a66b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply call new (p) T(...), used as a replacement to std::allocator::construct() which was removed in C++20.  <a href="#a3c3434a259385c92c1f7654356a66b4e">More...</a><br /></td></tr>
<tr class="separator:a3c3434a259385c92c1f7654356a66b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb440e376909f74fdadf346e1b10a19a"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:adb440e376909f74fdadf346e1b10a19a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#adb440e376909f74fdadf346e1b10a19a">distance</a> (const Iter &amp;first, const Iter &amp;last) noexcept -&gt; size_t</td></tr>
<tr class="memdesc:adb440e376909f74fdadf346e1b10a19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between first and last iterators for random access iterator category, 0 otherwise.  <a href="#adb440e376909f74fdadf346e1b10a19a">More...</a><br /></td></tr>
<tr class="separator:adb440e376909f74fdadf346e1b10a19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377e0223950bcd7f974c1ffcd47beaf4"><td class="memTemplParams" colspan="2">template&lt;bool IsL1, class L1 , class L2 , class... Args&gt; </td></tr>
<tr class="memitem:a377e0223950bcd7f974c1ffcd47beaf4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a377e0223950bcd7f974c1ffcd47beaf4">constexpr_if</a> (const L1 &amp;l1, const L2 &amp;l2, Args &amp;&amp;... args) -&gt; decltype(std::declval&lt; <a class="el" href="structseq_1_1detail_1_1_call_lambda.html">detail::CallLambda</a>&lt; L1, L2, IsL1 &gt; &amp;&gt;()(std::declval&lt; L1 &amp;&gt;(), std::declval&lt; L2 &amp;&gt;(), std::declval&lt; Args &gt;()...))</td></tr>
<tr class="memdesc:a377e0223950bcd7f974c1ffcd47beaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulation of C++17 if constexpr in C++14.  <a href="#a377e0223950bcd7f974c1ffcd47beaf4">More...</a><br /></td></tr>
<tr class="separator:a377e0223950bcd7f974c1ffcd47beaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bee86af84ec8c55228d0b9cd79c733"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a60bee86af84ec8c55228d0b9cd79c733"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a60bee86af84ec8c55228d0b9cd79c733">copy_allocator</a> (const Allocator &amp;alloc) -&gt; Allocator</td></tr>
<tr class="memdesc:a60bee86af84ec8c55228d0b9cd79c733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy allocator for container copy constructor.  <a href="#a60bee86af84ec8c55228d0b9cd79c733">More...</a><br /></td></tr>
<tr class="separator:a60bee86af84ec8c55228d0b9cd79c733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e83b922f85075d41cf05cbf365dc07"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a76e83b922f85075d41cf05cbf365dc07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a76e83b922f85075d41cf05cbf365dc07">swap_allocator</a> (Allocator &amp;left, Allocator &amp;right) noexcept</td></tr>
<tr class="memdesc:a76e83b922f85075d41cf05cbf365dc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap allocators for container.swap member.  <a href="#a76e83b922f85075d41cf05cbf365dc07">More...</a><br /></td></tr>
<tr class="separator:a76e83b922f85075d41cf05cbf365dc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed508491a96866338895cf1b5900292"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a3ed508491a96866338895cf1b5900292"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a3ed508491a96866338895cf1b5900292">assign_allocator</a> (Allocator &amp;left, const Allocator &amp;right) noexcept</td></tr>
<tr class="memdesc:a3ed508491a96866338895cf1b5900292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign allocator for container copy operator.  <a href="#a3ed508491a96866338895cf1b5900292">More...</a><br /></td></tr>
<tr class="separator:a3ed508491a96866338895cf1b5900292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81932472ffd88a08d7b6f0aaf2c123e9"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a81932472ffd88a08d7b6f0aaf2c123e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a81932472ffd88a08d7b6f0aaf2c123e9">move_allocator</a> (Allocator &amp;left, Allocator &amp;right) noexcept</td></tr>
<tr class="memdesc:a81932472ffd88a08d7b6f0aaf2c123e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move allocator for container move assignment.  <a href="#a81932472ffd88a08d7b6f0aaf2c123e9">More...</a><br /></td></tr>
<tr class="separator:a81932472ffd88a08d7b6f0aaf2c123e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>MIT License</p>
<p>Copyright (c) 2022 Victor Moncada <a href="#" onclick="location.href='mai'+'lto:'+'vtr'+'.m'+'onc'+'ad'+'a@g'+'ma'+'il.'+'co'+'m'; return false;">vtr.m<span style="display: none;">.nosp@m.</span>onca<span style="display: none;">.nosp@m.</span>da@gm<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>com</a></p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a24ef193cef19271b9b18ce6c74fc5b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ef193cef19271b9b18ce6c74fc5b54">&#9670;&nbsp;</a></span>any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a24ef193cef19271b9b18ce6c74fc5b54">seq::any</a> = typedef <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a853b19a4c230b9bda51396e407f64bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853b19a4c230b9bda51396e407f64bda">&#9670;&nbsp;</a></span>basic_tstring_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a853b19a4c230b9bda51396e407f64bda">seq::basic_tstring_view</a> = typedef <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, std::char_traits&lt;Char&gt;, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a>&lt;Char&gt;, 0&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d2b0aba572fc96bdcec68b500577b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2b0aba572fc96bdcec68b500577b5b">&#9670;&nbsp;</a></span>max_align_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a6d2b0aba572fc96bdcec68b500577b5b">seq::max_align_t</a> = typedef std::max_align_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ec98840dd82cf3a3207402caa66c73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec98840dd82cf3a3207402caa66c73f">&#9670;&nbsp;</a></span>nh_any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">seq::nh_any</a> = typedef <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;<a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a802ef6dd5cb892731a06e6699a27edf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802ef6dd5cb892731a06e6699a27edf8">&#9670;&nbsp;</a></span>nullbuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a802ef6dd5cb892731a06e6699a27edf8">seq::nullbuf</a> = typedef <a class="el" href="structseq_1_1basic__nullbuf.html">basic_nullbuf</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For tests only, alias for null buffer, to be used with c++ iostreams. </p>

</div>
</div>
<a id="ad40a76752e1ad984a96eb9ad080fe8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40a76752e1ad984a96eb9ad080fe8b5">&#9670;&nbsp;</a></span>r_any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#ad40a76752e1ad984a96eb9ad080fe8b5">seq::r_any</a> = typedef <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; <a class="el" href="structseq_1_1any__default__interface.html">any_default_interface</a>, sizeof(double), alignof(double), true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74ef7b667be012ddd3ce16cf0b28bbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ef7b667be012ddd3ce16cf0b28bbd6">&#9670;&nbsp;</a></span>r_nh_any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a74ef7b667be012ddd3ce16cf0b28bbd6">seq::r_nh_any</a> = typedef <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt;<a class="el" href="structseq_1_1any__no__hash__interface.html">any_no_hash_interface</a>, sizeof(double), alignof(double), true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebe7cbd216aa93afb6c62a1bc4d39ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe7cbd216aa93afb6c62a1bc4d39ba5">&#9670;&nbsp;</a></span>tstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#aebe7cbd216aa93afb6c62a1bc4d39ba5">seq::tstring</a> = typedef <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base string typedef, similar to std::string. Equivalent to <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string. ">tiny_string</a>&lt;0, std::allocator&lt;char&gt;&gt;. </p>

</div>
</div>
<a id="ad49cae5f5b0deacb82496c90c7953388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49cae5f5b0deacb82496c90c7953388">&#9670;&nbsp;</a></span>tstring_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">seq::tstring_view</a> = typedef <a class="el" href="namespaceseq.html#a853b19a4c230b9bda51396e407f64bda">basic_tstring_view</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base string view typedef, similar to std::string_view. </p>

</div>
</div>
<a id="a827314866bb33dc9d380b0c894f5be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827314866bb33dc9d380b0c894f5be2b">&#9670;&nbsp;</a></span>wtstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a827314866bb33dc9d380b0c894f5be2b">seq::wtstring</a> = typedef <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;wchar_t, std::char_traits&lt;wchar_t&gt;, std::allocator&lt;wchar_t&gt;, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88b1f17e00c3af6be1fa41a4546c801a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b1f17e00c3af6be1fa41a4546c801a">&#9670;&nbsp;</a></span>wtstring_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceseq.html#a88b1f17e00c3af6be1fa41a4546c801a">seq::wtstring_view</a> = typedef <a class="el" href="namespaceseq.html#a853b19a4c230b9bda51396e407f64bda">basic_tstring_view</a>&lt;wchar_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adac07c5c5e3d6da3ebb03f7ddd1e7cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac07c5c5e3d6da3ebb03f7ddd1e7cde">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants used by #object_pool, #parallel_object_pool and #object_allocator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adac07c5c5e3d6da3ebb03f7ddd1e7cdea668d551cd99226655e9e973b6d5be517"></a>DefaultAlignment&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a19a45e1f866d73140819b9ea2280c682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a45e1f866d73140819b9ea2280c682">&#9670;&nbsp;</a></span>chars_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">seq::chars_format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A BitmaskType used to specify floating-point formatting for <a class="el" href="namespaceseq.html#aaade1f4ec092684337563886384d3aaf" title="Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. ">seq::to_chars</a>. This is similar to std::chars_format, but without the hex value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a19a45e1f866d73140819b9ea2280c682af715ab801ec116cdbb4a7f7541e46166"></a>scientific&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19a45e1f866d73140819b9ea2280c682abfc5cfa7d975226254b5443690d9f918"></a>fixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d"></a>general&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5e3fb67407700bab4c66e60c7f7365c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3fb67407700bab4c66e60c7f7365c7">&#9670;&nbsp;</a></span>ContextRatio</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a5e3fb67407700bab4c66e60c7f7365c7">seq::ContextRatio</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum type used by <a class="el" href="classseq_1_1context__ratio.html" title="Define the maximum number of decompression contexts a cvector can use. The number of contexts is eith...">context_ratio</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e3fb67407700bab4c66e60c7f7365c7a82b7b69a7aecf7f511dde4bd663e72f3"></a>Fixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5e3fb67407700bab4c66e60c7f7365c7aead4f34f60237cc1a99223296ae6b1ef"></a>Ratio&#160;</td><td class="fielddoc"><p>Fixed number of decompression context. </p>
<p>Ratio of total number of chunks </p>
</td></tr>
</table>

</div>
</div>
<a id="a04f4e48fbeeb8d86e75555957c4e270c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f4e48fbeeb8d86e75555957c4e270c">&#9670;&nbsp;</a></span>DEVectorFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a04f4e48fbeeb8d86e75555957c4e270c">seq::DEVectorFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag indicating whether the devector is optimized for back insertion, front insertion or both. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04f4e48fbeeb8d86e75555957c4e270ca3d03c9bf4b559787d1de5ac0f9a7882d"></a>OptimizeForPushBack&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04f4e48fbeeb8d86e75555957c4e270caeb903e97e2b97b410b477676babb2653"></a>OptimizeForPushFront&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04f4e48fbeeb8d86e75555957c4e270ca998ccc48808777ad90d4228cd8fb9e84"></a>OptimizeForBothEnds&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a209c3fd2e66f43ecc90862f2ee5e3dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209c3fd2e66f43ecc90862f2ee5e3dd5">&#9670;&nbsp;</a></span>LayoutManagement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#a209c3fd2e66f43ecc90862f2ee5e3dd5">seq::LayoutManagement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory Layout Management for containers like <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant time rem...">seq::sequence</a> or <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a209c3fd2e66f43ecc90862f2ee5e3dd5a83983acd78764ffa023da74a7360670e"></a>OptimizeForSpeed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a209c3fd2e66f43ecc90862f2ee5e3dd5a51407649077d79765e15397347a57432"></a>OptimizeForMemory&#160;</td><td class="fielddoc"><p>Use more memory to favor speed. </p>
<p>Use as few memory as possible </p>
</td></tr>
</table>

</div>
</div>
<a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">&#9670;&nbsp;</a></span>StreamState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2">seq::StreamState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream object status for classes inheriting <a class="el" href="classseq_1_1basic__input__stream.html" title="Base class for input text streams. ">basic_input_stream</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2adc676c349921535a50db525652b39774"></a>Ok&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d"></a>EndOfFile&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587"></a>BadInputFormat&#160;</td><td class="fielddoc"><p>End of file reached. </p>
<p>Unable to read numerical value </p>
</td></tr>
</table>

</div>
</div>
<a id="affae767f96f2af9924f7c6f3bdd4c72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affae767f96f2af9924f7c6f3bdd4c72a">&#9670;&nbsp;</a></span>TagPointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceseq.html#affae767f96f2af9924f7c6f3bdd4c72a">seq::TagPointerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="affae767f96f2af9924f7c6f3bdd4c72aafb05ed7193c8b361ae6679027a774673"></a>StackPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="affae767f96f2af9924f7c6f3bdd4c72aa818e87f4cf07c4dc2006b54dbd4939e0"></a>HeapPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="affae767f96f2af9924f7c6f3bdd4c72aad297c23409b392745ce5f3024304a8e8"></a>CustomAlignment&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aef0653a43b827bc896829c70bfb47ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0653a43b827bc896829c70bfb47ab9">&#9670;&nbsp;</a></span>_a()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::_a </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">nh_any</a>, true&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e6841d57616cc1144f3347fe0113f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6841d57616cc1144f3347fe0113f82">&#9670;&nbsp;</a></span>_any()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::_any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="namespaceseq.html#a2ec98840dd82cf3a3207402caa66c73f">nh_any</a>, true&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create placeholder for any type for the formatting module. </p>

</div>
</div>
<a id="a191cf765becd8f118827fc7329aecb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191cf765becd8f118827fc7329aecb76">&#9670;&nbsp;</a></span>_fmt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::_fmt </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), false, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt;Args...&gt;::type, true, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbfe91dbf0ec2b4565fedd6d93097645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfe91dbf0ec2b4565fedd6d93097645">&#9670;&nbsp;</a></span>_fmt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::_fmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), false, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt;Args...&gt;::type, true, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dca10eb469071a8f8264b8f567b4da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dca10eb469071a8f8264b8f567b4da5">&#9670;&nbsp;</a></span>_join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args, class K  = typename std::enable_if&lt;!detail::IsFirstIterable&lt;Args...&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), true, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt;Args...&gt;::type, true, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbf9bdd5513aeeb0ddb7ff2b3a1aa3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf9bdd5513aeeb0ddb7ff2b3a1aa3c0">&#9670;&nbsp;</a></span>_join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterRange &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterRange &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt;<a class="el" href="structseq_1_1detail_1_1_iterable.html">detail::Iterable</a>&lt;IterRange&gt;,true &gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a900c6edb6afef4c5681f9bf11a20cb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900c6edb6afef4c5681f9bf11a20cb4f">&#9670;&nbsp;</a></span>_join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterRange , class T , bool S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterRange &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>wf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt;<a class="el" href="structseq_1_1detail_1_1_iterable.html">detail::Iterable</a>&lt;IterRange&gt;,true &gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6f8f4791e95dce2f0a4298ff8e82797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f8f4791e95dce2f0a4298ff8e82797">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::abs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt;T&gt;::type </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns absolute value of v. </p>

</div>
</div>
<a id="a04be1ca38e79158feb4755807ef3d08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04be1ca38e79158feb4755807ef3d08c">&#9670;&nbsp;</a></span>aligned_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::aligned_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees memory allocated with aligned_malloc. </p>

</div>
</div>
<a id="ac67ee9a9d6039de2b50c631129a0a1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67ee9a9d6039de2b50c631129a0a1bc">&#9670;&nbsp;</a></span>aligned_malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::aligned_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates <em>size</em> bytes. The returned pointer is guaranteed to have <em>align</em> bytes alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size in bytes to allocate </td></tr>
    <tr><td class="paramname">align</td><td>alignment of result pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>algned pointer or NULL on error </dd></dl>

</div>
</div>
<a id="a656aad880c48ac0ae0f8aa7db0786158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656aad880c48ac0ae0f8aa7db0786158">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A, bool R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td> -&gt; T
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a304b476587f21b36fe2fad1337834a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304b476587f21b36fe2fad1337834a5f">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A, bool R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td> -&gt; T
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3528d854cdb917df17252d633ecbf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3528d854cdb917df17252d633ecbf72">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A, bool R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; *&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td> -&gt; const T*
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64ed8ba94329f4980574e2c22e293da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ed8ba94329f4980574e2c22e293da2">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Interface , size_t S, size_t A, bool R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; *&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td> -&gt; T*
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ed508491a96866338895cf1b5900292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed508491a96866338895cf1b5900292">&#9670;&nbsp;</a></span>assign_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::assign_allocator </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign allocator for container copy operator. </p>

</div>
</div>
<a id="aeb73db39e1609aef776bd9499a838c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb73db39e1609aef776bd9499a838c85">&#9670;&nbsp;</a></span>bit_scan_forward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_forward </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest set bit index in <em>bb</em>. Undefined if bb==0. </p>

</div>
</div>
<a id="adaee03ba305545aff518038a6037813b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaee03ba305545aff518038a6037813b">&#9670;&nbsp;</a></span>bit_scan_forward_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_forward_32 </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; unsigned int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest set bit index in <em>val</em> Undefined if val==0. </p>

</div>
</div>
<a id="aea82743e4a07a05aad9c2226c85c5925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea82743e4a07a05aad9c2226c85c5925">&#9670;&nbsp;</a></span>bit_scan_forward_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_forward_64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest set bit index in <em>bb</em>. Developed by Kim Walisch (2012). Undefined if bb==0. </p>

</div>
</div>
<a id="a33b62146c2dc50a03ca53b97ace8bd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b62146c2dc50a03ca53b97ace8bd99">&#9670;&nbsp;</a></span>bit_scan_forward_8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_forward_8 </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; unsigned int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2a4aaad9e6e5b58b9ae8bc9a0a8df09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a4aaad9e6e5b58b9ae8bc9a0a8df09">&#9670;&nbsp;</a></span>bit_scan_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_reverse </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest set bit index in <em>bb</em>. Undefined if bb==0. </p>

</div>
</div>
<a id="a89b01e43cd0234954034486359baa02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b01e43cd0234954034486359baa02f">&#9670;&nbsp;</a></span>bit_scan_reverse_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_reverse_32 </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; unsigned int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest set bit index in <em>val</em> Undefined if val==0. </p>

</div>
</div>
<a id="aaea603fed30d1318a1a13ee9a6181c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea603fed30d1318a1a13ee9a6181c1a">&#9670;&nbsp;</a></span>bit_scan_reverse_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_reverse_64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest set bit index in <em>bb</em>. Developed by Kim Walisch, Mark Dickinson. Undefined if bb==0. </p>

</div>
</div>
<a id="adbee1b71b206139ba062e72ec88de1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbee1b71b206139ba062e72ec88de1cf">&#9670;&nbsp;</a></span>bit_scan_reverse_8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::bit_scan_reverse_8 </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; unsigned int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2104e47803d88e9c325e90e895abf654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2104e47803d88e9c325e90e895abf654">&#9670;&nbsp;</a></span>byte_swap_16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::byte_swap_16 </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::uint16_t </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a byte-swapped representation of the 16-bit argument. </p>

</div>
</div>
<a id="a0e5f3b912efdb92047bc111745cbcefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5f3b912efdb92047bc111745cbcefd">&#9670;&nbsp;</a></span>byte_swap_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::byte_swap_32 </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::uint32_t </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a byte-swapped representation of the 32-bit argument. </p>

</div>
</div>
<a id="a1e177ac4ac8797c494c39b28e639d3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e177ac4ac8797c494c39b28e639d3c9">&#9670;&nbsp;</a></span>byte_swap_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::byte_swap_64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::uint64_t </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a byte-swapped representation of the 64-bit argument. </p>

</div>
</div>
<a id="aa01a2e9b3b57b882c04f41e155e7d640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01a2e9b3b57b882c04f41e155e7d640">&#9670;&nbsp;</a></span>consecutive_N_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ConsecutiveNBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::consecutive_N_bits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of the first consecutive N bits within <em>num</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>number of consecutive bits to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first consecutive N bits within <em>num</em> </dd></dl>

</div>
</div>
<a id="a377e0223950bcd7f974c1ffcd47beaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377e0223950bcd7f974c1ffcd47beaf4">&#9670;&nbsp;</a></span>constexpr_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsL1, class L1 , class L2 , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::constexpr_if </td>
          <td>(</td>
          <td class="paramtype">const L1 &amp;&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L2 &amp;&#160;</td>
          <td class="paramname"><em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::declval&lt;<a class="el" href="structseq_1_1detail_1_1_call_lambda.html">detail::CallLambda</a>&lt;L1, L2, IsL1&gt;&amp;&gt;()(std::declval&lt;L1&amp;&gt;(), std::declval&lt;L2&amp;&gt;(),std::declval&lt;Args&gt;()...))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulation of C++17 if constexpr in C++14. </p>

</div>
</div>
<a id="a3c3434a259385c92c1f7654356a66b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3434a259385c92c1f7654356a66b4e">&#9670;&nbsp;</a></span>construct_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void seq::construct_ptr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply call new (p) T(...), used as a replacement to std::allocator::construct() which was removed in C++20. </p>

</div>
</div>
<a id="a60bee86af84ec8c55228d0b9cd79c733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bee86af84ec8c55228d0b9cd79c733">&#9670;&nbsp;</a></span>copy_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::copy_allocator </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td> -&gt; Allocator
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy allocator for container copy constructor. </p>

</div>
</div>
<a id="ad229ce51d8085cde156a70f274f2dce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad229ce51d8085cde156a70f274f2dce2">&#9670;&nbsp;</a></span>count_digits_base_10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::count_digits_base_10 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; unsigned </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of digits used to represent an integer in base 10. This function only works for unsigned integral types </p>

</div>
</div>
<a id="a18560ed6fb98b9e4159f5a246a0a8708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18560ed6fb98b9e4159f5a246a0a8708">&#9670;&nbsp;</a></span>cycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::cycle </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="structseq_1_1detail_1_1_n_iterator_wrap.html">detail::NIteratorWrap</a>&lt;typename Iterable::const_iterator&gt;&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4059063640bce7cc2340cfbaae099c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4059063640bce7cc2340cfbaae099c1a">&#9670;&nbsp;</a></span>destroy_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void seq::destroy_ptr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply call p-&gt;~T(), used as a replacement to std::allocator::destroy() which was removed in C++20. </p>

</div>
</div>
<a id="adb440e376909f74fdadf346e1b10a19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb440e376909f74fdadf346e1b10a19a">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::distance </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between first and last iterators for random access iterator category, 0 otherwise. </p>

</div>
</div>
<a id="a2c99841240cccf7ffccabb7ba9d0649c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c99841240cccf7ffccabb7ba9d0649c">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter1 , class Iter2 , class BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::equal </td>
          <td>(</td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to C++14 std::equal. </p>

</div>
</div>
<a id="af145a6e5a5152d63e95d0cdca95423ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af145a6e5a5152d63e95d0cdca95423ba">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter1 , class Iter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::equal </td>
          <td>(</td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade9a3cabcec0a1c739817cf3b66f2196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9a3cabcec0a1c739817cf3b66f2196">&#9670;&nbsp;</a></span>equal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter1 , class Iter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::equal </td>
          <td>(</td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a425af004809cddd3a0b99a627039e2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425af004809cddd3a0b99a627039e2f8">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey , class Al , class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt;Key, ExtractKey, Al&gt;::size_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>

</div>
</div>
<a id="a272bfe364a7c543ae0d7475f3defd7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272bfe364a7c543ae0d7475f3defd7cb">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class ExtractKey , class Al , class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt;Key, T, ExtractKey, Al&gt;::size_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>

</div>
</div>
<a id="a2bde7d21b0fd6405cd671441c6ab4bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bde7d21b0fd6405cd671441c6ab4bab">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare , class Al1 , bool S1, bool U1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt;Key, Compare, Al1, S1, U1&gt;::size_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>

</div>
</div>
<a id="ac7b4884322c989de0cfb165cf2ab41ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b4884322c989de0cfb165cf2ab41ba">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare , class Al1 , bool S1, bool U1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt;Key, T, Compare, Al1, S1, U1&gt;::size_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>

</div>
</div>
<a id="ac8c9030a8049270841c9d1ceb949ed16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c9030a8049270841c9d1ceb949ed16">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>container from which to erase </td></tr>
    <tr><td class="paramname">p</td><td>predicate that returns true if the element should be erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>

</div>
</div>
<a id="a345460864d8e607d34f3547e6d1e01fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345460864d8e607d34f3547e6d1e01fd">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash1 , class KeyEqual , class Allocator1 , LayoutManagement Layout1, class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate p from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>container from which to erase </td></tr>
    <tr><td class="paramname">p</td><td>predicate that returns true if the element should be erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>

</div>
</div>
<a id="a03816e7c3b50a05fea57bc0934de320f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03816e7c3b50a05fea57bc0934de320f">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structseq_1_1filler.html">filler</a> seq::fill </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a filler object used to fill a string slot within a formatting expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>filler character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>filler object </dd></dl>

</div>
</div>
<a id="abad460325f27b703c618b5757fefa4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad460325f27b703c618b5757fefa4a0">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::flatten </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a> &lt;<a class="el" href="structseq_1_1detail_1_1_flatten_pair.html">detail::FlattenPair</a>&lt;typename Iterable::const_iterator&gt; &gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6121df4185303d9c1babf573d914e4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6121df4185303d9c1babf573d914e4d1">&#9670;&nbsp;</a></span>fmt() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args),false, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt;Args...&gt;::type, false, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3fb0eb956da2343b3354867d5f5cd27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fb0eb956da2343b3354867d5f5cd27">&#9670;&nbsp;</a></span>fmt() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ... Ts, class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args),false, <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt;Ts...&gt;, false, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e1285ca30ab2e5fe9794f18b2d0e3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1285ca30ab2e5fe9794f18b2d0e3df">&#9670;&nbsp;</a></span>fmt() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args),false, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt;Args...&gt;::type, false, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d6f65f0b0ecf8d8214d8bbfdef74935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6f65f0b0ecf8d8214d8bbfdef74935">&#9670;&nbsp;</a></span>fmt() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt;T, S&gt;, false &gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ef86982e406fd6777fec657b967b27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef86982e406fd6777fec657b967b27a">&#9670;&nbsp;</a></span>fmt() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::fmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt;T, S&gt;, false &gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1718699b0708da31869470b90309a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1718699b0708da31869470b90309a5b">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an integral value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">base</td><td>integer base (default to 10) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for an integral pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>This function is similar to std::from_chars except for the following situations: </p><pre class="fragment">- For hexadecimal numbers, the (potential) '0x' prefix will be automatically detected and handled.
- Leading spaces are consumed.
- Leading '+' sign is valid.
- If the pattern is a valid integral text representation too large to be stored in a value, the full pattern will still be consumed,
the function will return a 'success' from_chars_result, and value will silently overflow.
- Reading a negative text representation in an unsigned variable is NOT valid.
</pre><p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="af7ad3302058c1fd1dfd687ecdece61c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ad3302058c1fd1dfd687ecdece61c1">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a812bd0d28d7c1255c96653a7166665b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812bd0d28d7c1255c96653a7166665b8">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad334f8a7ca660e93f0ef55bc886b78b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad334f8a7ca660e93f0ef55bc886b78b1">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace4f5cdcd5b7105e50e1d01e9dd32331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4f5cdcd5b7105e50e1d01e9dd32331">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0e197ee8175965cf95fb0ddcf0871b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e197ee8175965cf95fb0ddcf0871b0">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d50a7d5d36ca43975d8d76528740bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d50a7d5d36ca43975d8d76528740bb0">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a5d4ddc227721feec149a82f85f73cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5d4ddc227721feec149a82f85f73cd">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4596a80118fe7670d639ebc1266c878e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4596a80118fe7670d639ebc1266c878e">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1108c21e3ed098d6e134e1856f672ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1108c21e3ed098d6e134e1856f672ac9">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1a4bc6bba17141d6258f6220e42c868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a4bc6bba17141d6258f6220e42c868">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6a4b7fe569864c695641332f004acec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a4b7fe569864c695641332f004acec">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a floating point value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>decimal point character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod, and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="a2b35225d5a96bc5ac0774b9238b6efa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b35225d5a96bc5ac0774b9238b6efa2">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a floating point value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>decimal point character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod, and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="ad918ef5a661c096e650809b91fc5e1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad918ef5a661c096e650809b91fc5e1cc">&#9670;&nbsp;</a></span>from_chars() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::from_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1from__chars__result.html">from_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a floating point value from the sequence of characters [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first character of the sequence </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>decimal point character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">from_chars_result</a> object storing a past-the-end pointer (on success) and an error code.</dd></dl>
<p>Analyzes the character sequence [first,last) for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod, and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">seq::from_chars_result</a> such that ptr points at the first character not matching the pattern, or has the value equal to last if all characters match and ec is value-initialized.</p>
<p>If there is no pattern match, returns a value of type <a class="el" href="structseq_1_1from__chars__result.html" title="Return type for seq::from_chars functions, similar to std::from_chars_result. ">from_chars_result</a> such that ptr equals first and ec equals std::errc::invalid_argument. value is set to 0. </p>

</div>
</div>
<a id="ade167dcc6d29b420964a6be1498889ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade167dcc6d29b420964a6be1498889ac">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an integral value from a <a class="el" href="classseq_1_1basic__input__stream.html" title="Base class for input text streams. ">seq::basic_input_stream</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">base</td><td>integer base (default to 10) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for an integral pattern. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.</p>
<p>For hexadecimal numbers, the (potential) '0x' prefix will be automatically detected and handled. Leading spaces are consumed. If the pattern is a valid integral text representation too large to be stored in a value, the full pattern will still be consumed. Reading a negative text representation in an unsigned variable is not valid.</p>
<p>If the parsing fails (no integral pattern was detected), the stream status will be set to BadInputFormat or EndOfFile depending on the situation.</p>
<p><a class="el" href="namespaceseq.html#aa1718699b0708da31869470b90309a5b" title="Read an integral value from the sequence of characters [first,last). ">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object. ">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters. ">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="af0031c82ad3d33c5094644a8c07f5464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0031c82ad3d33c5094644a8c07f5464">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a floating point value from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>dot character, usually '.' for 'C' locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an floating point value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>If the parsing fails (no floating point pattern was detected), the stream status will be set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587" title="End of file reached. ">BadInputFormat</a> or <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error. ">EndOfFile</a> depending on the situation, and stream get position will be reverted to its original state.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>This function is usefull when you need to read a huge amount of floating point values of a std::istream object. Internal benchmarks show that using <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object. ">from_stream()</a> is around 20 faster (or more) than using <a class="el" href="namespaceseq.html#af63e912eb6011acc4393a84d8a70da27">std::istream::operator&gt;&gt;()</a>.</p>
<p><a class="el" href="namespaceseq.html#aa1718699b0708da31869470b90309a5b" title="Read an integral value from the sequence of characters [first,last). ">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object. ">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters. ">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="a0581674bf80cd428f3680506119eb7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0581674bf80cd428f3680506119eb7d8">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a floating point value from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>dot character, usually '.' for 'C' locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an floating point value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>If the parsing fails (no floating point pattern was detected), the stream status will be set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587" title="End of file reached. ">BadInputFormat</a> or <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error. ">EndOfFile</a> depending on the situation, and stream get position will be reverted to its original state.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>This function is usefull when you need to read a huge amount of floating point values of a std::istream object. Internal benchmarks show that using <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object. ">from_stream()</a> is around 20 faster (or more) than using <a class="el" href="namespaceseq.html#af63e912eb6011acc4393a84d8a70da27">std::istream::operator&gt;&gt;()</a>.</p>
<p><a class="el" href="namespaceseq.html#aa1718699b0708da31869470b90309a5b" title="Read an integral value from the sequence of characters [first,last). ">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object. ">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters. ">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="a36637d3bd7fde2e315ed4a5d1bc29f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36637d3bd7fde2e315ed4a5d1bc29f35">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682a37dc0b5d725475e8b304b312a07c079d">seq::general</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a floating point value from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object to read from </td></tr>
    <tr><td class="paramname">value</td><td>output read value </td></tr>
    <tr><td class="paramname">dot</td><td>dot character, usually '.' for 'C' locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Analyzes the stream for a floating point pattern. If no characters match the pattern, value is set to 0, otherwise the characters matching the pattern are interpreted as a text representation of an floating point value, which is stored in value.</p>
<p>Nan and infinit values (upper or lower case) are handled by this function.</p>
<p>If the parsing fails (no floating point pattern was detected), the stream status will be set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a255aad079a8bea265f55d1a6e8ef5587" title="End of file reached. ">BadInputFormat</a> or <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error. ">EndOfFile</a> depending on the situation, and stream get position will be reverted to its original state.</p>
<p>This function is simillar to C++17 std::from_chars with the following differences:</p><ul>
<li>Leading spaces are consumed.</li>
<li>If the pattern is a valid floating point text representation too large or too small to be stored in given output value, value will be set to (+-)inf or (+-)0, and the full pattern will be consumed. Therefore, std::errc::result_out_of_range is never returned.</li>
<li>Leading '+' sign is considered valid.</li>
<li>This function is not an exact parser. In some cases it relies on unprecise floating point arithmetic wich might produce different roundings than strtod() function. Note that the result is almost always equal to the result of strtod(), and potential differences are located in the last digits. Use this function when the speed factor is more important than 100% perfect exactitude.</li>
</ul>
<p>This function is usefull when you need to read a huge amount of floating point values of a std::istream object. Internal benchmarks show that using <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object. ">from_stream()</a> is around 20 faster (or more) than using <a class="el" href="namespaceseq.html#af63e912eb6011acc4393a84d8a70da27">std::istream::operator&gt;&gt;()</a>.</p>
<p><a class="el" href="namespaceseq.html#aa1718699b0708da31869470b90309a5b" title="Read an integral value from the sequence of characters [first,last). ">seq::from_chars</a> internally uses <a class="el" href="namespaceseq.html#ade167dcc6d29b420964a6be1498889ac" title="Read an integral value from a seq::basic_input_stream object. ">seq::from_stream</a> with a <a class="el" href="classseq_1_1buffer__input__stream.html" title="Input stream working on a sequence of characters. ">seq::buffer_input_stream</a> object. </p>

</div>
</div>
<a id="a7a713df989fd498a0a680d4b7cc673cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a713df989fd498a0a680d4b7cc673cb">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class Traits , class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a word from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full word from a stream object. In a text files, words are delimited by white-space characters (' ', '', '<br />
', '', '', '', EOF). If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error. ">EndOfFile</a>. </p>

</div>
</div>
<a id="a0e0e5ed9d968a2eb03774cfacb2a4001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0e5ed9d968a2eb03774cfacb2a4001">&#9670;&nbsp;</a></span>from_stream() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class Traits , size_t Ss, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; char, Traits, Al, Ss &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a word from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full word from a stream object. In a text files, words are delimited by white-space characters (' ', '', '<br />
', '', '', '', EOF). If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error. ">EndOfFile</a>. </p>

</div>
</div>
<a id="a8ad0247ee4ca62ff368c30bea8e49dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad0247ee4ca62ff368c30bea8e49dfb">&#9670;&nbsp;</a></span>generate_random_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class String &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::generate_random_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; String
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For tests only, generate a random string of given max size. </p>

</div>
</div>
<a id="a30368dcf14dfdddd428c9ac9ec675b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30368dcf14dfdddd428c9ac9ec675b6f">&#9670;&nbsp;</a></span>get_memory_usage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::get_memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ca5fac631207b6d7245eab5a6bfe8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca5fac631207b6d7245eab5a6bfe8b7">&#9670;&nbsp;</a></span>get_type_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::get_type_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns type Id used by <a class="el" href="classseq_1_1hold__any.html" title="std::any like class optimized to build heterogeneous containers. ">hold_any</a> as a unique type identifier. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique Id for type T </dd></dl>

</div>
</div>
<a id="aa143c1836c024422e735b68350a8c58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa143c1836c024422e735b68350a8c58d">&#9670;&nbsp;</a></span>hash_bytes_fnv1a()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::hash_bytes_fnv1a </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  size_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73d484b65f61026ac2f11b34b371cce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d484b65f61026ac2f11b34b371cce1">&#9670;&nbsp;</a></span>hash_bytes_murmur64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::hash_bytes_murmur64 </td>
          <td>(</td>
          <td class="paramtype">const std::uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  size_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e75ac2752560b9441e25dbeb0a37035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e75ac2752560b9441e25dbeb0a37035">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::hash_combine </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>h2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine 2 hash values. Uses either murmurhash2 for 64 bits platform or the boost version for 32 bits platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h1</td><td>first hash value </td></tr>
    <tr><td class="paramname">h2</td><td>second hash value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combination of both hash value </dd></dl>

</div>
</div>
<a id="abb5af289596de39f1073e3071263a644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5af289596de39f1073e3071263a644">&#9670;&nbsp;</a></span>is_arithmetic_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_arithmetic_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to an arithmetic type (floating point or integral) </p>

</div>
</div>
<a id="aa2ee2f93a9ebfb47e00fb2a353c26627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ee2f93a9ebfb47e00fb2a353c26627">&#9670;&nbsp;</a></span>is_floating_point_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_floating_point_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to a floating point type. </p>

</div>
</div>
<a id="a29f9511e243d78950b21507f5a4fe896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f9511e243d78950b21507f5a4fe896">&#9670;&nbsp;</a></span>is_integral_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_integral_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to an integral type. </p>

</div>
</div>
<a id="aa78953b53d9255df1c87a82bb8a7ecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78953b53d9255df1c87a82bb8a7ecd4">&#9670;&nbsp;</a></span>is_signed_integral_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_signed_integral_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to a signed integral type. </p>

</div>
</div>
<a id="a9a34e6330b33a12e7e645c50d6d50a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a34e6330b33a12e7e645c50d6d50a84">&#9670;&nbsp;</a></span>is_string_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_string_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to a string type (std::string, tstring, tstring_view or const char*) </p>

</div>
</div>
<a id="a5e891e43f7fe2c2737322a9b273d4a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e891e43f7fe2c2737322a9b273d4a06">&#9670;&nbsp;</a></span>is_unsigned_integral_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::is_unsigned_integral_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; bool
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if given type id corresponds to an unsigned integral type. </p>

</div>
</div>
<a id="ae5c696025e12d6de56084a2d64214b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c696025e12d6de56084a2d64214b40">&#9670;&nbsp;</a></span>join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... Args, class K  = typename std::enable_if&lt;!detail::IsFirstIterable&lt;Args...&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_build_format.html">detail::BuildFormat</a>&lt; sizeof...(Args), true, typename <a class="el" href="structseq_1_1detail_1_1find__slots.html">detail::find_slots</a>&lt;Args...&gt;::type,false, Args...&gt;::return_type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa223aa54b2ea58cdd86897555de5caa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa223aa54b2ea58cdd86897555de5caa6">&#9670;&nbsp;</a></span>join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterRange &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterRange &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt;<a class="el" href="structseq_1_1detail_1_1_iterable.html">detail::Iterable</a>&lt;IterRange&gt; &gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a410a01fc0326543b86b969ed66cea960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410a01fc0326543b86b969ed66cea960">&#9670;&nbsp;</a></span>join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterRange , class T , bool S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterRange &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>wf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt;<a class="el" href="structseq_1_1detail_1_1_iterable.html">detail::Iterable</a>&lt;IterRange&gt; &gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf2b63f4cea16071daccd0ab528b695e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2b63f4cea16071daccd0ab528b695e">&#9670;&nbsp;</a></span>make_any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Any , class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::make_any </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; Any
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5417e4eca78972288f212c355f07923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5417e4eca78972288f212c355f07923">&#9670;&nbsp;</a></span>make_any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Any , class T , class U , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::make_any </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Any
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae02fc574f6876f28fef03044ed31569e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02fc574f6876f28fef03044ed31569e">&#9670;&nbsp;</a></span>make_comparator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::make_comparator </td>
          <td>(</td>
          <td class="paramtype">const Comp &amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structseq_1_1comp__wrapper.html">comp_wrapper</a>&lt;Comp&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a comparison functor that can be used by algorithms working on cvector objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Comp</td><td>actual comparison function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>comparison function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>comparison wrapper </dd></dl>

</div>
</div>
<a id="a32e7a0c600427f614ba162d86c3c4362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e7a0c600427f614ba162d86c3c4362">&#9670;&nbsp;</a></span>make_lock_guard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::make_lock_guard </td>
          <td>(</td>
          <td class="paramtype">Lock &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1lock__guard.html">lock_guard</a>&lt;Lock&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a lock guard around l. Use copy elison to avoid creating copies and locking twice the lock object. </p>

</div>
</div>
<a id="a81932472ffd88a08d7b6f0aaf2c123e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81932472ffd88a08d7b6f0aaf2c123e9">&#9670;&nbsp;</a></span>move_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::move_allocator </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move allocator for container move assignment. </p>

</div>
</div>
<a id="a7c279fa143d4e6216df953924ce47406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c279fa143d4e6216df953924ce47406">&#9670;&nbsp;</a></span>negate_if_signed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::negate_if_signed </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structseq_1_1integer__abs__return.html">integer_abs_return</a>&lt;T&gt;::type </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns -v if v is signed, v otherwise. </p>

</div>
</div>
<a id="ab2f848adb0c9d3ac36fb1c523850748b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f848adb0c9d3ac36fb1c523850748b">&#9670;&nbsp;</a></span>nth_bit_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned seq::nth_bit_set </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa1c88afedd41ee32a953675e55e7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa1c88afedd41ee32a953675e55e7d3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey , class Al1 , class Al2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are not equals. </p>

</div>
</div>
<a id="a400e9d7037a613d14f9a38347563be82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400e9d7037a613d14f9a38347563be82">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class ExtractKey , class Al1 , class Al2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are not equals. </p>

</div>
</div>
<a id="a0d26e806617c5a8c647633ca26c48ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d26e806617c5a8c647633ca26c48ced">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare , class Al1 , class Al2 , bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are not equals. </p>

</div>
</div>
<a id="a44254caec914e25dbb9f365648101280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44254caec914e25dbb9f365648101280">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare , class Al1 , class Al2 , bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are not equals. </p>

</div>
</div>
<a id="a2ec93819ac321959ed7b44ddc8ea2c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec93819ac321959ed7b44ddc8ea2c52">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a479608f726adc057d8d2cfa5816fcaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479608f726adc057d8d2cfa5816fcaf2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12a8e4ca5bdbbf2cd53645c2733449d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a8e4ca5bdbbf2cd53645c2733449d0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. ">ordered_set</a> for inequality, synthesized from operator==. </p>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare non equals, false otherwise </dd></dl>

</div>
</div>
<a id="ac8a77517d376eeb44fc2615040f226b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a77517d376eeb44fc2615040f226b3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. ">ordered_map</a> for inequality, synthesized from operator==. </p>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare non equals, false otherwise </dd></dl>

</div>
</div>
<a id="a695c2c18ca374da34a369b7442739926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695c2c18ca374da34a369b7442739926">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0eaae058a01e3f15f70f326b4f408647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eaae058a01e3f15f70f326b4f408647">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6880991b301072bed5280b0de2a43cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6880991b301072bed5280b0de2a43cd2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1aa03268dd5a041a606080a6d72cc21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa03268dd5a041a606080a6d72cc21a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7a4e8aff8fcd9bf5c4fe0a07a08ad78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a4e8aff8fcd9bf5c4fe0a07a08ad78">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57a83c380ba3efb861a6d64bd87360c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a83c380ba3efb861a6d64bd87360c1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bedc7bafaa1c5ef1e97d86389a1787e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bedc7bafaa1c5ef1e97d86389a1787e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t Size, class Al2 , size_t Size2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, Size2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;Char,Traits,<a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al2, Size2&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa472516527bb96b93aa7a2cfb8d04bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa472516527bb96b93aa7a2cfb8d04bf">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , size_t Size, class Al , class Al2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8ca569981586168d5487cb1cf7c4cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ca569981586168d5487cb1cf7c4cce">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac47108e7f89821a328dc8b0743be4b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47108e7f89821a328dc8b0743be4b16">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7685a1feb8ff18e4b9313d03a3e13d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7685a1feb8ff18e4b9313d03a3e13d7">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , size_t Size, class Al , class Al2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt; &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bc25ee31d1f47913986e3c67b7ce808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc25ee31d1f47913986e3c67b7ce808">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt;  &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e7f01f72c0ee9fc492828807b5eb66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7f01f72c0ee9fc492828807b5eb66e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , size_t Size, class Al &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator+ </td>
          <td>(</td>
          <td class="paramtype">Char&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structseq_1_1detail_1_1_find_return_type.html">detail::FindReturnType</a>&lt;Char, Traits, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt;, <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt;Char, Traits, Al, Size&gt;  &gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa242d97b0138a72bd07cabe76a62ef17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa242d97b0138a72bd07cabe76a62ef17">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt;::difference_type&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a3dab51febe50dfd60f7bd4fe46154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3dab51febe50dfd60f7bd4fe46154f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T&gt;::difference_type </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c4cb9a01f8408e24f5cf3b5874876f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4cb9a01f8408e24f5cf3b5874876f9">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeff27313847123eef67c0de05797b758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff27313847123eef67c0de05797b758">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72706e2b2834a21aa430d177b624546d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72706e2b2834a21aa430d177b624546d">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa46652d2852e9aac603339e0b26d62d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46652d2852e9aac603339e0b26d62d2">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba2fb7bf890a492b43f052bd519affd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2fb7bf890a492b43f052bd519affd8">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae29f73ad0bfc1e18397989ced44eb5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29f73ad0bfc1e18397989ced44eb5c5">&#9670;&nbsp;</a></span>operator<() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a413f7e38de30c96a31b79b5ac0bef6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413f7e38de30c96a31b79b5ac0bef6c6">&#9670;&nbsp;</a></span>operator<() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61dd527886084b02b47a73633a84c1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dd527886084b02b47a73633a84c1f8">&#9670;&nbsp;</a></span>operator<() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa905511e61ee9e449a5ed9e38f89ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa905511e61ee9e449a5ed9e38f89ca">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Elem , class Traits , class T , bool S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>oss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ostream__format.html">ostream_format</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::basic_ostream&lt;Elem, Traits&gt;&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class. ">ostream_format</a> object to a std::ostream. </p>

</div>
</div>
<a id="ad6f2b4c519aa50f2b808e7401a502bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f2b4c519aa50f2b808e7401a502bc5">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>oss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::ostream&amp; 
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88a3ddd798c88bc1b4e22d2d35ddea5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a3ddd798c88bc1b4e22d2d35ddea5f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Elem , class Traits , class T , bool HS, class P , bool S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>oss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1detail_1_1mutli__ostream__format.html">detail::mutli_ostream_format</a>&lt; T, HS, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::basic_ostream&lt;Elem, Traits&gt;&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class. ">ostream_format</a> object to a std::ostream object. </p>

</div>
</div>
<a id="ac8658c17ae7ad6e45721ab470d0dd2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8658c17ae7ad6e45721ab470d0dd2c0">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Elem , class Traits , size_t Size, class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>oss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Elem, Traits, Alloc, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::basic_ostream&lt;Elem, Traits&gt;&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6920a1594333ae1cb5a606a699e2fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6920a1594333ae1cb5a606a699e2fa7">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2393e534f64f957e7bb215f856ca74d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2393e534f64f957e7bb215f856ca74d3">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10f089e3cd1b684f11f0e31e6ac49a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f089e3cd1b684f11f0e31e6ac49a1b">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47e742b5a5a114e04415b13bc9d4eb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e742b5a5a114e04415b13bc9d4eb6a">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a5c3512c9a7056ec428f9c5b816cadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5c3512c9a7056ec428f9c5b816cadf">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11e9a9ae93c0e92495830af1b8147a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e9a9ae93c0e92495830af1b8147a74">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c1caec84127a30e15fbcbeec5e3907a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1caec84127a30e15fbcbeec5e3907a">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7732b5a0475169a15f4386b74ce6bc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7732b5a0475169a15f4386b74ce6bc41">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02812cee981693bc33614eecea8d45dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02812cee981693bc33614eecea8d45dc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey , class Al1 , class Al2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position. </p>

</div>
</div>
<a id="a8f30bf51b65c1dda85a65bb995a6090a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f30bf51b65c1dda85a65bb995a6090a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class ExtractKey , class Al1 , class Al2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__map.html">radix_map</a>&lt; Key, T, ExtractKey, Al2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position. </p>

</div>
</div>
<a id="a2aa312ea998bfce36889d0f3d89a0253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa312ea998bfce36889d0f3d89a0253">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare , class Al1 , class Al2 , bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Al2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position. </p>

</div>
</div>
<a id="a5a694c998ffa1289077fa7cc28524990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a694c998ffa1289077fa7cc28524990">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare , class Al1 , class Al2 , bool S1, bool S2, bool U1, bool U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al1, S1, U1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__map.html">flat_map</a>&lt; Key, T, Compare, Al2, S2, U2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of s1 and s2 are equal, that is, they have the same number of elements and each element in s1 compares equal with the element in s2 at the same position. </p>

</div>
</div>
<a id="a8d60e85edea2233f085bdf747bddcff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d60e85edea2233f085bdf747bddcff2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value,void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a724b3d5a01fe3634b25679520b5ef76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724b3d5a01fe3634b25679520b5ef76f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4308e82af69325da59bf1abe2e9b30d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4308e82af69325da59bf1abe2e9b30d1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. ">ordered_set</a> for equality. Two <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. ">ordered_set</a> are considered equal if they contain the same keys. Key ordering is not considered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. ">ordered_set</a> </td></tr>
    <tr><td class="paramname">rhs</td><td>right <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. ">ordered_set</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare equals, false otherwise </dd></dl>

</div>
</div>
<a id="a3debed99e1f30055ff02d9d0ee009727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3debed99e1f30055ff02d9d0ee009727">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash1 , class Hash2 , class KeyEqual , class Allocator1 , class Allocator2 , LayoutManagement Layout1, LayoutManagement Layout2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash1, KeyEqual, Allocator1, Layout1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__map.html">ordered_map</a>&lt; Key, T, Hash2, KeyEqual, Allocator2, Layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. ">ordered_map</a> for equality. Two <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. ">ordered_map</a> are considered equal if they contain the same pairs key-&gt;value. Key ordering is not considered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. ">ordered_map</a> </td></tr>
    <tr><td class="paramname">rhs</td><td>right <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. ">ordered_map</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both containers compare equals, false otherwise </dd></dl>

</div>
</div>
<a id="a1c865c483c552fe56c66cbcca0e4c8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c865c483c552fe56c66cbcca0e4c8b6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78b1b3b672400626cabfbaaba0a8e507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b1b3b672400626cabfbaaba0a8e507">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0be59e11b72f7a46f60a25341e142c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be59e11b72f7a46f60a25341e142c87">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68868ab059ceff25f0420a62dbe398d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68868ab059ceff25f0420a62dbe398d8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb690b643ff25719baadcb15d9c84cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb690b643ff25719baadcb15d9c84cd5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e24e00cf888c85c3bc16fa9a8f8dfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e24e00cf888c85c3bc16fa9a8f8dfbf">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3915ca3d10e71950f65df48b17962b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3915ca3d10e71950f65df48b17962b5d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaa57e12b70dcecd63e46910892ef654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa57e12b70dcecd63e46910892ef654">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5aee0f0e155eb9f313a4e7bbec575953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aee0f0e155eb9f313a4e7bbec575953">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bd06fe0ed32777597cb1b94f6be7c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd06fe0ed32777597cb1b94f6be7c5f">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e339fbd9e7c56cd07e91717c65b1678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e339fbd9e7c56cd07e91717c65b1678">&#9670;&nbsp;</a></span>operator>() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab614ebb908519b061eb878082c381eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab614ebb908519b061eb878082c381eb6">&#9670;&nbsp;</a></span>operator>() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87c08fc3f8c6e1c4a66d8980e719ee2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c08fc3f8c6e1c4a66d8980e719ee2a">&#9670;&nbsp;</a></span>operator>() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93bda8a7271df48555e68fe9d51ebf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bda8a7271df48555e68fe9d51ebf37">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvalue__iterator.html">cvalue_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94bca4bc401423cdc7201aea937ead6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bca4bc401423cdc7201aea937ead6c">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95d9c6b0597c2f1faf898ec6de1092c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d9c6b0597c2f1faf898ec6de1092c7">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R, class T , class  = typename std::enable_if&lt;!detail::is_value_wrapper&lt;T&gt;::value, void&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d37adacf6c3e89a8a92fe212afdac5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d37adacf6c3e89a8a92fe212afdac5d">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class A1 , class A2 , size_t S1, size_t S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A1, S1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, A2, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4303c700d412ca7164d682a810349995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4303c700d412ca7164d682a810349995">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02ee63226848240d8926aaf45caf2bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ee63226848240d8926aaf45caf2bd0">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed49e9ad09fafea07ddabecdeba9f77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed49e9ad09fafea07ddabecdeba9f77e">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8666fcc971ce7730bf6d673fd9b42b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8666fcc971ce7730bf6d673fd9b42b71">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , class Al2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto seq::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af63e912eb6011acc4393a84d8a70da27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63e912eb6011acc4393a84d8a70da27">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface , size_t S, size_t A, bool R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>iss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1hold__any.html">hold_any</a>&lt; Interface, S, A, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::istream&amp;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd17142bbec3b3cdc22b32952feee534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd17142bbec3b3cdc22b32952feee534">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Elem , class Traits , size_t Size, class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>iss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Elem, Traits, Alloc, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;!std::is_same&lt;Alloc, <a class="el" href="structseq_1_1view__allocator.html">view_allocator</a>&lt;Elem&gt; &gt;::value, std::basic_istream&lt;Elem, Traits&gt; &gt;::type	&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a348cf02b3ab7947f01df82985d741138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348cf02b3ab7947f01df82985d741138">&#9670;&nbsp;</a></span>popcnt16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::popcnt16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; unsigned
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08ad7cd23d956c6e3205dd20ff1629b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ad7cd23d956c6e3205dd20ff1629b3">&#9670;&nbsp;</a></span>popcnt32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t seq::popcnt32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93474d742382c06825212a479a720fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93474d742382c06825212a479a720fcb">&#9670;&nbsp;</a></span>popcnt64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t seq::popcnt64 </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2cd15c1c849768be9995bcb1fd1733a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cd15c1c849768be9995bcb1fd1733a">&#9670;&nbsp;</a></span>popcnt8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::popcnt8 </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; unsigned
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab534e8a0f6ac376f61e976fe7cd65457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab534e8a0f6ac376f61e976fe7cd65457">&#9670;&nbsp;</a></span>pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::pos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structseq_1_1detail_1_1_positional.html">detail::Positional</a>&lt;Ts...&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a positional object used either by <a class="el" href="namespaceseq.html#a6121df4185303d9c1babf573d914e4d1">seq::fmt()</a> or operator() of formatting object. </p>

</div>
</div>
<a id="aa6c8fd38b49f17879d09232a8e640bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c8fd38b49f17879d09232a8e640bbb">&#9670;&nbsp;</a></span>print_features()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::print_features </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b887df093a1fae4487fccd6c1949116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b887df093a1fae4487fccd6c1949116">&#9670;&nbsp;</a></span>print_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::print_null </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8b268bc53b846426ab17a84bb756fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b268bc53b846426ab17a84bb756fab">&#9670;&nbsp;</a></span>random_shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::random_shuffle </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to C++11 (and deprecated) std::random_shuffle. </p>

</div>
</div>
<a id="a2727f596361adeef66d2054dc80df83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2727f596361adeef66d2054dc80df83a">&#9670;&nbsp;</a></span>range() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter , class  = typename std::enable_if&lt;!std::is_arithmetic&lt;Iter&gt;::value, void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::range </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;Iter&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build and return an iterable object over the range [first,last) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b67dafb70204550191674aa9eefdc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b67dafb70204550191674aa9eefdc6f">&#9670;&nbsp;</a></span>range() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter , class  = typename std::enable_if&lt;!std::is_arithmetic&lt;Iter&gt;::value, void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::range </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="structseq_1_1detail_1_1_n_iterator.html">detail::NIterator</a>&lt;Iter&gt;&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build and return an iterable object over the range [first, min(first + count, last)) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a676294ca64f6638e227f31c79b040251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676294ca64f6638e227f31c79b040251">&#9670;&nbsp;</a></span>range() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral , class  = typename std::enable_if&lt;std::is_integral&lt;Integral&gt;::value, void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::range </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="structseq_1_1detail_1_1_integral_iterator.html">detail::IntegralIterator</a>&lt;Integral&gt; &gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build and return an iterable object over the integral range [first, last) with a step of 1. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integral</td><td>integral type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d76f074323f27c200f338aba629d85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d76f074323f27c200f338aba629d85b">&#9670;&nbsp;</a></span>range() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Arithmetic , class  = typename std::enable_if&lt;std::is_arithmetic&lt;Arithmetic&gt;::value, void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::range </td>
          <td>(</td>
          <td class="paramtype">Arithmetic&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arithmetic&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arithmetic&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="structseq_1_1detail_1_1_arithmetic_iterator.html">detail::ArithmeticIterator</a>&lt;Arithmetic&gt; &gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build and return an iterable object over the integral range [first, last) with given step. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arithmetic</td><td>arithmetic type It is possible to provide a negative step, in which case first should be greater than last. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af90e9a81c26ca4cf0f9fd3cd2ba30b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90e9a81c26ca4cf0f9fd3cd2ba30b57">&#9670;&nbsp;</a></span>range() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::range </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;typename Container::const_iterator&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build and return an iterable object over the range [c.begin(), c.end()) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterable</td><td>container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Iterable container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaf4f36570fe474a4970d306b7ccdb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf4f36570fe474a4970d306b7ccdb40">&#9670;&nbsp;</a></span>range() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::range </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;const T*&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build and return an iterable object over the range [lst.begin(), lst.end()) </p>

</div>
</div>
<a id="a8f60f564f232ca6fda3fe28fe03d364a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f60f564f232ca6fda3fe28fe03d364a">&#9670;&nbsp;</a></span>range() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; Iter &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt; const <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;Iter&gt;&amp;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just to avoid deeply nested <a class="el" href="classseq_1_1iterator__range.html" title="iterator_range class used to join iterables ">iterator_range</a> objects. </p>

</div>
</div>
<a id="a1b689643e0744253bef536676346a3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b689643e0744253bef536676346a3e5">&#9670;&nbsp;</a></span>range_p()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter , class  = typename std::enable_if&lt;!std::is_arithmetic&lt;Iter&gt;::value, void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::range_p </td>
          <td>(</td>
          <td class="paramtype">Iter *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="structseq_1_1detail_1_1_n_iterator_ref.html">detail::NIteratorRef</a>&lt;Iter&gt;&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build and return an iterable object over the range [first, min(first + count, last)) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20f46b0218710a8c5534b5795ce95b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f46b0218710a8c5534b5795ce95b2e">&#9670;&nbsp;</a></span>read_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint16_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 16 bits integer from src. </p>

</div>
</div>
<a id="a36b48ff10138ee36cd0f4949f01a23f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b48ff10138ee36cd0f4949f01a23f1">&#9670;&nbsp;</a></span>read_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint32_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 32 bits integer from src. </p>

</div>
</div>
<a id="a53674d0482ead92a98023ed0d7c57dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53674d0482ead92a98023ed0d7c57dd1">&#9670;&nbsp;</a></span>read_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint64_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 64 bits integer from src. </p>

</div>
</div>
<a id="aa1f9f34cc361321151e13951ccad2ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f9f34cc361321151e13951ccad2ac4">&#9670;&nbsp;</a></span>read_BE_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_BE_16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint16_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 16 bits integer from src in big endian order. </p>

</div>
</div>
<a id="adccead2b857599b0e675267609e5120f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccead2b857599b0e675267609e5120f">&#9670;&nbsp;</a></span>read_BE_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_BE_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint32_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 32 bits integer from src in big endian order. </p>

</div>
</div>
<a id="a3778777f10583618f958211656aec2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3778777f10583618f958211656aec2b4">&#9670;&nbsp;</a></span>read_BE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_BE_64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint64_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 64 bits integer from src in big endian order. </p>

</div>
</div>
<a id="a79fbedb52aef41b37b7b243497ead642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fbedb52aef41b37b7b243497ead642">&#9670;&nbsp;</a></span>read_BE_size_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_BE_size_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads size_t object from src in big endian order. </p>

</div>
</div>
<a id="a052b75a0721954d5497ff1753315e997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052b75a0721954d5497ff1753315e997">&#9670;&nbsp;</a></span>read_LE_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_LE_16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint16_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read 16 bits integer from src in little endian order. </p>

</div>
</div>
<a id="a1a00bc4c5f354e2350bab137e35c0ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a00bc4c5f354e2350bab137e35c0ceb">&#9670;&nbsp;</a></span>read_LE_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_LE_32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint32_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read 32 bits integer from src in little endian order. </p>

</div>
</div>
<a id="aee33b43276433d62551712f283741546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee33b43276433d62551712f283741546">&#9670;&nbsp;</a></span>read_LE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_LE_64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uint64_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read 64 bits integer from src in little endian order. </p>

</div>
</div>
<a id="aa1f5bd629161aaad113175e3b0217f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f5bd629161aaad113175e3b0217f29">&#9670;&nbsp;</a></span>read_LE_size_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_LE_size_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads size_t object from src in little endian order. </p>

</div>
</div>
<a id="acbab83476e9a93ab4a0fe3626a3c27ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbab83476e9a93ab4a0fe3626a3c27ab">&#9670;&nbsp;</a></span>read_line_from_stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class Traits , class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_line_from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a line from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full line from a stream object. In a text files, lines are delimited by characters '<br />
', '' or EOF. If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error. ">EndOfFile</a>. </p>

</div>
</div>
<a id="ae49d64c12c56026d4476c0e97ea9230c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49d64c12c56026d4476c0e97ea9230c">&#9670;&nbsp;</a></span>read_line_from_stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class Traits , size_t Ss, class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_line_from_stream </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; char, Traits, Al, Ss &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Stream&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a line from a #basic_input_stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>stream object </td></tr>
    <tr><td class="paramname">value</td><td>output string object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream object</dd></dl>
<p>Read a full line from a stream object. In a text files, lines are delimited by characters '<br />
', '' or EOF. If no string was read because the get position was after the last stream character, the value string is cleared and stream state is set to <a class="el" href="namespaceseq.html#ac3d7eb5b00b5c7e90602aaf0e8bd23e2a3f7afd64256598243b4355a79f0e4d7d" title="No error. ">EndOfFile</a>. </p>

</div>
</div>
<a id="ae07d1a9758d3ce39924f26eff332f759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07d1a9758d3ce39924f26eff332f759">&#9670;&nbsp;</a></span>read_ptr_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_ptr_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::uintptr_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads uintptr_t integer from src. </p>

</div>
</div>
<a id="a2adb2cb36973f3d571f0984dffb68d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adb2cb36973f3d571f0984dffb68d87">&#9670;&nbsp;</a></span>read_size_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::read_size_t </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; size_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads size_t object from src. </p>

</div>
</div>
<a id="a97851d71ded4c7928aabd76f4280d268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97851d71ded4c7928aabd76f4280d268">&#9670;&nbsp;</a></span>register_any_conversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_conversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a conversion function based on explicit conversion from type T to type U. </p>

</div>
</div>
<a id="ad7a515ea06834d35cedd4e4f9c4ba1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a515ea06834d35cedd4e4f9c4ba1b0">&#9670;&nbsp;</a></span>register_any_conversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_conversion </td>
          <td>(</td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a conversion function using given functor. </p>

</div>
</div>
<a id="adb61336a531e99a11a888883a46d0f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb61336a531e99a11a888883a46d0f01">&#9670;&nbsp;</a></span>register_any_equal_comparison() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_equal_comparison </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the comparison function <a class="el" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T()</a> == U() </p>

</div>
</div>
<a id="aaa783de724c82de2264d98a3437294df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa783de724c82de2264d98a3437294df">&#9670;&nbsp;</a></span>register_any_equal_comparison() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_equal_comparison </td>
          <td>(</td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a comparison function between types T and U based on given functor. </p>

</div>
</div>
<a id="ab390e9bf772c9a88f9f48c5bd360d7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab390e9bf772c9a88f9f48c5bd360d7ed">&#9670;&nbsp;</a></span>register_any_less_comparison() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_less_comparison </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the comparison function <a class="el" href="namespaceseq_1_1detail.html#ae4e48f51c85e7a3a935596cba71a7355">T()</a> &lt; U() </p>

</div>
</div>
<a id="a0b0810417829f24c04037720cfe1cc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0810417829f24c04037720cfe1cc92">&#9670;&nbsp;</a></span>register_any_less_comparison() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::register_any_less_comparison </td>
          <td>(</td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a comparison function between types T and U based on given functor. </p>

</div>
</div>
<a id="a4a6c3cb07d1db3914b73700e871982c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6c3cb07d1db3914b73700e871982c3">&#9670;&nbsp;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::repeat </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="structseq_1_1detail_1_1_n_iterator_repeat.html">detail::NIteratorRepeat</a>&lt;typename std::decay&lt;T&gt;::type&gt; &gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65d14b24f21161f7a7188e36b3ed8549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d14b24f21161f7a7188e36b3ed8549">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::string
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acabfa3eaf9a03808f516c1c71d521dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabfa3eaf9a03808f516c1c71d521dee">&#9670;&nbsp;</a></span>reset_memory_usage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::reset_memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1452eb51c66f96eff698c862bca8631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1452eb51c66f96eff698c862bca8631">&#9670;&nbsp;</a></span>reverse_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> T seq::reverse_bits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a563c78745a64d62dffe9db8ead6c59b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563c78745a64d62dffe9db8ead6c59b3">&#9670;&nbsp;</a></span>split() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Skip  = no_skip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Skip&#160;</td>
          <td class="paramname"><em>skip</em> = <code>Skip()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_split_iter.html">detail::SplitIter</a>&lt;<a class="el" href="structseq_1_1by__string.html">by_string</a>, Skip&gt; &gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18b811191ca77f9bf39346b6d30ae4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b811191ca77f9bf39346b6d30ae4d0">&#9670;&nbsp;</a></span>split() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Skip  = no_skip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Skip&#160;</td>
          <td class="paramname"><em>skip</em> = <code>Skip()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_split_iter.html">detail::SplitIter</a>&lt;<a class="el" href="structseq_1_1by__char.html">by_char</a>, Skip&gt; &gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36473c179443ac54eaec04624d16fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36473c179443ac54eaec04624d16fe1d">&#9670;&nbsp;</a></span>split() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Match , class Skip  = no_skip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#ad49cae5f5b0deacb82496c90c7953388">tstring_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1match__base.html">match_base</a>&lt; Match &gt; &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Skip&#160;</td>
          <td class="paramname"><em>skip</em> = <code>Skip()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structseq_1_1detail_1_1_split_iter.html">detail::SplitIter</a>&lt;Match, Skip&gt; &gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="addd2941446a52e1c8ea5894d0a6ddbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd2941446a52e1c8ea5894d0a6ddbdc">&#9670;&nbsp;</a></span>string_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; const Char* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string data (const char*) for given string object. </p>

</div>
</div>
<a id="a7aaa959e4bd65e5c34ce50d52eaed781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aaa959e4bd65e5c34ce50d52eaed781">&#9670;&nbsp;</a></span>string_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; const Char* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f7319f4efbdf6e6e22bf008804fa59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7319f4efbdf6e6e22bf008804fa59c">&#9670;&nbsp;</a></span>string_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_data </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; const Char* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7003288989da375f3058bee852965ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7003288989da375f3058bee852965ad0">&#9670;&nbsp;</a></span>string_size() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Char, Traits, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string size for given string object. </p>

</div>
</div>
<a id="a5e4cd270107200e9e64fbe2e74a0066f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4cd270107200e9e64fbe2e74a0066f">&#9670;&nbsp;</a></span>string_size() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char , class Traits , class Al , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiny__string.html">tiny_string</a>&lt; Char, Traits, Al, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48302925a280dbce105cd46f7677f8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48302925a280dbce105cd46f7677f8ab">&#9670;&nbsp;</a></span>string_size() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::string_size </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a76e83b922f85075d41cf05cbf365dc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e83b922f85075d41cf05cbf365dc07">&#9670;&nbsp;</a></span>swap_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::swap_allocator </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap allocators for container.swap member. </p>

</div>
</div>
<a id="ad863fcfc143b646f5a2f2362a1327575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad863fcfc143b646f5a2f2362a1327575">&#9670;&nbsp;</a></span>tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::tick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For tests only, reset timer for calling thread. </p>

</div>
</div>
<a id="aaade1f4ec092684337563886384d3aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaade1f4ec092684337563886384d3aaf">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first output character </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>input value to convert to string </td></tr>
    <tr><td class="paramname">base</td><td>integer base (default to 10) </td></tr>
    <tr><td class="paramname">fmt</td><td>optional format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result. ">to_chars_result</a> object</dd></dl>
<p>value is converted to a string of digits in the given base (with no redundant leading zeroes by default). Digits in the range 10..35 (inclusive) are represented as lowercase characters a..z by default. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type char as the type of the parameter value. This function produces a similar output as std::to_chars.</p>
<p>Output formatting can be controlled through a #integral_chars_format object:</p><ul>
<li>Digits in the range 10..35 (inclusive) can be represented as uppercase characters A..Z with <a class="el" href="structseq_1_1integral__chars__format.html#acafd17ef17d30b606b9c7087ec7e8d73" title="Output upper characters for hexadecimal numbers. ">integral_chars_format::upper_case</a></li>
<li>For base 16, a trailing '0x' can be added with <a class="el" href="structseq_1_1integral__chars__format.html#adbac65c685a9d5c9021e228cee354eed" title="Add &#39;0x&#39; prefix to hexadecimal numbers. ">integral_chars_format::hex_prefix</a></li>
<li>A minimum width (in number of digits) can be specified to add leading zeros with <a class="el" href="structseq_1_1integral__chars__format.html#a7fd219f1f9f4a2d0760313d06a378f3a" title="Minimum digits to represent integral types (use zero padding). ">integral_chars_format::integral_min_width</a></li>
</ul>
<p>On success, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result. ">seq::to_chars_result</a> such that ec equals value-initialized std::errc and ptr is the one-past-the-end pointer of the characters written. Note that the string is not NULL-terminated.</p>
<p>On error, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result. ">seq::to_chars_result</a> holding std::errc::value_too_large in ec, a copy of the value last in ptr, and leaves the contents of the range[first, last) in unspecified state. </p>

</div>
</div>
<a id="a099d83f326c156da30ad657ad718ea4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099d83f326c156da30ad657ad718ea4c">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad25c9658376d453f2a56a173746672c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25c9658376d453f2a56a173746672c9">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afcd334ad81488273a36930fece9304ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd334ad81488273a36930fece9304ed">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed606c84f8e4c850d5b68a054ce0a15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed606c84f8e4c850d5b68a054ce0a15e">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaab1e86cd0b413375e5e592efa851fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaab1e86cd0b413375e5e592efa851fe">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab247e78aa5765ba115078d0224c49c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab247e78aa5765ba115078d0224c49c16">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d0956a6e8b7a3bbf55aa5457d39119f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0956a6e8b7a3bbf55aa5457d39119f">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fce5d7e14a9d6daf2307355d4c396ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fce5d7e14a9d6daf2307355d4c396ad">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefccfef5bd4c953871f7d35dd07bd43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefccfef5bd4c953871f7d35dd07bd43d">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd91e37c46eb88e41f560947130f5473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd91e37c46eb88e41f560947130f5473">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9848bd29c3454546f0851b641a010741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9848bd29c3454546f0851b641a010741">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first output character </td></tr>
    <tr><td class="paramname">last</td><td>past-the-end character </td></tr>
    <tr><td class="paramname">value</td><td>input value to convert to string </td></tr>
    <tr><td class="paramname">fmt</td><td>floating-point formatting to use, a bitmask of type <a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682" title="A BitmaskType used to specify floating-point formatting for seq::to_chars. This is similar to std::ch...">seq::chars_format</a> </td></tr>
    <tr><td class="paramname">precision</td><td>maximum digits after the radix point </td></tr>
    <tr><td class="paramname">fmt</td><td>optional format </td></tr>
    <tr><td class="paramname">dot</td><td>optional decimal point sequence, default to "." </td></tr>
    <tr><td class="paramname">exp</td><td>optional exponential character, default to 'e' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result. ">to_chars_result</a> object</dd></dl>
<p>value is converted to a string as if by std::printf in the default ("C") locale (with some differences, see below). This function DOES NOT provide exact formatting of the input unlike printf familly of functions.</p>
<p>The conversion specifier is 'f' or 'e' (resolving in favor of f in case of a tie), chosen according to the requirement for a shortest representation: the string representation consists of the smallest number of characters such that there is at least one digit before the radix point (if present).</p>
<p>The conversion specified for the as-if printf is 'f' if fmt is seq::chars_format::fixed, 'e' if fmt is seq::chars_format::scientific, and 'g' if fmt is chars_format::general (default).</p>
<p>If the precision is specified by the parameter 'precision', this function will output up-to (but to necessarily exactly) 'precision' digits after the radix point. The default precision is 6. This function will always try to output the smallest possible character sequence. If 'dot' is specified, it will replace the '.' decimal point used by the "C" locale.</p>
<p>If 'exp' is specified, it will replace the 'e' exponent character used by the "C" locale.</p>
<p>NaN and infinit values are handled by this function.</p>
<p>On success, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result. ">seq::to_chars_result</a> such that ec equals value-initialized std::errc and ptr is the one-past-the-end pointer of the characters written. Note that the string is not NULL-terminated.</p>
<p>On error, returns a value of type <a class="el" href="structseq_1_1to__chars__result.html" title="Return type for seq::to_chars functions, similar to std::to_chars_result. ">seq::to_chars_result</a> holding std::errc::value_too_large in ec, a copy of the value last in ptr, and leaves the contents of the range[first, last) in unspecified state.</p>
<p>There are currently a lot of different algorithms to provide fast and exact convertion of floating point values to strings: ryu, grisu-exact, dragonbox... This function tries to provide a faster and lighter alternative when exact precision is not a requirement (which is my case). Internal benchmarks show that convertiing double values to string using this function is around 2 times faster than with ryu library for scientific or general formatting, and 3 times faster with fixed formatting.</p>
<p>When converting double values, obtained strings are similar to the result of printf in 100% of the cases when the required precision is below 12. After that, the ratio decreases to 87% of exactitude for a precision of 17. Converting a very high (or very small) value with the 'f' specifier will usually produce slightly different output, especially in the "garbade" digits.</p>
<p>Use this function when you need very fast formatting of a huge amount of floating point values without exact formatting requirement. </p>

</div>
</div>
<a id="a5b0180d389d8f3068a5df2e6d5dfc803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0180d389d8f3068a5df2e6d5dfc803">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62e708206c2575bd63ab6b4d52e58a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e708206c2575bd63ab6b4d52e58a78">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1ccb0a2e6e282ce1c7c5176a32274da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ccb0a2e6e282ce1c7c5176a32274da">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c8eb39bb928f38502c5a6433d1478c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8eb39bb928f38502c5a6433d1478c2">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6cbe0f00262b2bbd898d26c35a15f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cbe0f00262b2bbd898d26c35a15f05">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a774b42dc254e78ac416a8466308c4dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774b42dc254e78ac416a8466308c4dc3">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>exp</em> = <code>'e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d8fd1f2d9c6c556f7a8057230c2969b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8fd1f2d9c6c556f7a8057230c2969b">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>exp</em> = <code>'e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25ec4de73a0ecf29b16cf62709e1c3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ec4de73a0ecf29b16cf62709e1c3a8">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga89bbfc3be29174b51bb075417a8a1d1f">SEQ_EXPORT</a> auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceseq.html#a19a45e1f866d73140819b9ea2280c682">chars_format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dot</em> = <code>'.'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>exp</em> = <code>'e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac778d2e1714b0bc1a988a8ef573fed6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac778d2e1714b0bc1a988a8ef573fed6e">&#9670;&nbsp;</a></span>to_chars() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::to_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="structseq_1_1integral__chars__format.html">integral_chars_format</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structseq_1_1to__chars__result.html">to_chars_result</a>=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a576ae74a514ded550299e48e4c32cc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576ae74a514ded550299e48e4c32cc64">&#9670;&nbsp;</a></span>tock_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto seq::tock_ms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::uint64_t
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For tests only, returns elapsed milliseconds since last call to <a class="el" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575" title="For tests only, reset timer for calling thread. ">tick()</a> </p>

</div>
</div>
<a id="a1349a44a2ff37300a5c72a03780780fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1349a44a2ff37300a5c72a03780780fe">&#9670;&nbsp;</a></span>unique_ptr_delete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::unique_ptr_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate pointer previously held by a std::unqiue_ptr&lt;T,unique_ptr_deleter&lt;T&gt; &gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2480216425c6423b34df46e854b9764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2480216425c6423b34df46e854b9764">&#9670;&nbsp;</a></span>write_BE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_BE_64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 64 bits integer value to dst in big endian order. </p>

</div>
</div>
<a id="a8aa0f34c5b9efbaacd24ae215c6ebdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa0f34c5b9efbaacd24ae215c6ebdfe">&#9670;&nbsp;</a></span>write_LE_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_LE_16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 16 bits integer value to dst in little endian order. </p>

</div>
</div>
<a id="abbce06d3b6c0dd24ef956b3bba564914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbce06d3b6c0dd24ef956b3bba564914">&#9670;&nbsp;</a></span>write_LE_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_LE_32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 32 bits integer value to dst in little endian order. </p>

</div>
</div>
<a id="a2dd16ebc1860bdc316a5f83c8210a361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd16ebc1860bdc316a5f83c8210a361">&#9670;&nbsp;</a></span>write_LE_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seq::write_LE_64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write 64 bits integer value to dst in little endian order. </p>

</div>
</div>
<a id="ac2ff14a56a7dc2b518fbc19b289b6ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ff14a56a7dc2b518fbc19b289b6ca2">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterable1 , class Iterable2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto seq::zip </td>
          <td>(</td>
          <td class="paramtype">const Iterable1 &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterable2 &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="structseq_1_1detail_1_1_zip_iterator.html">detail::ZipIterator</a>&lt;typename Iterable1::const_iterator, typename Iterable2::const_iterator&gt;&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
