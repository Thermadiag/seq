<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: sequence&lt; T, Allocator, layout, ChunkAllocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsequence.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsequence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sequence&lt; T, Allocator, layout, ChunkAllocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>sequence is an ordered container supporting constant time removal and insertion at both end and .  
 <a href="classsequence.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sequence_8hpp_source.html">sequence.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="structdetail_1_1base__container.html">detail::base_container&lt; T &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab3895842306e59e5f8d7cd3b7246ed24"><td class="memItemLeft" align="right" valign="top"><a id="ab3895842306e59e5f8d7cd3b7246ed24"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:ab3895842306e59e5f8d7cd3b7246ed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb86b0cca50fff17300b965ce95785bb"><td class="memItemLeft" align="right" valign="top"><a id="acb86b0cca50fff17300b965ce95785bb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = T *</td></tr>
<tr class="separator:acb86b0cca50fff17300b965ce95785bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32133cb3b79be7b19a98f5efc2783d7b"><td class="memItemLeft" align="right" valign="top"><a id="a32133cb3b79be7b19a98f5efc2783d7b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = T &amp;</td></tr>
<tr class="separator:a32133cb3b79be7b19a98f5efc2783d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd2b540fb9e49684c80fb7d6789c0b"><td class="memItemLeft" align="right" valign="top"><a id="af9fd2b540fb9e49684c80fb7d6789c0b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const T *</td></tr>
<tr class="separator:af9fd2b540fb9e49684c80fb7d6789c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101676946d2f40946522bd205dfb2985"><td class="memItemLeft" align="right" valign="top"><a id="a101676946d2f40946522bd205dfb2985"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename std::allocator_traits&lt; Allocator &gt;::difference_type</td></tr>
<tr class="separator:a101676946d2f40946522bd205dfb2985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb4332855685a26d8e6de5286c320d3"><td class="memItemLeft" align="right" valign="top"><a id="aadb4332855685a26d8e6de5286c320d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename std::allocator_traits&lt; Allocator &gt;::size_type</td></tr>
<tr class="separator:aadb4332855685a26d8e6de5286c320d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0477ff369c9a1af599f9777eb643fc45"><td class="memItemLeft" align="right" valign="top"><a id="a0477ff369c9a1af599f9777eb643fc45"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structdetail_1_1sequence__iterator.html">detail::sequence_iterator</a>&lt; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout &gt; &gt;</td></tr>
<tr class="separator:a0477ff369c9a1af599f9777eb643fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715f06733f0271869c6dc4d564b5eeac"><td class="memItemLeft" align="right" valign="top"><a id="a715f06733f0271869c6dc4d564b5eeac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structdetail_1_1sequence__const__iterator.html">detail::sequence_const_iterator</a>&lt; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout &gt; &gt;</td></tr>
<tr class="separator:a715f06733f0271869c6dc4d564b5eeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771b0d23fcae2c877e0cb79fcd9c485b"><td class="memItemLeft" align="right" valign="top"><a id="a771b0d23fcae2c877e0cb79fcd9c485b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a771b0d23fcae2c877e0cb79fcd9c485b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d1c9d31adc8bc25c480c529478366f"><td class="memItemLeft" align="right" valign="top"><a id="a72d1c9d31adc8bc25c480c529478366f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a72d1c9d31adc8bc25c480c529478366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3895842306e59e5f8d7cd3b7246ed24"><td class="memItemLeft" align="right" valign="top"><a id="ab3895842306e59e5f8d7cd3b7246ed24"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:ab3895842306e59e5f8d7cd3b7246ed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb86b0cca50fff17300b965ce95785bb"><td class="memItemLeft" align="right" valign="top"><a id="acb86b0cca50fff17300b965ce95785bb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = T *</td></tr>
<tr class="separator:acb86b0cca50fff17300b965ce95785bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32133cb3b79be7b19a98f5efc2783d7b"><td class="memItemLeft" align="right" valign="top"><a id="a32133cb3b79be7b19a98f5efc2783d7b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = T &amp;</td></tr>
<tr class="separator:a32133cb3b79be7b19a98f5efc2783d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd2b540fb9e49684c80fb7d6789c0b"><td class="memItemLeft" align="right" valign="top"><a id="af9fd2b540fb9e49684c80fb7d6789c0b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const T *</td></tr>
<tr class="separator:af9fd2b540fb9e49684c80fb7d6789c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101676946d2f40946522bd205dfb2985"><td class="memItemLeft" align="right" valign="top"><a id="a101676946d2f40946522bd205dfb2985"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename std::allocator_traits&lt; Allocator &gt;::difference_type</td></tr>
<tr class="separator:a101676946d2f40946522bd205dfb2985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb4332855685a26d8e6de5286c320d3"><td class="memItemLeft" align="right" valign="top"><a id="aadb4332855685a26d8e6de5286c320d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename std::allocator_traits&lt; Allocator &gt;::size_type</td></tr>
<tr class="separator:aadb4332855685a26d8e6de5286c320d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0477ff369c9a1af599f9777eb643fc45"><td class="memItemLeft" align="right" valign="top"><a id="a0477ff369c9a1af599f9777eb643fc45"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structdetail_1_1sequence__iterator.html">detail::sequence_iterator</a>&lt; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout &gt; &gt;</td></tr>
<tr class="separator:a0477ff369c9a1af599f9777eb643fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715f06733f0271869c6dc4d564b5eeac"><td class="memItemLeft" align="right" valign="top"><a id="a715f06733f0271869c6dc4d564b5eeac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structdetail_1_1sequence__const__iterator.html">detail::sequence_const_iterator</a>&lt; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout &gt; &gt;</td></tr>
<tr class="separator:a715f06733f0271869c6dc4d564b5eeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771b0d23fcae2c877e0cb79fcd9c485b"><td class="memItemLeft" align="right" valign="top"><a id="a771b0d23fcae2c877e0cb79fcd9c485b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a771b0d23fcae2c877e0cb79fcd9c485b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d1c9d31adc8bc25c480c529478366f"><td class="memItemLeft" align="right" valign="top"><a id="a72d1c9d31adc8bc25c480c529478366f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a72d1c9d31adc8bc25c480c529478366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3895842306e59e5f8d7cd3b7246ed24"><td class="memItemLeft" align="right" valign="top"><a id="ab3895842306e59e5f8d7cd3b7246ed24"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:ab3895842306e59e5f8d7cd3b7246ed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb86b0cca50fff17300b965ce95785bb"><td class="memItemLeft" align="right" valign="top"><a id="acb86b0cca50fff17300b965ce95785bb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = T *</td></tr>
<tr class="separator:acb86b0cca50fff17300b965ce95785bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32133cb3b79be7b19a98f5efc2783d7b"><td class="memItemLeft" align="right" valign="top"><a id="a32133cb3b79be7b19a98f5efc2783d7b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = T &amp;</td></tr>
<tr class="separator:a32133cb3b79be7b19a98f5efc2783d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd2b540fb9e49684c80fb7d6789c0b"><td class="memItemLeft" align="right" valign="top"><a id="af9fd2b540fb9e49684c80fb7d6789c0b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const T *</td></tr>
<tr class="separator:af9fd2b540fb9e49684c80fb7d6789c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae427d5324f9ce4cd83b3566a6f1cfc90"><td class="memItemLeft" align="right" valign="top"><a id="ae427d5324f9ce4cd83b3566a6f1cfc90"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:ae427d5324f9ce4cd83b3566a6f1cfc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101676946d2f40946522bd205dfb2985"><td class="memItemLeft" align="right" valign="top"><a id="a101676946d2f40946522bd205dfb2985"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename std::allocator_traits&lt; Allocator &gt;::difference_type</td></tr>
<tr class="separator:a101676946d2f40946522bd205dfb2985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb4332855685a26d8e6de5286c320d3"><td class="memItemLeft" align="right" valign="top"><a id="aadb4332855685a26d8e6de5286c320d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename std::allocator_traits&lt; Allocator &gt;::size_type</td></tr>
<tr class="separator:aadb4332855685a26d8e6de5286c320d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0477ff369c9a1af599f9777eb643fc45"><td class="memItemLeft" align="right" valign="top"><a id="a0477ff369c9a1af599f9777eb643fc45"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structdetail_1_1sequence__iterator.html">detail::sequence_iterator</a>&lt; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout &gt; &gt;</td></tr>
<tr class="separator:a0477ff369c9a1af599f9777eb643fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715f06733f0271869c6dc4d564b5eeac"><td class="memItemLeft" align="right" valign="top"><a id="a715f06733f0271869c6dc4d564b5eeac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structdetail_1_1sequence__const__iterator.html">detail::sequence_const_iterator</a>&lt; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout &gt; &gt;</td></tr>
<tr class="separator:a715f06733f0271869c6dc4d564b5eeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771b0d23fcae2c877e0cb79fcd9c485b"><td class="memItemLeft" align="right" valign="top"><a id="a771b0d23fcae2c877e0cb79fcd9c485b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a771b0d23fcae2c877e0cb79fcd9c485b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d1c9d31adc8bc25c480c529478366f"><td class="memItemLeft" align="right" valign="top"><a id="a72d1c9d31adc8bc25c480c529478366f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a72d1c9d31adc8bc25c480c529478366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adaab09b0e1c9cd9bbe2be3712439f273"><td class="memItemLeft" align="right" valign="top"><a id="adaab09b0e1c9cd9bbe2be3712439f273"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (const Allocator &amp;al)</td></tr>
<tr class="separator:adaab09b0e1c9cd9bbe2be3712439f273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769d6a3bc55f80cb3eed997644ae830e"><td class="memItemLeft" align="right" valign="top"><a id="a769d6a3bc55f80cb3eed997644ae830e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (const ChunkAllocator &amp;al)</td></tr>
<tr class="separator:a769d6a3bc55f80cb3eed997644ae830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad373880330bbc219f447ee324347c363"><td class="memItemLeft" align="right" valign="top"><a id="ad373880330bbc219f447ee324347c363"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (size_type count, const T &amp;value, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:ad373880330bbc219f447ee324347c363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504e733fb40e43e2124dfba8f1b10207"><td class="memItemLeft" align="right" valign="top"><a id="a504e733fb40e43e2124dfba8f1b10207"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (size_type count, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a504e733fb40e43e2124dfba8f1b10207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20548d0819815e25e98de41126938379"><td class="memItemLeft" align="right" valign="top"><a id="a20548d0819815e25e98de41126938379"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (const <a class="el" href="classsequence.html">sequence</a> &amp;other)</td></tr>
<tr class="separator:a20548d0819815e25e98de41126938379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787e1ac109e4dbf319373187ce58e8ee"><td class="memItemLeft" align="right" valign="top"><a id="a787e1ac109e4dbf319373187ce58e8ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (const <a class="el" href="classsequence.html">sequence</a> &amp;other, const Allocator &amp;al)</td></tr>
<tr class="separator:a787e1ac109e4dbf319373187ce58e8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f73489ed348af13a75dea0b02df289"><td class="memItemLeft" align="right" valign="top"><a id="aa0f73489ed348af13a75dea0b02df289"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (<a class="el" href="classsequence.html">sequence</a> &amp;&amp;other)</td></tr>
<tr class="separator:aa0f73489ed348af13a75dea0b02df289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbabe7bd3840123b24f044b76f25c70"><td class="memItemLeft" align="right" valign="top"><a id="acdbabe7bd3840123b24f044b76f25c70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (const std::initializer_list&lt; T &gt; &amp;lst, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:acdbabe7bd3840123b24f044b76f25c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="memTemplParams" colspan="2"><a id="a6c56466582b25edd3e70dbdcdf0cb0f9"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequence</b> (Iter first, Iter last, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b465afa1146b81ab74635d23fe842a"><td class="memItemLeft" align="right" valign="top"><a id="aa6b465afa1146b81ab74635d23fe842a"></a>
Data *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> ()</td></tr>
<tr class="separator:aa6b465afa1146b81ab74635d23fe842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999127d3e890634852b775a70205f5e5"><td class="memItemLeft" align="right" valign="top"><a id="a999127d3e890634852b775a70205f5e5"></a>
const Data *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const</td></tr>
<tr class="separator:a999127d3e890634852b775a70205f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc2643aec7dbdf12546e82254f4e5aa"><td class="memItemLeft" align="right" valign="top"><a id="a5fc2643aec7dbdf12546e82254f4e5aa"></a>
layout_manager &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> () noexcept</td></tr>
<tr class="separator:a5fc2643aec7dbdf12546e82254f4e5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb351406b91966f065c19642436f143"><td class="memItemLeft" align="right" valign="top"><a id="a1fb351406b91966f065c19642436f143"></a>
const layout_manager &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> () const noexcept</td></tr>
<tr class="separator:a1fb351406b91966f065c19642436f143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f24939e2050de1b2d2fab0ab5be93b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#ad2f24939e2050de1b2d2fab0ab5be93b">memory_footprint</a> () const noexcept</td></tr>
<tr class="separator:ad2f24939e2050de1b2d2fab0ab5be93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fb2d06c72a27dd7a19e6d4ee835a68"><td class="memItemLeft" align="right" valign="top"><a id="a97fb2d06c72a27dd7a19e6d4ee835a68"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="separator:a97fb2d06c72a27dd7a19e6d4ee835a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9386f3eba97030a06d242058c5a70b"><td class="memItemLeft" align="right" valign="top"><a id="aea9386f3eba97030a06d242058c5a70b"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> () const noexcept</td></tr>
<tr class="separator:aea9386f3eba97030a06d242058c5a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7bf1dd2090d7024e5432e7c0a09d37"><td class="memItemLeft" align="right" valign="top"><a id="abe7bf1dd2090d7024e5432e7c0a09d37"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> () noexcept</td></tr>
<tr class="separator:abe7bf1dd2090d7024e5432e7c0a09d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35989eeb997ec25897236eb6dc1ee1ea"><td class="memItemLeft" align="right" valign="top"><a id="a35989eeb997ec25897236eb6dc1ee1ea"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> () const noexcept</td></tr>
<tr class="separator:a35989eeb997ec25897236eb6dc1ee1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64124d3629fafa19b29a1d5f29bd8a36"><td class="memItemLeft" align="right" valign="top"><a id="a64124d3629fafa19b29a1d5f29bd8a36"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> () noexcept</td></tr>
<tr class="separator:a64124d3629fafa19b29a1d5f29bd8a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0305beac5abda33a1edf8a78c1baf9ec"><td class="memItemLeft" align="right" valign="top"><a id="a0305beac5abda33a1edf8a78c1baf9ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a0305beac5abda33a1edf8a78c1baf9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c928053fd857c85152e8481c9085fd"><td class="memTemplParams" colspan="2"><a id="a26c928053fd857c85152e8481c9085fd"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a26c928053fd857c85152e8481c9085fd"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a26c928053fd857c85152e8481c9085fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa0bfb1b661c56015fc0ed5d0f66094"><td class="memItemLeft" align="right" valign="top"><a id="a2fa0bfb1b661c56015fc0ed5d0f66094"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (const T &amp;value)</td></tr>
<tr class="separator:a2fa0bfb1b661c56015fc0ed5d0f66094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771d78864810b402bef7f9472e2839d7"><td class="memItemLeft" align="right" valign="top"><a id="a771d78864810b402bef7f9472e2839d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a771d78864810b402bef7f9472e2839d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69253c2d613ac1106f8ea904c49b1705"><td class="memTemplParams" colspan="2"><a id="a69253c2d613ac1106f8ea904c49b1705"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a69253c2d613ac1106f8ea904c49b1705"><td class="memTemplItemLeft" align="right" valign="top">INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back_iter</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a69253c2d613ac1106f8ea904c49b1705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ff734a47a8147615d19cb0e65bc404"><td class="memItemLeft" align="right" valign="top"><a id="a91ff734a47a8147615d19cb0e65bc404"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>push_back_iter</b> (const T &amp;value)</td></tr>
<tr class="separator:a91ff734a47a8147615d19cb0e65bc404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb93a2a891317681bb5d7e72007ae35d"><td class="memItemLeft" align="right" valign="top"><a id="aeb93a2a891317681bb5d7e72007ae35d"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>push_back_iter</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:aeb93a2a891317681bb5d7e72007ae35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="memTemplParams" colspan="2"><a id="a9da3b4f3576e5dda10cccd6f25eaa20c"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_front</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44390ab9d37afd652166ea06aa61581b"><td class="memItemLeft" align="right" valign="top"><a id="a44390ab9d37afd652166ea06aa61581b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (const T &amp;value)</td></tr>
<tr class="separator:a44390ab9d37afd652166ea06aa61581b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646323fdac2528501cbec140df3356dc"><td class="memItemLeft" align="right" valign="top"><a id="a646323fdac2528501cbec140df3356dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a646323fdac2528501cbec140df3356dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a25695fe2ba05ac0cfe55bd70e61606"><td class="memItemLeft" align="right" valign="top"><a id="a5a25695fe2ba05ac0cfe55bd70e61606"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type new_size)</td></tr>
<tr class="separator:a5a25695fe2ba05ac0cfe55bd70e61606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74929c7aba23d9f27e0896a512781824"><td class="memItemLeft" align="right" valign="top"><a id="a74929c7aba23d9f27e0896a512781824"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type new_size, const T &amp;value)</td></tr>
<tr class="separator:a74929c7aba23d9f27e0896a512781824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354a7a5d4b51f8861cee2fa6f323d529"><td class="memItemLeft" align="right" valign="top"><a id="a354a7a5d4b51f8861cee2fa6f323d529"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_front</b> (size_type new_size)</td></tr>
<tr class="separator:a354a7a5d4b51f8861cee2fa6f323d529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeeef9733fbffc481814e0280c844d8"><td class="memItemLeft" align="right" valign="top"><a id="abbeeef9733fbffc481814e0280c844d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_front</b> (size_type new_size, const T &amp;value)</td></tr>
<tr class="separator:abbeeef9733fbffc481814e0280c844d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="memTemplParams" colspan="2"><a id="ae07666f6c9dd6d86e4dd3bf6af428c33"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (Iter first, Iter last)</td></tr>
<tr class="separator:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1677cc0e4614b53fe4982ad75da3a73"><td class="memItemLeft" align="right" valign="top"><a id="aa1677cc0e4614b53fe4982ad75da3a73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="separator:aa1677cc0e4614b53fe4982ad75da3a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c333756a4f16abaf0c6cc120b2d585"><td class="memItemLeft" align="right" valign="top"><a id="a21c333756a4f16abaf0c6cc120b2d585"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (size_type count, const T &amp;value)</td></tr>
<tr class="separator:a21c333756a4f16abaf0c6cc120b2d585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d851eb2405943b78ea1a4ceb5dbc5e9"><td class="memTemplParams" colspan="2"><a id="a1d851eb2405943b78ea1a4ceb5dbc5e9"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a1d851eb2405943b78ea1a4ceb5dbc5e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, Iter begin, Iter end)</td></tr>
<tr class="separator:a1d851eb2405943b78ea1a4ceb5dbc5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accef60a4a30f148f8d828d09c97010ac"><td class="memItemLeft" align="right" valign="top"><a id="accef60a4a30f148f8d828d09c97010ac"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="separator:accef60a4a30f148f8d828d09c97010ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2c111ccb4c46ab76a569b88476dbb2"><td class="memItemLeft" align="right" valign="top"><a id="ade2c111ccb4c46ab76a569b88476dbb2"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, size_type count, const T &amp;value)</td></tr>
<tr class="separator:ade2c111ccb4c46ab76a569b88476dbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcddc578d197cdca156faf1f3d1b3d06"><td class="memTemplParams" colspan="2"><a id="abcddc578d197cdca156faf1f3d1b3d06"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:abcddc578d197cdca156faf1f3d1b3d06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_anywhere</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:abcddc578d197cdca156faf1f3d1b3d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c7bb3c11340827abb35e9011c6a19e"><td class="memItemLeft" align="right" valign="top"><a id="ac0c7bb3c11340827abb35e9011c6a19e"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_anywhere</b> (const T &amp;value)</td></tr>
<tr class="separator:ac0c7bb3c11340827abb35e9011c6a19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6600a474fe05486bc95356149bb926"><td class="memItemLeft" align="right" valign="top"><a id="a8e6600a474fe05486bc95356149bb926"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_anywhere</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a8e6600a474fe05486bc95356149bb926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1600c966ef245a06d8b4b7320fccc2e"><td class="memTemplParams" colspan="2"><a id="aa1600c966ef245a06d8b4b7320fccc2e"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa1600c966ef245a06d8b4b7320fccc2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, Args &amp;&amp;... args)</td></tr>
<tr class="separator:aa1600c966ef245a06d8b4b7320fccc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e55b2eab0b32a681f96ed6721010fb3"><td class="memItemLeft" align="right" valign="top"><a id="a3e55b2eab0b32a681f96ed6721010fb3"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, const T &amp;value)</td></tr>
<tr class="separator:a3e55b2eab0b32a681f96ed6721010fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cc3bf5f62c72d62e90a52172ceecb1"><td class="memItemLeft" align="right" valign="top"><a id="aa9cc3bf5f62c72d62e90a52172ceecb1"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, T &amp;&amp;value)</td></tr>
<tr class="separator:aa9cc3bf5f62c72d62e90a52172ceecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50c2082fc8950503cefb3757f4aea88"><td class="memItemLeft" align="right" valign="top"><a id="aa50c2082fc8950503cefb3757f4aea88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="separator:aa50c2082fc8950503cefb3757f4aea88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9020aac0b3608a3f2669da85552f6e"><td class="memItemLeft" align="right" valign="top"><a id="abb9020aac0b3608a3f2669da85552f6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (size_t size)</td></tr>
<tr class="separator:abb9020aac0b3608a3f2669da85552f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870663bf39ecd823c27209a0e6dbec6d"><td class="memItemLeft" align="right" valign="top"><a id="a870663bf39ecd823c27209a0e6dbec6d"></a>
Allocator&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const noexcept</td></tr>
<tr class="separator:a870663bf39ecd823c27209a0e6dbec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af718d9b330f3003712989145722c2c71"><td class="memItemLeft" align="right" valign="top"><a id="af718d9b330f3003712989145722c2c71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_front</b> () noexcept</td></tr>
<tr class="separator:af718d9b330f3003712989145722c2c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1abcdc4e8a28ccdf5f2f773545c0553"><td class="memItemLeft" align="right" valign="top"><a id="aa1abcdc4e8a28ccdf5f2f773545c0553"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> () noexcept</td></tr>
<tr class="separator:aa1abcdc4e8a28ccdf5f2f773545c0553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40ac8ecd47e9fe7328409b978bedf78"><td class="memItemLeft" align="right" valign="top"><a id="ad40ac8ecd47e9fe7328409b978bedf78"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_at</b> (size_type pos) noexcept</td></tr>
<tr class="separator:ad40ac8ecd47e9fe7328409b978bedf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e97d78db6b640c4b4b95daaa16bf332"><td class="memItemLeft" align="right" valign="top"><a id="a6e97d78db6b640c4b4b95daaa16bf332"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_at</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a6e97d78db6b640c4b4b95daaa16bf332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b9bc6d5992a987540c2802c0cc8005"><td class="memItemLeft" align="right" valign="top"><a id="a47b9bc6d5992a987540c2802c0cc8005"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> it) noexcept</td></tr>
<tr class="separator:a47b9bc6d5992a987540c2802c0cc8005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a94e38d9abffa69703632925b77e3b"><td class="memItemLeft" align="right" valign="top"><a id="a12a94e38d9abffa69703632925b77e3b"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> first, <a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="separator:a12a94e38d9abffa69703632925b77e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b0474851aea2bc97281fa45e6a12e5"><td class="memItemLeft" align="right" valign="top"><a id="a46b0474851aea2bc97281fa45e6a12e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort</b> ()</td></tr>
<tr class="separator:a46b0474851aea2bc97281fa45e6a12e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67217477cd30beb1f2209d6a1f1a4c86"><td class="memTemplParams" colspan="2"><a id="a67217477cd30beb1f2209d6a1f1a4c86"></a>
template&lt;class Less &gt; </td></tr>
<tr class="memitem:a67217477cd30beb1f2209d6a1f1a4c86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (<a class="el" href="struct_less.html">Less</a> less)</td></tr>
<tr class="separator:a67217477cd30beb1f2209d6a1f1a4c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206c97c3bf360322fd6389ecb4c453ae"><td class="memItemLeft" align="right" valign="top"><a id="a206c97c3bf360322fd6389ecb4c453ae"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:a206c97c3bf360322fd6389ecb4c453ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4998dc243763bdb0df14a9625f1ad435"><td class="memItemLeft" align="right" valign="top"><a id="a4998dc243763bdb0df14a9625f1ad435"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a4998dc243763bdb0df14a9625f1ad435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81392c0c58ad4529b10fbe6edcb95656"><td class="memItemLeft" align="right" valign="top"><a id="a81392c0c58ad4529b10fbe6edcb95656"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a81392c0c58ad4529b10fbe6edcb95656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd2fb16fbb41b270faee83a217473aa"><td class="memItemLeft" align="right" valign="top"><a id="a5bd2fb16fbb41b270faee83a217473aa"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a5bd2fb16fbb41b270faee83a217473aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567daff77bd3c7ebbf6c0b6ab61720c6"><td class="memItemLeft" align="right" valign="top"><a id="a567daff77bd3c7ebbf6c0b6ab61720c6"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:a567daff77bd3c7ebbf6c0b6ab61720c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d59ea40863943c28cd61547ac89285"><td class="memItemLeft" align="right" valign="top"><a id="a03d59ea40863943c28cd61547ac89285"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:a03d59ea40863943c28cd61547ac89285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac20ca1d6b564f44cae2e7c1d96a90e7"><td class="memItemLeft" align="right" valign="top"><a id="aac20ca1d6b564f44cae2e7c1d96a90e7"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () noexcept</td></tr>
<tr class="separator:aac20ca1d6b564f44cae2e7c1d96a90e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c04a6a5fbfb24f3938daa32547971a"><td class="memItemLeft" align="right" valign="top"><a id="a45c04a6a5fbfb24f3938daa32547971a"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:a45c04a6a5fbfb24f3938daa32547971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b776d37ac1f1ee11fde9b29c2589f08"><td class="memItemLeft" align="right" valign="top"><a id="a9b776d37ac1f1ee11fde9b29c2589f08"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () noexcept</td></tr>
<tr class="separator:a9b776d37ac1f1ee11fde9b29c2589f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75737e419ee124b86e23071f0abb9e6e"><td class="memItemLeft" align="right" valign="top"><a id="a75737e419ee124b86e23071f0abb9e6e"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:a75737e419ee124b86e23071f0abb9e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e864797c312e25d2657d6e6ce4e252"><td class="memItemLeft" align="right" valign="top"><a id="a15e864797c312e25d2657d6e6ce4e252"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const noexcept</td></tr>
<tr class="separator:a15e864797c312e25d2657d6e6ce4e252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b0baf205cd89b8ff371dcf460bb23e"><td class="memItemLeft" align="right" valign="top"><a id="a49b0baf205cd89b8ff371dcf460bb23e"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="separator:a49b0baf205cd89b8ff371dcf460bb23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaab09b0e1c9cd9bbe2be3712439f273"><td class="memItemLeft" align="right" valign="top"><a id="adaab09b0e1c9cd9bbe2be3712439f273"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (const Allocator &amp;al)</td></tr>
<tr class="separator:adaab09b0e1c9cd9bbe2be3712439f273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad373880330bbc219f447ee324347c363"><td class="memItemLeft" align="right" valign="top"><a id="ad373880330bbc219f447ee324347c363"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (size_type count, const T &amp;value, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:ad373880330bbc219f447ee324347c363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504e733fb40e43e2124dfba8f1b10207"><td class="memItemLeft" align="right" valign="top"><a id="a504e733fb40e43e2124dfba8f1b10207"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (size_type count, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a504e733fb40e43e2124dfba8f1b10207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20548d0819815e25e98de41126938379"><td class="memItemLeft" align="right" valign="top"><a id="a20548d0819815e25e98de41126938379"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (const <a class="el" href="classsequence.html">sequence</a> &amp;other)</td></tr>
<tr class="separator:a20548d0819815e25e98de41126938379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787e1ac109e4dbf319373187ce58e8ee"><td class="memItemLeft" align="right" valign="top"><a id="a787e1ac109e4dbf319373187ce58e8ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (const <a class="el" href="classsequence.html">sequence</a> &amp;other, const Allocator &amp;al)</td></tr>
<tr class="separator:a787e1ac109e4dbf319373187ce58e8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f73489ed348af13a75dea0b02df289"><td class="memItemLeft" align="right" valign="top"><a id="aa0f73489ed348af13a75dea0b02df289"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (<a class="el" href="classsequence.html">sequence</a> &amp;&amp;other)</td></tr>
<tr class="separator:aa0f73489ed348af13a75dea0b02df289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1005c9df996d89f4adf53b593e666c"><td class="memItemLeft" align="right" valign="top"><a id="adf1005c9df996d89f4adf53b593e666c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (<a class="el" href="classsequence.html">sequence</a> &amp;&amp;other, const Allocator &amp;al)</td></tr>
<tr class="separator:adf1005c9df996d89f4adf53b593e666c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbabe7bd3840123b24f044b76f25c70"><td class="memItemLeft" align="right" valign="top"><a id="acdbabe7bd3840123b24f044b76f25c70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> (const std::initializer_list&lt; T &gt; &amp;lst, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:acdbabe7bd3840123b24f044b76f25c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="memTemplParams" colspan="2"><a id="a6c56466582b25edd3e70dbdcdf0cb0f9"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequence</b> (Iter first, Iter last, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1cf4f0dbceab1313cf14cbb9be8848"><td class="memItemLeft" align="right" valign="top"><a id="a9a1cf4f0dbceab1313cf14cbb9be8848"></a>
<a class="el" href="classsequence.html">sequence</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsequence.html">sequence</a> &amp;other)</td></tr>
<tr class="separator:a9a1cf4f0dbceab1313cf14cbb9be8848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3a906da8ff1ea5135d65bb786b497c"><td class="memItemLeft" align="right" valign="top"><a id="a5a3a906da8ff1ea5135d65bb786b497c"></a>
<a class="el" href="classsequence.html">sequence</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsequence.html">sequence</a> &amp;&amp;other)</td></tr>
<tr class="separator:a5a3a906da8ff1ea5135d65bb786b497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e671286a2cbd0c77f65a2be134b07f2"><td class="memItemLeft" align="right" valign="top"><a id="a3e671286a2cbd0c77f65a2be134b07f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classsequence.html">sequence</a> &amp;other)</td></tr>
<tr class="separator:a3e671286a2cbd0c77f65a2be134b07f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014ebd07a11538cefa9dcd090d0e4555"><td class="memItemLeft" align="right" valign="top"><a id="a014ebd07a11538cefa9dcd090d0e4555"></a>
Data *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () noexcept</td></tr>
<tr class="separator:a014ebd07a11538cefa9dcd090d0e4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1f97d9457f879441836d4d1426992f"><td class="memItemLeft" align="right" valign="top"><a id="abc1f97d9457f879441836d4d1426992f"></a>
const Data *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const noexcept</td></tr>
<tr class="separator:abc1f97d9457f879441836d4d1426992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f24939e2050de1b2d2fab0ab5be93b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#ad2f24939e2050de1b2d2fab0ab5be93b">memory_footprint</a> () const noexcept</td></tr>
<tr class="separator:ad2f24939e2050de1b2d2fab0ab5be93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fb2d06c72a27dd7a19e6d4ee835a68"><td class="memItemLeft" align="right" valign="top"><a id="a97fb2d06c72a27dd7a19e6d4ee835a68"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="separator:a97fb2d06c72a27dd7a19e6d4ee835a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9386f3eba97030a06d242058c5a70b"><td class="memItemLeft" align="right" valign="top"><a id="aea9386f3eba97030a06d242058c5a70b"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> () const noexcept</td></tr>
<tr class="separator:aea9386f3eba97030a06d242058c5a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7bf1dd2090d7024e5432e7c0a09d37"><td class="memItemLeft" align="right" valign="top"><a id="abe7bf1dd2090d7024e5432e7c0a09d37"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> () noexcept</td></tr>
<tr class="separator:abe7bf1dd2090d7024e5432e7c0a09d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35989eeb997ec25897236eb6dc1ee1ea"><td class="memItemLeft" align="right" valign="top"><a id="a35989eeb997ec25897236eb6dc1ee1ea"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> () const noexcept</td></tr>
<tr class="separator:a35989eeb997ec25897236eb6dc1ee1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64124d3629fafa19b29a1d5f29bd8a36"><td class="memItemLeft" align="right" valign="top"><a id="a64124d3629fafa19b29a1d5f29bd8a36"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> () noexcept</td></tr>
<tr class="separator:a64124d3629fafa19b29a1d5f29bd8a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7044ce880c5d679e49d211b095ff5f05"><td class="memItemLeft" align="right" valign="top"><a id="a7044ce880c5d679e49d211b095ff5f05"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> () noexcept</td></tr>
<tr class="separator:a7044ce880c5d679e49d211b095ff5f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c928053fd857c85152e8481c9085fd"><td class="memTemplParams" colspan="2"><a id="a26c928053fd857c85152e8481c9085fd"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a26c928053fd857c85152e8481c9085fd"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a26c928053fd857c85152e8481c9085fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4523ecdfdd34d66231c552e9e838d99a"><td class="memTemplParams" colspan="2"><a id="a4523ecdfdd34d66231c552e9e838d99a"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4523ecdfdd34d66231c552e9e838d99a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back_iter</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a4523ecdfdd34d66231c552e9e838d99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa0bfb1b661c56015fc0ed5d0f66094"><td class="memItemLeft" align="right" valign="top"><a id="a2fa0bfb1b661c56015fc0ed5d0f66094"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (const T &amp;value)</td></tr>
<tr class="separator:a2fa0bfb1b661c56015fc0ed5d0f66094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771d78864810b402bef7f9472e2839d7"><td class="memItemLeft" align="right" valign="top"><a id="a771d78864810b402bef7f9472e2839d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a771d78864810b402bef7f9472e2839d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="memTemplParams" colspan="2"><a id="a9da3b4f3576e5dda10cccd6f25eaa20c"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_front</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5d4624c1f847d68eb5928065424adf"><td class="memTemplParams" colspan="2"><a id="a4e5d4624c1f847d68eb5928065424adf"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4e5d4624c1f847d68eb5928065424adf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_front_iter</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a4e5d4624c1f847d68eb5928065424adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44390ab9d37afd652166ea06aa61581b"><td class="memItemLeft" align="right" valign="top"><a id="a44390ab9d37afd652166ea06aa61581b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (const T &amp;value)</td></tr>
<tr class="separator:a44390ab9d37afd652166ea06aa61581b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646323fdac2528501cbec140df3356dc"><td class="memItemLeft" align="right" valign="top"><a id="a646323fdac2528501cbec140df3356dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a646323fdac2528501cbec140df3356dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcddc578d197cdca156faf1f3d1b3d06"><td class="memTemplParams" colspan="2"><a id="abcddc578d197cdca156faf1f3d1b3d06"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:abcddc578d197cdca156faf1f3d1b3d06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_anywhere</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:abcddc578d197cdca156faf1f3d1b3d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c7bb3c11340827abb35e9011c6a19e"><td class="memItemLeft" align="right" valign="top"><a id="ac0c7bb3c11340827abb35e9011c6a19e"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_anywhere</b> (const T &amp;value)</td></tr>
<tr class="separator:ac0c7bb3c11340827abb35e9011c6a19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6600a474fe05486bc95356149bb926"><td class="memItemLeft" align="right" valign="top"><a id="a8e6600a474fe05486bc95356149bb926"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_anywhere</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a8e6600a474fe05486bc95356149bb926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a25695fe2ba05ac0cfe55bd70e61606"><td class="memItemLeft" align="right" valign="top"><a id="a5a25695fe2ba05ac0cfe55bd70e61606"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type new_size)</td></tr>
<tr class="separator:a5a25695fe2ba05ac0cfe55bd70e61606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74929c7aba23d9f27e0896a512781824"><td class="memItemLeft" align="right" valign="top"><a id="a74929c7aba23d9f27e0896a512781824"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type new_size, const T &amp;value)</td></tr>
<tr class="separator:a74929c7aba23d9f27e0896a512781824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354a7a5d4b51f8861cee2fa6f323d529"><td class="memItemLeft" align="right" valign="top"><a id="a354a7a5d4b51f8861cee2fa6f323d529"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_front</b> (size_type new_size)</td></tr>
<tr class="separator:a354a7a5d4b51f8861cee2fa6f323d529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeeef9733fbffc481814e0280c844d8"><td class="memItemLeft" align="right" valign="top"><a id="abbeeef9733fbffc481814e0280c844d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_front</b> (size_type new_size, const T &amp;value)</td></tr>
<tr class="separator:abbeeef9733fbffc481814e0280c844d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="memTemplParams" colspan="2"><a id="ae07666f6c9dd6d86e4dd3bf6af428c33"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (Iter first, Iter last)</td></tr>
<tr class="separator:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1677cc0e4614b53fe4982ad75da3a73"><td class="memItemLeft" align="right" valign="top"><a id="aa1677cc0e4614b53fe4982ad75da3a73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="separator:aa1677cc0e4614b53fe4982ad75da3a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c333756a4f16abaf0c6cc120b2d585"><td class="memItemLeft" align="right" valign="top"><a id="a21c333756a4f16abaf0c6cc120b2d585"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (size_type count, const T &amp;value)</td></tr>
<tr class="separator:a21c333756a4f16abaf0c6cc120b2d585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d851eb2405943b78ea1a4ceb5dbc5e9"><td class="memTemplParams" colspan="2"><a id="a1d851eb2405943b78ea1a4ceb5dbc5e9"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a1d851eb2405943b78ea1a4ceb5dbc5e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, Iter begin, Iter end)</td></tr>
<tr class="separator:a1d851eb2405943b78ea1a4ceb5dbc5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accef60a4a30f148f8d828d09c97010ac"><td class="memItemLeft" align="right" valign="top"><a id="accef60a4a30f148f8d828d09c97010ac"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="separator:accef60a4a30f148f8d828d09c97010ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2c111ccb4c46ab76a569b88476dbb2"><td class="memItemLeft" align="right" valign="top"><a id="ade2c111ccb4c46ab76a569b88476dbb2"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, size_type count, const T &amp;value)</td></tr>
<tr class="separator:ade2c111ccb4c46ab76a569b88476dbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac015176b3dca11fea1d77d7c18d1d68e"><td class="memTemplParams" colspan="2"><a id="ac015176b3dca11fea1d77d7c18d1d68e"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac015176b3dca11fea1d77d7c18d1d68e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_in_non_full_node</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ac015176b3dca11fea1d77d7c18d1d68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1600c966ef245a06d8b4b7320fccc2e"><td class="memTemplParams" colspan="2"><a id="aa1600c966ef245a06d8b4b7320fccc2e"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa1600c966ef245a06d8b4b7320fccc2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, Args &amp;&amp;... args)</td></tr>
<tr class="separator:aa1600c966ef245a06d8b4b7320fccc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e55b2eab0b32a681f96ed6721010fb3"><td class="memItemLeft" align="right" valign="top"><a id="a3e55b2eab0b32a681f96ed6721010fb3"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, const T &amp;value)</td></tr>
<tr class="separator:a3e55b2eab0b32a681f96ed6721010fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cc3bf5f62c72d62e90a52172ceecb1"><td class="memItemLeft" align="right" valign="top"><a id="aa9cc3bf5f62c72d62e90a52172ceecb1"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> where, T &amp;&amp;value)</td></tr>
<tr class="separator:aa9cc3bf5f62c72d62e90a52172ceecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50c2082fc8950503cefb3757f4aea88"><td class="memItemLeft" align="right" valign="top"><a id="aa50c2082fc8950503cefb3757f4aea88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="separator:aa50c2082fc8950503cefb3757f4aea88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9020aac0b3608a3f2669da85552f6e"><td class="memItemLeft" align="right" valign="top"><a id="abb9020aac0b3608a3f2669da85552f6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (size_t size)</td></tr>
<tr class="separator:abb9020aac0b3608a3f2669da85552f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69094af80d9ade98e6dc374d8fb128e"><td class="memItemLeft" align="right" valign="top"><a id="ad69094af80d9ade98e6dc374d8fb128e"></a>
Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () noexcept</td></tr>
<tr class="separator:ad69094af80d9ade98e6dc374d8fb128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870663bf39ecd823c27209a0e6dbec6d"><td class="memItemLeft" align="right" valign="top"><a id="a870663bf39ecd823c27209a0e6dbec6d"></a>
Allocator&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const noexcept</td></tr>
<tr class="separator:a870663bf39ecd823c27209a0e6dbec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af718d9b330f3003712989145722c2c71"><td class="memItemLeft" align="right" valign="top"><a id="af718d9b330f3003712989145722c2c71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_front</b> () noexcept</td></tr>
<tr class="separator:af718d9b330f3003712989145722c2c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1abcdc4e8a28ccdf5f2f773545c0553"><td class="memItemLeft" align="right" valign="top"><a id="aa1abcdc4e8a28ccdf5f2f773545c0553"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> () noexcept</td></tr>
<tr class="separator:aa1abcdc4e8a28ccdf5f2f773545c0553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40ac8ecd47e9fe7328409b978bedf78"><td class="memItemLeft" align="right" valign="top"><a id="ad40ac8ecd47e9fe7328409b978bedf78"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_at</b> (size_type pos) noexcept</td></tr>
<tr class="separator:ad40ac8ecd47e9fe7328409b978bedf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e97d78db6b640c4b4b95daaa16bf332"><td class="memItemLeft" align="right" valign="top"><a id="a6e97d78db6b640c4b4b95daaa16bf332"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_at</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a6e97d78db6b640c4b4b95daaa16bf332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b9bc6d5992a987540c2802c0cc8005"><td class="memItemLeft" align="right" valign="top"><a id="a47b9bc6d5992a987540c2802c0cc8005"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> it) noexcept</td></tr>
<tr class="separator:a47b9bc6d5992a987540c2802c0cc8005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a94e38d9abffa69703632925b77e3b"><td class="memItemLeft" align="right" valign="top"><a id="a12a94e38d9abffa69703632925b77e3b"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> first, <a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="separator:a12a94e38d9abffa69703632925b77e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b0474851aea2bc97281fa45e6a12e5"><td class="memItemLeft" align="right" valign="top"><a id="a46b0474851aea2bc97281fa45e6a12e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort</b> ()</td></tr>
<tr class="separator:a46b0474851aea2bc97281fa45e6a12e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67217477cd30beb1f2209d6a1f1a4c86"><td class="memTemplParams" colspan="2"><a id="a67217477cd30beb1f2209d6a1f1a4c86"></a>
template&lt;class Less &gt; </td></tr>
<tr class="memitem:a67217477cd30beb1f2209d6a1f1a4c86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (<a class="el" href="struct_less.html">Less</a> less)</td></tr>
<tr class="separator:a67217477cd30beb1f2209d6a1f1a4c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206c97c3bf360322fd6389ecb4c453ae"><td class="memItemLeft" align="right" valign="top"><a id="a206c97c3bf360322fd6389ecb4c453ae"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:a206c97c3bf360322fd6389ecb4c453ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4998dc243763bdb0df14a9625f1ad435"><td class="memItemLeft" align="right" valign="top"><a id="a4998dc243763bdb0df14a9625f1ad435"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a4998dc243763bdb0df14a9625f1ad435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81392c0c58ad4529b10fbe6edcb95656"><td class="memItemLeft" align="right" valign="top"><a id="a81392c0c58ad4529b10fbe6edcb95656"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a81392c0c58ad4529b10fbe6edcb95656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd2fb16fbb41b270faee83a217473aa"><td class="memItemLeft" align="right" valign="top"><a id="a5bd2fb16fbb41b270faee83a217473aa"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a5bd2fb16fbb41b270faee83a217473aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567daff77bd3c7ebbf6c0b6ab61720c6"><td class="memItemLeft" align="right" valign="top"><a id="a567daff77bd3c7ebbf6c0b6ab61720c6"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:a567daff77bd3c7ebbf6c0b6ab61720c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d59ea40863943c28cd61547ac89285"><td class="memItemLeft" align="right" valign="top"><a id="a03d59ea40863943c28cd61547ac89285"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:a03d59ea40863943c28cd61547ac89285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac20ca1d6b564f44cae2e7c1d96a90e7"><td class="memItemLeft" align="right" valign="top"><a id="aac20ca1d6b564f44cae2e7c1d96a90e7"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () noexcept</td></tr>
<tr class="separator:aac20ca1d6b564f44cae2e7c1d96a90e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c04a6a5fbfb24f3938daa32547971a"><td class="memItemLeft" align="right" valign="top"><a id="a45c04a6a5fbfb24f3938daa32547971a"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:a45c04a6a5fbfb24f3938daa32547971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b776d37ac1f1ee11fde9b29c2589f08"><td class="memItemLeft" align="right" valign="top"><a id="a9b776d37ac1f1ee11fde9b29c2589f08"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () noexcept</td></tr>
<tr class="separator:a9b776d37ac1f1ee11fde9b29c2589f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75737e419ee124b86e23071f0abb9e6e"><td class="memItemLeft" align="right" valign="top"><a id="a75737e419ee124b86e23071f0abb9e6e"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:a75737e419ee124b86e23071f0abb9e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e864797c312e25d2657d6e6ce4e252"><td class="memItemLeft" align="right" valign="top"><a id="a15e864797c312e25d2657d6e6ce4e252"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const noexcept</td></tr>
<tr class="separator:a15e864797c312e25d2657d6e6ce4e252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b0baf205cd89b8ff371dcf460bb23e"><td class="memItemLeft" align="right" valign="top"><a id="a49b0baf205cd89b8ff371dcf460bb23e"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="separator:a49b0baf205cd89b8ff371dcf460bb23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53233ad3a23afe594b8a4be52dbaec06"><td class="memItemLeft" align="right" valign="top"><a id="a53233ad3a23afe594b8a4be52dbaec06"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a53233ad3a23afe594b8a4be52dbaec06">sequence</a> ()</td></tr>
<tr class="memdesc:a53233ad3a23afe594b8a4be52dbaec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, initialize internal data. <br /></td></tr>
<tr class="separator:a53233ad3a23afe594b8a4be52dbaec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaab09b0e1c9cd9bbe2be3712439f273"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#adaab09b0e1c9cd9bbe2be3712439f273">sequence</a> (const Allocator &amp;al)</td></tr>
<tr class="memdesc:adaab09b0e1c9cd9bbe2be3712439f273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an allocator object.  <a href="classsequence.html#adaab09b0e1c9cd9bbe2be3712439f273">More...</a><br /></td></tr>
<tr class="separator:adaab09b0e1c9cd9bbe2be3712439f273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad373880330bbc219f447ee324347c363"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#ad373880330bbc219f447ee324347c363">sequence</a> (size_type count, const T &amp;value, const Allocator &amp;al=Allocator())</td></tr>
<tr class="memdesc:ad373880330bbc219f447ee324347c363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with an initial size and a fill value.  <a href="classsequence.html#ad373880330bbc219f447ee324347c363">More...</a><br /></td></tr>
<tr class="separator:ad373880330bbc219f447ee324347c363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504e733fb40e43e2124dfba8f1b10207"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a504e733fb40e43e2124dfba8f1b10207">sequence</a> (size_type count, const Allocator &amp;al=Allocator())</td></tr>
<tr class="memdesc:a504e733fb40e43e2124dfba8f1b10207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with an initial size. Objects will be value initialize.  <a href="classsequence.html#a504e733fb40e43e2124dfba8f1b10207">More...</a><br /></td></tr>
<tr class="separator:a504e733fb40e43e2124dfba8f1b10207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20548d0819815e25e98de41126938379"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a20548d0819815e25e98de41126938379">sequence</a> (const <a class="el" href="classsequence.html">sequence</a> &amp;other)</td></tr>
<tr class="memdesc:a20548d0819815e25e98de41126938379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classsequence.html#a20548d0819815e25e98de41126938379">More...</a><br /></td></tr>
<tr class="separator:a20548d0819815e25e98de41126938379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787e1ac109e4dbf319373187ce58e8ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a787e1ac109e4dbf319373187ce58e8ee">sequence</a> (const <a class="el" href="classsequence.html">sequence</a> &amp;other, const Allocator &amp;al)</td></tr>
<tr class="memdesc:a787e1ac109e4dbf319373187ce58e8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classsequence.html#a787e1ac109e4dbf319373187ce58e8ee">More...</a><br /></td></tr>
<tr class="separator:a787e1ac109e4dbf319373187ce58e8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fd0bf75f3fa30bf458fb8f56bcbe1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a55fd0bf75f3fa30bf458fb8f56bcbe1c">sequence</a> (<a class="el" href="classsequence.html">sequence</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a55fd0bf75f3fa30bf458fb8f56bcbe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classsequence.html#a55fd0bf75f3fa30bf458fb8f56bcbe1c">More...</a><br /></td></tr>
<tr class="separator:a55fd0bf75f3fa30bf458fb8f56bcbe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a81c61fee659726f2f81da756381682"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a4a81c61fee659726f2f81da756381682">sequence</a> (<a class="el" href="classsequence.html">sequence</a> &amp;&amp;other, const Allocator &amp;alloc) noexcept(std::is_nothrow_move_assignable&lt; T &gt;::value)</td></tr>
<tr class="memdesc:a4a81c61fee659726f2f81da756381682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move.  <a href="classsequence.html#a4a81c61fee659726f2f81da756381682">More...</a><br /></td></tr>
<tr class="separator:a4a81c61fee659726f2f81da756381682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbabe7bd3840123b24f044b76f25c70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#acdbabe7bd3840123b24f044b76f25c70">sequence</a> (const std::initializer_list&lt; T &gt; &amp;lst, const Allocator &amp;al=Allocator())</td></tr>
<tr class="memdesc:acdbabe7bd3840123b24f044b76f25c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the sequence with the contents of the initializer list <em>lst</em>.  <a href="classsequence.html#acdbabe7bd3840123b24f044b76f25c70">More...</a><br /></td></tr>
<tr class="separator:acdbabe7bd3840123b24f044b76f25c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsequence.html#a6c56466582b25edd3e70dbdcdf0cb0f9">sequence</a> (Iter first, Iter last, const Allocator &amp;al=Allocator())</td></tr>
<tr class="memdesc:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the sequence with the contents of the range [first, last).  <a href="classsequence.html#a6c56466582b25edd3e70dbdcdf0cb0f9">More...</a><br /></td></tr>
<tr class="separator:a6c56466582b25edd3e70dbdcdf0cb0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20401a0750eec31632ec9654ff146b07"><td class="memItemLeft" align="right" valign="top"><a id="a20401a0750eec31632ec9654ff146b07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a20401a0750eec31632ec9654ff146b07">~sequence</a> ()</td></tr>
<tr class="memdesc:a20401a0750eec31632ec9654ff146b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a20401a0750eec31632ec9654ff146b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1cf4f0dbceab1313cf14cbb9be8848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsequence.html">sequence</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a9a1cf4f0dbceab1313cf14cbb9be8848">operator=</a> (const <a class="el" href="classsequence.html">sequence</a> &amp;other)</td></tr>
<tr class="memdesc:a9a1cf4f0dbceab1313cf14cbb9be8848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator, basic exception guarantee.  <a href="classsequence.html#a9a1cf4f0dbceab1313cf14cbb9be8848">More...</a><br /></td></tr>
<tr class="separator:a9a1cf4f0dbceab1313cf14cbb9be8848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a923134f4d71eee780e083028905f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsequence.html">sequence</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#aa7a923134f4d71eee780e083028905f2">operator=</a> (<a class="el" href="classsequence.html">sequence</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aa7a923134f4d71eee780e083028905f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classsequence.html#aa7a923134f4d71eee780e083028905f2">More...</a><br /></td></tr>
<tr class="separator:aa7a923134f4d71eee780e083028905f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f64c52baadc59c48ab1478ed420e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a72f64c52baadc59c48ab1478ed420e51">swap</a> (<a class="el" href="classsequence.html">sequence</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a72f64c52baadc59c48ab1478ed420e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.  <a href="classsequence.html#a72f64c52baadc59c48ab1478ed420e51">More...</a><br /></td></tr>
<tr class="separator:a72f64c52baadc59c48ab1478ed420e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014ebd07a11538cefa9dcd090d0e4555"><td class="memItemLeft" align="right" valign="top"><a id="a014ebd07a11538cefa9dcd090d0e4555"></a>
Data *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a014ebd07a11538cefa9dcd090d0e4555">data</a> () noexcept</td></tr>
<tr class="memdesc:a014ebd07a11538cefa9dcd090d0e4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sequence internal data. Internal use only. <br /></td></tr>
<tr class="separator:a014ebd07a11538cefa9dcd090d0e4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1f97d9457f879441836d4d1426992f"><td class="memItemLeft" align="right" valign="top"><a id="abc1f97d9457f879441836d4d1426992f"></a>
const Data *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const noexcept</td></tr>
<tr class="separator:abc1f97d9457f879441836d4d1426992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f24939e2050de1b2d2fab0ab5be93b"><td class="memItemLeft" align="right" valign="top"><a id="ad2f24939e2050de1b2d2fab0ab5be93b"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#ad2f24939e2050de1b2d2fab0ab5be93b">memory_footprint</a> () const noexcept</td></tr>
<tr class="memdesc:ad2f24939e2050de1b2d2fab0ab5be93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full memory footprint of this sequence in bytes, excluding sizeof(*this). <br /></td></tr>
<tr class="separator:ad2f24939e2050de1b2d2fab0ab5be93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69094af80d9ade98e6dc374d8fb128e"><td class="memItemLeft" align="right" valign="top"><a id="ad69094af80d9ade98e6dc374d8fb128e"></a>
Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#ad69094af80d9ade98e6dc374d8fb128e">get_allocator</a> () noexcept</td></tr>
<tr class="memdesc:ad69094af80d9ade98e6dc374d8fb128e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container. <br /></td></tr>
<tr class="separator:ad69094af80d9ade98e6dc374d8fb128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870663bf39ecd823c27209a0e6dbec6d"><td class="memItemLeft" align="right" valign="top"><a id="a870663bf39ecd823c27209a0e6dbec6d"></a>
Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a870663bf39ecd823c27209a0e6dbec6d">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:a870663bf39ecd823c27209a0e6dbec6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container. <br /></td></tr>
<tr class="separator:a870663bf39ecd823c27209a0e6dbec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fb2d06c72a27dd7a19e6d4ee835a68"><td class="memItemLeft" align="right" valign="top"><a id="a97fb2d06c72a27dd7a19e6d4ee835a68"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a97fb2d06c72a27dd7a19e6d4ee835a68">size</a> () const noexcept</td></tr>
<tr class="memdesc:a97fb2d06c72a27dd7a19e6d4ee835a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns thenumber of elements in this sequence. <br /></td></tr>
<tr class="separator:a97fb2d06c72a27dd7a19e6d4ee835a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19a2b51755cac8b79aa4ad305622a6c"><td class="memItemLeft" align="right" valign="top"><a id="aa19a2b51755cac8b79aa4ad305622a6c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#aa19a2b51755cac8b79aa4ad305622a6c">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:aa19a2b51755cac8b79aa4ad305622a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container has currently allocated space for. <br /></td></tr>
<tr class="separator:aa19a2b51755cac8b79aa4ad305622a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9386f3eba97030a06d242058c5a70b"><td class="memItemLeft" align="right" valign="top"><a id="aea9386f3eba97030a06d242058c5a70b"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#aea9386f3eba97030a06d242058c5a70b">back</a> () const noexcept</td></tr>
<tr class="memdesc:aea9386f3eba97030a06d242058c5a70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the back sequence value. <br /></td></tr>
<tr class="separator:aea9386f3eba97030a06d242058c5a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7bf1dd2090d7024e5432e7c0a09d37"><td class="memItemLeft" align="right" valign="top"><a id="abe7bf1dd2090d7024e5432e7c0a09d37"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#abe7bf1dd2090d7024e5432e7c0a09d37">back</a> () noexcept</td></tr>
<tr class="memdesc:abe7bf1dd2090d7024e5432e7c0a09d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the back sequence value. <br /></td></tr>
<tr class="separator:abe7bf1dd2090d7024e5432e7c0a09d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35989eeb997ec25897236eb6dc1ee1ea"><td class="memItemLeft" align="right" valign="top"><a id="a35989eeb997ec25897236eb6dc1ee1ea"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a35989eeb997ec25897236eb6dc1ee1ea">front</a> () const noexcept</td></tr>
<tr class="memdesc:a35989eeb997ec25897236eb6dc1ee1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the front sequence value. <br /></td></tr>
<tr class="separator:a35989eeb997ec25897236eb6dc1ee1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64124d3629fafa19b29a1d5f29bd8a36"><td class="memItemLeft" align="right" valign="top"><a id="a64124d3629fafa19b29a1d5f29bd8a36"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a64124d3629fafa19b29a1d5f29bd8a36">front</a> () noexcept</td></tr>
<tr class="memdesc:a64124d3629fafa19b29a1d5f29bd8a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the front sequence value. <br /></td></tr>
<tr class="separator:a64124d3629fafa19b29a1d5f29bd8a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7044ce880c5d679e49d211b095ff5f05"><td class="memItemLeft" align="right" valign="top"><a id="a7044ce880c5d679e49d211b095ff5f05"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a7044ce880c5d679e49d211b095ff5f05">clear</a> () noexcept</td></tr>
<tr class="memdesc:a7044ce880c5d679e49d211b095ff5f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents. Erases all elements from the container. After this call, size() returns zero. Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid. <br /></td></tr>
<tr class="separator:a7044ce880c5d679e49d211b095ff5f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c928053fd857c85152e8481c9085fd"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a26c928053fd857c85152e8481c9085fd"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsequence.html#a26c928053fd857c85152e8481c9085fd">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a26c928053fd857c85152e8481c9085fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the end.  <a href="classsequence.html#a26c928053fd857c85152e8481c9085fd">More...</a><br /></td></tr>
<tr class="separator:a26c928053fd857c85152e8481c9085fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4523ecdfdd34d66231c552e9e838d99a"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4523ecdfdd34d66231c552e9e838d99a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsequence.html#a4523ecdfdd34d66231c552e9e838d99a">emplace_back_iter</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4523ecdfdd34d66231c552e9e838d99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the end and returns an iterator pointing to this element.  <a href="classsequence.html#a4523ecdfdd34d66231c552e9e838d99a">More...</a><br /></td></tr>
<tr class="separator:a4523ecdfdd34d66231c552e9e838d99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa0bfb1b661c56015fc0ed5d0f66094"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a2fa0bfb1b661c56015fc0ed5d0f66094">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a2fa0bfb1b661c56015fc0ed5d0f66094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the sequence.  <a href="classsequence.html#a2fa0bfb1b661c56015fc0ed5d0f66094">More...</a><br /></td></tr>
<tr class="separator:a2fa0bfb1b661c56015fc0ed5d0f66094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771d78864810b402bef7f9472e2839d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a771d78864810b402bef7f9472e2839d7">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a771d78864810b402bef7f9472e2839d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the sequence. value is moved into the new element.  <a href="classsequence.html#a771d78864810b402bef7f9472e2839d7">More...</a><br /></td></tr>
<tr class="separator:a771d78864810b402bef7f9472e2839d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsequence.html#a9da3b4f3576e5dda10cccd6f25eaa20c">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the beginning.  <a href="classsequence.html#a9da3b4f3576e5dda10cccd6f25eaa20c">More...</a><br /></td></tr>
<tr class="separator:a9da3b4f3576e5dda10cccd6f25eaa20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5d4624c1f847d68eb5928065424adf"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4e5d4624c1f847d68eb5928065424adf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsequence.html#a4e5d4624c1f847d68eb5928065424adf">emplace_front_iter</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4e5d4624c1f847d68eb5928065424adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the beginning and returns an iterator pointing to this element.  <a href="classsequence.html#a4e5d4624c1f847d68eb5928065424adf">More...</a><br /></td></tr>
<tr class="separator:a4e5d4624c1f847d68eb5928065424adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44390ab9d37afd652166ea06aa61581b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a44390ab9d37afd652166ea06aa61581b">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a44390ab9d37afd652166ea06aa61581b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element value to the beginning of the sequence.  <a href="classsequence.html#a44390ab9d37afd652166ea06aa61581b">More...</a><br /></td></tr>
<tr class="separator:a44390ab9d37afd652166ea06aa61581b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646323fdac2528501cbec140df3356dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a646323fdac2528501cbec140df3356dc">push_front</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a646323fdac2528501cbec140df3356dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element value to the beginning of the sequence. value is moved into the new element.  <a href="classsequence.html#a646323fdac2528501cbec140df3356dc">More...</a><br /></td></tr>
<tr class="separator:a646323fdac2528501cbec140df3356dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa374ac8d4e9081248af8c0d87f3a389a"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa374ac8d4e9081248af8c0d87f3a389a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsequence.html#aa374ac8d4e9081248af8c0d87f3a389a">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa374ac8d4e9081248af8c0d87f3a389a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place anywhere into the sequence.  <a href="classsequence.html#aa374ac8d4e9081248af8c0d87f3a389a">More...</a><br /></td></tr>
<tr class="separator:aa374ac8d4e9081248af8c0d87f3a389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac877ba7ba0f16aee06c259825d4f8a0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#ac877ba7ba0f16aee06c259825d4f8a0f">insert</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ac877ba7ba0f16aee06c259825d4f8a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given element into the sequence.  <a href="classsequence.html#ac877ba7ba0f16aee06c259825d4f8a0f">More...</a><br /></td></tr>
<tr class="separator:ac877ba7ba0f16aee06c259825d4f8a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1b94a58942af2e64bd7f4ca3ef40c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#aae1b94a58942af2e64bd7f4ca3ef40c2">insert</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:aae1b94a58942af2e64bd7f4ca3ef40c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given element into the sequence. value is moved into the new element.  <a href="classsequence.html#aae1b94a58942af2e64bd7f4ca3ef40c2">More...</a><br /></td></tr>
<tr class="separator:aae1b94a58942af2e64bd7f4ca3ef40c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d9c3533038203285a849e166dc56ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a68d9c3533038203285a849e166dc56ae">resize</a> (size_type count)</td></tr>
<tr class="memdesc:a68d9c3533038203285a849e166dc56ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classsequence.html#a68d9c3533038203285a849e166dc56ae">More...</a><br /></td></tr>
<tr class="separator:a68d9c3533038203285a849e166dc56ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347e2b6f81f51ae535a0674239ea548d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a347e2b6f81f51ae535a0674239ea548d">resize</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a347e2b6f81f51ae535a0674239ea548d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classsequence.html#a347e2b6f81f51ae535a0674239ea548d">More...</a><br /></td></tr>
<tr class="separator:a347e2b6f81f51ae535a0674239ea548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25506926c789d4d296550ee3189d1ea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a25506926c789d4d296550ee3189d1ea2">resize_front</a> (size_type count)</td></tr>
<tr class="memdesc:a25506926c789d4d296550ee3189d1ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classsequence.html#a25506926c789d4d296550ee3189d1ea2">More...</a><br /></td></tr>
<tr class="separator:a25506926c789d4d296550ee3189d1ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b8fd95af05c5bd2e9bbc67ebf91ba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#ab3b8fd95af05c5bd2e9bbc67ebf91ba1">resize_front</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:ab3b8fd95af05c5bd2e9bbc67ebf91ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classsequence.html#ab3b8fd95af05c5bd2e9bbc67ebf91ba1">More...</a><br /></td></tr>
<tr class="separator:ab3b8fd95af05c5bd2e9bbc67ebf91ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsequence.html#ae07666f6c9dd6d86e4dd3bf6af428c33">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container.  <a href="classsequence.html#ae07666f6c9dd6d86e4dd3bf6af428c33">More...</a><br /></td></tr>
<tr class="separator:ae07666f6c9dd6d86e4dd3bf6af428c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1677cc0e4614b53fe4982ad75da3a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#aa1677cc0e4614b53fe4982ad75da3a73">assign</a> (const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="memdesc:aa1677cc0e4614b53fe4982ad75da3a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container.  <a href="classsequence.html#aa1677cc0e4614b53fe4982ad75da3a73">More...</a><br /></td></tr>
<tr class="separator:aa1677cc0e4614b53fe4982ad75da3a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c333756a4f16abaf0c6cc120b2d585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a21c333756a4f16abaf0c6cc120b2d585">assign</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a21c333756a4f16abaf0c6cc120b2d585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with count copies of value <em>value</em>.  <a href="classsequence.html#a21c333756a4f16abaf0c6cc120b2d585">More...</a><br /></td></tr>
<tr class="separator:a21c333756a4f16abaf0c6cc120b2d585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50c2082fc8950503cefb3757f4aea88"><td class="memItemLeft" align="right" valign="top"><a id="aa50c2082fc8950503cefb3757f4aea88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#aa50c2082fc8950503cefb3757f4aea88">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:aa50c2082fc8950503cefb3757f4aea88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack the sequence to remove empty slots and release unused memory. All empty slots created by calls to #erase() are filled by moving each element toward the beginning. Ths function might deallocate unused buckets created by the shrinking operation, but never allocates memory. Invalidates all references and iterators. Basic exception guarantee. <br  />
 <br /></td></tr>
<tr class="separator:aa50c2082fc8950503cefb3757f4aea88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c106bcdaa549fecb92d559f5dd30b10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a6c106bcdaa549fecb92d559f5dd30b10">reserve</a> (size_t new_cap)</td></tr>
<tr class="memdesc:a6c106bcdaa549fecb92d559f5dd30b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the vector to a value that's greater or equal to new_cap.  <a href="classsequence.html#a6c106bcdaa549fecb92d559f5dd30b10">More...</a><br /></td></tr>
<tr class="separator:a6c106bcdaa549fecb92d559f5dd30b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af718d9b330f3003712989145722c2c71"><td class="memItemLeft" align="right" valign="top"><a id="af718d9b330f3003712989145722c2c71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#af718d9b330f3003712989145722c2c71">pop_front</a> () noexcept</td></tr>
<tr class="memdesc:af718d9b330f3003712989145722c2c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of the container. Calling pop_front on an empty container results in undefined behavior. Iterators and references to the first element are invalidated. Other iterators and references remain valid. <br /></td></tr>
<tr class="separator:af718d9b330f3003712989145722c2c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1abcdc4e8a28ccdf5f2f773545c0553"><td class="memItemLeft" align="right" valign="top"><a id="aa1abcdc4e8a28ccdf5f2f773545c0553"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#aa1abcdc4e8a28ccdf5f2f773545c0553">pop_back</a> () noexcept</td></tr>
<tr class="memdesc:aa1abcdc4e8a28ccdf5f2f773545c0553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container. Calling pop_back on an empty container results in undefined behavior. Iterators and references to the last element are invalidated. Other iterators and references remain valid. <br /></td></tr>
<tr class="separator:aa1abcdc4e8a28ccdf5f2f773545c0553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40ac8ecd47e9fe7328409b978bedf78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#ad40ac8ecd47e9fe7328409b978bedf78">iterator_at</a> (size_type pos) noexcept</td></tr>
<tr class="memdesc:ad40ac8ecd47e9fe7328409b978bedf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to given position.  <a href="classsequence.html#ad40ac8ecd47e9fe7328409b978bedf78">More...</a><br /></td></tr>
<tr class="separator:ad40ac8ecd47e9fe7328409b978bedf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e97d78db6b640c4b4b95daaa16bf332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a6e97d78db6b640c4b4b95daaa16bf332">iterator_at</a> (size_type pos) const noexcept</td></tr>
<tr class="memdesc:a6e97d78db6b640c4b4b95daaa16bf332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to given position.  <a href="classsequence.html#a6e97d78db6b640c4b4b95daaa16bf332">More...</a><br /></td></tr>
<tr class="separator:a6e97d78db6b640c4b4b95daaa16bf332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b9bc6d5992a987540c2802c0cc8005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a47b9bc6d5992a987540c2802c0cc8005">erase</a> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> it) noexcept</td></tr>
<tr class="memdesc:a47b9bc6d5992a987540c2802c0cc8005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the specified element from the container.  <a href="classsequence.html#a47b9bc6d5992a987540c2802c0cc8005">More...</a><br /></td></tr>
<tr class="separator:a47b9bc6d5992a987540c2802c0cc8005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e30b217bfed9503871c3d3cc1202f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#afe1e30b217bfed9503871c3d3cc1202f">erase</a> (<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> first, <a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> last) noexcept</td></tr>
<tr class="memdesc:afe1e30b217bfed9503871c3d3cc1202f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the specified elements from the container.  <a href="classsequence.html#afe1e30b217bfed9503871c3d3cc1202f">More...</a><br /></td></tr>
<tr class="separator:afe1e30b217bfed9503871c3d3cc1202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b0474851aea2bc97281fa45e6a12e5"><td class="memItemLeft" align="right" valign="top"><a id="a46b0474851aea2bc97281fa45e6a12e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a46b0474851aea2bc97281fa45e6a12e5">sort</a> ()</td></tr>
<tr class="memdesc:a46b0474851aea2bc97281fa45e6a12e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator. sort() relies on the pdqsort implementation from Orson Peters, and should be as fast as sorting a std::deque. This invalidates all iterators and references. <br /></td></tr>
<tr class="separator:a46b0474851aea2bc97281fa45e6a12e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67217477cd30beb1f2209d6a1f1a4c86"><td class="memTemplParams" colspan="2"><a id="a67217477cd30beb1f2209d6a1f1a4c86"></a>
template&lt;class Less &gt; </td></tr>
<tr class="memitem:a67217477cd30beb1f2209d6a1f1a4c86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsequence.html#a67217477cd30beb1f2209d6a1f1a4c86">sort</a> (<a class="el" href="struct_less.html">Less</a> less)</td></tr>
<tr class="memdesc:a67217477cd30beb1f2209d6a1f1a4c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the sequence using given comparator. sort() relies on the pdqsort implementation from Orson Peters, and should be as fast as sorting a std::deque. This invalidates all iterators and references. <br /></td></tr>
<tr class="separator:a67217477cd30beb1f2209d6a1f1a4c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901b4ad368f5048b602ea43fd47f1ad7"><td class="memItemLeft" align="right" valign="top"><a id="a901b4ad368f5048b602ea43fd47f1ad7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a901b4ad368f5048b602ea43fd47f1ad7">stable_sort</a> ()</td></tr>
<tr class="memdesc:a901b4ad368f5048b602ea43fd47f1ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator. <a class="el" href="classsequence.html#a901b4ad368f5048b602ea43fd47f1ad7" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">stable_sort()</a> relies on std::stable_sort. This invalidates all iterators and references. <br /></td></tr>
<tr class="separator:a901b4ad368f5048b602ea43fd47f1ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f94076ee127b6860822c67f4f0cc6e"><td class="memTemplParams" colspan="2"><a id="af1f94076ee127b6860822c67f4f0cc6e"></a>
template&lt;class Less &gt; </td></tr>
<tr class="memitem:af1f94076ee127b6860822c67f4f0cc6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsequence.html#af1f94076ee127b6860822c67f4f0cc6e">stable_sort</a> (<a class="el" href="struct_less.html">Less</a> less)</td></tr>
<tr class="memdesc:af1f94076ee127b6860822c67f4f0cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the sequence using given comparator. The sequence is sorted using the std::less&lt;value_type&gt; comparator. <a class="el" href="classsequence.html#a901b4ad368f5048b602ea43fd47f1ad7" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">stable_sort()</a> relies on std::stable_sort. This invalidates all iterators and references. <br /></td></tr>
<tr class="separator:af1f94076ee127b6860822c67f4f0cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206c97c3bf360322fd6389ecb4c453ae"><td class="memItemLeft" align="right" valign="top"><a id="a206c97c3bf360322fd6389ecb4c453ae"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a206c97c3bf360322fd6389ecb4c453ae">begin</a> () noexcept</td></tr>
<tr class="memdesc:a206c97c3bf360322fd6389ecb4c453ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the sequence. <br /></td></tr>
<tr class="separator:a206c97c3bf360322fd6389ecb4c453ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4998dc243763bdb0df14a9625f1ad435"><td class="memItemLeft" align="right" valign="top"><a id="a4998dc243763bdb0df14a9625f1ad435"></a>
<a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a4998dc243763bdb0df14a9625f1ad435">end</a> () noexcept</td></tr>
<tr class="memdesc:a4998dc243763bdb0df14a9625f1ad435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the sequence. <br /></td></tr>
<tr class="separator:a4998dc243763bdb0df14a9625f1ad435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81392c0c58ad4529b10fbe6edcb95656"><td class="memItemLeft" align="right" valign="top"><a id="a81392c0c58ad4529b10fbe6edcb95656"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a81392c0c58ad4529b10fbe6edcb95656">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a81392c0c58ad4529b10fbe6edcb95656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the sequence. <br /></td></tr>
<tr class="separator:a81392c0c58ad4529b10fbe6edcb95656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd2fb16fbb41b270faee83a217473aa"><td class="memItemLeft" align="right" valign="top"><a id="a5bd2fb16fbb41b270faee83a217473aa"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a5bd2fb16fbb41b270faee83a217473aa">end</a> () const noexcept</td></tr>
<tr class="memdesc:a5bd2fb16fbb41b270faee83a217473aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the sequence. <br /></td></tr>
<tr class="separator:a5bd2fb16fbb41b270faee83a217473aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567daff77bd3c7ebbf6c0b6ab61720c6"><td class="memItemLeft" align="right" valign="top"><a id="a567daff77bd3c7ebbf6c0b6ab61720c6"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a567daff77bd3c7ebbf6c0b6ab61720c6">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a567daff77bd3c7ebbf6c0b6ab61720c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the sequence. <br /></td></tr>
<tr class="separator:a567daff77bd3c7ebbf6c0b6ab61720c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d59ea40863943c28cd61547ac89285"><td class="memItemLeft" align="right" valign="top"><a id="a03d59ea40863943c28cd61547ac89285"></a>
<a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a03d59ea40863943c28cd61547ac89285">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a03d59ea40863943c28cd61547ac89285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the sequence. <br /></td></tr>
<tr class="separator:a03d59ea40863943c28cd61547ac89285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac20ca1d6b564f44cae2e7c1d96a90e7"><td class="memItemLeft" align="right" valign="top"><a id="aac20ca1d6b564f44cae2e7c1d96a90e7"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#aac20ca1d6b564f44cae2e7c1d96a90e7">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:aac20ca1d6b564f44cae2e7c1d96a90e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list. <br /></td></tr>
<tr class="separator:aac20ca1d6b564f44cae2e7c1d96a90e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c04a6a5fbfb24f3938daa32547971a"><td class="memItemLeft" align="right" valign="top"><a id="a45c04a6a5fbfb24f3938daa32547971a"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a45c04a6a5fbfb24f3938daa32547971a">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a45c04a6a5fbfb24f3938daa32547971a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list. <br /></td></tr>
<tr class="separator:a45c04a6a5fbfb24f3938daa32547971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b776d37ac1f1ee11fde9b29c2589f08"><td class="memItemLeft" align="right" valign="top"><a id="a9b776d37ac1f1ee11fde9b29c2589f08"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a9b776d37ac1f1ee11fde9b29c2589f08">rend</a> () noexcept</td></tr>
<tr class="memdesc:a9b776d37ac1f1ee11fde9b29c2589f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list. <br /></td></tr>
<tr class="separator:a9b776d37ac1f1ee11fde9b29c2589f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75737e419ee124b86e23071f0abb9e6e"><td class="memItemLeft" align="right" valign="top"><a id="a75737e419ee124b86e23071f0abb9e6e"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a75737e419ee124b86e23071f0abb9e6e">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a75737e419ee124b86e23071f0abb9e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list. <br /></td></tr>
<tr class="separator:a75737e419ee124b86e23071f0abb9e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e864797c312e25d2657d6e6ce4e252"><td class="memItemLeft" align="right" valign="top"><a id="a15e864797c312e25d2657d6e6ce4e252"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a15e864797c312e25d2657d6e6ce4e252">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a15e864797c312e25d2657d6e6ce4e252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list. <br /></td></tr>
<tr class="separator:a15e864797c312e25d2657d6e6ce4e252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b0baf205cd89b8ff371dcf460bb23e"><td class="memItemLeft" align="right" valign="top"><a id="a49b0baf205cd89b8ff371dcf460bb23e"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#a49b0baf205cd89b8ff371dcf460bb23e">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a49b0baf205cd89b8ff371dcf460bb23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list. <br /></td></tr>
<tr class="separator:a49b0baf205cd89b8ff371dcf460bb23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structdetail_1_1base__container"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structdetail_1_1base__container')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structdetail_1_1base__container.html">detail::base_container&lt; T &gt;</a></td></tr>
<tr class="memitem:a43f6015d84d46a04551f30b9580e744a inherit pub_methods_structdetail_1_1base__container"><td class="memItemLeft" align="right" valign="top"><a id="a43f6015d84d46a04551f30b9580e744a"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>memory_footprint</b> () const</td></tr>
<tr class="separator:a43f6015d84d46a04551f30b9580e744a inherit pub_methods_structdetail_1_1base__container"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae21cbc9e247d63fc21c9da760d63672a"><td class="memItemLeft" align="right" valign="top"><a id="ae21cbc9e247d63fc21c9da760d63672a"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () noexcept</td></tr>
<tr class="separator:ae21cbc9e247d63fc21c9da760d63672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21cbc9e247d63fc21c9da760d63672a"><td class="memItemLeft" align="right" valign="top"><a id="ae21cbc9e247d63fc21c9da760d63672a"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () noexcept</td></tr>
<tr class="separator:ae21cbc9e247d63fc21c9da760d63672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21cbc9e247d63fc21c9da760d63672a"><td class="memItemLeft" align="right" valign="top"><a id="ae21cbc9e247d63fc21c9da760d63672a"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequence.html#ae21cbc9e247d63fc21c9da760d63672a">max_size</a> () noexcept</td></tr>
<tr class="memdesc:ae21cbc9e247d63fc21c9da760d63672a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sequence maximum size. <br /></td></tr>
<tr class="separator:ae21cbc9e247d63fc21c9da760d63672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aeb6ac52d4ab37a2cace3a9c45e6dfe50"><td class="memItemLeft" align="right" valign="top"><a id="aeb6ac52d4ab37a2cace3a9c45e6dfe50"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::sequence_const_iterator&lt; this_type &gt;</b></td></tr>
<tr class="separator:aeb6ac52d4ab37a2cace3a9c45e6dfe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678594126fb1327768c3931311cad470"><td class="memItemLeft" align="right" valign="top"><a id="a678594126fb1327768c3931311cad470"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::sequence_iterator&lt; this_type &gt;</b></td></tr>
<tr class="separator:a678594126fb1327768c3931311cad470"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Allocator = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator = detail::NullChunkAllocator&gt;<br />
class sequence&lt; T, Allocator, layout, ChunkAllocator &gt;</h3>

<p>sequence is an ordered container supporting constant time removal and insertion at both end and . </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator type</td></tr>
  </table>
  </dd>
</dl>
<p>The sequence container behave very similary to a std::list. It provides:</p><ul>
<li>Constant time insertion at the back or the front using members #push_back(), #emplace_back(), #push_front() and #emplace_front()</li>
<li>Constant time removale of one or more elements with #erase()</li>
<li>Stability of references and iterators.</li>
</ul>
<p>Unlike std::list, the sequence container does not provide insertion anywhere in the container. Instead, sequence provides unordered insertion through its member #insert(), much like the <a class="el" href="classplf_1_1colony.html">plf::colony</a> class (link). Unordered insertion is usually prefered to back or front insertion as it can reuse free slots created by #erase() and avoid potential allocations. In addition, its #sort(), <a class="el" href="classsequence.html#a901b4ad368f5048b602ea43fd47f1ad7" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">stable_sort()</a> and #shrink_to_fit() members do not preserve reference and iterator stability.</p>
<p>Its main advantages other std::list (and other containers) are: </p><pre class="fragment">- Insertion at both ends is faster than a std::deque or std::vector (without reserve)
- Walking through the sequence with iterators is usually faster than walking through a std::deque
- Sorting a sequence (with #sort() or #stable_sort()) is usually as fast as sorting a std::deque.
Note that #sequence::sort() uses pdqsort (link) from Orson Peters.
- Its memory overhead is lower than a std::list: 1 byte per element.
</pre><p>The sequence container is a perfect candidate for std::queue and std::stack.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Technical description</h2>
<p>sequence container is implemented as a linked list of buckets. Each bucket holds 64 elements in a contiguous storage, and a 64 bits integer telling if a slot is empty or occupied.</p>
<p>In order to retrieve the index of the first (or last) used slot in a bucket, or to get the number of occupied slots, the sequence container uses OS intrinsics to scan the 64 bits integer. For instance, on Windows, <em>_BitScanForward64</em>, <em>_BitScanRevers64</em> and <em>_mm_popcnt_u64</em> are used. Removing an element from the sequence will set the corresponding bit to 0, inserting will set the bit to 1.</p>
<p>In addition, the sequence maintains another linked list of partially free buckets in order to perform fast unordered insertion using #insert() member and therefore reuse slots previously deleted by #erase().</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Iterators</h2>
<p>sequence iterator and const_iterator are bidirectional iterators. However, they provide all the features to behave like random access iterator, except the std::random_access_iterator_tag typedef.</p>
<p>Indeed, using <em>iterator::operator+=</em> is, for instance, much faster than <em>std::advance</em> as it can skip whole buckets to reach the required location. Likewise subtracting 2 iterators is much faster than using <em>std::distance</em>.</p>
<p>sequence iterator also provide comparison operators &lt;, &gt;, &lt;= and &gt;=.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Memory managment</h2>
<p>When using the <em>OptimizeForMemory</em> flag, the sequence will allocate each bucket independently using the provided allocator.</p>
<p>When using the <em>OptimizeForSpeed</em> flag, the sequence will use a memory pool to allocate several buckets at once, still using the provided allocator. The memory pool uses a growing strategy to allocate more and more buckets based on a growth factor (SEQ_GROW_FACTOR define, defaulting to 1.6). The memory pool makes insertion tipically 50% faster than the default allocation strategy, but will consume slightly more memory.</p>
<p>Whenever a bucket is empty (by calls to #erase(), #clear(), #resize(), #resize_front() or #shrink_to_fit()), the sequence releases the occupied memory. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adaab09b0e1c9cd9bbe2be3712439f273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaab09b0e1c9cd9bbe2be3712439f273">&#9670;&nbsp;</a></span>sequence() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::<a class="el" href="classsequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an allocator object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad373880330bbc219f447ee324347c363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad373880330bbc219f447ee324347c363">&#9670;&nbsp;</a></span>sequence() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::<a class="el" href="classsequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with an initial size and a fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>initial size </td></tr>
    <tr><td class="paramname">value</td><td>fill value </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a504e733fb40e43e2124dfba8f1b10207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504e733fb40e43e2124dfba8f1b10207">&#9670;&nbsp;</a></span>sequence() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::<a class="el" href="classsequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with an initial size. Objects will be value initialize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>initial size </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20548d0819815e25e98de41126938379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20548d0819815e25e98de41126938379">&#9670;&nbsp;</a></span>sequence() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::<a class="el" href="classsequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>input sequence to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a787e1ac109e4dbf319373187ce58e8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787e1ac109e4dbf319373187ce58e8ee">&#9670;&nbsp;</a></span>sequence() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::<a class="el" href="classsequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>input sequence to copy </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55fd0bf75f3fa30bf458fb8f56bcbe1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fd0bf75f3fa30bf458fb8f56bcbe1c">&#9670;&nbsp;</a></span>sequence() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::<a class="el" href="classsequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a81c61fee659726f2f81da756381682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a81c61fee659726f2f81da756381682">&#9670;&nbsp;</a></span>sequence() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::<a class="el" href="classsequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdbabe7bd3840123b24f044b76f25c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbabe7bd3840123b24f044b76f25c70">&#9670;&nbsp;</a></span>sequence() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::<a class="el" href="classsequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the sequence with the contents of the initializer list <em>lst</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td>initializer list </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c56466582b25edd3e70dbdcdf0cb0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c56466582b25edd3e70dbdcdf0cb0f9">&#9670;&nbsp;</a></span>sequence() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::<a class="el" href="classsequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the sequence with the contents of the range [first, last). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>begin iterator </td></tr>
    <tr><td class="paramname">last</td><td>end iterator </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa1677cc0e4614b53fe4982ad75da3a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1677cc0e4614b53fe4982ad75da3a73">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td>initializer list to copy the values from Basic exception guarantee. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae07666f6c9dd6d86e4dd3bf6af428c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07666f6c9dd6d86e4dd3bf6af428c33">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>LegacyInputIterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>range to copy the elements from Basic exception guarantee. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21c333756a4f16abaf0c6cc120b2d585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c333756a4f16abaf0c6cc120b2d585">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with count copies of value <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with Basic exception guarantee. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa374ac8d4e9081248af8c0d87f3a389a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa374ac8d4e9081248af8c0d87f3a389a">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place anywhere into the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to newly inserted element The element could be inserted anywhere inside the sequence, including at the back or front. This function tries to recyclate free slots after calls to erase(). You should favor this function if you don't care about the sequence ordering. No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a26c928053fd857c85152e8481c9085fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c928053fd857c85152e8481c9085fd">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the end. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the newly constructed object No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a4523ecdfdd34d66231c552e9e838d99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4523ecdfdd34d66231c552e9e838d99a">&#9670;&nbsp;</a></span>emplace_back_iter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::emplace_back_iter </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the end and returns an iterator pointing to this element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the inserted element No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a9da3b4f3576e5dda10cccd6f25eaa20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da3b4f3576e5dda10cccd6f25eaa20c">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the beginning. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the newly constructed object No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a4e5d4624c1f847d68eb5928065424adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5d4624c1f847d68eb5928065424adf">&#9670;&nbsp;</a></span>emplace_front_iter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::emplace_front_iter </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the beginning and returns an iterator pointing to this element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the inserted element No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="afe1e30b217bfed9503871c3d3cc1202f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1e30b217bfed9503871c3d3cc1202f">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the specified elements from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the element to remove </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element This function performs in O(1). Iterators and references to the erased elements are invalidated. Iterators and references to other elements in the sequence remain valid. </dd></dl>

</div>
</div>
<a id="a47b9bc6d5992a987540c2802c0cc8005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b9bc6d5992a987540c2802c0cc8005">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the specified element from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element This function performs in O(1). Iterators and references to the erased element are invalidated. Iterators and references to other elements in the sequence remain valid. </dd></dl>

</div>
</div>
<a id="ac877ba7ba0f16aee06c259825d4f8a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac877ba7ba0f16aee06c259825d4f8a0f">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given element into the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to newly inserted element The element could be inserted anywhere inside the sequence, including at the back or front. This function tries to recyclate free slots after calls to erase(). You should favor this function if you don't care about the sequence ordering. No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="aae1b94a58942af2e64bd7f4ca3ef40c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1b94a58942af2e64bd7f4ca3ef40c2">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given element into the sequence. value is moved into the new element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to newly inserted element The element could be inserted anywhere inside the sequence, including at the back or front. This function tries to recyclate free slots after calls to erase(). You should favor this function if you don't care about the sequence ordering. No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a6e97d78db6b640c4b4b95daaa16bf332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e97d78db6b640c4b4b95daaa16bf332">&#9670;&nbsp;</a></span>iterator_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1sequence__const__iterator.html">const_iterator</a> <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::iterator_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator to given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position in the sequence While sequence is not a random access container, operations on iterators are still faster than for a conventional std::list. This function is faster than using begin()+pos as it might start from the end to reach the required position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad40ac8ecd47e9fe7328409b978bedf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40ac8ecd47e9fe7328409b978bedf78">&#9670;&nbsp;</a></span>iterator_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1sequence__iterator.html">iterator</a> <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::iterator_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position in the sequence While sequence is not a random access container, operations on iterators are still faster than for a conventional std::list. This function is faster than using begin()+pos as it might start from the end to reach the required position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2f24939e2050de1b2d2fab0ab5be93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f24939e2050de1b2d2fab0ab5be93b">&#9670;&nbsp;</a></span>memory_footprint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::memory_footprint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the full memory footprint of this object </p>

</div>
</div>
<a id="ad2f24939e2050de1b2d2fab0ab5be93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f24939e2050de1b2d2fab0ab5be93b">&#9670;&nbsp;</a></span>memory_footprint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::memory_footprint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the full memory footprint of this object </p>

</div>
</div>
<a id="a9a1cf4f0dbceab1313cf14cbb9be8848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1cf4f0dbceab1313cf14cbb9be8848">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&amp; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator, basic exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>input sequence object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="aa7a923134f4d71eee780e083028905f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a923134f4d71eee780e083028905f2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsequence.html">sequence</a>&amp; <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>input sequence object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="a2fa0bfb1b661c56015fc0ed5d0f66094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa0bfb1b661c56015fc0ed5d0f66094">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>No iterators or references are invalidated. Strong exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a771d78864810b402bef7f9472e2839d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771d78864810b402bef7f9472e2839d7">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the sequence. value is moved into the new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44390ab9d37afd652166ea06aa61581b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44390ab9d37afd652166ea06aa61581b">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element value to the beginning of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>No iterators or references are invalidated. Strong exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a646323fdac2528501cbec140df3356dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646323fdac2528501cbec140df3356dc">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element value to the beginning of the sequence. value is moved into the new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>No iterators or references are invalidated. Strong exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c106bcdaa549fecb92d559f5dd30b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c106bcdaa549fecb92d559f5dd30b10">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity of the vector to a value that's greater or equal to new_cap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>new capacity of the sequence If new_cap is greater than the current <a class="el" href="classsequence.html#aa19a2b51755cac8b79aa4ad305622a6c" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, new storage is allocated, otherwise the function does nothing. reserve() does not change the size of the sequence. Note that reserve() only works with <em>OptimizeForSpeed</em> flag. Basic exception guarantee. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68d9c3533038203285a849e166dc56ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d9c3533038203285a849e166dc56ae">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-inserted elements are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a347e2b6f81f51ae535a0674239ea548d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347e2b6f81f51ae535a0674239ea548d">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of value are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25506926c789d4d296550ee3189d1ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25506926c789d4d296550ee3189d1ea2">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional default-inserted elements are prepended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3b8fd95af05c5bd2e9bbc67ebf91ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b8fd95af05c5bd2e9bbc67ebf91ba1">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional copies of value are prepended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72f64c52baadc59c48ab1478ed420e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f64c52baadc59c48ab1478ed420e51">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, class ChunkAllocator  = detail::NullChunkAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsequence.html">sequence</a>&lt; T, Allocator, layout, ChunkAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other sequence to swap with All iterators and references remain valid. An iterator holding the past-the-end value in this container will refer to the other container after the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>save_seq.txt</li>
<li><a class="el" href="sequence_01-_01_copie_8hpp_source.html">sequence - Copie.hpp</a></li>
<li><a class="el" href="sequence_8hpp_source.html">sequence.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classsequence.html">sequence</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
