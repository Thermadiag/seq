<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::devector&lt; T, Allocator, flag &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classseq_1_1devector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseq_1_1devector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::devector&lt; T, Allocator, flag &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Double-ending vector implementation which can be optimized for several use case.  
 <a href="classseq_1_1devector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="devector_8hpp_source.html">devector.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="structseq_1_1detail_1_1_d_e_vector_data.html">seq::detail::DEVectorData&lt; T, std::allocator&lt; T &gt;, OptimizeForBothEnds &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae3217177144dd3d22afd21fb01409fa4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ae3217177144dd3d22afd21fb01409fa4">value_type</a> = T</td></tr>
<tr class="separator:ae3217177144dd3d22afd21fb01409fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e7ecd7ca31f09c06f32a50ba7afbc9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ab4e7ecd7ca31f09c06f32a50ba7afbc9">allocator_type</a> = Allocator</td></tr>
<tr class="separator:ab4e7ecd7ca31f09c06f32a50ba7afbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a5b543beee7d7b1d0caea19bb60d49"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a> = size_t</td></tr>
<tr class="separator:a24a5b543beee7d7b1d0caea19bb60d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce005bbb17f69a2bc55daf9aecf68fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a8ce005bbb17f69a2bc55daf9aecf68fa">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="separator:a8ce005bbb17f69a2bc55daf9aecf68fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5da5ceeca35e724ef47bd91797bb0a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ac5da5ceeca35e724ef47bd91797bb0a2">reference</a> = T &amp;</td></tr>
<tr class="separator:ac5da5ceeca35e724ef47bd91797bb0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d622d174cfd20e4c5a3b2dfae67ffc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#af2d622d174cfd20e4c5a3b2dfae67ffc">const_reference</a> = const T &amp;</td></tr>
<tr class="separator:af2d622d174cfd20e4c5a3b2dfae67ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027484875528af750d6826817c942cf3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a027484875528af750d6826817c942cf3">pointer</a> = T *</td></tr>
<tr class="separator:a027484875528af750d6826817c942cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ad9c011bd3afd2edf57352f4bb27f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ac3ad9c011bd3afd2edf57352f4bb27f1">const_pointer</a> = const T *</td></tr>
<tr class="separator:ac3ad9c011bd3afd2edf57352f4bb27f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadae105c5c9770faf504a4dc6a269886"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> = T *</td></tr>
<tr class="separator:aadae105c5c9770faf504a4dc6a269886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32bd5500b6a718faf99aeda79a8c349"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> = const T *</td></tr>
<tr class="separator:af32bd5500b6a718faf99aeda79a8c349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af816b3889e97dc10e8cd147bb8d6e84f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#af816b3889e97dc10e8cd147bb8d6e84f">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> &gt;</td></tr>
<tr class="separator:af816b3889e97dc10e8cd147bb8d6e84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aebd524decb8d4263b0c182a12dea4c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> &gt;</td></tr>
<tr class="separator:a4aebd524decb8d4263b0c182a12dea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3fefe84a3c6a7388140229c42c159d6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a3fefe84a3c6a7388140229c42c159d6c">devector</a> ()</td></tr>
<tr class="memdesc:a3fefe84a3c6a7388140229c42c159d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classseq_1_1devector.html#a3fefe84a3c6a7388140229c42c159d6c">More...</a><br /></td></tr>
<tr class="separator:a3fefe84a3c6a7388140229c42c159d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9ad834efb737db31bd53ba773d2984"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#adb9ad834efb737db31bd53ba773d2984">devector</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:adb9ad834efb737db31bd53ba773d2984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given allocator alloc.  <a href="classseq_1_1devector.html#adb9ad834efb737db31bd53ba773d2984">More...</a><br /></td></tr>
<tr class="separator:adb9ad834efb737db31bd53ba773d2984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9873d3e5052a49786073cdf25a406f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a0f9873d3e5052a49786073cdf25a406f">devector</a> (<a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a> count, const T &amp;value, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a0f9873d3e5052a49786073cdf25a406f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of elements with value value.  <a href="classseq_1_1devector.html#a0f9873d3e5052a49786073cdf25a406f">More...</a><br /></td></tr>
<tr class="separator:a0f9873d3e5052a49786073cdf25a406f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab084dbdeb123b2c9527114fd99e1b046"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ab084dbdeb123b2c9527114fd99e1b046">devector</a> (<a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a> count, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:ab084dbdeb123b2c9527114fd99e1b046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count element default constructed.  <a href="classseq_1_1devector.html#ab084dbdeb123b2c9527114fd99e1b046">More...</a><br /></td></tr>
<tr class="separator:ab084dbdeb123b2c9527114fd99e1b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ccf4875731b2440cdadae85751b56e"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ae6ccf4875731b2440cdadae85751b56e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ae6ccf4875731b2440cdadae85751b56e">devector</a> (InputIt first, InputIt last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:ae6ccf4875731b2440cdadae85751b56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="classseq_1_1devector.html#ae6ccf4875731b2440cdadae85751b56e">More...</a><br /></td></tr>
<tr class="separator:ae6ccf4875731b2440cdadae85751b56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c71d99d38b3b770ecf39b09dc3ecfc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a81c71d99d38b3b770ecf39b09dc3ecfc">devector</a> (const <a class="el" href="classseq_1_1devector.html">devector</a> &amp;other)</td></tr>
<tr class="memdesc:a81c71d99d38b3b770ecf39b09dc3ecfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1devector.html#a81c71d99d38b3b770ecf39b09dc3ecfc">More...</a><br /></td></tr>
<tr class="separator:a81c71d99d38b3b770ecf39b09dc3ecfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba09d5a78f67724af349d70b298ccd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ac5ba09d5a78f67724af349d70b298ccd">devector</a> (const <a class="el" href="classseq_1_1devector.html">devector</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:ac5ba09d5a78f67724af349d70b298ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1devector.html#ac5ba09d5a78f67724af349d70b298ccd">More...</a><br /></td></tr>
<tr class="separator:ac5ba09d5a78f67724af349d70b298ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f2955b059ff0a24cf3c371e06f764d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ab9f2955b059ff0a24cf3c371e06f764d">devector</a> (<a class="el" href="classseq_1_1devector.html">devector</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab9f2955b059ff0a24cf3c371e06f764d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classseq_1_1devector.html#ab9f2955b059ff0a24cf3c371e06f764d">More...</a><br /></td></tr>
<tr class="separator:ab9f2955b059ff0a24cf3c371e06f764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa637f78aff0773b889bba39a6db5ac91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#aa637f78aff0773b889bba39a6db5ac91">devector</a> (<a class="el" href="classseq_1_1devector.html">devector</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:aa637f78aff0773b889bba39a6db5ac91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classseq_1_1devector.html#aa637f78aff0773b889bba39a6db5ac91">More...</a><br /></td></tr>
<tr class="separator:aa637f78aff0773b889bba39a6db5ac91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3500ca8da2e7fd7d39523e948cceded"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ad3500ca8da2e7fd7d39523e948cceded">devector</a> (std::initializer_list&lt; T &gt; init, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:ad3500ca8da2e7fd7d39523e948cceded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init.  <a href="classseq_1_1devector.html#ad3500ca8da2e7fd7d39523e948cceded">More...</a><br /></td></tr>
<tr class="separator:ad3500ca8da2e7fd7d39523e948cceded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60f96b557a4fa6a56ec461b4de165d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4">size</a> () const noexcept</td></tr>
<tr class="memdesc:af60f96b557a4fa6a56ec461b4de165d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size.  <a href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4">More...</a><br /></td></tr>
<tr class="separator:af60f96b557a4fa6a56ec461b4de165d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046d4be644a2fe27859066e26c08f339"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a046d4be644a2fe27859066e26c08f339">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a046d4be644a2fe27859066e26c08f339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container full capacity (<a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87" title="Returns the container back capacity.">back_capacity()</a> + <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a> + <a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942" title="Returns the container front capacity.">front_capacity()</a>)  <a href="classseq_1_1devector.html#a046d4be644a2fe27859066e26c08f339">More...</a><br /></td></tr>
<tr class="separator:a046d4be644a2fe27859066e26c08f339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3684a613c9ffec39e6b56772c850aa87"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87">back_capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a3684a613c9ffec39e6b56772c850aa87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container back capacity.  <a href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87">More...</a><br /></td></tr>
<tr class="separator:a3684a613c9ffec39e6b56772c850aa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669166063e020cce4e00092288b0a942"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942">front_capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a669166063e020cce4e00092288b0a942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container front capacity.  <a href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942">More...</a><br /></td></tr>
<tr class="separator:a669166063e020cce4e00092288b0a942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae486774510d411a45a11765b7a948464"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ae486774510d411a45a11765b7a948464">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:ae486774510d411a45a11765b7a948464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size.  <a href="classseq_1_1devector.html#ae486774510d411a45a11765b7a948464">More...</a><br /></td></tr>
<tr class="separator:ae486774510d411a45a11765b7a948464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf61be36c4ce28bede8e1c8d8a35b51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#afbf61be36c4ce28bede8e1c8d8a35b51">empty</a> () const noexcept</td></tr>
<tr class="memdesc:afbf61be36c4ce28bede8e1c8d8a35b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the container is empty, false otherwise.  <a href="classseq_1_1devector.html#afbf61be36c4ce28bede8e1c8d8a35b51">More...</a><br /></td></tr>
<tr class="separator:afbf61be36c4ce28bede8e1c8d8a35b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadee566959ee1d042db57d542f359ed8"><td class="memItemLeft" align="right" valign="top">Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#aadee566959ee1d042db57d542f359ed8">get_allocator</a> () noexcept</td></tr>
<tr class="memdesc:aadee566959ee1d042db57d542f359ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container allocator object.  <a href="classseq_1_1devector.html#aadee566959ee1d042db57d542f359ed8">More...</a><br /></td></tr>
<tr class="separator:aadee566959ee1d042db57d542f359ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138520afd8421861ebfc1e5d05eaeda7"><td class="memItemLeft" align="right" valign="top">Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a138520afd8421861ebfc1e5d05eaeda7">get_allocator</a> () const</td></tr>
<tr class="memdesc:a138520afd8421861ebfc1e5d05eaeda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container allocator object.  <a href="classseq_1_1devector.html#a138520afd8421861ebfc1e5d05eaeda7">More...</a><br /></td></tr>
<tr class="separator:a138520afd8421861ebfc1e5d05eaeda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7670284631ce1eedfea53b96b5cd4494"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a7670284631ce1eedfea53b96b5cd4494">clear</a> () noexcept</td></tr>
<tr class="memdesc:a7670284631ce1eedfea53b96b5cd4494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the container, but does not deallocate the storage.  <a href="classseq_1_1devector.html#a7670284631ce1eedfea53b96b5cd4494">More...</a><br /></td></tr>
<tr class="separator:a7670284631ce1eedfea53b96b5cd4494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dc6ca1ccdabd0c74731209913b2090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ad7dc6ca1ccdabd0c74731209913b2090">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:ad7dc6ca1ccdabd0c74731209913b2090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity. Strong exception guarentee.  <a href="classseq_1_1devector.html#ad7dc6ca1ccdabd0c74731209913b2090">More...</a><br /></td></tr>
<tr class="separator:ad7dc6ca1ccdabd0c74731209913b2090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8de2d7bb6aaa6317e70c2fdf33a4890"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ac8de2d7bb6aaa6317e70c2fdf33a4890">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ac8de2d7bb6aaa6317e70c2fdf33a4890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element at the back of the container. The complexity is amortized O(1) for OptimizeForPushBack and OptimizeForBothEnds, O(N) for OptimizeForPushFront. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87" title="Returns the container back capacity.">back_capacity()</a> == 0.  <a href="classseq_1_1devector.html#ac8de2d7bb6aaa6317e70c2fdf33a4890">More...</a><br /></td></tr>
<tr class="separator:ac8de2d7bb6aaa6317e70c2fdf33a4890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab45a92dfbe1d074b7ef2ef419d0c325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#aab45a92dfbe1d074b7ef2ef419d0c325">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:aab45a92dfbe1d074b7ef2ef419d0c325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element at the back of the container using move semantic. The complexity is amortized O(1) for OptimizeForPushBack and OptimizeForBothEnds, O(N) for OptimizeForPushFront. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87" title="Returns the container back capacity.">back_capacity()</a> == 0.  <a href="classseq_1_1devector.html#aab45a92dfbe1d074b7ef2ef419d0c325">More...</a><br /></td></tr>
<tr class="separator:aab45a92dfbe1d074b7ef2ef419d0c325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7e17d782ff34c2fe0e0d0405f66129"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a2c7e17d782ff34c2fe0e0d0405f66129"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#ac5da5ceeca35e724ef47bd91797bb0a2">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a2c7e17d782ff34c2fe0e0d0405f66129">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2c7e17d782ff34c2fe0e0d0405f66129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the end of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... The complexity is amortized O(1) for OptimizeForPushBack and OptimizeForBothEnds, O(N) for OptimizeForPushFront. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87" title="Returns the container back capacity.">back_capacity()</a> == 0.  <a href="classseq_1_1devector.html#a2c7e17d782ff34c2fe0e0d0405f66129">More...</a><br /></td></tr>
<tr class="separator:a2c7e17d782ff34c2fe0e0d0405f66129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10831168489b4fcd47b4dbcc9fef96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a0d10831168489b4fcd47b4dbcc9fef96">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a0d10831168489b4fcd47b4dbcc9fef96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element at the front of the container. The complexity is amortized O(1) for OptimizeForPushFront and OptimizeForBothEnds, O(N) for OptimizeForPushBack. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942" title="Returns the container front capacity.">front_capacity()</a> == 0.  <a href="classseq_1_1devector.html#a0d10831168489b4fcd47b4dbcc9fef96">More...</a><br /></td></tr>
<tr class="separator:a0d10831168489b4fcd47b4dbcc9fef96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c496edf014b84398c0e2a21a47146c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a46c496edf014b84398c0e2a21a47146c">push_front</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a46c496edf014b84398c0e2a21a47146c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element at the front of the container using move semantic. The complexity is amortized O(1) for OptimizeForPushFront and OptimizeForBothEnds, O(N) for OptimizeForPushBack. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942" title="Returns the container front capacity.">front_capacity()</a> == 0.  <a href="classseq_1_1devector.html#a46c496edf014b84398c0e2a21a47146c">More...</a><br /></td></tr>
<tr class="separator:a46c496edf014b84398c0e2a21a47146c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d9ab1e2b039c7f2c4e55dbbfdaec10"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a84d9ab1e2b039c7f2c4e55dbbfdaec10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#ac5da5ceeca35e724ef47bd91797bb0a2">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a84d9ab1e2b039c7f2c4e55dbbfdaec10">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a84d9ab1e2b039c7f2c4e55dbbfdaec10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the front of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... The complexity is amortized O(1) for OptimizeForPushFront and OptimizeForBothEnds, O(N) for OptimizeForPushBack. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942" title="Returns the container front capacity.">front_capacity()</a> == 0.  <a href="classseq_1_1devector.html#a84d9ab1e2b039c7f2c4e55dbbfdaec10">More...</a><br /></td></tr>
<tr class="separator:a84d9ab1e2b039c7f2c4e55dbbfdaec10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936d7219cd92d42b74263dd7d8817fbb"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a936d7219cd92d42b74263dd7d8817fbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a936d7219cd92d42b74263dd7d8817fbb">emplace</a> (<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a936d7219cd92d42b74263dd7d8817fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before pos. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at a location provided by the container. However, if the required location has been occupied by an existing element, the inserted element is constructed at another location at first, and then move assigned into the required location. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... args... may directly or indirectly refer to a value in the container. Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee.  <a href="classseq_1_1devector.html#a936d7219cd92d42b74263dd7d8817fbb">More...</a><br /></td></tr>
<tr class="separator:a936d7219cd92d42b74263dd7d8817fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d5b49e3c1321a68c278cab2946d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a610d5b49e3c1321a68c278cab2946d3b">insert</a> (<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a610d5b49e3c1321a68c278cab2946d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before pos. Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee.  <a href="classseq_1_1devector.html#a610d5b49e3c1321a68c278cab2946d3b">More...</a><br /></td></tr>
<tr class="separator:a610d5b49e3c1321a68c278cab2946d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2da204b04f387a7d7def09e2de9a4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a8d2da204b04f387a7d7def09e2de9a4e">insert</a> (<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a8d2da204b04f387a7d7def09e2de9a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before pos using move semantic. Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee.  <a href="classseq_1_1devector.html#a8d2da204b04f387a7d7def09e2de9a4e">More...</a><br /></td></tr>
<tr class="separator:a8d2da204b04f387a7d7def09e2de9a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56754fdef6558bba3ab574e473125f8c"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a56754fdef6558bba3ab574e473125f8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a56754fdef6558bba3ab574e473125f8c">insert</a> (<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a56754fdef6558bba3ab574e473125f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos. Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee.  <a href="classseq_1_1devector.html#a56754fdef6558bba3ab574e473125f8c">More...</a><br /></td></tr>
<tr class="separator:a56754fdef6558bba3ab574e473125f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160a5a9e1188d858980af44bdc630af3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a160a5a9e1188d858980af44bdc630af3">insert</a> (<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>, <a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a160a5a9e1188d858980af44bdc630af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts count copies of the value before pos Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee.  <a href="classseq_1_1devector.html#a160a5a9e1188d858980af44bdc630af3">More...</a><br /></td></tr>
<tr class="separator:a160a5a9e1188d858980af44bdc630af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c6a990e15975fe7b1a1cf111c7ad92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a67c6a990e15975fe7b1a1cf111c7ad92">insert</a> (<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a67c6a990e15975fe7b1a1cf111c7ad92"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts elements from initializer list ilist before pos Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee.  <a href="classseq_1_1devector.html#a67c6a990e15975fe7b1a1cf111c7ad92">More...</a><br /></td></tr>
<tr class="separator:a67c6a990e15975fe7b1a1cf111c7ad92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de2b39307fc6d565bfd4c0ae22bfee5"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a8de2b39307fc6d565bfd4c0ae22bfee5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a8de2b39307fc6d565bfd4c0ae22bfee5">assign</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a8de2b39307fc6d565bfd4c0ae22bfee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign elements from range [first, last) to the container. Invalidate all references and iterators. Basic exception guarantee.  <a href="classseq_1_1devector.html#a8de2b39307fc6d565bfd4c0ae22bfee5">More...</a><br /></td></tr>
<tr class="separator:a8de2b39307fc6d565bfd4c0ae22bfee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb7a0517ccfe626af25a490267ca906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a1eb7a0517ccfe626af25a490267ca906">assign</a> (<a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a1eb7a0517ccfe626af25a490267ca906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with count copies of value value Invalidate all references and iterators. Basic exception guarantee.  <a href="classseq_1_1devector.html#a1eb7a0517ccfe626af25a490267ca906">More...</a><br /></td></tr>
<tr class="separator:a1eb7a0517ccfe626af25a490267ca906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9443a54a1b2fbaf09cc3eda134c1c746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a9443a54a1b2fbaf09cc3eda134c1c746">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a9443a54a1b2fbaf09cc3eda134c1c746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list ilist Invalidate all references and iterators. Basic exception guarantee.  <a href="classseq_1_1devector.html#a9443a54a1b2fbaf09cc3eda134c1c746">More...</a><br /></td></tr>
<tr class="separator:a9443a54a1b2fbaf09cc3eda134c1c746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf9a8520bffb6176384db953146c8ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a8bf9a8520bffb6176384db953146c8ba">pop_back</a> () noexcept</td></tr>
<tr class="memdesc:a8bf9a8520bffb6176384db953146c8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container Iterators and references to the last element, as well as the <a class="el" href="classseq_1_1devector.html#a1a74b918b004144e4f1f6025797a94a3" title="Returns an iterator to the element following the last element of the devector.">end()</a> iterator, are invalidated.  <a href="classseq_1_1devector.html#a8bf9a8520bffb6176384db953146c8ba">More...</a><br /></td></tr>
<tr class="separator:a8bf9a8520bffb6176384db953146c8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe0361f9ea84833729ab052c94566eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#adbe0361f9ea84833729ab052c94566eb">pop_front</a> () noexcept</td></tr>
<tr class="memdesc:adbe0361f9ea84833729ab052c94566eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of the container Iterators and references to the first element are invalidated.  <a href="classseq_1_1devector.html#adbe0361f9ea84833729ab052c94566eb">More...</a><br /></td></tr>
<tr class="separator:adbe0361f9ea84833729ab052c94566eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ee5fce221473f6a4f5ab69bcb67940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a14ee5fce221473f6a4f5ab69bcb67940">erase</a> (<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> first, <a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> last)</td></tr>
<tr class="memdesc:a14ee5fce221473f6a4f5ab69bcb67940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last). Basic exception guarantee.  <a href="classseq_1_1devector.html#a14ee5fce221473f6a4f5ab69bcb67940">More...</a><br /></td></tr>
<tr class="separator:a14ee5fce221473f6a4f5ab69bcb67940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d33556776d4139b965aea0ca10da0a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a9d33556776d4139b965aea0ca10da0a2">erase</a> (<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>)</td></tr>
<tr class="memdesc:a9d33556776d4139b965aea0ca10da0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos Basic exception guarantee.  <a href="classseq_1_1devector.html#a9d33556776d4139b965aea0ca10da0a2">More...</a><br /></td></tr>
<tr class="separator:a9d33556776d4139b965aea0ca10da0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdd4a389d12386193a8e027210df1b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a8cdd4a389d12386193a8e027210df1b0">swap</a> (<a class="el" href="classseq_1_1devector.html">devector</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a8cdd4a389d12386193a8e027210df1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this container with other Does not invalidated iterators, including <a class="el" href="classseq_1_1devector.html#a1a74b918b004144e4f1f6025797a94a3" title="Returns an iterator to the element following the last element of the devector.">end()</a> iterator.  <a href="classseq_1_1devector.html#a8cdd4a389d12386193a8e027210df1b0">More...</a><br /></td></tr>
<tr class="separator:a8cdd4a389d12386193a8e027210df1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e4712f4c74bec591ff2f0d10e10a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a54e4712f4c74bec591ff2f0d10e10a53">reserve</a> (size_t new_cap)</td></tr>
<tr class="memdesc:a54e4712f4c74bec591ff2f0d10e10a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the devector (the total number of elements that the devector can hold without requiring reallocation) to a value that's greater or equal to new_cap. If new_cap is greater than the current <a class="el" href="structseq_1_1detail_1_1_d_e_vector_data.html#ad9792bc1862077268e153a4dfd0a2b66">capacity()</a>, new storage is allocated, otherwise the function does nothing. When reallocating, the front and back capacity is adjusted depending on the optimization flag. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee.  <a href="classseq_1_1devector.html#a54e4712f4c74bec591ff2f0d10e10a53">More...</a><br /></td></tr>
<tr class="separator:a54e4712f4c74bec591ff2f0d10e10a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a79a5beaf35a4568574ff4a1e8ddf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a49a79a5beaf35a4568574ff4a1e8ddf6">reserve_back</a> (size_t new_back_capacity)</td></tr>
<tr class="memdesc:a49a79a5beaf35a4568574ff4a1e8ddf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the devector has at least new_back_capacity free slots at the back, no matter what is the optimization flag. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee.  <a href="classseq_1_1devector.html#a49a79a5beaf35a4568574ff4a1e8ddf6">More...</a><br /></td></tr>
<tr class="separator:a49a79a5beaf35a4568574ff4a1e8ddf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa650950408291dc8681255279bc85a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#aa650950408291dc8681255279bc85a3e">reserve_front</a> (size_t new_front_capacity)</td></tr>
<tr class="memdesc:aa650950408291dc8681255279bc85a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the devector has at least new_front_capacity free slots at the front, no matter what is the optimization flag. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee.  <a href="classseq_1_1devector.html#aa650950408291dc8681255279bc85a3e">More...</a><br /></td></tr>
<tr class="separator:aa650950408291dc8681255279bc85a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f275a449330e0c685adc5b8e907c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a22f275a449330e0c685adc5b8e907c22">resize</a> (size_t count)</td></tr>
<tr class="memdesc:a22f275a449330e0c685adc5b8e907c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee.  <a href="classseq_1_1devector.html#a22f275a449330e0c685adc5b8e907c22">More...</a><br /></td></tr>
<tr class="separator:a22f275a449330e0c685adc5b8e907c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34202c1f317b92dce0d00c7345d4f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ac34202c1f317b92dce0d00c7345d4f56">resize</a> (size_t count, const T &amp;value)</td></tr>
<tr class="memdesc:ac34202c1f317b92dce0d00c7345d4f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee.  <a href="classseq_1_1devector.html#ac34202c1f317b92dce0d00c7345d4f56">More...</a><br /></td></tr>
<tr class="separator:ac34202c1f317b92dce0d00c7345d4f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3089cff6cc2da56dace46cab6a666ead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a3089cff6cc2da56dace46cab6a666ead">resize_front</a> (size_t new_size)</td></tr>
<tr class="memdesc:a3089cff6cc2da56dace46cab6a666ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements. The container is extended by the front. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee.  <a href="classseq_1_1devector.html#a3089cff6cc2da56dace46cab6a666ead">More...</a><br /></td></tr>
<tr class="separator:a3089cff6cc2da56dace46cab6a666ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33066dedfb3543a31b22de5f3c22abce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a33066dedfb3543a31b22de5f3c22abce">resize_front</a> (size_t new_size, const T &amp;value)</td></tr>
<tr class="memdesc:a33066dedfb3543a31b22de5f3c22abce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements. The container is extended by the front. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee.  <a href="classseq_1_1devector.html#a33066dedfb3543a31b22de5f3c22abce">More...</a><br /></td></tr>
<tr class="separator:a33066dedfb3543a31b22de5f3c22abce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983a72269e8244a29d1837f029264430"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430">data</a> () noexcept</td></tr>
<tr class="memdesc:a983a72269e8244a29d1837f029264430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case).  <a href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430">More...</a><br /></td></tr>
<tr class="separator:a983a72269e8244a29d1837f029264430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4195eae975c9bbf57fcf0e634de5ad8d"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a4195eae975c9bbf57fcf0e634de5ad8d">data</a> () const noexcept</td></tr>
<tr class="memdesc:a4195eae975c9bbf57fcf0e634de5ad8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case).  <a href="classseq_1_1devector.html#a4195eae975c9bbf57fcf0e634de5ad8d">More...</a><br /></td></tr>
<tr class="separator:a4195eae975c9bbf57fcf0e634de5ad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4233499d7df6a2be8eb311652476f4c5"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a4233499d7df6a2be8eb311652476f4c5">back</a> () noexcept</td></tr>
<tr class="memdesc:a4233499d7df6a2be8eb311652476f4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the back element.  <a href="classseq_1_1devector.html#a4233499d7df6a2be8eb311652476f4c5">More...</a><br /></td></tr>
<tr class="separator:a4233499d7df6a2be8eb311652476f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cc563a86a19ac48e63c5995c8f5d92"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ae5cc563a86a19ac48e63c5995c8f5d92">back</a> () const noexcept</td></tr>
<tr class="memdesc:ae5cc563a86a19ac48e63c5995c8f5d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the back element.  <a href="classseq_1_1devector.html#ae5cc563a86a19ac48e63c5995c8f5d92">More...</a><br /></td></tr>
<tr class="separator:ae5cc563a86a19ac48e63c5995c8f5d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91da93246bc151eeca655d0f40a5910"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ae91da93246bc151eeca655d0f40a5910">front</a> () noexcept</td></tr>
<tr class="memdesc:ae91da93246bc151eeca655d0f40a5910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the front element.  <a href="classseq_1_1devector.html#ae91da93246bc151eeca655d0f40a5910">More...</a><br /></td></tr>
<tr class="separator:ae91da93246bc151eeca655d0f40a5910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7633fa19128528b51235c2e1d33b77"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#abc7633fa19128528b51235c2e1d33b77">front</a> () const noexcept</td></tr>
<tr class="memdesc:abc7633fa19128528b51235c2e1d33b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the front element.  <a href="classseq_1_1devector.html#abc7633fa19128528b51235c2e1d33b77">More...</a><br /></td></tr>
<tr class="separator:abc7633fa19128528b51235c2e1d33b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88d8674cf3d3ed081e14e70d09d51fb"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ae88d8674cf3d3ed081e14e70d09d51fb">operator[]</a> (size_t <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>) const noexcept</td></tr>
<tr class="memdesc:ae88d8674cf3d3ed081e14e70d09d51fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at pos.  <a href="classseq_1_1devector.html#ae88d8674cf3d3ed081e14e70d09d51fb">More...</a><br /></td></tr>
<tr class="separator:ae88d8674cf3d3ed081e14e70d09d51fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0fe0a8a0f62ba1e246200e3884f9fa"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a2a0fe0a8a0f62ba1e246200e3884f9fa">operator[]</a> (size_t <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>) noexcept</td></tr>
<tr class="memdesc:a2a0fe0a8a0f62ba1e246200e3884f9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at pos.  <a href="classseq_1_1devector.html#a2a0fe0a8a0f62ba1e246200e3884f9fa">More...</a><br /></td></tr>
<tr class="separator:a2a0fe0a8a0f62ba1e246200e3884f9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3307eb36c64638601f3657b9cd8b20d"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#aa3307eb36c64638601f3657b9cd8b20d">at</a> (size_t <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>) const</td></tr>
<tr class="memdesc:aa3307eb36c64638601f3657b9cd8b20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at pos. Throw std::out_of_range if pos is invalid. <br  />
  <a href="classseq_1_1devector.html#aa3307eb36c64638601f3657b9cd8b20d">More...</a><br /></td></tr>
<tr class="separator:aa3307eb36c64638601f3657b9cd8b20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a0a122a2cfe6a3cb7b5927b7d21d06"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ab3a0a122a2cfe6a3cb7b5927b7d21d06">at</a> (size_t <a class="el" href="namespaceseq.html#a4af98bbd3b7d9b7d7cb552f6f3a8d220">pos</a>)</td></tr>
<tr class="memdesc:ab3a0a122a2cfe6a3cb7b5927b7d21d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at pos. Throw std::out_of_range if pos is invalid. <br  />
  <a href="classseq_1_1devector.html#ab3a0a122a2cfe6a3cb7b5927b7d21d06">More...</a><br /></td></tr>
<tr class="separator:ab3a0a122a2cfe6a3cb7b5927b7d21d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017a1f3425009f7c01051744334e43ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a017a1f3425009f7c01051744334e43ca">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a017a1f3425009f7c01051744334e43ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the devector.  <a href="classseq_1_1devector.html#a017a1f3425009f7c01051744334e43ca">More...</a><br /></td></tr>
<tr class="separator:a017a1f3425009f7c01051744334e43ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58382cc988c7412bed513adf5a5854a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#af58382cc988c7412bed513adf5a5854a">begin</a> () noexcept</td></tr>
<tr class="memdesc:af58382cc988c7412bed513adf5a5854a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the devector.  <a href="classseq_1_1devector.html#af58382cc988c7412bed513adf5a5854a">More...</a><br /></td></tr>
<tr class="separator:af58382cc988c7412bed513adf5a5854a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4660372a671c8aa2ab3e06b432b011e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a4660372a671c8aa2ab3e06b432b011e0">end</a> () const noexcept</td></tr>
<tr class="memdesc:a4660372a671c8aa2ab3e06b432b011e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the devector.  <a href="classseq_1_1devector.html#a4660372a671c8aa2ab3e06b432b011e0">More...</a><br /></td></tr>
<tr class="separator:a4660372a671c8aa2ab3e06b432b011e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a74b918b004144e4f1f6025797a94a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a1a74b918b004144e4f1f6025797a94a3">end</a> () noexcept</td></tr>
<tr class="memdesc:a1a74b918b004144e4f1f6025797a94a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the devector.  <a href="classseq_1_1devector.html#a1a74b918b004144e4f1f6025797a94a3">More...</a><br /></td></tr>
<tr class="separator:a1a74b918b004144e4f1f6025797a94a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b39c0cc242f2a6a09c26c01898cb08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#af816b3889e97dc10e8cd147bb8d6e84f">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ac0b39c0cc242f2a6a09c26c01898cb08">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:ac0b39c0cc242f2a6a09c26c01898cb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed devector.  <a href="classseq_1_1devector.html#ac0b39c0cc242f2a6a09c26c01898cb08">More...</a><br /></td></tr>
<tr class="separator:ac0b39c0cc242f2a6a09c26c01898cb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d3c6b801ee2a1fb1df803d1d26be69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#ae8d3c6b801ee2a1fb1df803d1d26be69">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ae8d3c6b801ee2a1fb1df803d1d26be69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed devector.  <a href="classseq_1_1devector.html#ae8d3c6b801ee2a1fb1df803d1d26be69">More...</a><br /></td></tr>
<tr class="separator:ae8d3c6b801ee2a1fb1df803d1d26be69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960b362a35f8c3a39acd7684d605ad28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#af816b3889e97dc10e8cd147bb8d6e84f">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a960b362a35f8c3a39acd7684d605ad28">rend</a> () noexcept</td></tr>
<tr class="memdesc:a960b362a35f8c3a39acd7684d605ad28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed devector.  <a href="classseq_1_1devector.html#a960b362a35f8c3a39acd7684d605ad28">More...</a><br /></td></tr>
<tr class="separator:a960b362a35f8c3a39acd7684d605ad28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9465b9c0126b19828ab74e5d812ad735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a9465b9c0126b19828ab74e5d812ad735">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a9465b9c0126b19828ab74e5d812ad735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed devector.  <a href="classseq_1_1devector.html#a9465b9c0126b19828ab74e5d812ad735">More...</a><br /></td></tr>
<tr class="separator:a9465b9c0126b19828ab74e5d812ad735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6895b1d5c06e13ca597b97d5aa0c5fc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a6895b1d5c06e13ca597b97d5aa0c5fc2">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a6895b1d5c06e13ca597b97d5aa0c5fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the devector.  <a href="classseq_1_1devector.html#a6895b1d5c06e13ca597b97d5aa0c5fc2">More...</a><br /></td></tr>
<tr class="separator:a6895b1d5c06e13ca597b97d5aa0c5fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1dbbfc5088ab1864429909f6f8a98c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a0d1dbbfc5088ab1864429909f6f8a98c">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a0d1dbbfc5088ab1864429909f6f8a98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the devector.  <a href="classseq_1_1devector.html#a0d1dbbfc5088ab1864429909f6f8a98c">More...</a><br /></td></tr>
<tr class="separator:a0d1dbbfc5088ab1864429909f6f8a98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeffdbeecf345708b279bf64028d4852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#aaeffdbeecf345708b279bf64028d4852">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aaeffdbeecf345708b279bf64028d4852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed devector.  <a href="classseq_1_1devector.html#aaeffdbeecf345708b279bf64028d4852">More...</a><br /></td></tr>
<tr class="separator:aaeffdbeecf345708b279bf64028d4852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473c5865528c0fa68ce9bf6c9e751bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a473c5865528c0fa68ce9bf6c9e751bde">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a473c5865528c0fa68ce9bf6c9e751bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed devector.  <a href="classseq_1_1devector.html#a473c5865528c0fa68ce9bf6c9e751bde">More...</a><br /></td></tr>
<tr class="separator:a473c5865528c0fa68ce9bf6c9e751bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85071c0d48aecf687c5c42d287b5df08"><td class="memTemplParams" colspan="2">template&lt;class Alloc , DEVectorFlag F&gt; </td></tr>
<tr class="memitem:a85071c0d48aecf687c5c42d287b5df08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html">devector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a85071c0d48aecf687c5c42d287b5df08">operator=</a> (const <a class="el" href="classseq_1_1devector.html">devector</a>&lt; T, Alloc, F &gt; &amp;other)</td></tr>
<tr class="memdesc:a85071c0d48aecf687c5c42d287b5df08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator.  <a href="classseq_1_1devector.html#a85071c0d48aecf687c5c42d287b5df08">More...</a><br /></td></tr>
<tr class="separator:a85071c0d48aecf687c5c42d287b5df08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1a251add8f788531f3af96821e1f0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html">devector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#adf1a251add8f788531f3af96821e1f0c">operator=</a> (const <a class="el" href="classseq_1_1devector.html">devector</a> &amp;other)</td></tr>
<tr class="memdesc:adf1a251add8f788531f3af96821e1f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator.  <a href="classseq_1_1devector.html#adf1a251add8f788531f3af96821e1f0c">More...</a><br /></td></tr>
<tr class="separator:adf1a251add8f788531f3af96821e1f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4244e12f49c601abd79a4a819b7231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1devector.html">devector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1devector.html#a1b4244e12f49c601abd79a4a819b7231">operator=</a> (<a class="el" href="classseq_1_1devector.html">devector</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a1b4244e12f49c601abd79a4a819b7231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classseq_1_1devector.html#a1b4244e12f49c601abd79a4a819b7231">More...</a><br /></td></tr>
<tr class="separator:a1b4244e12f49c601abd79a4a819b7231"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Allocator = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt;<br />
class seq::devector&lt; T, Allocator, flag &gt;</h3>

<p>Double-ending vector implementation which can be optimized for several use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator type </td></tr>
    <tr><td class="paramname">flag</td><td>optimization flag</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1devector.html" title="Double-ending vector implementation which can be optimized for several use case.">seq::devector</a> is a double-ending vector class that mixes the behavior and performances of std::deque and std::vector. Elements are stored in a contiguous memory chunk exatcly like a vector, but might contain free space at the front in addition to free space at the back in order to provide O(1) insertion at the front.</p>
<p><a class="el" href="classseq_1_1devector.html" title="Double-ending vector implementation which can be optimized for several use case.">seq::devector</a> provides a similar interface as std::vector with the following additional members:</p><ul>
<li><a class="el" href="classseq_1_1devector.html#a0d10831168489b4fcd47b4dbcc9fef96" title="Insert an element at the front of the container. The complexity is amortized O(1) for OptimizeForPush...">push_front()</a> and <a class="el" href="classseq_1_1devector.html#a84d9ab1e2b039c7f2c4e55dbbfdaec10" title="Appends a new element to the front of the container. The element is constructed through std::allocato...">emplace_front()</a>: insert an element at the front of the devector</li>
<li><a class="el" href="classseq_1_1devector.html#a3089cff6cc2da56dace46cab6a666ead" title="Resizes the container to contain count elements. The container is extended by the front....">resize_front()</a>: resize the devector from the front instead of the back of the container</li>
<li><a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87" title="Returns the container back capacity.">back_capacity()</a>: returns the capacity (free slots) at the back of the devector</li>
<li><a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942" title="Returns the container front capacity.">front_capacity()</a>: returns the capacity (free slots) at the front of the devector</li>
</ul>
<p>Almost all members provide basic exception guarantee, except if the value type has a noexcept move constructor and move assignment operator, in which case members provide strong exception guarantee.</p>
<p>References and iterators are invalidated by insertion/removal of elements.</p>
<p><a class="el" href="classseq_1_1devector.html" title="Double-ending vector implementation which can be optimized for several use case.">seq::devector</a> is used by <a class="el" href="classseq_1_1deque.html" title="seq::deque is a std::deque like container implemented as a tiered-vector.">seq::deque</a> for bucket storage.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Optimization flags</h2>
<p>devector can be configured with the following flags:</p><ul>
<li>OptimizeForPushBack: the devector behaves like a std::vector, adding free space at the back based on the growth factor SEQ_GROW_FACTOR. In this case, inserting elements at the front is as slow as for std::vector as it require to move all elements toward the back.</li>
<li>OptimizeForPushFront: the devector adds free space at the front based on the growth factor SEQ_GROW_FACTOR. Inserting elements at the front is amortized O(1), inserting at the back is O(N).</li>
<li>OptimizeForBothEnds (default): the devector has as many free space at the back and the front. Both <a class="el" href="classseq_1_1devector.html#ac8de2d7bb6aaa6317e70c2fdf33a4890" title="Insert an element at the back of the container. The complexity is amortized O(1) for OptimizeForPushB...">push_back()</a> and <a class="el" href="classseq_1_1devector.html#a0d10831168489b4fcd47b4dbcc9fef96" title="Insert an element at the front of the container. The complexity is amortized O(1) for OptimizeForPush...">push_front()</a> behave in amortized O(1). When the memory storage grows (by a factor of SEQ_GROW_FACTOR), the elements are moved to the middle of the storage, leaving as much space at the front and the back. When inserting an element at the back, several scenarios are checked (this is similar for front insertion):<ol type="1">
<li>Free slots are available at the back and the element is inserted there.</li>
<li>The devector does not have available slots at the back or the front, a new chunk of memory of size <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a>*SEQ_GROW_FACTOR is allocated, elements are moved to this new memory location (leaving the same capacity at the back and the front) and the new element is inserted at the back.</li>
<li>The devector does not have enough capacity at the back, but has free capacity at the front. In this case, there are 2 possibilities:<ol type="a">
<li>front capacity is greater than <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a> / __SEQ_DEVECTOR_SIZE_LIMIT: elements are moved toward the front, leaving the same capacity at the back and the front. The new element is then inserted at the back.</li>
<li>front capacity is lower or equal to <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a> / __SEQ_DEVECTOR_SIZE_LIMIT: a new chunk is allocated like in b). By default, __SEQ_DEVECTOR_SIZE_LIMIT is set to 16. __SEQ_DEVECTOR_SIZE_LIMIT can be adjusted to provide a different trade-off between insertion speed and memory usage.</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
Performances</h2>
<p>Internal benchmarks show that devector is as fast as std::vector when inserting at the back with OptimizeForPushBack, or inserting at the front with OptimizeForPushFront. Using OptimizeForBothEnds makes insertion at both ends usually twice as slow as back insertion for std::vector.</p>
<p><a class="el" href="classseq_1_1devector.html" title="Double-ending vector implementation which can be optimized for several use case.">seq::devector</a> is faster than std::vector for relocatable types (where <a class="el" href="structseq_1_1is__relocatable.html#a9bc3104d310961a601c2185957f846ad">seq::is_relocatable&lt;T&gt;::value</a> is true) as memcpy and memmove can be used instead of std::copy or std::move on reallocation.</p>
<p>Inserting a new element in the middle of a devector is on average twice as fast as on std::vector, since the values can be pushed to either ends, whichever is faster (at least with OptimizeForBothEnds). </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab4e7ecd7ca31f09c06f32a50ba7afbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e7ecd7ca31f09c06f32a50ba7afbc9">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#ab4e7ecd7ca31f09c06f32a50ba7afbc9">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af32bd5500b6a718faf99aeda79a8c349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32bd5500b6a718faf99aeda79a8c349">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> =  const T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3ad9c011bd3afd2edf57352f4bb27f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ad9c011bd3afd2edf57352f4bb27f1">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#ac3ad9c011bd3afd2edf57352f4bb27f1">const_pointer</a> =  const T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2d622d174cfd20e4c5a3b2dfae67ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d622d174cfd20e4c5a3b2dfae67ffc">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#af2d622d174cfd20e4c5a3b2dfae67ffc">const_reference</a> =  const T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4aebd524decb8d4263b0c182a12dea4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aebd524decb8d4263b0c182a12dea4c">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ce005bbb17f69a2bc55daf9aecf68fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce005bbb17f69a2bc55daf9aecf68fa">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#a8ce005bbb17f69a2bc55daf9aecf68fa">difference_type</a> =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadae105c5c9770faf504a4dc6a269886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadae105c5c9770faf504a4dc6a269886">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a027484875528af750d6826817c942cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027484875528af750d6826817c942cf3">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#a027484875528af750d6826817c942cf3">pointer</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5da5ceeca35e724ef47bd91797bb0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5da5ceeca35e724ef47bd91797bb0a2">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#ac5da5ceeca35e724ef47bd91797bb0a2">reference</a> =  T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af816b3889e97dc10e8cd147bb8d6e84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af816b3889e97dc10e8cd147bb8d6e84f">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#af816b3889e97dc10e8cd147bb8d6e84f">reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24a5b543beee7d7b1d0caea19bb60d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a5b543beee7d7b1d0caea19bb60d49">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a> =  size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3217177144dd3d22afd21fb01409fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3217177144dd3d22afd21fb01409fa4">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html#ae3217177144dd3d22afd21fb01409fa4">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3fefe84a3c6a7388140229c42c159d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fefe84a3c6a7388140229c42c159d6c">&#9670;&nbsp;</a></span>devector() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="adb9ad834efb737db31bd53ba773d2984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9ad834efb737db31bd53ba773d2984">&#9670;&nbsp;</a></span>devector() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given allocator alloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f9873d3e5052a49786073cdf25a406f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9873d3e5052a49786073cdf25a406f">&#9670;&nbsp;</a></span>devector() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab084dbdeb123b2c9527114fd99e1b046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab084dbdeb123b2c9527114fd99e1b046">&#9670;&nbsp;</a></span>devector() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count element default constructed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the size of the container </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6ccf4875731b2440cdadae85751b56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ccf4875731b2440cdadae85751b56e">&#9670;&nbsp;</a></span>devector() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81c71d99d38b3b770ecf39b09dc3ecfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c71d99d38b3b770ecf39b09dc3ecfc">&#9670;&nbsp;</a></span>devector() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1devector.html">devector</a>&lt; T, Allocator, flag &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5ba09d5a78f67724af349d70b298ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ba09d5a78f67724af349d70b298ccd">&#9670;&nbsp;</a></span>devector() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1devector.html">devector</a>&lt; T, Allocator, flag &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9f2955b059ff0a24cf3c371e06f764d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f2955b059ff0a24cf3c371e06f764d">&#9670;&nbsp;</a></span>devector() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html">devector</a>&lt; T, Allocator, flag &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa637f78aff0773b889bba39a6db5ac91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa637f78aff0773b889bba39a6db5ac91">&#9670;&nbsp;</a></span>devector() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html">devector</a>&lt; T, Allocator, flag &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3500ca8da2e7fd7d39523e948cceded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3500ca8da2e7fd7d39523e948cceded">&#9670;&nbsp;</a></span>devector() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::<a class="el" href="classseq_1_1devector.html">devector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8de2b39307fc6d565bfd4c0ae22bfee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de2b39307fc6d565bfd4c0ae22bfee5">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign elements from range [first, last) to the container. Invalidate all references and iterators. Basic exception guarantee. </p>

</div>
</div>
<a id="a1eb7a0517ccfe626af25a490267ca906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb7a0517ccfe626af25a490267ca906">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with count copies of value value Invalidate all references and iterators. Basic exception guarantee. </p>

</div>
</div>
<a id="a9443a54a1b2fbaf09cc3eda134c1c746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9443a54a1b2fbaf09cc3eda134c1c746">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with the elements from the initializer list ilist Invalidate all references and iterators. Basic exception guarantee. </p>

</div>
</div>
<a id="ab3a0a122a2cfe6a3cb7b5927b7d21d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a0a122a2cfe6a3cb7b5927b7d21d06">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at pos. Throw std::out_of_range if pos is invalid. <br  />
 </p>

</div>
</div>
<a id="aa3307eb36c64638601f3657b9cd8b20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3307eb36c64638601f3657b9cd8b20d">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at pos. Throw std::out_of_range if pos is invalid. <br  />
 </p>

</div>
</div>
<a id="ae5cc563a86a19ac48e63c5995c8f5d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cc563a86a19ac48e63c5995c8f5d92">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the back element. </p>

</div>
</div>
<a id="a4233499d7df6a2be8eb311652476f4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4233499d7df6a2be8eb311652476f4c5">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the back element. </p>

</div>
</div>
<a id="a3684a613c9ffec39e6b56772c850aa87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3684a613c9ffec39e6b56772c850aa87">&#9670;&nbsp;</a></span>back_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::back_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container back capacity. </p>

</div>
</div>
<a id="a017a1f3425009f7c01051744334e43ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017a1f3425009f7c01051744334e43ca">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the devector. </p>

</div>
</div>
<a id="af58382cc988c7412bed513adf5a5854a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58382cc988c7412bed513adf5a5854a">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the devector. </p>

</div>
</div>
<a id="a046d4be644a2fe27859066e26c08f339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046d4be644a2fe27859066e26c08f339">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container full capacity (<a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87" title="Returns the container back capacity.">back_capacity()</a> + <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a> + <a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942" title="Returns the container front capacity.">front_capacity()</a>) </p>

</div>
</div>
<a id="a6895b1d5c06e13ca597b97d5aa0c5fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6895b1d5c06e13ca597b97d5aa0c5fc2">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the devector. </p>

</div>
</div>
<a id="a0d1dbbfc5088ab1864429909f6f8a98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1dbbfc5088ab1864429909f6f8a98c">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the devector. </p>

</div>
</div>
<a id="a7670284631ce1eedfea53b96b5cd4494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7670284631ce1eedfea53b96b5cd4494">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the container, but does not deallocate the storage. </p>

</div>
</div>
<a id="aaeffdbeecf345708b279bf64028d4852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeffdbeecf345708b279bf64028d4852">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed devector. </p>

</div>
</div>
<a id="a473c5865528c0fa68ce9bf6c9e751bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473c5865528c0fa68ce9bf6c9e751bde">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed devector. </p>

</div>
</div>
<a id="a4195eae975c9bbf57fcf0e634de5ad8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4195eae975c9bbf57fcf0e634de5ad8d">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case). </p>

</div>
</div>
<a id="a983a72269e8244a29d1837f029264430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983a72269e8244a29d1837f029264430">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classseq_1_1devector.html#a983a72269e8244a29d1837f029264430" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case). </p>

</div>
</div>
<a id="a936d7219cd92d42b74263dd7d8817fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936d7219cd92d42b74263dd7d8817fbb">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before pos. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at a location provided by the container. However, if the required location has been occupied by an existing element, the inserted element is constructed at another location at first, and then move assigned into the required location. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... args... may directly or indirectly refer to a value in the container. Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the inserted element </dd></dl>

</div>
</div>
<a id="a2c7e17d782ff34c2fe0e0d0405f66129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7e17d782ff34c2fe0e0d0405f66129">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#ac5da5ceeca35e724ef47bd91797bb0a2">reference</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the end of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... The complexity is amortized O(1) for OptimizeForPushBack and OptimizeForBothEnds, O(N) for OptimizeForPushFront. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87" title="Returns the container back capacity.">back_capacity()</a> == 0. </p>

</div>
</div>
<a id="a84d9ab1e2b039c7f2c4e55dbbfdaec10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d9ab1e2b039c7f2c4e55dbbfdaec10">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#ac5da5ceeca35e724ef47bd91797bb0a2">reference</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the front of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... The complexity is amortized O(1) for OptimizeForPushFront and OptimizeForBothEnds, O(N) for OptimizeForPushBack. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942" title="Returns the container front capacity.">front_capacity()</a> == 0. </p>

</div>
</div>
<a id="afbf61be36c4ce28bede8e1c8d8a35b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf61be36c4ce28bede8e1c8d8a35b51">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the container is empty, false otherwise. </p>

</div>
</div>
<a id="a4660372a671c8aa2ab3e06b432b011e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4660372a671c8aa2ab3e06b432b011e0">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the devector. </p>

</div>
</div>
<a id="a1a74b918b004144e4f1f6025797a94a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a74b918b004144e4f1f6025797a94a3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the devector. </p>

</div>
</div>
<a id="a14ee5fce221473f6a4f5ab69bcb67940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ee5fce221473f6a4f5ab69bcb67940">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). Basic exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>range of elements to remove </td></tr>
    <tr><td class="paramname">last</td><td>range of elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element </dd></dl>

</div>
</div>
<a id="a9d33556776d4139b965aea0ca10da0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d33556776d4139b965aea0ca10da0a2">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at pos Basic exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator to the position to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="abc7633fa19128528b51235c2e1d33b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7633fa19128528b51235c2e1d33b77">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the front element. </p>

</div>
</div>
<a id="ae91da93246bc151eeca655d0f40a5910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91da93246bc151eeca655d0f40a5910">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the front element. </p>

</div>
</div>
<a id="a669166063e020cce4e00092288b0a942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669166063e020cce4e00092288b0a942">&#9670;&nbsp;</a></span>front_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::front_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container front capacity. </p>

</div>
</div>
<a id="a138520afd8421861ebfc1e5d05eaeda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138520afd8421861ebfc1e5d05eaeda7">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Allocator <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container allocator object. </p>

</div>
</div>
<a id="aadee566959ee1d042db57d542f359ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadee566959ee1d042db57d542f359ed8">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Allocator&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container allocator object. </p>

</div>
</div>
<a id="a610d5b49e3c1321a68c278cab2946d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610d5b49e3c1321a68c278cab2946d3b">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before pos. Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the inserted element </dd></dl>

</div>
</div>
<a id="a56754fdef6558bba3ab574e473125f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56754fdef6558bba3ab574e473125f8c">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos. Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classseq_1_1devector.html#a1a74b918b004144e4f1f6025797a94a3" title="Returns an iterator to the element following the last element of the devector.">end()</a> iterator </td></tr>
    <tr><td class="paramname">first</td><td>the range of elements to insert, can't be iterators into container for which insert is called </td></tr>
    <tr><td class="paramname">last</td><td>the range of elements to insert, can't be iterators into container for which insert is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first element inserted, or pos if first==last. </dd></dl>

</div>
</div>
<a id="a160a5a9e1188d858980af44bdc630af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160a5a9e1188d858980af44bdc630af3">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#a24a5b543beee7d7b1d0caea19bb60d49">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts count copies of the value before pos Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classseq_1_1devector.html#a1a74b918b004144e4f1f6025797a94a3" title="Returns an iterator to the element following the last element of the devector.">end()</a> iterator </td></tr>
    <tr><td class="paramname">count</td><td>number of elements to insert </td></tr>
    <tr><td class="paramname">value</td><td>element value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first element inserted, or pos if first==last </dd></dl>

</div>
</div>
<a id="a67c6a990e15975fe7b1a1cf111c7ad92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c6a990e15975fe7b1a1cf111c7ad92">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts elements from initializer list ilist before pos Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classseq_1_1devector.html#a1a74b918b004144e4f1f6025797a94a3" title="Returns an iterator to the element following the last element of the devector.">end()</a> iterator </td></tr>
    <tr><td class="paramname">ilist</td><td>initializer list to insert the values from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first element inserted, or pos if first==last </dd></dl>

</div>
</div>
<a id="a8d2da204b04f387a7d7def09e2de9a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2da204b04f387a7d7def09e2de9a4e">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#aadae105c5c9770faf504a4dc6a269886">iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html#af32bd5500b6a718faf99aeda79a8c349">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before pos using move semantic. Invalidate all references and iterators. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the inserted element </dd></dl>

</div>
</div>
<a id="ae486774510d411a45a11765b7a948464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae486774510d411a45a11765b7a948464">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container maximum size. </p>

</div>
</div>
<a id="adf1a251add8f788531f3af96821e1f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1a251add8f788531f3af96821e1f0c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">devector</a>&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1devector.html">devector</a>&lt; T, Allocator, flag &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator. </p>

</div>
</div>
<a id="a85071c0d48aecf687c5c42d287b5df08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85071c0d48aecf687c5c42d287b5df08">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<div class="memtemplate">
template&lt;class Alloc , DEVectorFlag F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">devector</a>&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1devector.html">devector</a>&lt; T, Alloc, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator. </p>

</div>
</div>
<a id="a1b4244e12f49c601abd79a4a819b7231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4244e12f49c601abd79a4a819b7231">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html">devector</a>&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html">devector</a>&lt; T, Allocator, flag &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="ae88d8674cf3d3ed081e14e70d09d51fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88d8674cf3d3ed081e14e70d09d51fb">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at pos. </p>

</div>
</div>
<a id="a2a0fe0a8a0f62ba1e246200e3884f9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0fe0a8a0f62ba1e246200e3884f9fa">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at pos. </p>

</div>
</div>
<a id="a8bf9a8520bffb6176384db953146c8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf9a8520bffb6176384db953146c8ba">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container Iterators and references to the last element, as well as the <a class="el" href="classseq_1_1devector.html#a1a74b918b004144e4f1f6025797a94a3" title="Returns an iterator to the element following the last element of the devector.">end()</a> iterator, are invalidated. </p>

</div>
</div>
<a id="adbe0361f9ea84833729ab052c94566eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe0361f9ea84833729ab052c94566eb">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element of the container Iterators and references to the first element are invalidated. </p>

</div>
</div>
<a id="ac8de2d7bb6aaa6317e70c2fdf33a4890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8de2d7bb6aaa6317e70c2fdf33a4890">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element at the back of the container. The complexity is amortized O(1) for OptimizeForPushBack and OptimizeForBothEnds, O(N) for OptimizeForPushFront. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87" title="Returns the container back capacity.">back_capacity()</a> == 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab45a92dfbe1d074b7ef2ef419d0c325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab45a92dfbe1d074b7ef2ef419d0c325">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element at the back of the container using move semantic. The complexity is amortized O(1) for OptimizeForPushBack and OptimizeForBothEnds, O(N) for OptimizeForPushFront. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a3684a613c9ffec39e6b56772c850aa87" title="Returns the container back capacity.">back_capacity()</a> == 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d10831168489b4fcd47b4dbcc9fef96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10831168489b4fcd47b4dbcc9fef96">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element at the front of the container. The complexity is amortized O(1) for OptimizeForPushFront and OptimizeForBothEnds, O(N) for OptimizeForPushBack. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942" title="Returns the container front capacity.">front_capacity()</a> == 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46c496edf014b84398c0e2a21a47146c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c496edf014b84398c0e2a21a47146c">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element at the front of the container using move semantic. The complexity is amortized O(1) for OptimizeForPushFront and OptimizeForBothEnds, O(N) for OptimizeForPushBack. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. Invalidate all references and iterators if <a class="el" href="classseq_1_1devector.html#a669166063e020cce4e00092288b0a942" title="Returns the container front capacity.">front_capacity()</a> == 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8d3c6b801ee2a1fb1df803d1d26be69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d3c6b801ee2a1fb1df803d1d26be69">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed devector. </p>

</div>
</div>
<a id="ac0b39c0cc242f2a6a09c26c01898cb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b39c0cc242f2a6a09c26c01898cb08">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#af816b3889e97dc10e8cd147bb8d6e84f">reverse_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed devector. </p>

</div>
</div>
<a id="a9465b9c0126b19828ab74e5d812ad735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9465b9c0126b19828ab74e5d812ad735">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#a4aebd524decb8d4263b0c182a12dea4c">const_reverse_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed devector. </p>

</div>
</div>
<a id="a960b362a35f8c3a39acd7684d605ad28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960b362a35f8c3a39acd7684d605ad28">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1devector.html#af816b3889e97dc10e8cd147bb8d6e84f">reverse_iterator</a> <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed devector. </p>

</div>
</div>
<a id="a54e4712f4c74bec591ff2f0d10e10a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e4712f4c74bec591ff2f0d10e10a53">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity of the devector (the total number of elements that the devector can hold without requiring reallocation) to a value that's greater or equal to new_cap. If new_cap is greater than the current <a class="el" href="structseq_1_1detail_1_1_d_e_vector_data.html#ad9792bc1862077268e153a4dfd0a2b66">capacity()</a>, new storage is allocated, otherwise the function does nothing. When reallocating, the front and back capacity is adjusted depending on the optimization flag. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee. </p>

</div>
</div>
<a id="a49a79a5beaf35a4568574ff4a1e8ddf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a79a5beaf35a4568574ff4a1e8ddf6">&#9670;&nbsp;</a></span>reserve_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::reserve_back </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_back_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that the devector has at least new_back_capacity free slots at the back, no matter what is the optimization flag. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_back_capacity</td><td>minimum back capacity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa650950408291dc8681255279bc85a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa650950408291dc8681255279bc85a3e">&#9670;&nbsp;</a></span>reserve_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::reserve_front </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_front_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that the devector has at least new_front_capacity free slots at the front, no matter what is the optimization flag. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee if move constructor and move assignment operator are noexcept. Otherwise basic exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_back_capacity</td><td>minimum front capacity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22f275a449330e0c685adc5b8e907c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f275a449330e0c685adc5b8e907c22">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new container size <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac34202c1f317b92dce0d00c7345d4f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34202c1f317b92dce0d00c7345d4f56">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new container size </td></tr>
    <tr><td class="paramname">value</td><td>if count is greater than <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a>, copies of value are appended to the back of the devector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3089cff6cc2da56dace46cab6a666ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3089cff6cc2da56dace46cab6a666ead">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. The container is extended by the front. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new container size <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33066dedfb3543a31b22de5f3c22abce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33066dedfb3543a31b22de5f3c22abce">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. The container is extended by the front. Invalidate iterators and references if a new storage is allocated. Strong exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new container size </td></tr>
    <tr><td class="paramname">value</td><td>if count is greater than <a class="el" href="classseq_1_1devector.html#af60f96b557a4fa6a56ec461b4de165d4" title="Returns the container size.">size()</a>, copies of value are prepended to the back of the devector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7dc6ca1ccdabd0c74731209913b2090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7dc6ca1ccdabd0c74731209913b2090">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. Strong exception guarentee. </p>

</div>
</div>
<a id="af60f96b557a4fa6a56ec461b4de165d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60f96b557a4fa6a56ec461b4de165d4">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size. </p>

</div>
</div>
<a id="a8cdd4a389d12386193a8e027210df1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdd4a389d12386193a8e027210df1b0">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, DEVectorFlag flag = OptimizeForBothEnds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1devector.html">seq::devector</a>&lt; T, Allocator, flag &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1devector.html">devector</a>&lt; T, Allocator, flag &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap this container with other Does not invalidated iterators, including <a class="el" href="classseq_1_1devector.html#a1a74b918b004144e4f1f6025797a94a3" title="Returns an iterator to the element following the last element of the devector.">end()</a> iterator. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="devector_8hpp_source.html">devector.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1devector.html">devector</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
