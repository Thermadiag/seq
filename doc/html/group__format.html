<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: Format: Type safe formatting module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__format.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">Format: Type safe formatting module</div>  </div>
</div><!--header-->
<div class="contents">

<p>The format module provides fast routines for object formatting to string/streams. It is strongly typed and does not rely on string parsing to find the output format. Therefore, almost all possible formatting errors are detected at compilation instead of runtime.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceseq"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceseq.html">seq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The format module provides fast routines for object formatting to string/streams. It is strongly typed and does not rely on string parsing to find the output format. Therefore, almost all possible formatting errors are detected at compilation instead of runtime. </p>
<p>There are already several great C++ formatting libraries available in <a href="https://abseil.io/">Abseil</a>, <a href="https://github.com/facebook/folly">Folly</a> or the <a href="https://fmt.dev/latest/index.html">fmt</a> library. Furtheremore, C++20 will provide a new text formatting library similar to the {fmt} one. The format module is an attempt to provide (yet) another formatting library which does not rely on string parsing, is compatible with c++ streams and is <b>fast</b>.</p>
<p>It was designed first to output huge matrices or tables to files and strings. Format module is based on the <a class="el" href="group__charconv.html">charconv</a> module to format numerical values.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Formatting single values</h2>
<p>Format module heavily relies on the <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a> function to format single or several values.</p>
<p>When formatting a single value, <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a> returns a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class.">seq::ostream_format</a> object providing several members to modify the formatting options:</p><ul>
<li><b>base(int)</b>: specify the base for integral types, similar to b(int)</li>
<li><b>format(char)</b>: specify the format ('e', 'E', 'g', 'G', 'f') for floating point types, similar to t(char)</li>
<li><b>precision(int)</b>: specify the maximum precision for floating point types, similar to p(int)</li>
<li><b>dot(char)</b>: specify the dot character for floating point types, similar to d(char)</li>
<li><b>hex_prefix()</b>: add trailing '0x' for hexadecimal format, similar to h()</li>
<li><b>upper()</b>: output hexadecimal value in upper case, similar to u()</li>
<li><b>as_char()</b>: output integral value as an ascii character, similar to c()</li>
<li><b>left(int)</b>: align output to the left for given width, similar to l(int)</li>
<li><b>right(int)</b>: align output to the right for given width, similar to r(int)</li>
<li><b>center(int)</b>: center output for given width, similar to c(int)</li>
<li><b>fill(char)</b>: specify the filling character used for aligned output (default to space character), similar to f(char)</li>
</ul>
<p>Usage:</p>
<div class="fragment"><div class="line"><span class="comment">// Usage for formatting one value</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> PI = 3.14159265358979323846;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(PI) &lt;&lt; std::endl;                                      <span class="comment">//default double formatting</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(PI,<span class="charliteral">&#39;E&#39;</span>) &lt;&lt; std::endl;                                  <span class="comment">//scientific notation, equivalent to fmt(PI).format(&#39;E&#39;) or fmt(PI).t(&#39;E&#39;)</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(PI,<span class="charliteral">&#39;E&#39;</span>).precision(12) &lt;&lt; std::endl;                    <span class="comment">//scientific notation with maximum precision, equivalent to fmt(PI).t(&#39;E&#39;).precision(12) or fmt(PI).t(&#39;E&#39;).p(12)</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(PI).dot(<span class="charliteral">&#39;,&#39;</span>) &lt;&lt; std::endl;                             <span class="comment">//change dot, equivalent to fmt(PI).d(&#39;,&#39;)</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(PI).right(10).fill(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;                  <span class="comment">//align to the right and pad with &#39;-&#39;, equivalent to fmt(PI).r(10).f(&#39;-&#39;)</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(PI).left(10).fill(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;                   <span class="comment">//align to the left and pad with &#39;-&#39;, equivalent to fmt(PI).l(10).f(&#39;-&#39;)</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(PI).center(10).fill(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;                 <span class="comment">//align to the center and pad with &#39;-&#39;, equivalent to fmt(PI).c(10).f(&#39;-&#39;)</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(123456).base(16).hex_prefix().upper() &lt;&lt; std::endl;    <span class="comment">//hexadecimal upper case with &#39;0x&#39; prefix. equivalent to fmt(123456).b(16).h().u() or hex(123456).h().u()</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;hello&quot;</span>).c(10).f(<span class="charliteral">&#39;*&#39;</span>) &lt;&lt; std::endl;                    <span class="comment">//center string and pad with &#39;*&#39;, equivalent to fmt(&quot;hello&quot;).center(10).fill(&#39;*&#39;)</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;hello&quot;</span>).c(3) &lt;&lt; std::endl;                            <span class="comment">//center and truncate string</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Direct string conversion</span></div>
<div class="line">std::string <a class="code" href="namespaceseq_1_1detail.html#a84d714603751dddb280584583ccdd7e3">str</a> = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(PI);</div>
<div class="line"><span class="comment">// Direct string conversion using .str()</span></div>
<div class="line">std::string str2 = <span class="stringliteral">&quot;PI value is &quot;</span> + <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(PI).str();</div>
<div class="line">std::cout &lt;&lt; str2 &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The format module provides additional convenient functions to shorten the syntax even more:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convenient shortcut functions</span></div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; ch(<span class="charliteral">&#39;u&#39;</span>) &lt;&lt; std::endl;  <span class="comment">//equivalent to fmt(&#39;u&#39;).as_char() or fmt(&#39;u&#39;).c()</span></div>
<div class="line">std::cout &lt;&lt; e(1.2) &lt;&lt; std::endl;   <span class="comment">//equivalent to fmt(1.2,&#39;e&#39;) or fmt(1.2).format(&#39;e&#39;) or fmt(1.2).t(&#39;e&#39;)</span></div>
<div class="line">std::cout &lt;&lt; E(1.2) &lt;&lt; std::endl;   <span class="comment">//equivalent to fmt(1.2,&#39;E&#39;) or fmt(1.2).format(&#39;E&#39;) or fmt(1.2).t(&#39;E&#39;)</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a>(1.2) &lt;&lt; std::endl;   <span class="comment">//equivalent to fmt(1.2,&#39;f&#39;) or fmt(1.2).format(&#39;f&#39;) or fmt(1.2).t(&#39;f&#39;)</span></div>
<div class="line">std::cout &lt;&lt; F(1.2) &lt;&lt; std::endl;   <span class="comment">//equivalent to fmt(1.2,&#39;F&#39;) or fmt(1.2).format(&#39;F&#39;) or fmt(1.2).t(&#39;F&#39;)</span></div>
<div class="line">std::cout &lt;&lt; g(1.2) &lt;&lt; std::endl;   <span class="comment">//equivalent to fmt(1.2,&#39;g&#39;) or fmt(1.2).format(&#39;g&#39;) or fmt(1.2).t(&#39;g&#39;)</span></div>
<div class="line">std::cout &lt;&lt; G(1.2) &lt;&lt; std::endl;   <span class="comment">//equivalent to fmt(1.2,&#39;G&#39;) or fmt(1.2).format(&#39;G&#39;) or fmt(1.2).t(&#39;G&#39;)</span></div>
<div class="line">std::cout &lt;&lt; hex(100) &lt;&lt; std::endl; <span class="comment">//equivalent to fmt(100).base(16) or fmt(100).b(16)</span></div>
<div class="line">std::cout &lt;&lt; oct(100) &lt;&lt; std::endl; <span class="comment">//equivalent to fmt(100).base(8) or fmt(100).b(8)</span></div>
<div class="line">std::cout &lt;&lt; bin(100) &lt;&lt; std::endl; <span class="comment">//equivalent to fmt(100).base(2) or fmt(100).b(2)</span></div>
</div><!-- fragment --><p><a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a> calls can also be nested:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nested formatting</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;surrounded text&quot;</span>)).c(20).<a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a>(<span class="charliteral">&#39;*&#39;</span>)).c(30).<a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a>(<span class="charliteral">&#39;#&#39;</span>)).c(40).f(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md26"></a>
Formatting several values</h2>
<p>The <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a> function can be used to format any number of values at once:</p>
<div class="fragment"><div class="line"><span class="comment">// Formatting multiple values</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Direct stream</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;The answer is &quot;</span>, 43,<span class="stringliteral">&quot; ...&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// Direct stream with nested formatting</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;...Or it could be&quot;</span>, <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(43.3,<span class="charliteral">&#39;e&#39;</span>).c(10) ) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reuse a formatting object built without arguments</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a> = fmt&lt;int, tstring_view, double, tstring_view, double&gt;();</div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a>(1, <span class="stringliteral">&quot; + &quot;</span>, 2.2, <span class="stringliteral">&quot; = &quot;</span>, 3.2) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reuse a formatting object and use seq::null to only update some arguments</span></div>
<div class="line"><span class="keyword">auto</span> f2 = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="keywordtype">int</span>(), <span class="stringliteral">&quot; + &quot;</span>, fmt&lt;double&gt;().format(<span class="charliteral">&#39;g&#39;</span>), <span class="stringliteral">&quot; = &quot;</span>, fmt&lt;double&gt;().format(<span class="charliteral">&#39;e&#39;</span>));</div>
<div class="line">std::cout &lt;&lt; f2(1, <span class="keyword">null</span>, 2.2, <span class="keyword">null</span>, 3.2) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convert to string or tstring</span></div>
<div class="line">std::string s1 = f2(1, <span class="keyword">null</span>, 2.2, <span class="keyword">null</span>, 3.2);   <span class="comment">//equivalent to s1 = f2(1, null, 2.2, null, 3.2).str();</span></div>
<div class="line"><a class="code" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">tstring</a> s2 = f2(1, <span class="keyword">null</span>, 2.2, <span class="keyword">null</span>, 3.2);       <span class="comment">//equivalent to s2 = f2(1, null, 2.2, null, 3.2).str&lt;tstring&gt;();</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Append to string</span></div>
<div class="line">s2 += <span class="stringliteral">&quot;, repeat-&gt; &quot;</span>;</div>
<div class="line">f2(1, <span class="keyword">null</span>, 2.2, <span class="keyword">null</span>, 3.2).append(s2);         <span class="comment">// append formatted result to s2</span></div>
<div class="line">std::cout &lt;&lt; s2 &lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Modify formatting object using get() and/or set()</span></div>
<div class="line">f2.set&lt;0&gt;(fmt&lt;int&gt;().base(16).h().u()); <span class="comment">// reset the formatting object at position 0</span></div>
<div class="line">f2.get&lt;2&gt;().format(<span class="charliteral">&#39;e&#39;</span>);                <span class="comment">// modifiy the formatting object at position 2</span></div>
<div class="line">std::cout &lt;&lt; f2(1, <span class="keyword">null</span>, 2.2, <span class="keyword">null</span>, 3.2) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use positional argument</span></div>
<div class="line">std::cout &lt;&lt; f2(pos&lt;0, 2, 4&gt;(), 1, 2.2, 3.2) &lt;&lt; std::endl; <span class="comment">// provided arguments are used for positions 0, 2 and 4</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Positional directly in the fmt call</span></div>
<div class="line"><span class="keyword">auto</span> f3 = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(pos&lt;0, 2, 4&gt;(), <span class="keywordtype">int</span>(), <span class="stringliteral">&quot; + &quot;</span>, seq::g&lt;double&gt;(), <span class="stringliteral">&quot; = &quot;</span>, seq::e&lt;double&gt;());</div>
<div class="line">std::cout &lt;&lt; f3(1, 2.2, 3.2) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Building tables</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// header/trailer format, 2 columns of width 20 centered, separated by a &#39;|&#39;</span></div>
<div class="line"><span class="keyword">auto</span> header = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(pos&lt;1, 3&gt;(),<span class="stringliteral">&quot;|&quot;</span>, seq::str().c(20), <span class="stringliteral">&quot;|&quot;</span>, seq::str().c(20), <span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line"><span class="comment">//line format, 2 columns of width 20 centered, separated by a &#39;|&#39;</span></div>
<div class="line"><span class="keyword">auto</span> line = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(pos&lt;1, 3&gt;(),<span class="stringliteral">&quot;|&quot;</span>, seq::fmt&lt;double&gt;().c(20), <span class="stringliteral">&quot;|&quot;</span>, seq::fmt&lt;double&gt;().c(20), <span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line"><span class="comment">// write table</span></div>
<div class="line">std::cout &lt;&lt; header( <span class="stringliteral">&quot;Header 1&quot;</span>, <span class="stringliteral">&quot;Header 2&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; line( 1.1, 2.2) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; line( 3.3, 4.4) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; header( <span class="stringliteral">&quot;Trailer 1&quot;</span>, <span class="stringliteral">&quot;Trailer 2&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
Nested formatting</h2>
<p>Nested formatting occurs when using <em>fmt</em> calls within other <em>fmt</em> calls. The complexity comes from the argument replacement when using formatting objects as functors. The following example shows how to use nested <em>fmt</em> calls with multiple arguments and argument replacement:</p>
<div class="fragment"><div class="line"><span class="comment">// Build a formatting functor used to display 2 couples animal/species</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a> = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(</div>
<div class="line">        pos&lt;1,3&gt;(), <span class="comment">//we can modifies positions 1 and 3 (the 2 couples animal/species)</span></div>
<div class="line">        <span class="stringliteral">&quot;We have 2 couples:\nAnimal/Species: &quot;</span>,</div>
<div class="line">        <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(pos&lt;0,2&gt;(),<span class="stringliteral">&quot;&quot;</span>,<span class="stringliteral">&quot;/&quot;</span>,<span class="stringliteral">&quot;&quot;</span>).c(20),    <span class="comment">//A couple Animal/Species centered on a 20 characters width string</span></div>
<div class="line">        <span class="stringliteral">&quot;\nAnimal/Species: &quot;</span>,</div>
<div class="line">        <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(pos&lt;0,2&gt;(),<span class="stringliteral">&quot;&quot;</span>,<span class="stringliteral">&quot;/&quot;</span>,<span class="stringliteral">&quot;&quot;</span>).c(20)     <span class="comment">//Another couple Animal/Species centered on a 20 characters width string</span></div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use this functor with custom values.</span></div>
<div class="line"><span class="comment">// fmt calls are used to replace arguments in a multi-formatting object</span></div>
<div class="line">    std::cout &lt;&lt; <a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a>(</div>
<div class="line">        <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;Tiger&quot;</span>, <span class="stringliteral">&quot;P. tigris&quot;</span>),</div>
<div class="line">        <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;Panda&quot;</span>, <span class="stringliteral">&quot;A. melanoleuca&quot;</span>)</div>
<div class="line">    ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28"></a>
Formatting to string or buffer</h2>
<p>A formatting object can be:</p><ul>
<li>Printed to a std::ostream object</li>
<li>Converted to a string object</li>
<li>Added to an existing string object</li>
<li>Writed to a buffer</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Print to std::cout</span></div>
<div class="line">std::cout&lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(1.123456789,<span class="charliteral">&#39;g&#39;</span>) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convert to string</span></div>
<div class="line">std::string <a class="code" href="namespaceseq_1_1detail.html#a84d714603751dddb280584583ccdd7e3">str</a> = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(1.123456789,<span class="charliteral">&#39;g&#39;</span>).str&lt;std::string&gt;();</div>
<div class="line">std::cout&lt;&lt; <a class="code" href="namespaceseq_1_1detail.html#a84d714603751dddb280584583ccdd7e3">str</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Append to an existing string</span></div>
<div class="line">std::string str2;</div>
<div class="line"><a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(1.123456789,<span class="charliteral">&#39;g&#39;</span>).append(str2);</div>
<div class="line">std::cout&lt;&lt; str2 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// write to buffer (to_chars(char*) returns past-the-end pointer)</span></div>
<div class="line"><span class="keywordtype">char</span> dst[100];</div>
<div class="line">*<a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(1.123456789,<span class="charliteral">&#39;g&#39;</span>).to_chars(dst) = 0;</div>
<div class="line">std::cout&lt;&lt; dst &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// write to buffer with maximum size (to_chars(char*,size_t) returns a pair of past-the-end pointer and size without truncation)</span></div>
<div class="line"><span class="keywordtype">char</span> dst2[100];</div>
<div class="line">*<a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(1.123456789,<span class="charliteral">&#39;g&#39;</span>).to_chars(dst2, <span class="keyword">sizeof</span>(dst2)).first = 0;</div>
<div class="line">std::cout&lt;&lt; dst2 &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md29"></a>
Using std::to_chars</h2>
<p>It is possible to use std::to_chars instead of <a class="el" href="namespaceseq.html#a9e1cfb2de75c85497d57702430705b1c" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a> within the format module, mostly when exact round-trip guarantee is mandatory. For that, you must define SEQ_FORMAT_USE_STD_TO_CHARS and enable C++17. If C++17 is not supported by the compiler, the format module will always fallback to <a class="el" href="namespaceseq.html#a9e1cfb2de75c85497d57702430705b1c" title="Converts value into a character string by successively filling the range [first, last),...">seq::to_chars</a>.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Working with custom types</h2>
<p>By default, the format library supports arithmetic types and string types. Not that std::string, <a class="el" href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5" title="Base string typedef, similar to std::string. Equivalent to tiny_string&lt;0, std::allocator&lt;char&gt;&gt;.">seq::tstring</a> or const char* arguments are represented internally as string views (tstring_view class). The format module is extendible to custom types by 2 means:</p><ul>
<li>If the type is streamable to std::ostream, it will directly work with <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a> using internally a (slow) std::ostringstream.</li>
<li>Otherwise, you need to specialize <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class.">seq::ostream_format</a> for your type.</li>
</ul>
<p>Example of custom type formatting:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="format_8hpp.html">format.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceseq.html">seq</a></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialization of ostream_format for std::pair&lt;T,T&gt;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    <span class="keyword">class </span>ostream_format&lt;<a class="code" href="namespacestd.html">std</a>::pair&lt;T, T&gt; &gt;: <span class="keyword">public</span> base_ostream_format&lt;std::pair&lt;T, T&gt; , ostream_format&lt;std::pair&lt;T, T&gt; &gt; &gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> base_type = base_ostream_format&lt;std::pair&lt;T, T&gt;, ostream_format&lt;std::pair&lt;T, T&gt; &gt; &gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classseq_1_1ostream__format.html#a3eb7536572cddbefdbb8844bb64cafe4">ostream_format</a>() : base_type() {}</div>
<div class="line">        <a class="code" href="classseq_1_1ostream__format.html#a3eb7536572cddbefdbb8844bb64cafe4">ostream_format</a>(<span class="keyword">const</span> std::pair&lt;T, T&gt;&amp; v) : base_type(v) {}</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The specialization must provide this member:</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">size_t</span> <a class="code" href="classseq_1_1ostream__format.html#a3c30d958ce8fb82d6509acc7e23f2648">to_string</a>(std::string &amp; out)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordtype">size_t</span> prev = out.size();</div>
<div class="line"> </div>
<div class="line">            out.append(<span class="stringliteral">&quot;(&quot;</span>);</div>
<div class="line">            <span class="comment">// Format the first member of the pair using the internal numeric format</span></div>
<div class="line">            ostream_format&lt;T&gt;(this-&gt;value().<a class="code" href="namespaceseq_1_1detail.html#a4abc955e0a77f9f1a5d4b9fa147745e1">first</a>, this-&gt;numeric_fmt()).append(out);</div>
<div class="line">            out.append(<span class="stringliteral">&quot;, &quot;</span>);</div>
<div class="line">            <span class="comment">// Format the second member of the pair using the internal numeric format</span></div>
<div class="line">            ostream_format&lt;T&gt;(this-&gt;value().second, this-&gt;numeric_fmt()).append(out);</div>
<div class="line">            out.append(<span class="stringliteral">&quot;)&quot;</span>);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">return</span> out.size() - prev;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Formatting custom types</span></div>
<div class="line">    std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;Print a pair of float: &quot;</span>, std::make_pair(1.2f, 3.4f)) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Formatting custom types with custom format</span></div>
<div class="line">    std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;Print a pair of double: &quot;</span>, <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(std::make_pair(1.2, 3.4)).format(<span class="charliteral">&#39;e&#39;</span>)) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Formatting custom types with custom format and alignment</span></div>
<div class="line">    std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(<span class="stringliteral">&quot;Print a pair of double centered: &quot;</span>, <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(std::make_pair(1.2, 3.4)).t(<span class="charliteral">&#39;e&#39;</span>).c(30).<a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a>(<span class="charliteral">&#39;*&#39;</span>)) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For arithmetic types, a <a class="el" href="classseq_1_1ostream__format.html" title="Number and string formatting class.">seq::ostream_format</a> internally stores a copy of the value passed as argument of <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>. Therefore, the ostream_format object can be stored and formatted afterward. However, for custom types as well as strings, it is unsafe to store a ostream_format object and format it afterward as it internally stores a <em>pointer</em> to the actual data.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Format arithmetic type</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a> = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(1.2);</div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a> &lt;&lt; std::endl;        <span class="comment">// Safe: the ostream_format stores a plain double value</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Format string type</span></div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(<span class="stringliteral">&quot;format a string&quot;</span>)&lt;&lt; std::endl;                   <span class="comment">// Safe: lifetime of string literals is the lifetime of the program</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(std::string(<span class="stringliteral">&quot;format a string&quot;</span>)) &lt;&lt; std::endl;     <span class="comment">// Safe: the temporay string is valid when the actual formatting occurs</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> f2 = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(std::string(<span class="stringliteral">&quot;format a string&quot;</span>));</div>
<div class="line">std::cout &lt;&lt; f2(std::string(<span class="stringliteral">&quot;another string&quot;</span>)) &lt;&lt;std::endl;     <span class="comment">//Safe: the first string is replace by a new temporary one</span></div>
<div class="line">std::cout &lt;&lt; f2 &lt;&lt; std::endl;                                   <span class="comment">//UNSAFE: attempt to format the temporay std::string holding &quot;another string&quot; which was already destroyed</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
Thread safety</h2>
<p>The format module is thread safe: formatting objects in different threads is allowed, as the format module only uses (few) global variables with the <em>thread_local</em> specifier. However, a formatting object returned by <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a> is not thread safe and you must pass copies of this object to other threads.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Performances</h2>
<p>The format module is relatively fast compared to C++ streams, mainly thanks to the <a class="el" href="group__charconv.html">charconv</a> module. Usually, using <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a> to output arithmetic values to streams should be around 8 times faster than directly writing the values to a std::ostream object. This will, of course, vary greatly depending on the considered scenario.</p>
<p>The following code is a simple benchmark on writing a 4 * 1000000 table of double values to a std::ostream object.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="testing_8hpp.html">testing.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="format_8hpp.html">format.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Generate 4M double values</span></div>
<div class="line">    <span class="keyword">using</span> float_type = double;</div>
<div class="line">    <a class="code" href="classseq_1_1random__float__genertor.html">random_float_genertor&lt;float_type&gt;</a> rgn;</div>
<div class="line">    std::vector&lt;float_type&gt; vec_d;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4000000; ++i)</div>
<div class="line">        vec_d.push_back(rgn());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Null ostream object</span></div>
<div class="line">    <a class="code" href="structseq_1_1basic__nullbuf.html">nullbuf</a> <a class="code" href="namespaceseq_1_1detail.html#a12c9a7db6862be66b508b7cc80e12a2d">n</a>;</div>
<div class="line">    std::ostream oss(&amp;<a class="code" href="namespaceseq_1_1detail.html#a12c9a7db6862be66b508b7cc80e12a2d">n</a>);</div>
<div class="line">    oss.sync_with_stdio(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Build a table of 4 * 1000000 double values separated by a &#39;|&#39;. All values are centered on a 20 characters space</span></div>
<div class="line">    <a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line">    oss &lt;&lt; std::setprecision(6);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec_d.size()/4; ++i)</div>
<div class="line">    {</div>
<div class="line">        oss &lt;&lt; std::left &lt;&lt; std::setw(20) &lt;&lt; vec_d[i * 4] &lt;&lt; <span class="stringliteral">&quot;|&quot;</span>;</div>
<div class="line">        oss &lt;&lt; std::left &lt;&lt; std::setw(20) &lt;&lt; vec_d[i * 4+1] &lt;&lt; <span class="stringliteral">&quot;|&quot;</span>;</div>
<div class="line">        oss &lt;&lt; std::left &lt;&lt; std::setw(20) &lt;&lt; vec_d[i * 4+2] &lt;&lt; <span class="stringliteral">&quot;|&quot;</span>;</div>
<div class="line">        oss &lt;&lt; std::left &lt;&lt; std::setw(20) &lt;&lt; vec_d[i * 4+3] &lt;&lt; <span class="stringliteral">&quot;|&quot;</span>;</div>
<div class="line">        oss &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">size_t</span> el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Write table with streams: &quot;</span> &lt;&lt;el&lt;&lt;<span class="stringliteral">&quot; ms&quot;</span>&lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Build the same table with format module</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the format object</span></div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a> = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">fmt</a>(pos&lt;0, 2, 4, 6&gt;(), g&lt;float_type&gt;().p(6).c(20), <span class="stringliteral">&quot;|&quot;</span>, g&lt;float_type&gt;().p(6).c(20), <span class="stringliteral">&quot;|&quot;</span>, g&lt;float_type&gt;().p(6).c(20), <span class="stringliteral">&quot;|&quot;</span>, g&lt;float_type&gt;().p(6).c(20), <span class="stringliteral">&quot;|&quot;</span>);</div>
<div class="line">    <a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec_d.size() / 4; ++i)</div>
<div class="line">        oss &lt;&lt; <a class="code" href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">f</a>(vec_d[i * 4], vec_d[i * 4+1], vec_d[i * 4+2], vec_d[i * 4+3]) &lt;&lt; std::endl;</div>
<div class="line">    el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Write table with seq formatting module: &quot;</span> &lt;&lt; el &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use std::format</span></div>
<div class="line">    <span class="comment">// tick();</span></div>
<div class="line">    <span class="comment">// for (size_t i = 0; i &lt; vec_d.size() / 4; ++i)</span></div>
<div class="line">    <span class="comment">//  std::format_to(std::ostreambuf_iterator&lt;char&gt;(oss), &quot;{:^20.6g} | {:^20.6g} | {:^20.6g} | {:^20.6g}\n&quot;, vec_d[i * 4], vec_d[i * 4 + 1], vec_d[i * 4 + 2], vec_d[i * 4 + 3]);</span></div>
<div class="line">    <span class="comment">// el = tock_ms();</span></div>
<div class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Write table with std::format : &quot; &lt;&lt; el &lt;&lt; &quot; ms&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Just for comparison, directly dump the double values without the &#39;|&#39; character (but keeping centering)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line">    <span class="keyword">auto</span> f2 = <a class="code" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>(float_type(), <span class="charliteral">&#39;g&#39;</span>).c(20);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec_d.size(); ++i)</div>
<div class="line">        oss &lt;&lt; f2(vec_d[i]);</div>
<div class="line">    el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Write centered double with seq::fmt: &quot;</span> &lt;&lt; el &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">    <span class="comment">// use std::ostream::bad() to make sure the above tests are not simply ignored by the compiler</span></div>
<div class="line">    <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)oss.bad())</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;error&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Above example compiled with gcc 10.1.0 (-O3) for msys2 on Windows 10 on a Intel(R) Core(TM) i7-10850H at 2.70GHz gives the following output:</p>
<blockquote class="doxtable">
<p>Write table with streams: 3469 ms</p>
<p>Write table with seq formatting module: 413 ms</p>
<p>Write centered double with <a class="el" href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a>: 366 ms </p>
</blockquote>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceseq_html_a8d9a01a2c5a12df6d4baac1d1520d4b5"><div class="ttname"><a href="namespaceseq.html#a8d9a01a2c5a12df6d4baac1d1520d4b5">seq::tstring</a></div><div class="ttdeci">tiny_string&lt; 0, std::allocator&lt; char &gt; &gt; tstring</div><div class="ttdoc">Base string typedef, similar to std::string. Equivalent to tiny_string&lt;0, std::allocator&lt;char&gt;&gt;.</div><div class="ttdef"><b>Definition:</b> tiny_string.hpp:85</div></div>
<div class="ttc" id="aformat_8hpp_html"><div class="ttname"><a href="format_8hpp.html">format.hpp</a></div></div>
<div class="ttc" id="anamespaceseq_1_1detail_html_a84d714603751dddb280584583ccdd7e3"><div class="ttname"><a href="namespaceseq_1_1detail.html#a84d714603751dddb280584583ccdd7e3">seq::detail::str</a></div><div class="ttdeci">Integral int char Stream &amp; str</div><div class="ttdef"><b>Definition:</b> charconv.hpp:716</div></div>
<div class="ttc" id="anamespaceseq_html"><div class="ttname"><a href="namespaceseq.html">seq</a></div><div class="ttdef"><b>Definition:</b> any.hpp:58</div></div>
<div class="ttc" id="anamespaceseq_1_1detail_html_a76fa776653402382e316c7b6715856af"><div class="ttname"><a href="namespaceseq_1_1detail.html#a76fa776653402382e316c7b6715856af">seq::detail::f</a></div><div class="ttdeci">char f</div><div class="ttdef"><b>Definition:</b> charconv.hpp:688</div></div>
<div class="ttc" id="anamespaceseq_1_1detail_html_a4abc955e0a77f9f1a5d4b9fa147745e1"><div class="ttname"><a href="namespaceseq_1_1detail.html#a4abc955e0a77f9f1a5d4b9fa147745e1">seq::detail::first</a></div><div class="ttdeci">int first</div><div class="ttdef"><b>Definition:</b> charconv.hpp:725</div></div>
<div class="ttc" id="anamespaceseq_html_ad863fcfc143b646f5a2f2362a1327575"><div class="ttname"><a href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">seq::tick</a></div><div class="ttdeci">void tick()</div><div class="ttdoc">For tests only, reset timer for calling thread.</div><div class="ttdef"><b>Definition:</b> testing.hpp:177</div></div>
<div class="ttc" id="anamespaceseq_1_1detail_html_a12c9a7db6862be66b508b7cc80e12a2d"><div class="ttname"><a href="namespaceseq_1_1detail.html#a12c9a7db6862be66b508b7cc80e12a2d">seq::detail::n</a></div><div class="ttdeci">char n</div><div class="ttdef"><b>Definition:</b> charconv.hpp:674</div></div>
<div class="ttc" id="anamespaceseq_html_a21b27d9d28ab49b4e36657f9e95013c7"><div class="ttname"><a href="namespaceseq.html#a21b27d9d28ab49b4e36657f9e95013c7">seq::fmt</a></div><div class="ttdeci">auto fmt(Args &amp;&amp;... args) -&gt; typename detail::BuildFormat&lt; sizeof...(Args), void, Args... &gt;::return_type</div><div class="ttdef"><b>Definition:</b> format.hpp:2159</div></div>
<div class="ttc" id="aclassseq_1_1ostream__format_html_a3eb7536572cddbefdbb8844bb64cafe4"><div class="ttname"><a href="classseq_1_1ostream__format.html#a3eb7536572cddbefdbb8844bb64cafe4">seq::ostream_format::ostream_format</a></div><div class="ttdeci">friend class ostream_format</div><div class="ttdef"><b>Definition:</b> format.hpp:1250</div></div>
<div class="ttc" id="aclassseq_1_1random__float__genertor_html"><div class="ttname"><a href="classseq_1_1random__float__genertor.html">seq::random_float_genertor</a></div><div class="ttdoc">For tests only, generate random floating point number on the whole representable range (including pot...</div><div class="ttdef"><b>Definition:</b> testing.hpp:366</div></div>
<div class="ttc" id="aclassseq_1_1ostream__format_html_a3c30d958ce8fb82d6509acc7e23f2648"><div class="ttname"><a href="classseq_1_1ostream__format.html#a3c30d958ce8fb82d6509acc7e23f2648">seq::ostream_format::to_string</a></div><div class="ttdeci">auto to_string(String &amp;str) const -&gt; size_t</div><div class="ttdef"><b>Definition:</b> format.hpp:1283</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> any.hpp:2382</div></div>
<div class="ttc" id="anamespaceseq_html_a576ae74a514ded550299e48e4c32cc64"><div class="ttname"><a href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">seq::tock_ms</a></div><div class="ttdeci">auto tock_ms() -&gt; std::uint64_t</div><div class="ttdoc">For tests only, returns elapsed milliseconds since last call to tick()</div><div class="ttdef"><b>Definition:</b> testing.hpp:189</div></div>
<div class="ttc" id="atesting_8hpp_html"><div class="ttname"><a href="testing_8hpp.html">testing.hpp</a></div></div>
<div class="ttc" id="astructseq_1_1basic__nullbuf_html"><div class="ttname"><a href="structseq_1_1basic__nullbuf.html">seq::basic_nullbuf&lt; char &gt;</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
