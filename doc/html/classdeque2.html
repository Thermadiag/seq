<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: deque2&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdeque2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdeque2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">deque2&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>seq::deque is a std::deque like container implemented as a tiered-vector.  
 <a href="classdeque2.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="deque2_8hpp_source.html">deque2.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad15526f7d7553b867f1e00c548ecc21e"><td class="memItemLeft" align="right" valign="top"><a id="ad15526f7d7553b867f1e00c548ecc21e"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>min_block_size</b> = MinBSize, 
<b>max_block_size</b> = MaxBSize, 
<b>min_block_size</b> = MinBSize, 
<b>use_mem_pool</b> = UseMemPool, 
<br />
&#160;&#160;<b>use_mem_pool</b> = UseMemPool
<br />
 }</td></tr>
<tr class="separator:ad15526f7d7553b867f1e00c548ecc21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15526f7d7553b867f1e00c548ecc21e"><td class="memItemLeft" align="right" valign="top"><a id="ad15526f7d7553b867f1e00c548ecc21e"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>min_block_size</b> = MinBSize, 
<b>max_block_size</b> = MaxBSize, 
<b>min_block_size</b> = MinBSize, 
<b>use_mem_pool</b> = UseMemPool, 
<br />
&#160;&#160;<b>use_mem_pool</b> = UseMemPool
<br />
 }</td></tr>
<tr class="separator:ad15526f7d7553b867f1e00c548ecc21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae583d4129ad10d282fdcba684bf8f8bb"><td class="memItemLeft" align="right" valign="top"><a id="ae583d4129ad10d282fdcba684bf8f8bb"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>min_block_size</b> = MinBSize, 
<b>max_block_size</b> = MaxBSize, 
<b>min_block_size</b> = MinBSize, 
<b>min_block_size</b> = MinBSize
 }</td></tr>
<tr class="separator:ae583d4129ad10d282fdcba684bf8f8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15526f7d7553b867f1e00c548ecc21e"><td class="memItemLeft" align="right" valign="top"><a id="ad15526f7d7553b867f1e00c548ecc21e"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>min_block_size</b> = MinBSize, 
<b>max_block_size</b> = MaxBSize, 
<b>min_block_size</b> = MinBSize, 
<b>use_mem_pool</b> = UseMemPool, 
<br />
&#160;&#160;<b>use_mem_pool</b> = UseMemPool
<br />
 }</td></tr>
<tr class="separator:ad15526f7d7553b867f1e00c548ecc21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae583d4129ad10d282fdcba684bf8f8bb"><td class="memItemLeft" align="right" valign="top"><a id="ae583d4129ad10d282fdcba684bf8f8bb"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>min_block_size</b> = MinBSize, 
<b>max_block_size</b> = MaxBSize, 
<b>min_block_size</b> = MinBSize, 
<b>min_block_size</b> = MinBSize
 }</td></tr>
<tr class="separator:ae583d4129ad10d282fdcba684bf8f8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0053f339ea493d66e0e3973fe3d31221"><td class="memItemLeft" align="right" valign="top"><a id="a0053f339ea493d66e0e3973fe3d31221"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>max_block_size</b> = MaxBSize, 
<b>max_block_size</b> = MaxBSize
 }</td></tr>
<tr class="separator:a0053f339ea493d66e0e3973fe3d31221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15526f7d7553b867f1e00c548ecc21e"><td class="memItemLeft" align="right" valign="top"><a id="ad15526f7d7553b867f1e00c548ecc21e"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>min_block_size</b> = MinBSize, 
<b>max_block_size</b> = MaxBSize, 
<b>min_block_size</b> = MinBSize, 
<b>use_mem_pool</b> = UseMemPool, 
<br />
&#160;&#160;<b>use_mem_pool</b> = UseMemPool
<br />
 }</td></tr>
<tr class="separator:ad15526f7d7553b867f1e00c548ecc21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae583d4129ad10d282fdcba684bf8f8bb"><td class="memItemLeft" align="right" valign="top"><a id="ae583d4129ad10d282fdcba684bf8f8bb"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>min_block_size</b> = MinBSize, 
<b>max_block_size</b> = MaxBSize, 
<b>min_block_size</b> = MinBSize, 
<b>min_block_size</b> = MinBSize
 }</td></tr>
<tr class="separator:ae583d4129ad10d282fdcba684bf8f8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0053f339ea493d66e0e3973fe3d31221"><td class="memItemLeft" align="right" valign="top"><a id="a0053f339ea493d66e0e3973fe3d31221"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>max_block_size</b> = MaxBSize, 
<b>max_block_size</b> = MaxBSize
 }</td></tr>
<tr class="separator:a0053f339ea493d66e0e3973fe3d31221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61016c6bc3bd6bea570ebe5582178d90"><td class="memTemplParams" colspan="2"><a id="a61016c6bc3bd6bea570ebe5582178d90"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a61016c6bc3bd6bea570ebe5582178d90"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RebindAlloc</b> = typename std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; U &gt;</td></tr>
<tr class="separator:a61016c6bc3bd6bea570ebe5582178d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfef255176e1b3e52790038b45720d3"><td class="memItemLeft" align="right" valign="top"><a id="a9cfef255176e1b3e52790038b45720d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_manager</b> = <a class="el" href="structdetail_1_1_bucket_manager.html">detail::BucketManager</a>&lt; T, Allocator, MinBSize, MaxBSize, StoreBackValues, ValueCompare, layout &gt;</td></tr>
<tr class="separator:a9cfef255176e1b3e52790038b45720d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc85323d5cc39917b0054dcaef78ce2a"><td class="memItemLeft" align="right" valign="top"><a id="adc85323d5cc39917b0054dcaef78ce2a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_traits</b> = std::allocator_traits&lt; Allocator &gt;</td></tr>
<tr class="separator:adc85323d5cc39917b0054dcaef78ce2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4913bbcd3530a56400b655794b4470"><td class="memItemLeft" align="right" valign="top"><a id="a0b4913bbcd3530a56400b655794b4470"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b> = <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;</td></tr>
<tr class="separator:a0b4913bbcd3530a56400b655794b4470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8fef7202718c3b9649321ee8f7715"><td class="memItemLeft" align="right" valign="top"><a id="a46c8fef7202718c3b9649321ee8f7715"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>find_bsize_type</b> = FindBSize</td></tr>
<tr class="separator:a46c8fef7202718c3b9649321ee8f7715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600be7ec0c0a0256b789225b84308dcc"><td class="memItemLeft" align="right" valign="top"><a id="a600be7ec0c0a0256b789225b84308dcc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a600be7ec0c0a0256b789225b84308dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memItemLeft" align="right" valign="top"><a id="a228d205e7c179d9c87cf936d24ba9dd4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memItemLeft" align="right" valign="top"><a id="a3071baa70c70b9a6ec7083064e67d4c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename alloc_traits::size_type</td></tr>
<tr class="separator:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b571f84b69059f6d0868d3f9ac5427"><td class="memItemLeft" align="right" valign="top"><a id="a63b571f84b69059f6d0868d3f9ac5427"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename alloc_traits::difference_type</td></tr>
<tr class="separator:a63b571f84b69059f6d0868d3f9ac5427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memItemLeft" align="right" valign="top"><a id="a76c04bed428981ff4ef82cf9f6dbe2dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename alloc_traits::pointer</td></tr>
<tr class="separator:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1494a0f75f05c13327cf190fde8df"><td class="memItemLeft" align="right" valign="top"><a id="ac1f1494a0f75f05c13327cf190fde8df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename alloc_traits::const_pointer</td></tr>
<tr class="separator:ac1f1494a0f75f05c13327cf190fde8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8022190763c231b244bad7386a54f2"><td class="memItemLeft" align="right" valign="top"><a id="a0d8022190763c231b244bad7386a54f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:a0d8022190763c231b244bad7386a54f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333f714b25ba56afe74ed44113faee2d"><td class="memItemLeft" align="right" valign="top"><a id="a333f714b25ba56afe74ed44113faee2d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:a333f714b25ba56afe74ed44113faee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c8e01f341e504a6148901b7bf25aae"><td class="memItemLeft" align="right" valign="top"><a id="ae9c8e01f341e504a6148901b7bf25aae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structdetail_1_1deque__iterator.html">detail::deque_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:ae9c8e01f341e504a6148901b7bf25aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fe81bd4133e2a4c5a25ca26e3b72f9"><td class="memItemLeft" align="right" valign="top"><a id="a24fe81bd4133e2a4c5a25ca26e3b72f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structdetail_1_1deque__const__iterator.html">detail::deque_const_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:a24fe81bd4133e2a4c5a25ca26e3b72f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memItemLeft" align="right" valign="top"><a id="a6faa0a87e9f58b63bc8ee253838ffcf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1d8044a92d6e57d551b0b559343aad"><td class="memItemLeft" align="right" valign="top"><a id="add1d8044a92d6e57d551b0b559343aad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:add1d8044a92d6e57d551b0b559343aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f4881c0a9b1b07010fcddd00b2e8bc"><td class="memItemLeft" align="right" valign="top"><a id="a71f4881c0a9b1b07010fcddd00b2e8bc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_manager</b> = <a class="el" href="structdetail_1_1_bucket_manager.html">detail::BucketManager</a>&lt; T, Allocator, min_block_size, max_block_size, StoreBackValues, ValueCompare, layout &gt;</td></tr>
<tr class="separator:a71f4881c0a9b1b07010fcddd00b2e8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc85323d5cc39917b0054dcaef78ce2a"><td class="memItemLeft" align="right" valign="top"><a id="adc85323d5cc39917b0054dcaef78ce2a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_traits</b> = std::allocator_traits&lt; Allocator &gt;</td></tr>
<tr class="separator:adc85323d5cc39917b0054dcaef78ce2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d5faf45e011182104aad24e30252bf"><td class="memItemLeft" align="right" valign="top"><a id="aa5d5faf45e011182104aad24e30252bf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b> = <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, min_block_size, max_block_size, FindBSize, StoreBackValues, ValueCompare &gt;</td></tr>
<tr class="separator:aa5d5faf45e011182104aad24e30252bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8fef7202718c3b9649321ee8f7715"><td class="memItemLeft" align="right" valign="top"><a id="a46c8fef7202718c3b9649321ee8f7715"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>find_bsize_type</b> = FindBSize</td></tr>
<tr class="separator:a46c8fef7202718c3b9649321ee8f7715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600be7ec0c0a0256b789225b84308dcc"><td class="memItemLeft" align="right" valign="top"><a id="a600be7ec0c0a0256b789225b84308dcc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a600be7ec0c0a0256b789225b84308dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memItemLeft" align="right" valign="top"><a id="a228d205e7c179d9c87cf936d24ba9dd4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memItemLeft" align="right" valign="top"><a id="a3071baa70c70b9a6ec7083064e67d4c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename alloc_traits::size_type</td></tr>
<tr class="separator:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b571f84b69059f6d0868d3f9ac5427"><td class="memItemLeft" align="right" valign="top"><a id="a63b571f84b69059f6d0868d3f9ac5427"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename alloc_traits::difference_type</td></tr>
<tr class="separator:a63b571f84b69059f6d0868d3f9ac5427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memItemLeft" align="right" valign="top"><a id="a76c04bed428981ff4ef82cf9f6dbe2dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename alloc_traits::pointer</td></tr>
<tr class="separator:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1494a0f75f05c13327cf190fde8df"><td class="memItemLeft" align="right" valign="top"><a id="ac1f1494a0f75f05c13327cf190fde8df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename alloc_traits::const_pointer</td></tr>
<tr class="separator:ac1f1494a0f75f05c13327cf190fde8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8022190763c231b244bad7386a54f2"><td class="memItemLeft" align="right" valign="top"><a id="a0d8022190763c231b244bad7386a54f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:a0d8022190763c231b244bad7386a54f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333f714b25ba56afe74ed44113faee2d"><td class="memItemLeft" align="right" valign="top"><a id="a333f714b25ba56afe74ed44113faee2d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:a333f714b25ba56afe74ed44113faee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c8e01f341e504a6148901b7bf25aae"><td class="memItemLeft" align="right" valign="top"><a id="ae9c8e01f341e504a6148901b7bf25aae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structdetail_1_1deque__iterator.html">detail::deque_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:ae9c8e01f341e504a6148901b7bf25aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fe81bd4133e2a4c5a25ca26e3b72f9"><td class="memItemLeft" align="right" valign="top"><a id="a24fe81bd4133e2a4c5a25ca26e3b72f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structdetail_1_1deque__const__iterator.html">detail::deque_const_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:a24fe81bd4133e2a4c5a25ca26e3b72f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memItemLeft" align="right" valign="top"><a id="a6faa0a87e9f58b63bc8ee253838ffcf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1d8044a92d6e57d551b0b559343aad"><td class="memItemLeft" align="right" valign="top"><a id="add1d8044a92d6e57d551b0b559343aad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:add1d8044a92d6e57d551b0b559343aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61016c6bc3bd6bea570ebe5582178d90"><td class="memTemplParams" colspan="2"><a id="a61016c6bc3bd6bea570ebe5582178d90"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a61016c6bc3bd6bea570ebe5582178d90"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RebindAlloc</b> = typename std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; U &gt;</td></tr>
<tr class="separator:a61016c6bc3bd6bea570ebe5582178d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff337f311d8403f6de431411b102c59a"><td class="memItemLeft" align="right" valign="top"><a id="aff337f311d8403f6de431411b102c59a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_manager</b> = <a class="el" href="structdetail_1_1_bucket_manager.html">detail::BucketManager</a>&lt; T, Allocator, MinBSize, MaxBSize, StoreBackValues, layout &gt;</td></tr>
<tr class="separator:aff337f311d8403f6de431411b102c59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc85323d5cc39917b0054dcaef78ce2a"><td class="memItemLeft" align="right" valign="top"><a id="adc85323d5cc39917b0054dcaef78ce2a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_traits</b> = std::allocator_traits&lt; Allocator &gt;</td></tr>
<tr class="separator:adc85323d5cc39917b0054dcaef78ce2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecf76513eed89e865fc8876ebc7b61c"><td class="memItemLeft" align="right" valign="top"><a id="a4ecf76513eed89e865fc8876ebc7b61c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b> = <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues &gt;</td></tr>
<tr class="separator:a4ecf76513eed89e865fc8876ebc7b61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8fef7202718c3b9649321ee8f7715"><td class="memItemLeft" align="right" valign="top"><a id="a46c8fef7202718c3b9649321ee8f7715"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>find_bsize_type</b> = FindBSize</td></tr>
<tr class="separator:a46c8fef7202718c3b9649321ee8f7715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600be7ec0c0a0256b789225b84308dcc"><td class="memItemLeft" align="right" valign="top"><a id="a600be7ec0c0a0256b789225b84308dcc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a600be7ec0c0a0256b789225b84308dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memItemLeft" align="right" valign="top"><a id="a228d205e7c179d9c87cf936d24ba9dd4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memItemLeft" align="right" valign="top"><a id="a3071baa70c70b9a6ec7083064e67d4c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename alloc_traits::size_type</td></tr>
<tr class="separator:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b571f84b69059f6d0868d3f9ac5427"><td class="memItemLeft" align="right" valign="top"><a id="a63b571f84b69059f6d0868d3f9ac5427"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename alloc_traits::difference_type</td></tr>
<tr class="separator:a63b571f84b69059f6d0868d3f9ac5427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memItemLeft" align="right" valign="top"><a id="a76c04bed428981ff4ef82cf9f6dbe2dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename alloc_traits::pointer</td></tr>
<tr class="separator:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1494a0f75f05c13327cf190fde8df"><td class="memItemLeft" align="right" valign="top"><a id="ac1f1494a0f75f05c13327cf190fde8df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename alloc_traits::const_pointer</td></tr>
<tr class="separator:ac1f1494a0f75f05c13327cf190fde8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8022190763c231b244bad7386a54f2"><td class="memItemLeft" align="right" valign="top"><a id="a0d8022190763c231b244bad7386a54f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:a0d8022190763c231b244bad7386a54f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333f714b25ba56afe74ed44113faee2d"><td class="memItemLeft" align="right" valign="top"><a id="a333f714b25ba56afe74ed44113faee2d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:a333f714b25ba56afe74ed44113faee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c8e01f341e504a6148901b7bf25aae"><td class="memItemLeft" align="right" valign="top"><a id="ae9c8e01f341e504a6148901b7bf25aae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structdetail_1_1deque__iterator.html">detail::deque_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:ae9c8e01f341e504a6148901b7bf25aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fe81bd4133e2a4c5a25ca26e3b72f9"><td class="memItemLeft" align="right" valign="top"><a id="a24fe81bd4133e2a4c5a25ca26e3b72f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structdetail_1_1deque__const__iterator.html">detail::deque_const_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:a24fe81bd4133e2a4c5a25ca26e3b72f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memItemLeft" align="right" valign="top"><a id="a6faa0a87e9f58b63bc8ee253838ffcf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1d8044a92d6e57d551b0b559343aad"><td class="memItemLeft" align="right" valign="top"><a id="add1d8044a92d6e57d551b0b559343aad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:add1d8044a92d6e57d551b0b559343aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61016c6bc3bd6bea570ebe5582178d90"><td class="memTemplParams" colspan="2"><a id="a61016c6bc3bd6bea570ebe5582178d90"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a61016c6bc3bd6bea570ebe5582178d90"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RebindAlloc</b> = typename std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; U &gt;</td></tr>
<tr class="separator:a61016c6bc3bd6bea570ebe5582178d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96666615860aa2ccd1bc446f3333b9c5"><td class="memItemLeft" align="right" valign="top"><a id="a96666615860aa2ccd1bc446f3333b9c5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_manager</b> = <a class="el" href="structdetail_1_1_bucket_manager.html">detail::BucketManager</a>&lt; T, Allocator, UseMemPool, MinBSize, MaxBSize &gt;</td></tr>
<tr class="separator:a96666615860aa2ccd1bc446f3333b9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc85323d5cc39917b0054dcaef78ce2a"><td class="memItemLeft" align="right" valign="top"><a id="adc85323d5cc39917b0054dcaef78ce2a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_traits</b> = std::allocator_traits&lt; Allocator &gt;</td></tr>
<tr class="separator:adc85323d5cc39917b0054dcaef78ce2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cee2b1eb71f4212636769c5929bc5c"><td class="memItemLeft" align="right" valign="top"><a id="a45cee2b1eb71f4212636769c5929bc5c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b> = <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, UseMemPool, MinBSize, MaxBSize &gt;</td></tr>
<tr class="separator:a45cee2b1eb71f4212636769c5929bc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600be7ec0c0a0256b789225b84308dcc"><td class="memItemLeft" align="right" valign="top"><a id="a600be7ec0c0a0256b789225b84308dcc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a600be7ec0c0a0256b789225b84308dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memItemLeft" align="right" valign="top"><a id="a228d205e7c179d9c87cf936d24ba9dd4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memItemLeft" align="right" valign="top"><a id="a3071baa70c70b9a6ec7083064e67d4c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename alloc_traits::size_type</td></tr>
<tr class="separator:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b571f84b69059f6d0868d3f9ac5427"><td class="memItemLeft" align="right" valign="top"><a id="a63b571f84b69059f6d0868d3f9ac5427"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename alloc_traits::difference_type</td></tr>
<tr class="separator:a63b571f84b69059f6d0868d3f9ac5427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memItemLeft" align="right" valign="top"><a id="a76c04bed428981ff4ef82cf9f6dbe2dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename alloc_traits::pointer</td></tr>
<tr class="separator:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1494a0f75f05c13327cf190fde8df"><td class="memItemLeft" align="right" valign="top"><a id="ac1f1494a0f75f05c13327cf190fde8df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename alloc_traits::const_pointer</td></tr>
<tr class="separator:ac1f1494a0f75f05c13327cf190fde8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8022190763c231b244bad7386a54f2"><td class="memItemLeft" align="right" valign="top"><a id="a0d8022190763c231b244bad7386a54f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:a0d8022190763c231b244bad7386a54f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333f714b25ba56afe74ed44113faee2d"><td class="memItemLeft" align="right" valign="top"><a id="a333f714b25ba56afe74ed44113faee2d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:a333f714b25ba56afe74ed44113faee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c66ecb89b0b569ce12d9bb9d3bf17a4"><td class="memItemLeft" align="right" valign="top"><a id="a0c66ecb89b0b569ce12d9bb9d3bf17a4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structdetail_1_1deque__iterator.html">detail::deque_iterator</a>&lt; <a class="el" href="classdeque2.html">this_type</a> &gt;</td></tr>
<tr class="separator:a0c66ecb89b0b569ce12d9bb9d3bf17a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7c4a989b6341c7698548fcd9b2aaa0"><td class="memItemLeft" align="right" valign="top"><a id="a2e7c4a989b6341c7698548fcd9b2aaa0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structdetail_1_1deque__const__iterator.html">detail::deque_const_iterator</a>&lt; <a class="el" href="classdeque2.html">this_type</a> &gt;</td></tr>
<tr class="separator:a2e7c4a989b6341c7698548fcd9b2aaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memItemLeft" align="right" valign="top"><a id="a6faa0a87e9f58b63bc8ee253838ffcf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1d8044a92d6e57d551b0b559343aad"><td class="memItemLeft" align="right" valign="top"><a id="add1d8044a92d6e57d551b0b559343aad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:add1d8044a92d6e57d551b0b559343aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1781b3f5fadd1ba61026bdf43c3a349f"><td class="memItemLeft" align="right" valign="top"><a id="a1781b3f5fadd1ba61026bdf43c3a349f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u_iterator</b> = <a class="el" href="structdetail_1_1unsafe__iterator.html">detail::unsafe_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:a1781b3f5fadd1ba61026bdf43c3a349f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03fa7425f7acc53505160f41811b8e9"><td class="memItemLeft" align="right" valign="top"><a id="ae03fa7425f7acc53505160f41811b8e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u_const_iterator</b> = <a class="el" href="structdetail_1_1unsafe__const__iterator.html">detail::unsafe_const_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:ae03fa7425f7acc53505160f41811b8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327db2a454d0035fda0c63ff4793b383"><td class="memItemLeft" align="right" valign="top"><a id="a327db2a454d0035fda0c63ff4793b383"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1unsafe__iterator.html">u_iterator</a> &gt;</td></tr>
<tr class="separator:a327db2a454d0035fda0c63ff4793b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178ed9e5c58b36ce2546aae8354f4b5a"><td class="memItemLeft" align="right" valign="top"><a id="a178ed9e5c58b36ce2546aae8354f4b5a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u_const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a> &gt;</td></tr>
<tr class="separator:a178ed9e5c58b36ce2546aae8354f4b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61016c6bc3bd6bea570ebe5582178d90"><td class="memTemplParams" colspan="2"><a id="a61016c6bc3bd6bea570ebe5582178d90"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a61016c6bc3bd6bea570ebe5582178d90"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RebindAlloc</b> = typename std::allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; U &gt;</td></tr>
<tr class="separator:a61016c6bc3bd6bea570ebe5582178d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96666615860aa2ccd1bc446f3333b9c5"><td class="memItemLeft" align="right" valign="top"><a id="a96666615860aa2ccd1bc446f3333b9c5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_manager</b> = <a class="el" href="structdetail_1_1_bucket_manager.html">detail::BucketManager</a>&lt; T, Allocator, UseMemPool, MinBSize, MaxBSize &gt;</td></tr>
<tr class="separator:a96666615860aa2ccd1bc446f3333b9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc85323d5cc39917b0054dcaef78ce2a"><td class="memItemLeft" align="right" valign="top"><a id="adc85323d5cc39917b0054dcaef78ce2a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_traits</b> = std::allocator_traits&lt; Allocator &gt;</td></tr>
<tr class="separator:adc85323d5cc39917b0054dcaef78ce2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cee2b1eb71f4212636769c5929bc5c"><td class="memItemLeft" align="right" valign="top"><a id="a45cee2b1eb71f4212636769c5929bc5c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b> = <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, UseMemPool, MinBSize, MaxBSize &gt;</td></tr>
<tr class="separator:a45cee2b1eb71f4212636769c5929bc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600be7ec0c0a0256b789225b84308dcc"><td class="memItemLeft" align="right" valign="top"><a id="a600be7ec0c0a0256b789225b84308dcc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a600be7ec0c0a0256b789225b84308dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memItemLeft" align="right" valign="top"><a id="a228d205e7c179d9c87cf936d24ba9dd4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:a228d205e7c179d9c87cf936d24ba9dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memItemLeft" align="right" valign="top"><a id="a3071baa70c70b9a6ec7083064e67d4c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename alloc_traits::size_type</td></tr>
<tr class="separator:a3071baa70c70b9a6ec7083064e67d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b571f84b69059f6d0868d3f9ac5427"><td class="memItemLeft" align="right" valign="top"><a id="a63b571f84b69059f6d0868d3f9ac5427"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename alloc_traits::difference_type</td></tr>
<tr class="separator:a63b571f84b69059f6d0868d3f9ac5427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memItemLeft" align="right" valign="top"><a id="a76c04bed428981ff4ef82cf9f6dbe2dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename alloc_traits::pointer</td></tr>
<tr class="separator:a76c04bed428981ff4ef82cf9f6dbe2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1494a0f75f05c13327cf190fde8df"><td class="memItemLeft" align="right" valign="top"><a id="ac1f1494a0f75f05c13327cf190fde8df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename alloc_traits::const_pointer</td></tr>
<tr class="separator:ac1f1494a0f75f05c13327cf190fde8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8022190763c231b244bad7386a54f2"><td class="memItemLeft" align="right" valign="top"><a id="a0d8022190763c231b244bad7386a54f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:a0d8022190763c231b244bad7386a54f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333f714b25ba56afe74ed44113faee2d"><td class="memItemLeft" align="right" valign="top"><a id="a333f714b25ba56afe74ed44113faee2d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:a333f714b25ba56afe74ed44113faee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c66ecb89b0b569ce12d9bb9d3bf17a4"><td class="memItemLeft" align="right" valign="top"><a id="a0c66ecb89b0b569ce12d9bb9d3bf17a4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structdetail_1_1deque__iterator.html">detail::deque_iterator</a>&lt; <a class="el" href="classdeque2.html">this_type</a> &gt;</td></tr>
<tr class="separator:a0c66ecb89b0b569ce12d9bb9d3bf17a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7c4a989b6341c7698548fcd9b2aaa0"><td class="memItemLeft" align="right" valign="top"><a id="a2e7c4a989b6341c7698548fcd9b2aaa0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structdetail_1_1deque__const__iterator.html">detail::deque_const_iterator</a>&lt; <a class="el" href="classdeque2.html">this_type</a> &gt;</td></tr>
<tr class="separator:a2e7c4a989b6341c7698548fcd9b2aaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memItemLeft" align="right" valign="top"><a id="a6faa0a87e9f58b63bc8ee253838ffcf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a6faa0a87e9f58b63bc8ee253838ffcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1d8044a92d6e57d551b0b559343aad"><td class="memItemLeft" align="right" valign="top"><a id="add1d8044a92d6e57d551b0b559343aad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:add1d8044a92d6e57d551b0b559343aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1781b3f5fadd1ba61026bdf43c3a349f"><td class="memItemLeft" align="right" valign="top"><a id="a1781b3f5fadd1ba61026bdf43c3a349f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u_iterator</b> = <a class="el" href="structdetail_1_1unsafe__iterator.html">detail::unsafe_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:a1781b3f5fadd1ba61026bdf43c3a349f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03fa7425f7acc53505160f41811b8e9"><td class="memItemLeft" align="right" valign="top"><a id="ae03fa7425f7acc53505160f41811b8e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u_const_iterator</b> = <a class="el" href="structdetail_1_1unsafe__const__iterator.html">detail::unsafe_const_iterator</a>&lt; <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> &gt;</td></tr>
<tr class="separator:ae03fa7425f7acc53505160f41811b8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327db2a454d0035fda0c63ff4793b383"><td class="memItemLeft" align="right" valign="top"><a id="a327db2a454d0035fda0c63ff4793b383"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1unsafe__iterator.html">u_iterator</a> &gt;</td></tr>
<tr class="separator:a327db2a454d0035fda0c63ff4793b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178ed9e5c58b36ce2546aae8354f4b5a"><td class="memItemLeft" align="right" valign="top"><a id="a178ed9e5c58b36ce2546aae8354f4b5a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u_const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a> &gt;</td></tr>
<tr class="separator:a178ed9e5c58b36ce2546aae8354f4b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac6ca75793eff0ab70abb5aaa9a5d494b"><td class="memItemLeft" align="right" valign="top"><a id="ac6ca75793eff0ab70abb5aaa9a5d494b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const Allocator &amp;al)</td></tr>
<tr class="separator:ac6ca75793eff0ab70abb5aaa9a5d494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bddececf7a80fb4a59f973502ea78f2"><td class="memItemLeft" align="right" valign="top"><a id="a8bddececf7a80fb4a59f973502ea78f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (size_type count, const T &amp;value, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a8bddececf7a80fb4a59f973502ea78f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce543ee5f85c3a643f4c06f71a262f7"><td class="memItemLeft" align="right" valign="top"><a id="a1ce543ee5f85c3a643f4c06f71a262f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (size_type count, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a1ce543ee5f85c3a643f4c06f71a262f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575b9355e93af26795de39c95a6c1a03"><td class="memItemLeft" align="right" valign="top"><a id="a575b9355e93af26795de39c95a6c1a03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other)</td></tr>
<tr class="separator:a575b9355e93af26795de39c95a6c1a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee98802cdd938218fd880acc507f84dd"><td class="memItemLeft" align="right" valign="top"><a id="aee98802cdd938218fd880acc507f84dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other, const Allocator &amp;al)</td></tr>
<tr class="separator:aee98802cdd938218fd880acc507f84dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf479e8f20f7e6f1a7261c324eb0407f"><td class="memItemLeft" align="right" valign="top"><a id="acf479e8f20f7e6f1a7261c324eb0407f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other)</td></tr>
<tr class="separator:acf479e8f20f7e6f1a7261c324eb0407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf296fa64efebf3908dc032e732aadd6"><td class="memItemLeft" align="right" valign="top"><a id="abf296fa64efebf3908dc032e732aadd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other, const Allocator &amp;al)</td></tr>
<tr class="separator:abf296fa64efebf3908dc032e732aadd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9463e5cb9ffce18663771343373ee407"><td class="memItemLeft" align="right" valign="top"><a id="a9463e5cb9ffce18663771343373ee407"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const std::initializer_list&lt; T &gt; &amp;lst, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a9463e5cb9ffce18663771343373ee407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dab4eca1e9ac5cb4a92b1deeef1ad8"><td class="memTemplParams" colspan="2"><a id="a51dab4eca1e9ac5cb4a92b1deeef1ad8"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a51dab4eca1e9ac5cb4a92b1deeef1ad8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deque2</b> (Iter first, Iter last, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a51dab4eca1e9ac5cb4a92b1deeef1ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3004e6e90143b036175d56d8bbfaa7a1"><td class="memItemLeft" align="right" valign="top"><a id="a3004e6e90143b036175d56d8bbfaa7a1"></a>
<a class="el" href="classdeque2.html">deque2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a3004e6e90143b036175d56d8bbfaa7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27581d2e342d67b35c17076aa052d24"><td class="memItemLeft" align="right" valign="top"><a id="aa27581d2e342d67b35c17076aa052d24"></a>
<a class="el" href="classdeque2.html">deque2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other)</td></tr>
<tr class="separator:aa27581d2e342d67b35c17076aa052d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33237f11572fe69ce5289182a5c97bd"><td class="memItemLeft" align="right" valign="top"><a id="aa33237f11572fe69ce5289182a5c97bd"></a>
<a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> ()</td></tr>
<tr class="separator:aa33237f11572fe69ce5289182a5c97bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9556251fa4d00681e0c00764b76bf5d"><td class="memItemLeft" align="right" valign="top"><a id="ab9556251fa4d00681e0c00764b76bf5d"></a>
const <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> () const</td></tr>
<tr class="separator:ab9556251fa4d00681e0c00764b76bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7410e636e215d1c9a26e5143c1bbe1a5"><td class="memItemLeft" align="right" valign="top"><a id="a7410e636e215d1c9a26e5143c1bbe1a5"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a7410e636e215d1c9a26e5143c1bbe1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b36d5b665c22198212b5f57e137db2"><td class="memItemLeft" align="right" valign="top"><a id="a77b36d5b665c22198212b5f57e137db2"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () const</td></tr>
<tr class="separator:a77b36d5b665c22198212b5f57e137db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96859695b35909cce1f8e2d9017441cb"><td class="memItemLeft" align="right" valign="top"><a id="a96859695b35909cce1f8e2d9017441cb"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_count</b> () const</td></tr>
<tr class="separator:a96859695b35909cce1f8e2d9017441cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79990fcc5adea92b4db470811cb3e780"><td class="memItemLeft" align="right" valign="top"><a id="a79990fcc5adea92b4db470811cb3e780"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_size</b> () const</td></tr>
<tr class="separator:a79990fcc5adea92b4db470811cb3e780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69761ef6d0e315699ff266f096bb35"><td class="memItemLeft" align="right" valign="top"><a id="a6a69761ef6d0e315699ff266f096bb35"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:a6a69761ef6d0e315699ff266f096bb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5de9eaeea47d64c58ffb462c80baff"><td class="memItemLeft" align="right" valign="top"><a id="a5b5de9eaeea47d64c58ffb462c80baff"></a>
const Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a5b5de9eaeea47d64c58ffb462c80baff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaffbc4030df124777b75f068041c2f3"><td class="memItemLeft" align="right" valign="top"><a id="abaffbc4030df124777b75f068041c2f3"></a>
Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> ()</td></tr>
<tr class="separator:abaffbc4030df124777b75f068041c2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413d4c2b4b2ab4b9ea496a15cb7086bd"><td class="memItemLeft" align="right" valign="top"><a id="a413d4c2b4b2ab4b9ea496a15cb7086bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;other) noexcept</td></tr>
<tr class="separator:a413d4c2b4b2ab4b9ea496a15cb7086bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ab5f05303bc9176ca90cc141927437"><td class="memItemLeft" align="right" valign="top"><a id="a18ab5f05303bc9176ca90cc141927437"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="separator:a18ab5f05303bc9176ca90cc141927437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70817b27f1ca49ba921bb500e323aa1"><td class="memItemLeft" align="right" valign="top"><a id="ad70817b27f1ca49ba921bb500e323aa1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type size)</td></tr>
<tr class="separator:ad70817b27f1ca49ba921bb500e323aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42d94561d996aef405d13363df71c75"><td class="memItemLeft" align="right" valign="top"><a id="ab42d94561d996aef405d13363df71c75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type size, const T &amp;value)</td></tr>
<tr class="separator:ab42d94561d996aef405d13363df71c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1547738d10a9c169a73555f85be3ff37"><td class="memItemLeft" align="right" valign="top"><a id="a1547738d10a9c169a73555f85be3ff37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_front</b> (size_type size)</td></tr>
<tr class="separator:a1547738d10a9c169a73555f85be3ff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8f06360784823d8b942ab562800073"><td class="memItemLeft" align="right" valign="top"><a id="afa8f06360784823d8b942ab562800073"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_front</b> (size_type size, const T &amp;value)</td></tr>
<tr class="separator:afa8f06360784823d8b942ab562800073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1721abf59df0890421905681f06a1913"><td class="memItemLeft" align="right" valign="top"><a id="a1721abf59df0890421905681f06a1913"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a1721abf59df0890421905681f06a1913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca48f57aea391d037e676767ea2621c"><td class="memItemLeft" align="right" valign="top"><a id="a3ca48f57aea391d037e676767ea2621c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (const T &amp;value)</td></tr>
<tr class="separator:a3ca48f57aea391d037e676767ea2621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7d2474b171536fcc899509293b94da"><td class="memItemLeft" align="right" valign="top"><a id="a9d7d2474b171536fcc899509293b94da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a9d7d2474b171536fcc899509293b94da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efbb7f69a24333f38025294e0cb4a79"><td class="memTemplParams" colspan="2"><a id="a6efbb7f69a24333f38025294e0cb4a79"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6efbb7f69a24333f38025294e0cb4a79"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a6efbb7f69a24333f38025294e0cb4a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2ea4236b1def98b091b53566a5b32"><td class="memItemLeft" align="right" valign="top"><a id="a21c2ea4236b1def98b091b53566a5b32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (const T &amp;value)</td></tr>
<tr class="separator:a21c2ea4236b1def98b091b53566a5b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfb4c5a61549f5df100a82f9f02dc00"><td class="memItemLeft" align="right" valign="top"><a id="a4cfb4c5a61549f5df100a82f9f02dc00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a4cfb4c5a61549f5df100a82f9f02dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0db81affe0ce2e5f28afcee9952403"><td class="memTemplParams" colspan="2"><a id="aab0db81affe0ce2e5f28afcee9952403"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aab0db81affe0ce2e5f28afcee9952403"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_front</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:aab0db81affe0ce2e5f28afcee9952403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6111a1c166b94923046f5ce9b5d05658"><td class="memItemLeft" align="right" valign="top"><a id="a6111a1c166b94923046f5ce9b5d05658"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (size_type pos, const T &amp;value)</td></tr>
<tr class="separator:a6111a1c166b94923046f5ce9b5d05658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b2833d3c9688cbda07fffff6c988b3"><td class="memItemLeft" align="right" valign="top"><a id="a05b2833d3c9688cbda07fffff6c988b3"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it, const T &amp;value)</td></tr>
<tr class="separator:a05b2833d3c9688cbda07fffff6c988b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c68a938bc2a298449c5aa36dfbecc8a"><td class="memItemLeft" align="right" valign="top"><a id="a6c68a938bc2a298449c5aa36dfbecc8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (size_type pos, T &amp;&amp;value)</td></tr>
<tr class="separator:a6c68a938bc2a298449c5aa36dfbecc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c295f4c8ae4c879c4b030fa92cddf6"><td class="memItemLeft" align="right" valign="top"><a id="a55c295f4c8ae4c879c4b030fa92cddf6"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it, T &amp;&amp;value)</td></tr>
<tr class="separator:a55c295f4c8ae4c879c4b030fa92cddf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="memTemplParams" colspan="2"><a id="ae9dbd414ccc60320f772c189cc4bb0a7"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (size_type pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf31475aea5e645cd06c0a18b49fe67a"><td class="memTemplParams" colspan="2"><a id="abf31475aea5e645cd06c0a18b49fe67a"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:abf31475aea5e645cd06c0a18b49fe67a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:abf31475aea5e645cd06c0a18b49fe67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081250f49736dbf48e5b844deacafdb1"><td class="memTemplParams" colspan="2"><a id="a081250f49736dbf48e5b844deacafdb1"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a081250f49736dbf48e5b844deacafdb1"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a081250f49736dbf48e5b844deacafdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541c06978e7e6f577d2a2f8d1f08c598"><td class="memTemplParams" colspan="2"><a id="a541c06978e7e6f577d2a2f8d1f08c598"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a541c06978e7e6f577d2a2f8d1f08c598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (size_type pos, Iter first, Iter last)</td></tr>
<tr class="separator:a541c06978e7e6f577d2a2f8d1f08c598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e48983e2596f4393a9def65ecf884"><td class="memTemplParams" colspan="2"><a id="ac32e48983e2596f4393a9def65ecf884"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ac32e48983e2596f4393a9def65ecf884"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it, Iter first, Iter last)</td></tr>
<tr class="separator:ac32e48983e2596f4393a9def65ecf884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3205797052f31e99bbd835d3f7421f2"><td class="memItemLeft" align="right" valign="top"><a id="ae3205797052f31e99bbd835d3f7421f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (size_type pos, size_type count, const T &amp;value)</td></tr>
<tr class="separator:ae3205797052f31e99bbd835d3f7421f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839c9e8bff3303eaa6cc3470ce2df314"><td class="memItemLeft" align="right" valign="top"><a id="a839c9e8bff3303eaa6cc3470ce2df314"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> pos, size_type count, const T &amp;value)</td></tr>
<tr class="separator:a839c9e8bff3303eaa6cc3470ce2df314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memItemLeft" align="right" valign="top"><a id="a7412866d48eeeba1ae9831e2d90e2e9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="separator:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33bd83e3344bb65aed00cb9758165c"><td class="memItemLeft" align="right" valign="top"><a id="acf33bd83e3344bb65aed00cb9758165c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_front</b> ()</td></tr>
<tr class="separator:acf33bd83e3344bb65aed00cb9758165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d84531f6e31b03aa4d4af7346f069df"><td class="memItemLeft" align="right" valign="top"><a id="a7d84531f6e31b03aa4d4af7346f069df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (size_type pos)</td></tr>
<tr class="separator:a7d84531f6e31b03aa4d4af7346f069df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb557ffcf46f609cd37ebfcfe9c15b"><td class="memItemLeft" align="right" valign="top"><a id="a0dcb557ffcf46f609cd37ebfcfe9c15b"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it)</td></tr>
<tr class="separator:a0dcb557ffcf46f609cd37ebfcfe9c15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc74c95ca7d62c10f6078020ada986f"><td class="memItemLeft" align="right" valign="top"><a id="a0bc74c95ca7d62c10f6078020ada986f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (size_type first, size_type last)</td></tr>
<tr class="separator:a0bc74c95ca7d62c10f6078020ada986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709f986b066ffbd1b2d9a774d78b9add"><td class="memItemLeft" align="right" valign="top"><a id="a709f986b066ffbd1b2d9a774d78b9add"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> first, <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="separator:a709f986b066ffbd1b2d9a774d78b9add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70eaa59a8a8759ef893fd28d019e6937"><td class="memItemLeft" align="right" valign="top"><a id="a70eaa59a8a8759ef893fd28d019e6937"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (size_type count, const T &amp;value)</td></tr>
<tr class="separator:a70eaa59a8a8759ef893fd28d019e6937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c47c37e56f11714f0a09d269c57719"><td class="memTemplParams" colspan="2"><a id="a93c47c37e56f11714f0a09d269c57719"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a93c47c37e56f11714f0a09d269c57719"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (Iter first, Iter last)</td></tr>
<tr class="separator:a93c47c37e56f11714f0a09d269c57719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c684f4163189ef1124ee3315048259b"><td class="memItemLeft" align="right" valign="top"><a id="a8c684f4163189ef1124ee3315048259b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="separator:a8c684f4163189ef1124ee3315048259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f33a0bc38953f17e476ae498df9040"><td class="memTemplParams" colspan="2"><a id="a08f33a0bc38953f17e476ae498df9040"></a>
template&lt;class Fun &gt; </td></tr>
<tr class="memitem:a08f33a0bc38953f17e476ae498df9040"><td class="memTemplItemLeft" align="right" valign="top">Fun&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each</b> (size_type first, size_type last, Fun fun)</td></tr>
<tr class="separator:a08f33a0bc38953f17e476ae498df9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acff7357ef7605976812891c648dd10"><td class="memTemplParams" colspan="2"><a id="a3acff7357ef7605976812891c648dd10"></a>
template&lt;class Fun &gt; </td></tr>
<tr class="memitem:a3acff7357ef7605976812891c648dd10"><td class="memTemplItemLeft" align="right" valign="top">Fun&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each</b> (size_type first, size_type last, Fun fun) const</td></tr>
<tr class="separator:a3acff7357ef7605976812891c648dd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626ff0d93bf0a61826997cae1b13a54f"><td class="memItemLeft" align="right" valign="top"><a id="a626ff0d93bf0a61826997cae1b13a54f"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a626ff0d93bf0a61826997cae1b13a54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cdfa99cd9546752901c80f9c805677"><td class="memItemLeft" align="right" valign="top"><a id="a37cdfa99cd9546752901c80f9c805677"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (size_type pos) noexcept</td></tr>
<tr class="separator:a37cdfa99cd9546752901c80f9c805677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ff211593d9c16c401c8e4de79586e5"><td class="memItemLeft" align="right" valign="top"><a id="a33ff211593d9c16c401c8e4de79586e5"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a33ff211593d9c16c401c8e4de79586e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea59542bba56f67c662f9ed4f0d80e7a"><td class="memItemLeft" align="right" valign="top"><a id="aea59542bba56f67c662f9ed4f0d80e7a"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type pos) noexcept</td></tr>
<tr class="separator:aea59542bba56f67c662f9ed4f0d80e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf82cc501b7710a7620f6d87ba76027c"><td class="memItemLeft" align="right" valign="top"><a id="abf82cc501b7710a7620f6d87ba76027c"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> ()</td></tr>
<tr class="separator:abf82cc501b7710a7620f6d87ba76027c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedde7889adcb981115f80d8f768364ce"><td class="memItemLeft" align="right" valign="top"><a id="aedde7889adcb981115f80d8f768364ce"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> () const</td></tr>
<tr class="separator:aedde7889adcb981115f80d8f768364ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dc71f3abd1a384269dd4a5ade712ab"><td class="memItemLeft" align="right" valign="top"><a id="ab8dc71f3abd1a384269dd4a5ade712ab"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> ()</td></tr>
<tr class="separator:ab8dc71f3abd1a384269dd4a5ade712ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad746d0e885d28419ada40c502a105cbb"><td class="memItemLeft" align="right" valign="top"><a id="ad746d0e885d28419ada40c502a105cbb"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> () const</td></tr>
<tr class="separator:ad746d0e885d28419ada40c502a105cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac212188082da190386b63541e8c6d469"><td class="memItemLeft" align="right" valign="top"><a id="ac212188082da190386b63541e8c6d469"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:ac212188082da190386b63541e8c6d469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af464c96015bbd4fdd82b0f5d43046a02"><td class="memItemLeft" align="right" valign="top"><a id="af464c96015bbd4fdd82b0f5d43046a02"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:af464c96015bbd4fdd82b0f5d43046a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637ce4ab03c362c2d1913b2d7fd0ada9"><td class="memItemLeft" align="right" valign="top"><a id="a637ce4ab03c362c2d1913b2d7fd0ada9"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a637ce4ab03c362c2d1913b2d7fd0ada9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ac7ab28029a485d6b46da6a9b01f1b"><td class="memItemLeft" align="right" valign="top"><a id="a06ac7ab28029a485d6b46da6a9b01f1b"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a06ac7ab28029a485d6b46da6a9b01f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b2521b6dc207516124cf530b429b05"><td class="memItemLeft" align="right" valign="top"><a id="af3b2521b6dc207516124cf530b429b05"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () noexcept</td></tr>
<tr class="separator:af3b2521b6dc207516124cf530b429b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41617280aa72f0f794d763c767b339bb"><td class="memItemLeft" align="right" valign="top"><a id="a41617280aa72f0f794d763c767b339bb"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:a41617280aa72f0f794d763c767b339bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3ae65ccc69bf7ed8971b01aaac3bcb"><td class="memItemLeft" align="right" valign="top"><a id="a5a3ae65ccc69bf7ed8971b01aaac3bcb"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () noexcept</td></tr>
<tr class="separator:a5a3ae65ccc69bf7ed8971b01aaac3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea81d8b2ad8fa7981e6c7536ff5baeab"><td class="memItemLeft" align="right" valign="top"><a id="aea81d8b2ad8fa7981e6c7536ff5baeab"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:aea81d8b2ad8fa7981e6c7536ff5baeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c60d03af01a0dfab9afc4f0252940"><td class="memItemLeft" align="right" valign="top"><a id="afc6c60d03af01a0dfab9afc4f0252940"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:afc6c60d03af01a0dfab9afc4f0252940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda3bc2fa33630abae730c717bcfb1f3"><td class="memItemLeft" align="right" valign="top"><a id="acda3bc2fa33630abae730c717bcfb1f3"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:acda3bc2fa33630abae730c717bcfb1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00e7a3b56e091e7361f510edd714d89"><td class="memItemLeft" align="right" valign="top"><a id="ae00e7a3b56e091e7361f510edd714d89"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const noexcept</td></tr>
<tr class="separator:ae00e7a3b56e091e7361f510edd714d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e6719d9ca9c0fcb4b46b6561ddfc99"><td class="memItemLeft" align="right" valign="top"><a id="a65e6719d9ca9c0fcb4b46b6561ddfc99"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="separator:a65e6719d9ca9c0fcb4b46b6561ddfc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62acf9ffaf5220a9611c39ad3155cbf"><td class="memItemLeft" align="right" valign="top"><a id="aa62acf9ffaf5220a9611c39ad3155cbf"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_at</b> (size_t pos) noexcept</td></tr>
<tr class="separator:aa62acf9ffaf5220a9611c39ad3155cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a8b6a9daee6eab0635eb36da0fb5b3"><td class="memItemLeft" align="right" valign="top"><a id="a83a8b6a9daee6eab0635eb36da0fb5b3"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_at</b> (size_t pos) const noexcept</td></tr>
<tr class="separator:a83a8b6a9daee6eab0635eb36da0fb5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830ee91c694f6c6e48f5ce12f7a0bd54"><td class="memTemplParams" colspan="2"><a id="a830ee91c694f6c6e48f5ce12f7a0bd54"></a>
template&lt;class U , class Less  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a830ee91c694f6c6e48f5ce12f7a0bd54"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binary_search</b> (const U &amp;value, const <a class="el" href="struct_less.html">Less</a> &amp;le=<a class="el" href="struct_less.html">Less</a>()) const noexcept</td></tr>
<tr class="separator:a830ee91c694f6c6e48f5ce12f7a0bd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cca90cf6ea9d4f393cc2e1ec199a115"><td class="memTemplParams" colspan="2"><a id="a5cca90cf6ea9d4f393cc2e1ec199a115"></a>
template&lt;class U , class Less  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a5cca90cf6ea9d4f393cc2e1ec199a115"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const U &amp;value, const <a class="el" href="struct_less.html">Less</a> &amp;le=<a class="el" href="struct_less.html">Less</a>()) const noexcept</td></tr>
<tr class="separator:a5cca90cf6ea9d4f393cc2e1ec199a115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14b60911bd00bfa1abab542b541b9eb"><td class="memTemplParams" colspan="2"><a id="af14b60911bd00bfa1abab542b541b9eb"></a>
template&lt;class U , class Less  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:af14b60911bd00bfa1abab542b541b9eb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const U &amp;value, const <a class="el" href="struct_less.html">Less</a> &amp;le=<a class="el" href="struct_less.html">Less</a>()) const noexcept</td></tr>
<tr class="separator:af14b60911bd00bfa1abab542b541b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d32d45c4eaccddc736c21a811e898b2"><td class="memItemLeft" align="right" valign="top"><a id="a9d32d45c4eaccddc736c21a811e898b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a9d32d45c4eaccddc736c21a811e898b2">deque2</a> ()</td></tr>
<tr class="memdesc:a9d32d45c4eaccddc736c21a811e898b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, initialize the internal bucket manager. <br /></td></tr>
<tr class="separator:a9d32d45c4eaccddc736c21a811e898b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde1d8dd3a0df9d66583c90e4a47cffc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#adde1d8dd3a0df9d66583c90e4a47cffc">deque2</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:adde1d8dd3a0df9d66583c90e4a47cffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given allocator alloc.  <a href="classdeque2.html#adde1d8dd3a0df9d66583c90e4a47cffc">More...</a><br /></td></tr>
<tr class="separator:adde1d8dd3a0df9d66583c90e4a47cffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a4146ac9e9dc3ecc611d38d39612ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a14a4146ac9e9dc3ecc611d38d39612ba">deque2</a> (size_type count, const T &amp;value, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a14a4146ac9e9dc3ecc611d38d39612ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with <em>count</em> copies of elements with value <em>value</em>.  <a href="classdeque2.html#a14a4146ac9e9dc3ecc611d38d39612ba">More...</a><br /></td></tr>
<tr class="separator:a14a4146ac9e9dc3ecc611d38d39612ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4816d7bcd290309366a7649b0008a1e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a4816d7bcd290309366a7649b0008a1e1">deque2</a> (size_type count, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a4816d7bcd290309366a7649b0008a1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count default-inserted instances of T. No copies are made.  <a href="classdeque2.html#a4816d7bcd290309366a7649b0008a1e1">More...</a><br /></td></tr>
<tr class="separator:a4816d7bcd290309366a7649b0008a1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575b9355e93af26795de39c95a6c1a03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a575b9355e93af26795de39c95a6c1a03">deque2</a> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other)</td></tr>
<tr class="memdesc:a575b9355e93af26795de39c95a6c1a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other.  <a href="classdeque2.html#a575b9355e93af26795de39c95a6c1a03">More...</a><br /></td></tr>
<tr class="separator:a575b9355e93af26795de39c95a6c1a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d836281d75a3570875c1640e934a8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a04d836281d75a3570875c1640e934a8c">deque2</a> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a04d836281d75a3570875c1640e934a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the copy of the contents of other, using alloc as the allocator.  <a href="classdeque2.html#a04d836281d75a3570875c1640e934a8c">More...</a><br /></td></tr>
<tr class="separator:a04d836281d75a3570875c1640e934a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514bcd4479f84e16dbab77f39486d4c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a514bcd4479f84e16dbab77f39486d4c9">deque2</a> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a514bcd4479f84e16dbab77f39486d4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other.  <a href="classdeque2.html#a514bcd4479f84e16dbab77f39486d4c9">More...</a><br /></td></tr>
<tr class="separator:a514bcd4479f84e16dbab77f39486d4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64584fe43e94684e880dee234e72cda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ad64584fe43e94684e880dee234e72cda">deque2</a> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other, const Allocator &amp;alloc) noexcept(std::is_nothrow_move_assignable&lt; T &gt;::value)</td></tr>
<tr class="memdesc:ad64584fe43e94684e880dee234e72cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move.  <a href="classdeque2.html#ad64584fe43e94684e880dee234e72cda">More...</a><br /></td></tr>
<tr class="separator:ad64584fe43e94684e880dee234e72cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8523a9a78856485c4a7d3e8c2cb40145"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a8523a9a78856485c4a7d3e8c2cb40145">deque2</a> (const std::initializer_list&lt; T &gt; &amp;lst, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a8523a9a78856485c4a7d3e8c2cb40145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list <em>init</em>.  <a href="classdeque2.html#a8523a9a78856485c4a7d3e8c2cb40145">More...</a><br /></td></tr>
<tr class="separator:a8523a9a78856485c4a7d3e8c2cb40145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b7f9aaa26245d0437fc4f6732bc010"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a07b7f9aaa26245d0437fc4f6732bc010"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#a07b7f9aaa26245d0437fc4f6732bc010">deque2</a> (Iter first, Iter last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a07b7f9aaa26245d0437fc4f6732bc010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="classdeque2.html#a07b7f9aaa26245d0437fc4f6732bc010">More...</a><br /></td></tr>
<tr class="separator:a07b7f9aaa26245d0437fc4f6732bc010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff2723cf68fc3388eadfb56162b2ff7"><td class="memItemLeft" align="right" valign="top"><a id="a2ff2723cf68fc3388eadfb56162b2ff7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a2ff2723cf68fc3388eadfb56162b2ff7">~deque2</a> ()</td></tr>
<tr class="memdesc:a2ff2723cf68fc3388eadfb56162b2ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a2ff2723cf68fc3388eadfb56162b2ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3004e6e90143b036175d56d8bbfaa7a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdeque2.html">deque2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a3004e6e90143b036175d56d8bbfaa7a1">operator=</a> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a3004e6e90143b036175d56d8bbfaa7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classdeque2.html#a3004e6e90143b036175d56d8bbfaa7a1">More...</a><br /></td></tr>
<tr class="separator:a3004e6e90143b036175d56d8bbfaa7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27581d2e342d67b35c17076aa052d24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdeque2.html">deque2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#aa27581d2e342d67b35c17076aa052d24">operator=</a> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other)</td></tr>
<tr class="memdesc:aa27581d2e342d67b35c17076aa052d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classdeque2.html#aa27581d2e342d67b35c17076aa052d24">More...</a><br /></td></tr>
<tr class="separator:aa27581d2e342d67b35c17076aa052d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9490e9d02dc9046988d7ab145f9085"><td class="memItemLeft" align="right" valign="top"><a id="aaa9490e9d02dc9046988d7ab145f9085"></a>
<a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#aaa9490e9d02dc9046988d7ab145f9085">manager</a> () noexcept</td></tr>
<tr class="memdesc:aaa9490e9d02dc9046988d7ab145f9085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal bucket manager object. <br /></td></tr>
<tr class="separator:aaa9490e9d02dc9046988d7ab145f9085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d97624ceafe56cea993c7ec35d03e03"><td class="memItemLeft" align="right" valign="top"><a id="a3d97624ceafe56cea993c7ec35d03e03"></a>
const <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a3d97624ceafe56cea993c7ec35d03e03">manager</a> () const noexcept</td></tr>
<tr class="memdesc:a3d97624ceafe56cea993c7ec35d03e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal bucket manager object. <br /></td></tr>
<tr class="separator:a3d97624ceafe56cea993c7ec35d03e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea740c4033894c62ae7c427e1b4ed11"><td class="memItemLeft" align="right" valign="top"><a id="aeea740c4033894c62ae7c427e1b4ed11"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#aeea740c4033894c62ae7c427e1b4ed11">size</a> () const noexcept</td></tr>
<tr class="memdesc:aeea740c4033894c62ae7c427e1b4ed11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size. <br /></td></tr>
<tr class="separator:aeea740c4033894c62ae7c427e1b4ed11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1f33203301da65e144f7449d2dfc22"><td class="memItemLeft" align="right" valign="top"><a id="a9d1f33203301da65e144f7449d2dfc22"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a9d1f33203301da65e144f7449d2dfc22">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a9d1f33203301da65e144f7449d2dfc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size. <br /></td></tr>
<tr class="separator:a9d1f33203301da65e144f7449d2dfc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b32fbde47daf1a36a71b849a26aeb10"><td class="memItemLeft" align="right" valign="top"><a id="a1b32fbde47daf1a36a71b849a26aeb10"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a1b32fbde47daf1a36a71b849a26aeb10">bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:a1b32fbde47daf1a36a71b849a26aeb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of buckets within deque. <br /></td></tr>
<tr class="separator:a1b32fbde47daf1a36a71b849a26aeb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3821ad9cef7217a600b2398ec515fa61"><td class="memItemLeft" align="right" valign="top"><a id="a3821ad9cef7217a600b2398ec515fa61"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a3821ad9cef7217a600b2398ec515fa61">bucket_size</a> () const noexcept</td></tr>
<tr class="memdesc:a3821ad9cef7217a600b2398ec515fa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a bucket within deque. <br /></td></tr>
<tr class="separator:a3821ad9cef7217a600b2398ec515fa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab387217281fb34031a6412ad3b08795e"><td class="memItemLeft" align="right" valign="top"><a id="ab387217281fb34031a6412ad3b08795e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ab387217281fb34031a6412ad3b08795e">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ab387217281fb34031a6412ad3b08795e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retruns true if the container is empty, false otherwise. <br /></td></tr>
<tr class="separator:ab387217281fb34031a6412ad3b08795e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ff8bcbc758759712c65a9a8f7349fa"><td class="memItemLeft" align="right" valign="top"><a id="af7ff8bcbc758759712c65a9a8f7349fa"></a>
const Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#af7ff8bcbc758759712c65a9a8f7349fa">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:af7ff8bcbc758759712c65a9a8f7349fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container. <br /></td></tr>
<tr class="separator:af7ff8bcbc758759712c65a9a8f7349fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de9f97f1a1eb7f9ccd34fd45807c442"><td class="memItemLeft" align="right" valign="top"><a id="a8de9f97f1a1eb7f9ccd34fd45807c442"></a>
Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a8de9f97f1a1eb7f9ccd34fd45807c442">get_allocator</a> () noexcept</td></tr>
<tr class="memdesc:a8de9f97f1a1eb7f9ccd34fd45807c442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container. <br /></td></tr>
<tr class="separator:a8de9f97f1a1eb7f9ccd34fd45807c442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413d4c2b4b2ab4b9ea496a15cb7086bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a413d4c2b4b2ab4b9ea496a15cb7086bd">swap</a> (<a class="el" href="classdeque2.html">deque2</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a413d4c2b4b2ab4b9ea496a15cb7086bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.  <a href="classdeque2.html#a413d4c2b4b2ab4b9ea496a15cb7086bd">More...</a><br /></td></tr>
<tr class="separator:a413d4c2b4b2ab4b9ea496a15cb7086bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ab5f05303bc9176ca90cc141927437"><td class="memItemLeft" align="right" valign="top"><a id="a18ab5f05303bc9176ca90cc141927437"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a18ab5f05303bc9176ca90cc141927437">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a18ab5f05303bc9176ca90cc141927437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all unused memory, and move the deque content to the smallest possible storage. This function only makes sense for <em>OptimizeForSpeed</em> flag. Invalidate all iterators and references. <br /></td></tr>
<tr class="separator:a18ab5f05303bc9176ca90cc141927437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4f93360f8231415156b6861a09c739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a3a4f93360f8231415156b6861a09c739">resize</a> (size_type count)</td></tr>
<tr class="memdesc:a3a4f93360f8231415156b6861a09c739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classdeque2.html#a3a4f93360f8231415156b6861a09c739">More...</a><br /></td></tr>
<tr class="separator:a3a4f93360f8231415156b6861a09c739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ed0942ed60505b86261e28daa3d769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#af7ed0942ed60505b86261e28daa3d769">resize</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:af7ed0942ed60505b86261e28daa3d769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classdeque2.html#af7ed0942ed60505b86261e28daa3d769">More...</a><br /></td></tr>
<tr class="separator:af7ed0942ed60505b86261e28daa3d769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5924e01065e92c41121c4b6490f0bf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ac5924e01065e92c41121c4b6490f0bf8">resize_front</a> (size_type count)</td></tr>
<tr class="memdesc:ac5924e01065e92c41121c4b6490f0bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classdeque2.html#ac5924e01065e92c41121c4b6490f0bf8">More...</a><br /></td></tr>
<tr class="separator:ac5924e01065e92c41121c4b6490f0bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7d0148dd8ef08ad552afb3eadd30f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a7e7d0148dd8ef08ad552afb3eadd30f6">resize_front</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a7e7d0148dd8ef08ad552afb3eadd30f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classdeque2.html#a7e7d0148dd8ef08ad552afb3eadd30f6">More...</a><br /></td></tr>
<tr class="separator:a7e7d0148dd8ef08ad552afb3eadd30f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1721abf59df0890421905681f06a1913"><td class="memItemLeft" align="right" valign="top"><a id="a1721abf59df0890421905681f06a1913"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a1721abf59df0890421905681f06a1913">clear</a> ()</td></tr>
<tr class="memdesc:a1721abf59df0890421905681f06a1913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the container. <br /></td></tr>
<tr class="separator:a1721abf59df0890421905681f06a1913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca48f57aea391d037e676767ea2621c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a3ca48f57aea391d037e676767ea2621c">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a3ca48f57aea391d037e676767ea2621c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <a href="classdeque2.html#a3ca48f57aea391d037e676767ea2621c">More...</a><br /></td></tr>
<tr class="separator:a3ca48f57aea391d037e676767ea2621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7d2474b171536fcc899509293b94da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a9d7d2474b171536fcc899509293b94da">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a9d7d2474b171536fcc899509293b94da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container using move semantic.  <a href="classdeque2.html#a9d7d2474b171536fcc899509293b94da">More...</a><br /></td></tr>
<tr class="separator:a9d7d2474b171536fcc899509293b94da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efbb7f69a24333f38025294e0cb4a79"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6efbb7f69a24333f38025294e0cb4a79"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#a6efbb7f69a24333f38025294e0cb4a79">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6efbb7f69a24333f38025294e0cb4a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the end of the container.  <a href="classdeque2.html#a6efbb7f69a24333f38025294e0cb4a79">More...</a><br /></td></tr>
<tr class="separator:a6efbb7f69a24333f38025294e0cb4a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2ea4236b1def98b091b53566a5b32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a21c2ea4236b1def98b091b53566a5b32">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a21c2ea4236b1def98b091b53566a5b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the beginning of the container.  <a href="classdeque2.html#a21c2ea4236b1def98b091b53566a5b32">More...</a><br /></td></tr>
<tr class="separator:a21c2ea4236b1def98b091b53566a5b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfb4c5a61549f5df100a82f9f02dc00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a4cfb4c5a61549f5df100a82f9f02dc00">push_front</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a4cfb4c5a61549f5df100a82f9f02dc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the beginning of the container using move semantic.  <a href="classdeque2.html#a4cfb4c5a61549f5df100a82f9f02dc00">More...</a><br /></td></tr>
<tr class="separator:a4cfb4c5a61549f5df100a82f9f02dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0db81affe0ce2e5f28afcee9952403"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aab0db81affe0ce2e5f28afcee9952403"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#aab0db81affe0ce2e5f28afcee9952403">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aab0db81affe0ce2e5f28afcee9952403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the beginning of the container.  <a href="classdeque2.html#aab0db81affe0ce2e5f28afcee9952403">More...</a><br /></td></tr>
<tr class="separator:aab0db81affe0ce2e5f28afcee9952403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6111a1c166b94923046f5ce9b5d05658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a6111a1c166b94923046f5ce9b5d05658">insert</a> (size_type pos, const T &amp;value)</td></tr>
<tr class="memdesc:a6111a1c166b94923046f5ce9b5d05658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>pos</em>.  <a href="classdeque2.html#a6111a1c166b94923046f5ce9b5d05658">More...</a><br /></td></tr>
<tr class="separator:a6111a1c166b94923046f5ce9b5d05658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c68a938bc2a298449c5aa36dfbecc8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a6c68a938bc2a298449c5aa36dfbecc8a">insert</a> (size_type pos, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a6c68a938bc2a298449c5aa36dfbecc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>pos</em> using move semantic.  <a href="classdeque2.html#a6c68a938bc2a298449c5aa36dfbecc8a">More...</a><br /></td></tr>
<tr class="separator:a6c68a938bc2a298449c5aa36dfbecc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b2833d3c9688cbda07fffff6c988b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a05b2833d3c9688cbda07fffff6c988b3">insert</a> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it, const T &amp;value)</td></tr>
<tr class="memdesc:a05b2833d3c9688cbda07fffff6c988b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>it</em>.  <a href="classdeque2.html#a05b2833d3c9688cbda07fffff6c988b3">More...</a><br /></td></tr>
<tr class="separator:a05b2833d3c9688cbda07fffff6c988b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c295f4c8ae4c879c4b030fa92cddf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a55c295f4c8ae4c879c4b030fa92cddf6">insert</a> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a55c295f4c8ae4c879c4b030fa92cddf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>it</em> using move semantic.  <a href="classdeque2.html#a55c295f4c8ae4c879c4b030fa92cddf6">More...</a><br /></td></tr>
<tr class="separator:a55c295f4c8ae4c879c4b030fa92cddf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#ae9dbd414ccc60320f772c189cc4bb0a7">emplace</a> (size_type pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before <em>pos</em>.  <a href="classdeque2.html#ae9dbd414ccc60320f772c189cc4bb0a7">More...</a><br /></td></tr>
<tr class="separator:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081250f49736dbf48e5b844deacafdb1"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a081250f49736dbf48e5b844deacafdb1"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#a081250f49736dbf48e5b844deacafdb1">emplace</a> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a081250f49736dbf48e5b844deacafdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before <em>pos</em>.  <a href="classdeque2.html#a081250f49736dbf48e5b844deacafdb1">More...</a><br /></td></tr>
<tr class="separator:a081250f49736dbf48e5b844deacafdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541c06978e7e6f577d2a2f8d1f08c598"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a541c06978e7e6f577d2a2f8d1f08c598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#a541c06978e7e6f577d2a2f8d1f08c598">insert</a> (size_type pos, Iter first, Iter last)</td></tr>
<tr class="memdesc:a541c06978e7e6f577d2a2f8d1f08c598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos.  <a href="classdeque2.html#a541c06978e7e6f577d2a2f8d1f08c598">More...</a><br /></td></tr>
<tr class="separator:a541c06978e7e6f577d2a2f8d1f08c598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e48983e2596f4393a9def65ecf884"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ac32e48983e2596f4393a9def65ecf884"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#ac32e48983e2596f4393a9def65ecf884">insert</a> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it, Iter first, Iter last)</td></tr>
<tr class="memdesc:ac32e48983e2596f4393a9def65ecf884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before it.  <a href="classdeque2.html#ac32e48983e2596f4393a9def65ecf884">More...</a><br /></td></tr>
<tr class="separator:ac32e48983e2596f4393a9def65ecf884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64249801c41d575c76c7e8920e007e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a64249801c41d575c76c7e8920e007e90">insert</a> (size_type pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a64249801c41d575c76c7e8920e007e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist before pos.  <a href="classdeque2.html#a64249801c41d575c76c7e8920e007e90">More...</a><br /></td></tr>
<tr class="separator:a64249801c41d575c76c7e8920e007e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b56478cca246bfa99b3ef87e7e3e69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ac1b56478cca246bfa99b3ef87e7e3e69">insert</a> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:ac1b56478cca246bfa99b3ef87e7e3e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist before pos.  <a href="classdeque2.html#ac1b56478cca246bfa99b3ef87e7e3e69">More...</a><br /></td></tr>
<tr class="separator:ac1b56478cca246bfa99b3ef87e7e3e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3205797052f31e99bbd835d3f7421f2"><td class="memItemLeft" align="right" valign="top"><a id="ae3205797052f31e99bbd835d3f7421f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ae3205797052f31e99bbd835d3f7421f2">insert</a> (size_type pos, size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:ae3205797052f31e99bbd835d3f7421f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before pos Basic exception guarantee. <br  />
 <br /></td></tr>
<tr class="separator:ae3205797052f31e99bbd835d3f7421f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839c9e8bff3303eaa6cc3470ce2df314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a839c9e8bff3303eaa6cc3470ce2df314">insert</a> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> pos, size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a839c9e8bff3303eaa6cc3470ce2df314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before pos.  <a href="classdeque2.html#a839c9e8bff3303eaa6cc3470ce2df314">More...</a><br /></td></tr>
<tr class="separator:a839c9e8bff3303eaa6cc3470ce2df314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memItemLeft" align="right" valign="top"><a id="a7412866d48eeeba1ae9831e2d90e2e9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a7412866d48eeeba1ae9831e2d90e2e9c">pop_back</a> ()</td></tr>
<tr class="memdesc:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container. Calling pop_back on an empty container results in undefined behavior. Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). <br /></td></tr>
<tr class="separator:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33bd83e3344bb65aed00cb9758165c"><td class="memItemLeft" align="right" valign="top"><a id="acf33bd83e3344bb65aed00cb9758165c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#acf33bd83e3344bb65aed00cb9758165c">pop_front</a> ()</td></tr>
<tr class="memdesc:acf33bd83e3344bb65aed00cb9758165c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of the container. Calling pop_front on an empty container results in undefined behavior. Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). <br /></td></tr>
<tr class="separator:acf33bd83e3344bb65aed00cb9758165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d84531f6e31b03aa4d4af7346f069df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a7d84531f6e31b03aa4d4af7346f069df">erase</a> (size_type pos)</td></tr>
<tr class="memdesc:a7d84531f6e31b03aa4d4af7346f069df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given position.  <a href="classdeque2.html#a7d84531f6e31b03aa4d4af7346f069df">More...</a><br /></td></tr>
<tr class="separator:a7d84531f6e31b03aa4d4af7346f069df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb557ffcf46f609cd37ebfcfe9c15b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a0dcb557ffcf46f609cd37ebfcfe9c15b">erase</a> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it)</td></tr>
<tr class="memdesc:a0dcb557ffcf46f609cd37ebfcfe9c15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given position.  <a href="classdeque2.html#a0dcb557ffcf46f609cd37ebfcfe9c15b">More...</a><br /></td></tr>
<tr class="separator:a0dcb557ffcf46f609cd37ebfcfe9c15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc74c95ca7d62c10f6078020ada986f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a0bc74c95ca7d62c10f6078020ada986f">erase</a> (size_type first, size_type last)</td></tr>
<tr class="memdesc:a0bc74c95ca7d62c10f6078020ada986f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last).  <a href="classdeque2.html#a0bc74c95ca7d62c10f6078020ada986f">More...</a><br /></td></tr>
<tr class="separator:a0bc74c95ca7d62c10f6078020ada986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709f986b066ffbd1b2d9a774d78b9add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a709f986b066ffbd1b2d9a774d78b9add">erase</a> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> first, <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:a709f986b066ffbd1b2d9a774d78b9add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last).  <a href="classdeque2.html#a709f986b066ffbd1b2d9a774d78b9add">More...</a><br /></td></tr>
<tr class="separator:a709f986b066ffbd1b2d9a774d78b9add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70eaa59a8a8759ef893fd28d019e6937"><td class="memItemLeft" align="right" valign="top"><a id="a70eaa59a8a8759ef893fd28d019e6937"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a70eaa59a8a8759ef893fd28d019e6937">assign</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a70eaa59a8a8759ef893fd28d019e6937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with <em>count</em> copies of value <em>value</em> Basic exception guarantee. <br /></td></tr>
<tr class="separator:a70eaa59a8a8759ef893fd28d019e6937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c47c37e56f11714f0a09d269c57719"><td class="memTemplParams" colspan="2"><a id="a93c47c37e56f11714f0a09d269c57719"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a93c47c37e56f11714f0a09d269c57719"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#a93c47c37e56f11714f0a09d269c57719">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:a93c47c37e56f11714f0a09d269c57719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with copies of those in the range [first, last). The behavior is undefined if either argument is an iterator into *this. Basic exception guarantee. <br /></td></tr>
<tr class="separator:a93c47c37e56f11714f0a09d269c57719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c684f4163189ef1124ee3315048259b"><td class="memItemLeft" align="right" valign="top"><a id="a8c684f4163189ef1124ee3315048259b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a8c684f4163189ef1124ee3315048259b">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a8c684f4163189ef1124ee3315048259b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list ilist. Basic exception guarantee. <br /></td></tr>
<tr class="separator:a8c684f4163189ef1124ee3315048259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f33a0bc38953f17e476ae498df9040"><td class="memTemplParams" colspan="2">template&lt;class Fun &gt; </td></tr>
<tr class="memitem:a08f33a0bc38953f17e476ae498df9040"><td class="memTemplItemLeft" align="right" valign="top">Fun&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#a08f33a0bc38953f17e476ae498df9040">for_each</a> (size_type first, size_type last, Fun fun)</td></tr>
<tr class="memdesc:a08f33a0bc38953f17e476ae498df9040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply unary function <em>fun</em> to all elements within the range [first,last).  <a href="classdeque2.html#a08f33a0bc38953f17e476ae498df9040">More...</a><br /></td></tr>
<tr class="separator:a08f33a0bc38953f17e476ae498df9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acff7357ef7605976812891c648dd10"><td class="memTemplParams" colspan="2">template&lt;class Fun &gt; </td></tr>
<tr class="memitem:a3acff7357ef7605976812891c648dd10"><td class="memTemplItemLeft" align="right" valign="top">Fun&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#a3acff7357ef7605976812891c648dd10">for_each</a> (size_type first, size_type last, Fun fun) const</td></tr>
<tr class="memdesc:a3acff7357ef7605976812891c648dd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply unary function <em>fun</em> to all elements within the range [first,last).  <a href="classdeque2.html#a3acff7357ef7605976812891c648dd10">More...</a><br /></td></tr>
<tr class="separator:a3acff7357ef7605976812891c648dd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc276d62f18eba6c17f61143eae71313"><td class="memItemLeft" align="right" valign="top"><a id="afc276d62f18eba6c17f61143eae71313"></a>
INC_ALWAYS_INLINE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#afc276d62f18eba6c17f61143eae71313">at</a> (size_type pos) const</td></tr>
<tr class="memdesc:afc276d62f18eba6c17f61143eae71313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking. <br /></td></tr>
<tr class="separator:afc276d62f18eba6c17f61143eae71313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ecccfa9a1b8d820acc0f1d66df6348"><td class="memItemLeft" align="right" valign="top"><a id="ae6ecccfa9a1b8d820acc0f1d66df6348"></a>
INC_ALWAYS_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ae6ecccfa9a1b8d820acc0f1d66df6348">at</a> (size_type pos)</td></tr>
<tr class="memdesc:ae6ecccfa9a1b8d820acc0f1d66df6348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking. <br /></td></tr>
<tr class="separator:ae6ecccfa9a1b8d820acc0f1d66df6348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb3d4f7d077cb9b1f5fd25b0453cd10"><td class="memItemLeft" align="right" valign="top"><a id="acfb3d4f7d077cb9b1f5fd25b0453cd10"></a>
INC_ALWAYS_INLINE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#acfb3d4f7d077cb9b1f5fd25b0453cd10">operator[]</a> (size_type pos) const noexcept</td></tr>
<tr class="memdesc:acfb3d4f7d077cb9b1f5fd25b0453cd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, without bounds checking. <br /></td></tr>
<tr class="separator:acfb3d4f7d077cb9b1f5fd25b0453cd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a6ac6a2a43aba8209c94f261b75ad6"><td class="memItemLeft" align="right" valign="top"><a id="ad6a6ac6a2a43aba8209c94f261b75ad6"></a>
INC_ALWAYS_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ad6a6ac6a2a43aba8209c94f261b75ad6">operator[]</a> (size_type pos) noexcept</td></tr>
<tr class="memdesc:ad6a6ac6a2a43aba8209c94f261b75ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, without bounds checking. <br /></td></tr>
<tr class="separator:ad6a6ac6a2a43aba8209c94f261b75ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e50887a43c0329dad7437d5472133"><td class="memItemLeft" align="right" valign="top"><a id="a1d8e50887a43c0329dad7437d5472133"></a>
INC_ALWAYS_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a1d8e50887a43c0329dad7437d5472133">back</a> () noexcept</td></tr>
<tr class="memdesc:a1d8e50887a43c0329dad7437d5472133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container. <br /></td></tr>
<tr class="separator:a1d8e50887a43c0329dad7437d5472133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9c07cc11554d758e25a6e5f41a53f2"><td class="memItemLeft" align="right" valign="top"><a id="abc9c07cc11554d758e25a6e5f41a53f2"></a>
INC_ALWAYS_INLINE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#abc9c07cc11554d758e25a6e5f41a53f2">back</a> () const noexcept</td></tr>
<tr class="memdesc:abc9c07cc11554d758e25a6e5f41a53f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container. <br /></td></tr>
<tr class="separator:abc9c07cc11554d758e25a6e5f41a53f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a8607031f4ea86dc414133abcfcab5"><td class="memItemLeft" align="right" valign="top"><a id="a30a8607031f4ea86dc414133abcfcab5"></a>
INC_ALWAYS_INLINE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a30a8607031f4ea86dc414133abcfcab5">front</a> () noexcept</td></tr>
<tr class="memdesc:a30a8607031f4ea86dc414133abcfcab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container. <br /></td></tr>
<tr class="separator:a30a8607031f4ea86dc414133abcfcab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cd32520ab43fe9e409ee4acbd8e828"><td class="memItemLeft" align="right" valign="top"><a id="ad6cd32520ab43fe9e409ee4acbd8e828"></a>
INC_ALWAYS_INLINE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ad6cd32520ab43fe9e409ee4acbd8e828">front</a> () const noexcept</td></tr>
<tr class="memdesc:ad6cd32520ab43fe9e409ee4acbd8e828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container. <br /></td></tr>
<tr class="separator:ad6cd32520ab43fe9e409ee4acbd8e828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5a94bb95298295c0fb05679786daa9"><td class="memItemLeft" align="right" valign="top"><a id="a8f5a94bb95298295c0fb05679786daa9"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a8f5a94bb95298295c0fb05679786daa9">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a8f5a94bb95298295c0fb05679786daa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the deque. <br /></td></tr>
<tr class="separator:a8f5a94bb95298295c0fb05679786daa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaac5b3d4e611e3f9f74c9c1db0883ff"><td class="memItemLeft" align="right" valign="top"><a id="abaac5b3d4e611e3f9f74c9c1db0883ff"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#abaac5b3d4e611e3f9f74c9c1db0883ff">begin</a> () noexcept</td></tr>
<tr class="memdesc:abaac5b3d4e611e3f9f74c9c1db0883ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the deque. <br /></td></tr>
<tr class="separator:abaac5b3d4e611e3f9f74c9c1db0883ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade243d29ff6016aa9bc877ea4a8bd691"><td class="memItemLeft" align="right" valign="top"><a id="ade243d29ff6016aa9bc877ea4a8bd691"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ade243d29ff6016aa9bc877ea4a8bd691">end</a> () const noexcept</td></tr>
<tr class="memdesc:ade243d29ff6016aa9bc877ea4a8bd691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the deque. <br /></td></tr>
<tr class="separator:ade243d29ff6016aa9bc877ea4a8bd691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360e117c76bdb55b1bbd8d48328320fe"><td class="memItemLeft" align="right" valign="top"><a id="a360e117c76bdb55b1bbd8d48328320fe"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a360e117c76bdb55b1bbd8d48328320fe">end</a> () noexcept</td></tr>
<tr class="memdesc:a360e117c76bdb55b1bbd8d48328320fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the deque. <br /></td></tr>
<tr class="separator:a360e117c76bdb55b1bbd8d48328320fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97abe4a1ee4a3bdcc8a3987cc94516c4"><td class="memItemLeft" align="right" valign="top"><a id="a97abe4a1ee4a3bdcc8a3987cc94516c4"></a>
INC_ALWAYS_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a97abe4a1ee4a3bdcc8a3987cc94516c4">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a97abe4a1ee4a3bdcc8a3987cc94516c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list. <br /></td></tr>
<tr class="separator:a97abe4a1ee4a3bdcc8a3987cc94516c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61375f03fce7646dc08eccf151b2d555"><td class="memItemLeft" align="right" valign="top"><a id="a61375f03fce7646dc08eccf151b2d555"></a>
INC_ALWAYS_INLINE const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a61375f03fce7646dc08eccf151b2d555">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a61375f03fce7646dc08eccf151b2d555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list. <br /></td></tr>
<tr class="separator:a61375f03fce7646dc08eccf151b2d555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf05ce6a2b33eaef20a41c015957c030"><td class="memItemLeft" align="right" valign="top"><a id="acf05ce6a2b33eaef20a41c015957c030"></a>
INC_ALWAYS_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#acf05ce6a2b33eaef20a41c015957c030">rend</a> () noexcept</td></tr>
<tr class="memdesc:acf05ce6a2b33eaef20a41c015957c030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list. <br /></td></tr>
<tr class="separator:acf05ce6a2b33eaef20a41c015957c030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3876b759d2aed8cd8d3e595ab939c317"><td class="memItemLeft" align="right" valign="top"><a id="a3876b759d2aed8cd8d3e595ab939c317"></a>
INC_ALWAYS_INLINE const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a3876b759d2aed8cd8d3e595ab939c317">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a3876b759d2aed8cd8d3e595ab939c317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list. <br /></td></tr>
<tr class="separator:a3876b759d2aed8cd8d3e595ab939c317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b083e36c9af190dc87b783557e7a655"><td class="memItemLeft" align="right" valign="top"><a id="a4b083e36c9af190dc87b783557e7a655"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a4b083e36c9af190dc87b783557e7a655">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a4b083e36c9af190dc87b783557e7a655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the deque. <br /></td></tr>
<tr class="separator:a4b083e36c9af190dc87b783557e7a655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d961d23aa89c0752dae7da2c2686ee5"><td class="memItemLeft" align="right" valign="top"><a id="a6d961d23aa89c0752dae7da2c2686ee5"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a6d961d23aa89c0752dae7da2c2686ee5">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a6d961d23aa89c0752dae7da2c2686ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the deque. <br /></td></tr>
<tr class="separator:a6d961d23aa89c0752dae7da2c2686ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2868cb8966e2715a0918a55c60aef5b"><td class="memItemLeft" align="right" valign="top"><a id="ad2868cb8966e2715a0918a55c60aef5b"></a>
INC_ALWAYS_INLINE const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#ad2868cb8966e2715a0918a55c60aef5b">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ad2868cb8966e2715a0918a55c60aef5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list. <br /></td></tr>
<tr class="separator:ad2868cb8966e2715a0918a55c60aef5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9b04e269502675f6318db9baa130e7"><td class="memItemLeft" align="right" valign="top"><a id="a4b9b04e269502675f6318db9baa130e7"></a>
INC_ALWAYS_INLINE const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a4b9b04e269502675f6318db9baa130e7">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a4b9b04e269502675f6318db9baa130e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list. <br /></td></tr>
<tr class="separator:a4b9b04e269502675f6318db9baa130e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62acf9ffaf5220a9611c39ad3155cbf"><td class="memItemLeft" align="right" valign="top"><a id="aa62acf9ffaf5220a9611c39ad3155cbf"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#aa62acf9ffaf5220a9611c39ad3155cbf">iterator_at</a> (size_t pos) noexcept</td></tr>
<tr class="memdesc:aa62acf9ffaf5220a9611c39ad3155cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to given absolute position. This is slightly faster than begin()+pos. <br /></td></tr>
<tr class="separator:aa62acf9ffaf5220a9611c39ad3155cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a8b6a9daee6eab0635eb36da0fb5b3"><td class="memItemLeft" align="right" valign="top"><a id="a83a8b6a9daee6eab0635eb36da0fb5b3"></a>
INC_ALWAYS_INLINE <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeque2.html#a83a8b6a9daee6eab0635eb36da0fb5b3">iterator_at</a> (size_t pos) const noexcept</td></tr>
<tr class="memdesc:a83a8b6a9daee6eab0635eb36da0fb5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to given absolute position. This is slightly faster than begin()+pos. <br /></td></tr>
<tr class="separator:a83a8b6a9daee6eab0635eb36da0fb5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830ee91c694f6c6e48f5ce12f7a0bd54"><td class="memTemplParams" colspan="2"><a id="a830ee91c694f6c6e48f5ce12f7a0bd54"></a>
template&lt;class U , class Less  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a830ee91c694f6c6e48f5ce12f7a0bd54"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#a830ee91c694f6c6e48f5ce12f7a0bd54">binary_search</a> (const U &amp;value, const <a class="el" href="struct_less.html">Less</a> &amp;le=<a class="el" href="struct_less.html">Less</a>()) const noexcept</td></tr>
<tr class="memdesc:a830ee91c694f6c6e48f5ce12f7a0bd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized version of std::binary_search(begin(),end(),value,le); Only works for sorted deque. <br /></td></tr>
<tr class="separator:a830ee91c694f6c6e48f5ce12f7a0bd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cca90cf6ea9d4f393cc2e1ec199a115"><td class="memTemplParams" colspan="2"><a id="a5cca90cf6ea9d4f393cc2e1ec199a115"></a>
template&lt;class U , class Less  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a5cca90cf6ea9d4f393cc2e1ec199a115"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#a5cca90cf6ea9d4f393cc2e1ec199a115">lower_bound</a> (const U &amp;value, const <a class="el" href="struct_less.html">Less</a> &amp;le=<a class="el" href="struct_less.html">Less</a>()) const noexcept</td></tr>
<tr class="memdesc:a5cca90cf6ea9d4f393cc2e1ec199a115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized version of std::lower_bound(begin(),end(),value,le); Only works for sorted deque. <br /></td></tr>
<tr class="separator:a5cca90cf6ea9d4f393cc2e1ec199a115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14b60911bd00bfa1abab542b541b9eb"><td class="memTemplParams" colspan="2"><a id="af14b60911bd00bfa1abab542b541b9eb"></a>
template&lt;class U , class Less  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:af14b60911bd00bfa1abab542b541b9eb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdeque2.html#af14b60911bd00bfa1abab542b541b9eb">upper_bound</a> (const U &amp;value, const <a class="el" href="struct_less.html">Less</a> &amp;le=<a class="el" href="struct_less.html">Less</a>()) const noexcept</td></tr>
<tr class="memdesc:af14b60911bd00bfa1abab542b541b9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized version of std::upper_bound(begin(),end(),value,le); Only works for sorted deque. <br /></td></tr>
<tr class="separator:af14b60911bd00bfa1abab542b541b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ca75793eff0ab70abb5aaa9a5d494b"><td class="memItemLeft" align="right" valign="top"><a id="ac6ca75793eff0ab70abb5aaa9a5d494b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const Allocator &amp;al)</td></tr>
<tr class="separator:ac6ca75793eff0ab70abb5aaa9a5d494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bddececf7a80fb4a59f973502ea78f2"><td class="memItemLeft" align="right" valign="top"><a id="a8bddececf7a80fb4a59f973502ea78f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (size_type count, const T &amp;value, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a8bddececf7a80fb4a59f973502ea78f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce543ee5f85c3a643f4c06f71a262f7"><td class="memItemLeft" align="right" valign="top"><a id="a1ce543ee5f85c3a643f4c06f71a262f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (size_type count, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a1ce543ee5f85c3a643f4c06f71a262f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575b9355e93af26795de39c95a6c1a03"><td class="memItemLeft" align="right" valign="top"><a id="a575b9355e93af26795de39c95a6c1a03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other)</td></tr>
<tr class="separator:a575b9355e93af26795de39c95a6c1a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee98802cdd938218fd880acc507f84dd"><td class="memItemLeft" align="right" valign="top"><a id="aee98802cdd938218fd880acc507f84dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other, const Allocator &amp;al)</td></tr>
<tr class="separator:aee98802cdd938218fd880acc507f84dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf479e8f20f7e6f1a7261c324eb0407f"><td class="memItemLeft" align="right" valign="top"><a id="acf479e8f20f7e6f1a7261c324eb0407f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other)</td></tr>
<tr class="separator:acf479e8f20f7e6f1a7261c324eb0407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf296fa64efebf3908dc032e732aadd6"><td class="memItemLeft" align="right" valign="top"><a id="abf296fa64efebf3908dc032e732aadd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other, const Allocator &amp;al)</td></tr>
<tr class="separator:abf296fa64efebf3908dc032e732aadd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9463e5cb9ffce18663771343373ee407"><td class="memItemLeft" align="right" valign="top"><a id="a9463e5cb9ffce18663771343373ee407"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const std::initializer_list&lt; T &gt; &amp;lst, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a9463e5cb9ffce18663771343373ee407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dab4eca1e9ac5cb4a92b1deeef1ad8"><td class="memTemplParams" colspan="2"><a id="a51dab4eca1e9ac5cb4a92b1deeef1ad8"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a51dab4eca1e9ac5cb4a92b1deeef1ad8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deque2</b> (Iter first, Iter last, const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a51dab4eca1e9ac5cb4a92b1deeef1ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3004e6e90143b036175d56d8bbfaa7a1"><td class="memItemLeft" align="right" valign="top"><a id="a3004e6e90143b036175d56d8bbfaa7a1"></a>
<a class="el" href="classdeque2.html">deque2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a3004e6e90143b036175d56d8bbfaa7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27581d2e342d67b35c17076aa052d24"><td class="memItemLeft" align="right" valign="top"><a id="aa27581d2e342d67b35c17076aa052d24"></a>
<a class="el" href="classdeque2.html">deque2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other)</td></tr>
<tr class="separator:aa27581d2e342d67b35c17076aa052d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33237f11572fe69ce5289182a5c97bd"><td class="memItemLeft" align="right" valign="top"><a id="aa33237f11572fe69ce5289182a5c97bd"></a>
<a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> ()</td></tr>
<tr class="separator:aa33237f11572fe69ce5289182a5c97bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9556251fa4d00681e0c00764b76bf5d"><td class="memItemLeft" align="right" valign="top"><a id="ab9556251fa4d00681e0c00764b76bf5d"></a>
const <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> () const</td></tr>
<tr class="separator:ab9556251fa4d00681e0c00764b76bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7410e636e215d1c9a26e5143c1bbe1a5"><td class="memItemLeft" align="right" valign="top"><a id="a7410e636e215d1c9a26e5143c1bbe1a5"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a7410e636e215d1c9a26e5143c1bbe1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b36d5b665c22198212b5f57e137db2"><td class="memItemLeft" align="right" valign="top"><a id="a77b36d5b665c22198212b5f57e137db2"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () const</td></tr>
<tr class="separator:a77b36d5b665c22198212b5f57e137db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96859695b35909cce1f8e2d9017441cb"><td class="memItemLeft" align="right" valign="top"><a id="a96859695b35909cce1f8e2d9017441cb"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_count</b> () const</td></tr>
<tr class="separator:a96859695b35909cce1f8e2d9017441cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79990fcc5adea92b4db470811cb3e780"><td class="memItemLeft" align="right" valign="top"><a id="a79990fcc5adea92b4db470811cb3e780"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_size</b> () const</td></tr>
<tr class="separator:a79990fcc5adea92b4db470811cb3e780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69761ef6d0e315699ff266f096bb35"><td class="memItemLeft" align="right" valign="top"><a id="a6a69761ef6d0e315699ff266f096bb35"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:a6a69761ef6d0e315699ff266f096bb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5de9eaeea47d64c58ffb462c80baff"><td class="memItemLeft" align="right" valign="top"><a id="a5b5de9eaeea47d64c58ffb462c80baff"></a>
const Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a5b5de9eaeea47d64c58ffb462c80baff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaffbc4030df124777b75f068041c2f3"><td class="memItemLeft" align="right" valign="top"><a id="abaffbc4030df124777b75f068041c2f3"></a>
Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> ()</td></tr>
<tr class="separator:abaffbc4030df124777b75f068041c2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413d4c2b4b2ab4b9ea496a15cb7086bd"><td class="memItemLeft" align="right" valign="top"><a id="a413d4c2b4b2ab4b9ea496a15cb7086bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;other) noexcept</td></tr>
<tr class="separator:a413d4c2b4b2ab4b9ea496a15cb7086bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ab5f05303bc9176ca90cc141927437"><td class="memItemLeft" align="right" valign="top"><a id="a18ab5f05303bc9176ca90cc141927437"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="separator:a18ab5f05303bc9176ca90cc141927437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70817b27f1ca49ba921bb500e323aa1"><td class="memItemLeft" align="right" valign="top"><a id="ad70817b27f1ca49ba921bb500e323aa1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type size)</td></tr>
<tr class="separator:ad70817b27f1ca49ba921bb500e323aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42d94561d996aef405d13363df71c75"><td class="memItemLeft" align="right" valign="top"><a id="ab42d94561d996aef405d13363df71c75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type size, const T &amp;value)</td></tr>
<tr class="separator:ab42d94561d996aef405d13363df71c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1547738d10a9c169a73555f85be3ff37"><td class="memItemLeft" align="right" valign="top"><a id="a1547738d10a9c169a73555f85be3ff37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_front</b> (size_type size)</td></tr>
<tr class="separator:a1547738d10a9c169a73555f85be3ff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8f06360784823d8b942ab562800073"><td class="memItemLeft" align="right" valign="top"><a id="afa8f06360784823d8b942ab562800073"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_front</b> (size_type size, const T &amp;value)</td></tr>
<tr class="separator:afa8f06360784823d8b942ab562800073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1721abf59df0890421905681f06a1913"><td class="memItemLeft" align="right" valign="top"><a id="a1721abf59df0890421905681f06a1913"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a1721abf59df0890421905681f06a1913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca48f57aea391d037e676767ea2621c"><td class="memItemLeft" align="right" valign="top"><a id="a3ca48f57aea391d037e676767ea2621c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (const T &amp;value)</td></tr>
<tr class="separator:a3ca48f57aea391d037e676767ea2621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7d2474b171536fcc899509293b94da"><td class="memItemLeft" align="right" valign="top"><a id="a9d7d2474b171536fcc899509293b94da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a9d7d2474b171536fcc899509293b94da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efbb7f69a24333f38025294e0cb4a79"><td class="memTemplParams" colspan="2"><a id="a6efbb7f69a24333f38025294e0cb4a79"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6efbb7f69a24333f38025294e0cb4a79"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a6efbb7f69a24333f38025294e0cb4a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2ea4236b1def98b091b53566a5b32"><td class="memItemLeft" align="right" valign="top"><a id="a21c2ea4236b1def98b091b53566a5b32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (const T &amp;value)</td></tr>
<tr class="separator:a21c2ea4236b1def98b091b53566a5b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfb4c5a61549f5df100a82f9f02dc00"><td class="memItemLeft" align="right" valign="top"><a id="a4cfb4c5a61549f5df100a82f9f02dc00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a4cfb4c5a61549f5df100a82f9f02dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0db81affe0ce2e5f28afcee9952403"><td class="memTemplParams" colspan="2"><a id="aab0db81affe0ce2e5f28afcee9952403"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aab0db81affe0ce2e5f28afcee9952403"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_front</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:aab0db81affe0ce2e5f28afcee9952403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6111a1c166b94923046f5ce9b5d05658"><td class="memItemLeft" align="right" valign="top"><a id="a6111a1c166b94923046f5ce9b5d05658"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (size_type pos, const T &amp;value)</td></tr>
<tr class="separator:a6111a1c166b94923046f5ce9b5d05658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b2833d3c9688cbda07fffff6c988b3"><td class="memItemLeft" align="right" valign="top"><a id="a05b2833d3c9688cbda07fffff6c988b3"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it, const T &amp;value)</td></tr>
<tr class="separator:a05b2833d3c9688cbda07fffff6c988b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c68a938bc2a298449c5aa36dfbecc8a"><td class="memItemLeft" align="right" valign="top"><a id="a6c68a938bc2a298449c5aa36dfbecc8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (size_type pos, T &amp;&amp;value)</td></tr>
<tr class="separator:a6c68a938bc2a298449c5aa36dfbecc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c295f4c8ae4c879c4b030fa92cddf6"><td class="memItemLeft" align="right" valign="top"><a id="a55c295f4c8ae4c879c4b030fa92cddf6"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it, T &amp;&amp;value)</td></tr>
<tr class="separator:a55c295f4c8ae4c879c4b030fa92cddf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="memTemplParams" colspan="2"><a id="ae9dbd414ccc60320f772c189cc4bb0a7"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (size_type pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ae9dbd414ccc60320f772c189cc4bb0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf31475aea5e645cd06c0a18b49fe67a"><td class="memTemplParams" colspan="2"><a id="abf31475aea5e645cd06c0a18b49fe67a"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:abf31475aea5e645cd06c0a18b49fe67a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:abf31475aea5e645cd06c0a18b49fe67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081250f49736dbf48e5b844deacafdb1"><td class="memTemplParams" colspan="2"><a id="a081250f49736dbf48e5b844deacafdb1"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a081250f49736dbf48e5b844deacafdb1"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a081250f49736dbf48e5b844deacafdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541c06978e7e6f577d2a2f8d1f08c598"><td class="memTemplParams" colspan="2"><a id="a541c06978e7e6f577d2a2f8d1f08c598"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a541c06978e7e6f577d2a2f8d1f08c598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (size_type pos, Iter first, Iter last)</td></tr>
<tr class="separator:a541c06978e7e6f577d2a2f8d1f08c598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e48983e2596f4393a9def65ecf884"><td class="memTemplParams" colspan="2"><a id="ac32e48983e2596f4393a9def65ecf884"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ac32e48983e2596f4393a9def65ecf884"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it, Iter first, Iter last)</td></tr>
<tr class="separator:ac32e48983e2596f4393a9def65ecf884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3205797052f31e99bbd835d3f7421f2"><td class="memItemLeft" align="right" valign="top"><a id="ae3205797052f31e99bbd835d3f7421f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (size_type pos, size_type count, const T &amp;value)</td></tr>
<tr class="separator:ae3205797052f31e99bbd835d3f7421f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839c9e8bff3303eaa6cc3470ce2df314"><td class="memItemLeft" align="right" valign="top"><a id="a839c9e8bff3303eaa6cc3470ce2df314"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> pos, size_type count, const T &amp;value)</td></tr>
<tr class="separator:a839c9e8bff3303eaa6cc3470ce2df314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memItemLeft" align="right" valign="top"><a id="a7412866d48eeeba1ae9831e2d90e2e9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="separator:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33bd83e3344bb65aed00cb9758165c"><td class="memItemLeft" align="right" valign="top"><a id="acf33bd83e3344bb65aed00cb9758165c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_front</b> ()</td></tr>
<tr class="separator:acf33bd83e3344bb65aed00cb9758165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d84531f6e31b03aa4d4af7346f069df"><td class="memItemLeft" align="right" valign="top"><a id="a7d84531f6e31b03aa4d4af7346f069df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (size_type pos)</td></tr>
<tr class="separator:a7d84531f6e31b03aa4d4af7346f069df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb557ffcf46f609cd37ebfcfe9c15b"><td class="memItemLeft" align="right" valign="top"><a id="a0dcb557ffcf46f609cd37ebfcfe9c15b"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> it)</td></tr>
<tr class="separator:a0dcb557ffcf46f609cd37ebfcfe9c15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc74c95ca7d62c10f6078020ada986f"><td class="memItemLeft" align="right" valign="top"><a id="a0bc74c95ca7d62c10f6078020ada986f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (size_type first, size_type last)</td></tr>
<tr class="separator:a0bc74c95ca7d62c10f6078020ada986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709f986b066ffbd1b2d9a774d78b9add"><td class="memItemLeft" align="right" valign="top"><a id="a709f986b066ffbd1b2d9a774d78b9add"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> first, <a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="separator:a709f986b066ffbd1b2d9a774d78b9add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70eaa59a8a8759ef893fd28d019e6937"><td class="memItemLeft" align="right" valign="top"><a id="a70eaa59a8a8759ef893fd28d019e6937"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (size_type count, const T &amp;value)</td></tr>
<tr class="separator:a70eaa59a8a8759ef893fd28d019e6937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c47c37e56f11714f0a09d269c57719"><td class="memTemplParams" colspan="2"><a id="a93c47c37e56f11714f0a09d269c57719"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a93c47c37e56f11714f0a09d269c57719"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (Iter first, Iter last)</td></tr>
<tr class="separator:a93c47c37e56f11714f0a09d269c57719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c684f4163189ef1124ee3315048259b"><td class="memItemLeft" align="right" valign="top"><a id="a8c684f4163189ef1124ee3315048259b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="separator:a8c684f4163189ef1124ee3315048259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f33a0bc38953f17e476ae498df9040"><td class="memTemplParams" colspan="2"><a id="a08f33a0bc38953f17e476ae498df9040"></a>
template&lt;class Fun &gt; </td></tr>
<tr class="memitem:a08f33a0bc38953f17e476ae498df9040"><td class="memTemplItemLeft" align="right" valign="top">Fun&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each</b> (size_type first, size_type last, Fun fun)</td></tr>
<tr class="separator:a08f33a0bc38953f17e476ae498df9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acff7357ef7605976812891c648dd10"><td class="memTemplParams" colspan="2"><a id="a3acff7357ef7605976812891c648dd10"></a>
template&lt;class Fun &gt; </td></tr>
<tr class="memitem:a3acff7357ef7605976812891c648dd10"><td class="memTemplItemLeft" align="right" valign="top">Fun&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each</b> (size_type first, size_type last, Fun fun) const</td></tr>
<tr class="separator:a3acff7357ef7605976812891c648dd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626ff0d93bf0a61826997cae1b13a54f"><td class="memItemLeft" align="right" valign="top"><a id="a626ff0d93bf0a61826997cae1b13a54f"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a626ff0d93bf0a61826997cae1b13a54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cdfa99cd9546752901c80f9c805677"><td class="memItemLeft" align="right" valign="top"><a id="a37cdfa99cd9546752901c80f9c805677"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (size_type pos) noexcept</td></tr>
<tr class="separator:a37cdfa99cd9546752901c80f9c805677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ff211593d9c16c401c8e4de79586e5"><td class="memItemLeft" align="right" valign="top"><a id="a33ff211593d9c16c401c8e4de79586e5"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a33ff211593d9c16c401c8e4de79586e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea59542bba56f67c662f9ed4f0d80e7a"><td class="memItemLeft" align="right" valign="top"><a id="aea59542bba56f67c662f9ed4f0d80e7a"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type pos) noexcept</td></tr>
<tr class="separator:aea59542bba56f67c662f9ed4f0d80e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf82cc501b7710a7620f6d87ba76027c"><td class="memItemLeft" align="right" valign="top"><a id="abf82cc501b7710a7620f6d87ba76027c"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> ()</td></tr>
<tr class="separator:abf82cc501b7710a7620f6d87ba76027c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedde7889adcb981115f80d8f768364ce"><td class="memItemLeft" align="right" valign="top"><a id="aedde7889adcb981115f80d8f768364ce"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> () const</td></tr>
<tr class="separator:aedde7889adcb981115f80d8f768364ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dc71f3abd1a384269dd4a5ade712ab"><td class="memItemLeft" align="right" valign="top"><a id="ab8dc71f3abd1a384269dd4a5ade712ab"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> ()</td></tr>
<tr class="separator:ab8dc71f3abd1a384269dd4a5ade712ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad746d0e885d28419ada40c502a105cbb"><td class="memItemLeft" align="right" valign="top"><a id="ad746d0e885d28419ada40c502a105cbb"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> () const</td></tr>
<tr class="separator:ad746d0e885d28419ada40c502a105cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac212188082da190386b63541e8c6d469"><td class="memItemLeft" align="right" valign="top"><a id="ac212188082da190386b63541e8c6d469"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:ac212188082da190386b63541e8c6d469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af464c96015bbd4fdd82b0f5d43046a02"><td class="memItemLeft" align="right" valign="top"><a id="af464c96015bbd4fdd82b0f5d43046a02"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:af464c96015bbd4fdd82b0f5d43046a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637ce4ab03c362c2d1913b2d7fd0ada9"><td class="memItemLeft" align="right" valign="top"><a id="a637ce4ab03c362c2d1913b2d7fd0ada9"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a637ce4ab03c362c2d1913b2d7fd0ada9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ac7ab28029a485d6b46da6a9b01f1b"><td class="memItemLeft" align="right" valign="top"><a id="a06ac7ab28029a485d6b46da6a9b01f1b"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a06ac7ab28029a485d6b46da6a9b01f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b2521b6dc207516124cf530b429b05"><td class="memItemLeft" align="right" valign="top"><a id="af3b2521b6dc207516124cf530b429b05"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () noexcept</td></tr>
<tr class="separator:af3b2521b6dc207516124cf530b429b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41617280aa72f0f794d763c767b339bb"><td class="memItemLeft" align="right" valign="top"><a id="a41617280aa72f0f794d763c767b339bb"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:a41617280aa72f0f794d763c767b339bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3ae65ccc69bf7ed8971b01aaac3bcb"><td class="memItemLeft" align="right" valign="top"><a id="a5a3ae65ccc69bf7ed8971b01aaac3bcb"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () noexcept</td></tr>
<tr class="separator:a5a3ae65ccc69bf7ed8971b01aaac3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea81d8b2ad8fa7981e6c7536ff5baeab"><td class="memItemLeft" align="right" valign="top"><a id="aea81d8b2ad8fa7981e6c7536ff5baeab"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:aea81d8b2ad8fa7981e6c7536ff5baeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c60d03af01a0dfab9afc4f0252940"><td class="memItemLeft" align="right" valign="top"><a id="afc6c60d03af01a0dfab9afc4f0252940"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:afc6c60d03af01a0dfab9afc4f0252940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda3bc2fa33630abae730c717bcfb1f3"><td class="memItemLeft" align="right" valign="top"><a id="acda3bc2fa33630abae730c717bcfb1f3"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:acda3bc2fa33630abae730c717bcfb1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00e7a3b56e091e7361f510edd714d89"><td class="memItemLeft" align="right" valign="top"><a id="ae00e7a3b56e091e7361f510edd714d89"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const noexcept</td></tr>
<tr class="separator:ae00e7a3b56e091e7361f510edd714d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e6719d9ca9c0fcb4b46b6561ddfc99"><td class="memItemLeft" align="right" valign="top"><a id="a65e6719d9ca9c0fcb4b46b6561ddfc99"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="separator:a65e6719d9ca9c0fcb4b46b6561ddfc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554f84df0e4f2d3dc0d9e7e50fe2f4a5"><td class="memItemLeft" align="right" valign="top"><a id="a554f84df0e4f2d3dc0d9e7e50fe2f4a5"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_at</b> (size_t pos) noexcept</td></tr>
<tr class="separator:a554f84df0e4f2d3dc0d9e7e50fe2f4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ab4950e326b4d1670481d01540afdd"><td class="memItemLeft" align="right" valign="top"><a id="aa9ab4950e326b4d1670481d01540afdd"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_at</b> (size_t pos) const noexcept</td></tr>
<tr class="separator:aa9ab4950e326b4d1670481d01540afdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a2d6c49127e823063d3b51340c08d1"><td class="memTemplParams" colspan="2"><a id="a63a2d6c49127e823063d3b51340c08d1"></a>
template&lt;class U , class Less  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a63a2d6c49127e823063d3b51340c08d1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binary_search</b> (const U &amp;value, size_t start, size_t end, <a class="el" href="struct_less.html">Less</a> le=<a class="el" href="struct_less.html">Less</a>()) const noexcept</td></tr>
<tr class="separator:a63a2d6c49127e823063d3b51340c08d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa54848330282b143d38d116419c340"><td class="memTemplParams" colspan="2"><a id="afaa54848330282b143d38d116419c340"></a>
template&lt;class U , class Less  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:afaa54848330282b143d38d116419c340"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const U &amp;value, size_t start, size_t end, <a class="el" href="struct_less.html">Less</a> le=<a class="el" href="struct_less.html">Less</a>()) const noexcept</td></tr>
<tr class="separator:afaa54848330282b143d38d116419c340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f85497f3c3788b56404dcfd3e73d83"><td class="memTemplParams" colspan="2"><a id="ac3f85497f3c3788b56404dcfd3e73d83"></a>
template&lt;class U , class Less  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ac3f85497f3c3788b56404dcfd3e73d83"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const U &amp;value, size_t start, size_t end, <a class="el" href="struct_less.html">Less</a> le=<a class="el" href="struct_less.html">Less</a>()) const noexcept</td></tr>
<tr class="separator:ac3f85497f3c3788b56404dcfd3e73d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad739ede6074365c5ec746c94f7bfd902"><td class="memTemplParams" colspan="2"><a id="ad739ede6074365c5ec746c94f7bfd902"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad739ede6074365c5ec746c94f7bfd902"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_manager</b> (const Allocator &amp;al, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad739ede6074365c5ec746c94f7bfd902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fe7529e06d4347f4f3d9b4af0fce60"><td class="memItemLeft" align="right" valign="top"><a id="a61fe7529e06d4347f4f3d9b4af0fce60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy_manager</b> (<a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *manager)</td></tr>
<tr class="separator:a61fe7529e06d4347f4f3d9b4af0fce60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33237f11572fe69ce5289182a5c97bd"><td class="memItemLeft" align="right" valign="top"><a id="aa33237f11572fe69ce5289182a5c97bd"></a>
<a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> ()</td></tr>
<tr class="separator:aa33237f11572fe69ce5289182a5c97bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9556251fa4d00681e0c00764b76bf5d"><td class="memItemLeft" align="right" valign="top"><a id="ab9556251fa4d00681e0c00764b76bf5d"></a>
const <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> () const</td></tr>
<tr class="separator:ab9556251fa4d00681e0c00764b76bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f56493aea4b142564d2fce2b9e9cb8f"><td class="memItemLeft" align="right" valign="top"><a id="a9f56493aea4b142564d2fce2b9e9cb8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a9f56493aea4b142564d2fce2b9e9cb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575b9355e93af26795de39c95a6c1a03"><td class="memItemLeft" align="right" valign="top"><a id="a575b9355e93af26795de39c95a6c1a03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other)</td></tr>
<tr class="separator:a575b9355e93af26795de39c95a6c1a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf479e8f20f7e6f1a7261c324eb0407f"><td class="memItemLeft" align="right" valign="top"><a id="acf479e8f20f7e6f1a7261c324eb0407f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other)</td></tr>
<tr class="separator:acf479e8f20f7e6f1a7261c324eb0407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3166344991198d1094e25d6569838559"><td class="memItemLeft" align="right" valign="top"><a id="a3166344991198d1094e25d6569838559"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="separator:a3166344991198d1094e25d6569838559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7410e636e215d1c9a26e5143c1bbe1a5"><td class="memItemLeft" align="right" valign="top"><a id="a7410e636e215d1c9a26e5143c1bbe1a5"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a7410e636e215d1c9a26e5143c1bbe1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5de9eaeea47d64c58ffb462c80baff"><td class="memItemLeft" align="right" valign="top"><a id="a5b5de9eaeea47d64c58ffb462c80baff"></a>
const Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a5b5de9eaeea47d64c58ffb462c80baff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70817b27f1ca49ba921bb500e323aa1"><td class="memItemLeft" align="right" valign="top"><a id="ad70817b27f1ca49ba921bb500e323aa1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type size)</td></tr>
<tr class="separator:ad70817b27f1ca49ba921bb500e323aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1721abf59df0890421905681f06a1913"><td class="memItemLeft" align="right" valign="top"><a id="a1721abf59df0890421905681f06a1913"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a1721abf59df0890421905681f06a1913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1844a3867e423d3dfdc5f46a4b63d5f"><td class="memItemLeft" align="right" valign="top"><a id="ad1844a3867e423d3dfdc5f46a4b63d5f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_bucket_size</b> ()</td></tr>
<tr class="separator:ad1844a3867e423d3dfdc5f46a4b63d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca48f57aea391d037e676767ea2621c"><td class="memItemLeft" align="right" valign="top"><a id="a3ca48f57aea391d037e676767ea2621c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (const T &amp;value)</td></tr>
<tr class="separator:a3ca48f57aea391d037e676767ea2621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2ea4236b1def98b091b53566a5b32"><td class="memItemLeft" align="right" valign="top"><a id="a21c2ea4236b1def98b091b53566a5b32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (const T &amp;value)</td></tr>
<tr class="separator:a21c2ea4236b1def98b091b53566a5b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6111a1c166b94923046f5ce9b5d05658"><td class="memItemLeft" align="right" valign="top"><a id="a6111a1c166b94923046f5ce9b5d05658"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (size_type pos, const T &amp;value)</td></tr>
<tr class="separator:a6111a1c166b94923046f5ce9b5d05658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memItemLeft" align="right" valign="top"><a id="a7412866d48eeeba1ae9831e2d90e2e9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="separator:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33bd83e3344bb65aed00cb9758165c"><td class="memItemLeft" align="right" valign="top"><a id="acf33bd83e3344bb65aed00cb9758165c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_front</b> ()</td></tr>
<tr class="separator:acf33bd83e3344bb65aed00cb9758165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d84531f6e31b03aa4d4af7346f069df"><td class="memItemLeft" align="right" valign="top"><a id="a7d84531f6e31b03aa4d4af7346f069df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (size_type pos)</td></tr>
<tr class="separator:a7d84531f6e31b03aa4d4af7346f069df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad339529032a6371492d155e5dc6288c9"><td class="memItemLeft" align="right" valign="top"><a id="ad339529032a6371492d155e5dc6288c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_bucket_size</b> (int bsize)</td></tr>
<tr class="separator:ad339529032a6371492d155e5dc6288c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4794faa024985b84d0f50bf3457b14bd"><td class="memItemLeft" align="right" valign="top"><a id="a4794faa024985b84d0f50bf3457b14bd"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>cat</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a4794faa024985b84d0f50bf3457b14bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ff211593d9c16c401c8e4de79586e5"><td class="memItemLeft" align="right" valign="top"><a id="a33ff211593d9c16c401c8e4de79586e5"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a33ff211593d9c16c401c8e4de79586e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea59542bba56f67c662f9ed4f0d80e7a"><td class="memItemLeft" align="right" valign="top"><a id="aea59542bba56f67c662f9ed4f0d80e7a"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type pos) noexcept</td></tr>
<tr class="separator:aea59542bba56f67c662f9ed4f0d80e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac212188082da190386b63541e8c6d469"><td class="memItemLeft" align="right" valign="top"><a id="ac212188082da190386b63541e8c6d469"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:ac212188082da190386b63541e8c6d469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af464c96015bbd4fdd82b0f5d43046a02"><td class="memItemLeft" align="right" valign="top"><a id="af464c96015bbd4fdd82b0f5d43046a02"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:af464c96015bbd4fdd82b0f5d43046a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637ce4ab03c362c2d1913b2d7fd0ada9"><td class="memItemLeft" align="right" valign="top"><a id="a637ce4ab03c362c2d1913b2d7fd0ada9"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a637ce4ab03c362c2d1913b2d7fd0ada9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ac7ab28029a485d6b46da6a9b01f1b"><td class="memItemLeft" align="right" valign="top"><a id="a06ac7ab28029a485d6b46da6a9b01f1b"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a06ac7ab28029a485d6b46da6a9b01f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b2521b6dc207516124cf530b429b05"><td class="memItemLeft" align="right" valign="top"><a id="af3b2521b6dc207516124cf530b429b05"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () noexcept</td></tr>
<tr class="separator:af3b2521b6dc207516124cf530b429b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41617280aa72f0f794d763c767b339bb"><td class="memItemLeft" align="right" valign="top"><a id="a41617280aa72f0f794d763c767b339bb"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:a41617280aa72f0f794d763c767b339bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3ae65ccc69bf7ed8971b01aaac3bcb"><td class="memItemLeft" align="right" valign="top"><a id="a5a3ae65ccc69bf7ed8971b01aaac3bcb"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () noexcept</td></tr>
<tr class="separator:a5a3ae65ccc69bf7ed8971b01aaac3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea81d8b2ad8fa7981e6c7536ff5baeab"><td class="memItemLeft" align="right" valign="top"><a id="aea81d8b2ad8fa7981e6c7536ff5baeab"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:aea81d8b2ad8fa7981e6c7536ff5baeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c60d03af01a0dfab9afc4f0252940"><td class="memItemLeft" align="right" valign="top"><a id="afc6c60d03af01a0dfab9afc4f0252940"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:afc6c60d03af01a0dfab9afc4f0252940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda3bc2fa33630abae730c717bcfb1f3"><td class="memItemLeft" align="right" valign="top"><a id="acda3bc2fa33630abae730c717bcfb1f3"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:acda3bc2fa33630abae730c717bcfb1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00e7a3b56e091e7361f510edd714d89"><td class="memItemLeft" align="right" valign="top"><a id="ae00e7a3b56e091e7361f510edd714d89"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const noexcept</td></tr>
<tr class="separator:ae00e7a3b56e091e7361f510edd714d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e6719d9ca9c0fcb4b46b6561ddfc99"><td class="memItemLeft" align="right" valign="top"><a id="a65e6719d9ca9c0fcb4b46b6561ddfc99"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="separator:a65e6719d9ca9c0fcb4b46b6561ddfc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a0436da239b20a92bfea3fd0b86fc2"><td class="memItemLeft" align="right" valign="top"><a id="a38a0436da239b20a92bfea3fd0b86fc2"></a>
<a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_begin</b> () const noexcept</td></tr>
<tr class="separator:a38a0436da239b20a92bfea3fd0b86fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698f7326423bb85ac2a2e48d3cc6f95c"><td class="memItemLeft" align="right" valign="top"><a id="a698f7326423bb85ac2a2e48d3cc6f95c"></a>
<a class="el" href="structdetail_1_1unsafe__iterator.html">u_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_begin</b> () noexcept</td></tr>
<tr class="separator:a698f7326423bb85ac2a2e48d3cc6f95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18950e5721bef24702e423a2cc475931"><td class="memItemLeft" align="right" valign="top"><a id="a18950e5721bef24702e423a2cc475931"></a>
<a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_end</b> () const noexcept</td></tr>
<tr class="separator:a18950e5721bef24702e423a2cc475931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c923762b53b33fd39a42144a85d7d9"><td class="memItemLeft" align="right" valign="top"><a id="a60c923762b53b33fd39a42144a85d7d9"></a>
<a class="el" href="structdetail_1_1unsafe__iterator.html">u_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_end</b> () noexcept</td></tr>
<tr class="separator:a60c923762b53b33fd39a42144a85d7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138b1aeb854a5064df0696472e6f3cfb"><td class="memItemLeft" align="right" valign="top"><a id="a138b1aeb854a5064df0696472e6f3cfb"></a>
u_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_rbegin</b> () noexcept</td></tr>
<tr class="separator:a138b1aeb854a5064df0696472e6f3cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1287e647ec6e207dff5245dc05784c"><td class="memItemLeft" align="right" valign="top"><a id="abb1287e647ec6e207dff5245dc05784c"></a>
u_const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_rbegin</b> () const noexcept</td></tr>
<tr class="separator:abb1287e647ec6e207dff5245dc05784c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6717c137185c145a216d997649e10a"><td class="memItemLeft" align="right" valign="top"><a id="a5e6717c137185c145a216d997649e10a"></a>
u_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_rend</b> () noexcept</td></tr>
<tr class="separator:a5e6717c137185c145a216d997649e10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65537cf5a4b6e465f213b6639775409"><td class="memItemLeft" align="right" valign="top"><a id="ac65537cf5a4b6e465f213b6639775409"></a>
u_const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_rend</b> () const noexcept</td></tr>
<tr class="separator:ac65537cf5a4b6e465f213b6639775409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82d31e9eb592eeeb6e1995f7610a11d"><td class="memItemLeft" align="right" valign="top"><a id="ab82d31e9eb592eeeb6e1995f7610a11d"></a>
<a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_cbegin</b> () const noexcept</td></tr>
<tr class="separator:ab82d31e9eb592eeeb6e1995f7610a11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821a84892abf7ddd46b35db5e7a05fa3"><td class="memItemLeft" align="right" valign="top"><a id="a821a84892abf7ddd46b35db5e7a05fa3"></a>
<a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_cend</b> () const noexcept</td></tr>
<tr class="separator:a821a84892abf7ddd46b35db5e7a05fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c01f9123f967eb34779ae4092b3f0ee"><td class="memItemLeft" align="right" valign="top"><a id="a3c01f9123f967eb34779ae4092b3f0ee"></a>
u_const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_crbegin</b> () const noexcept</td></tr>
<tr class="separator:a3c01f9123f967eb34779ae4092b3f0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f44847c70660a020770a52bbe36f22f"><td class="memItemLeft" align="right" valign="top"><a id="a0f44847c70660a020770a52bbe36f22f"></a>
u_const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_crend</b> () const noexcept</td></tr>
<tr class="separator:a0f44847c70660a020770a52bbe36f22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad739ede6074365c5ec746c94f7bfd902"><td class="memTemplParams" colspan="2"><a id="ad739ede6074365c5ec746c94f7bfd902"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad739ede6074365c5ec746c94f7bfd902"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_manager</b> (const Allocator &amp;al, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad739ede6074365c5ec746c94f7bfd902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fe7529e06d4347f4f3d9b4af0fce60"><td class="memItemLeft" align="right" valign="top"><a id="a61fe7529e06d4347f4f3d9b4af0fce60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy_manager</b> (<a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *manager)</td></tr>
<tr class="separator:a61fe7529e06d4347f4f3d9b4af0fce60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33237f11572fe69ce5289182a5c97bd"><td class="memItemLeft" align="right" valign="top"><a id="aa33237f11572fe69ce5289182a5c97bd"></a>
<a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> ()</td></tr>
<tr class="separator:aa33237f11572fe69ce5289182a5c97bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9556251fa4d00681e0c00764b76bf5d"><td class="memItemLeft" align="right" valign="top"><a id="ab9556251fa4d00681e0c00764b76bf5d"></a>
const <a class="el" href="structdetail_1_1_bucket_manager.html">bucket_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> () const</td></tr>
<tr class="separator:ab9556251fa4d00681e0c00764b76bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f56493aea4b142564d2fce2b9e9cb8f"><td class="memItemLeft" align="right" valign="top"><a id="a9f56493aea4b142564d2fce2b9e9cb8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const Allocator &amp;al=Allocator())</td></tr>
<tr class="separator:a9f56493aea4b142564d2fce2b9e9cb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575b9355e93af26795de39c95a6c1a03"><td class="memItemLeft" align="right" valign="top"><a id="a575b9355e93af26795de39c95a6c1a03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const <a class="el" href="classdeque2.html">deque2</a> &amp;other)</td></tr>
<tr class="separator:a575b9355e93af26795de39c95a6c1a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf479e8f20f7e6f1a7261c324eb0407f"><td class="memItemLeft" align="right" valign="top"><a id="acf479e8f20f7e6f1a7261c324eb0407f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (<a class="el" href="classdeque2.html">deque2</a> &amp;&amp;other)</td></tr>
<tr class="separator:acf479e8f20f7e6f1a7261c324eb0407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3166344991198d1094e25d6569838559"><td class="memItemLeft" align="right" valign="top"><a id="a3166344991198d1094e25d6569838559"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>deque2</b> (const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="separator:a3166344991198d1094e25d6569838559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7410e636e215d1c9a26e5143c1bbe1a5"><td class="memItemLeft" align="right" valign="top"><a id="a7410e636e215d1c9a26e5143c1bbe1a5"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a7410e636e215d1c9a26e5143c1bbe1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5de9eaeea47d64c58ffb462c80baff"><td class="memItemLeft" align="right" valign="top"><a id="a5b5de9eaeea47d64c58ffb462c80baff"></a>
const Allocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a5b5de9eaeea47d64c58ffb462c80baff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70817b27f1ca49ba921bb500e323aa1"><td class="memItemLeft" align="right" valign="top"><a id="ad70817b27f1ca49ba921bb500e323aa1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_type size)</td></tr>
<tr class="separator:ad70817b27f1ca49ba921bb500e323aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1721abf59df0890421905681f06a1913"><td class="memItemLeft" align="right" valign="top"><a id="a1721abf59df0890421905681f06a1913"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a1721abf59df0890421905681f06a1913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1844a3867e423d3dfdc5f46a4b63d5f"><td class="memItemLeft" align="right" valign="top"><a id="ad1844a3867e423d3dfdc5f46a4b63d5f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_bucket_size</b> ()</td></tr>
<tr class="separator:ad1844a3867e423d3dfdc5f46a4b63d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca48f57aea391d037e676767ea2621c"><td class="memItemLeft" align="right" valign="top"><a id="a3ca48f57aea391d037e676767ea2621c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (const T &amp;value)</td></tr>
<tr class="separator:a3ca48f57aea391d037e676767ea2621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2ea4236b1def98b091b53566a5b32"><td class="memItemLeft" align="right" valign="top"><a id="a21c2ea4236b1def98b091b53566a5b32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (const T &amp;value)</td></tr>
<tr class="separator:a21c2ea4236b1def98b091b53566a5b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6111a1c166b94923046f5ce9b5d05658"><td class="memItemLeft" align="right" valign="top"><a id="a6111a1c166b94923046f5ce9b5d05658"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (size_type pos, const T &amp;value)</td></tr>
<tr class="separator:a6111a1c166b94923046f5ce9b5d05658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memItemLeft" align="right" valign="top"><a id="a7412866d48eeeba1ae9831e2d90e2e9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="separator:a7412866d48eeeba1ae9831e2d90e2e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33bd83e3344bb65aed00cb9758165c"><td class="memItemLeft" align="right" valign="top"><a id="acf33bd83e3344bb65aed00cb9758165c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_front</b> ()</td></tr>
<tr class="separator:acf33bd83e3344bb65aed00cb9758165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d84531f6e31b03aa4d4af7346f069df"><td class="memItemLeft" align="right" valign="top"><a id="a7d84531f6e31b03aa4d4af7346f069df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (size_type pos)</td></tr>
<tr class="separator:a7d84531f6e31b03aa4d4af7346f069df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad339529032a6371492d155e5dc6288c9"><td class="memItemLeft" align="right" valign="top"><a id="ad339529032a6371492d155e5dc6288c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_bucket_size</b> (int bsize)</td></tr>
<tr class="separator:ad339529032a6371492d155e5dc6288c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4794faa024985b84d0f50bf3457b14bd"><td class="memItemLeft" align="right" valign="top"><a id="a4794faa024985b84d0f50bf3457b14bd"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>cat</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a4794faa024985b84d0f50bf3457b14bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ff211593d9c16c401c8e4de79586e5"><td class="memItemLeft" align="right" valign="top"><a id="a33ff211593d9c16c401c8e4de79586e5"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type pos) const noexcept</td></tr>
<tr class="separator:a33ff211593d9c16c401c8e4de79586e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea59542bba56f67c662f9ed4f0d80e7a"><td class="memItemLeft" align="right" valign="top"><a id="aea59542bba56f67c662f9ed4f0d80e7a"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type pos) noexcept</td></tr>
<tr class="separator:aea59542bba56f67c662f9ed4f0d80e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac212188082da190386b63541e8c6d469"><td class="memItemLeft" align="right" valign="top"><a id="ac212188082da190386b63541e8c6d469"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:ac212188082da190386b63541e8c6d469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af464c96015bbd4fdd82b0f5d43046a02"><td class="memItemLeft" align="right" valign="top"><a id="af464c96015bbd4fdd82b0f5d43046a02"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:af464c96015bbd4fdd82b0f5d43046a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637ce4ab03c362c2d1913b2d7fd0ada9"><td class="memItemLeft" align="right" valign="top"><a id="a637ce4ab03c362c2d1913b2d7fd0ada9"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a637ce4ab03c362c2d1913b2d7fd0ada9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ac7ab28029a485d6b46da6a9b01f1b"><td class="memItemLeft" align="right" valign="top"><a id="a06ac7ab28029a485d6b46da6a9b01f1b"></a>
<a class="el" href="structdetail_1_1deque__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a06ac7ab28029a485d6b46da6a9b01f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b2521b6dc207516124cf530b429b05"><td class="memItemLeft" align="right" valign="top"><a id="af3b2521b6dc207516124cf530b429b05"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () noexcept</td></tr>
<tr class="separator:af3b2521b6dc207516124cf530b429b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41617280aa72f0f794d763c767b339bb"><td class="memItemLeft" align="right" valign="top"><a id="a41617280aa72f0f794d763c767b339bb"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:a41617280aa72f0f794d763c767b339bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3ae65ccc69bf7ed8971b01aaac3bcb"><td class="memItemLeft" align="right" valign="top"><a id="a5a3ae65ccc69bf7ed8971b01aaac3bcb"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () noexcept</td></tr>
<tr class="separator:a5a3ae65ccc69bf7ed8971b01aaac3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea81d8b2ad8fa7981e6c7536ff5baeab"><td class="memItemLeft" align="right" valign="top"><a id="aea81d8b2ad8fa7981e6c7536ff5baeab"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:aea81d8b2ad8fa7981e6c7536ff5baeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c60d03af01a0dfab9afc4f0252940"><td class="memItemLeft" align="right" valign="top"><a id="afc6c60d03af01a0dfab9afc4f0252940"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:afc6c60d03af01a0dfab9afc4f0252940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda3bc2fa33630abae730c717bcfb1f3"><td class="memItemLeft" align="right" valign="top"><a id="acda3bc2fa33630abae730c717bcfb1f3"></a>
<a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:acda3bc2fa33630abae730c717bcfb1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00e7a3b56e091e7361f510edd714d89"><td class="memItemLeft" align="right" valign="top"><a id="ae00e7a3b56e091e7361f510edd714d89"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const noexcept</td></tr>
<tr class="separator:ae00e7a3b56e091e7361f510edd714d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e6719d9ca9c0fcb4b46b6561ddfc99"><td class="memItemLeft" align="right" valign="top"><a id="a65e6719d9ca9c0fcb4b46b6561ddfc99"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="separator:a65e6719d9ca9c0fcb4b46b6561ddfc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a0436da239b20a92bfea3fd0b86fc2"><td class="memItemLeft" align="right" valign="top"><a id="a38a0436da239b20a92bfea3fd0b86fc2"></a>
<a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_begin</b> () const noexcept</td></tr>
<tr class="separator:a38a0436da239b20a92bfea3fd0b86fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698f7326423bb85ac2a2e48d3cc6f95c"><td class="memItemLeft" align="right" valign="top"><a id="a698f7326423bb85ac2a2e48d3cc6f95c"></a>
<a class="el" href="structdetail_1_1unsafe__iterator.html">u_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_begin</b> () noexcept</td></tr>
<tr class="separator:a698f7326423bb85ac2a2e48d3cc6f95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18950e5721bef24702e423a2cc475931"><td class="memItemLeft" align="right" valign="top"><a id="a18950e5721bef24702e423a2cc475931"></a>
<a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_end</b> () const noexcept</td></tr>
<tr class="separator:a18950e5721bef24702e423a2cc475931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c923762b53b33fd39a42144a85d7d9"><td class="memItemLeft" align="right" valign="top"><a id="a60c923762b53b33fd39a42144a85d7d9"></a>
<a class="el" href="structdetail_1_1unsafe__iterator.html">u_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_end</b> () noexcept</td></tr>
<tr class="separator:a60c923762b53b33fd39a42144a85d7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138b1aeb854a5064df0696472e6f3cfb"><td class="memItemLeft" align="right" valign="top"><a id="a138b1aeb854a5064df0696472e6f3cfb"></a>
u_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_rbegin</b> () noexcept</td></tr>
<tr class="separator:a138b1aeb854a5064df0696472e6f3cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1287e647ec6e207dff5245dc05784c"><td class="memItemLeft" align="right" valign="top"><a id="abb1287e647ec6e207dff5245dc05784c"></a>
u_const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_rbegin</b> () const noexcept</td></tr>
<tr class="separator:abb1287e647ec6e207dff5245dc05784c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6717c137185c145a216d997649e10a"><td class="memItemLeft" align="right" valign="top"><a id="a5e6717c137185c145a216d997649e10a"></a>
u_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_rend</b> () noexcept</td></tr>
<tr class="separator:a5e6717c137185c145a216d997649e10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65537cf5a4b6e465f213b6639775409"><td class="memItemLeft" align="right" valign="top"><a id="ac65537cf5a4b6e465f213b6639775409"></a>
u_const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_rend</b> () const noexcept</td></tr>
<tr class="separator:ac65537cf5a4b6e465f213b6639775409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82d31e9eb592eeeb6e1995f7610a11d"><td class="memItemLeft" align="right" valign="top"><a id="ab82d31e9eb592eeeb6e1995f7610a11d"></a>
<a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_cbegin</b> () const noexcept</td></tr>
<tr class="separator:ab82d31e9eb592eeeb6e1995f7610a11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821a84892abf7ddd46b35db5e7a05fa3"><td class="memItemLeft" align="right" valign="top"><a id="a821a84892abf7ddd46b35db5e7a05fa3"></a>
<a class="el" href="structdetail_1_1unsafe__const__iterator.html">u_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u_cend</b> () const noexcept</td></tr>
<tr class="separator:a821a84892abf7ddd46b35db5e7a05fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c01f9123f967eb34779ae4092b3f0ee"><td class="memItemLeft" align="right" valign="top"><a id="a3c01f9123f967eb34779ae4092b3f0ee"></a>
u_const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_crbegin</b> () const noexcept</td></tr>
<tr class="separator:a3c01f9123f967eb34779ae4092b3f0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f44847c70660a020770a52bbe36f22f"><td class="memItemLeft" align="right" valign="top"><a id="a0f44847c70660a020770a52bbe36f22f"></a>
u_const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>u_crend</b> () const noexcept</td></tr>
<tr class="separator:a0f44847c70660a020770a52bbe36f22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Allocator = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt;<br />
class deque2&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;</h3>

<p>seq::deque is a std::deque like container implemented as a tiered-vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator type </td></tr>
    <tr><td class="paramname">FindBSize</td><td>struct used to find the bucket size for a given deque size </td></tr>
    <tr><td class="paramname">ValueCompare</td><td>internal use only</td></tr>
  </table>
  </dd>
</dl>
<p>seq::deque is a random-access, bucket based container providing a similar interface to std::deque. Its internals are however very different as it is implemented as a <a href="http://cs.brown.edu/cgc/jdsl/papers/tiered-vector.pdf">tiered vector</a>. Instead of maintaining a vector of fixed size buckets, seq::deque uses a bucket size close to sqrt(size()). The bucket size is always a power of 2 for fast division and modulo. Furtheremore, the bucket is not a linear buffer but is instead implemented as a circular buffer. This allows a complexity of O(sqrt(N)) for insertion and deletion in the middle of the deque instead of O(N) for std::deque. Inserting and deleting elements at both ends is still O(1).</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Interface</h2>
<p>seq::deque interface is the same as std::deque. The only difference is the additional #for_each() members providing a faster way to walk through the deque than iterators.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Bucket managment</h2>
<p>The seq::deque maintains internally an array of circular buffers (or buckets). At any moment, all buckets have the same size which is a power of 2. At container initialization, the bucket size is given by template parameter <em>MinBSize</em> which is, by default, between 64 and 8 depending on value_type size. Whenever seq::deque grows (through #push_back(), #push_front(), #insert(), #resize() ...), the new bucket size is computed using the template parameter <em>FindBSize</em>. <em>FindBSize</em> must provide the member </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span>  FindBSize::operator() (<span class="keywordtype">size_t</span> size, <span class="keywordtype">unsigned</span> MinBSize, <span class="keywordtype">unsigned</span> MaxBSize) <span class="keyword">const</span> noexcept ;</div>
</div><!-- fragment --><p> returning the new bucket size based on the container size, the minimum and maximum bucket size. Default implementation returns a value close to sqrt(size()) rounded up to the next power of 2.</p>
<p>If the new bucket size is different than the current one, new buckets are created and elements from the old buckets are moved to the new ones. This has the practical consequence to &lt; b&gt; invalidate all iterators and references on growing or shrinking &lt; /b&gt;, as opposed to std::deque which maintains references when insert/deleting at both ends.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Inserting and deleting elements</h2>
<p>Inserting or deleting elements at the back or the front behaves the same way as for std::deque, except if the bucket size is updated (as explained above).</p>
<p>Inerting an element in the middle of seq::deque follows these steps: </p><pre class="fragment">- The bucket index and the element position within the bucket are first computed
- The back element of the bucket is extracted and removed from the bucket
- The new element is inserted at the right position. Since the bucket is implemented as a dense
circular buffer, at most half of the bucket elements must be moved (toward the left or the right,
whichever is the shortest path)
- The back value that was previously removed is inserted at the front of the next bucket
- The next bucket back value is extracted and inserted at the front of the following bucket
- ....
- And so forth until we reach the last bucket. 
</pre><p>This operation of <em>insert front/pop back</em> is very fast on a circular buffer as it involves only two element moves and shifting the begin index of the buffer. If the bucket size is exactly sqrt(size()), inserting an element in the middle performs in O(sqrt(N)) as it involves as many element moves within a single bucket than between buckets.</p>
<p>In practice the buckets size should be greater than sqrt(size()) as moving elements within a bucket is much faster than between buckets due to cache locality.</p>
<p>Note that, depending on the insertion location, elements can be shifted toward the front bucket instead of the back one if this is the shortest path. This practically divides by 2 (on average) the number of moved elements.</p>
<p>Erasing an element in the middle follows the exact same logic.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Exception guarantee</h2>
<p>All insertion/deletion operations on a seq::deque are much more complex than for a std::deque. Especially, each operation might change the bucket size, and therefore trigger the allocation of new buckets plus moving all elements within the new buckets.</p>
<p>Although possible, providing strong exception guarantee on seq::deque operations would have added a very complex layer hurting its performances. Therefore, all seq::deque operations only provide <b>basic exception guarantee</b>.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Iterators and references invalidation</h2>
<p>As explained above, all seq::deque operations invalidate iterators and references, except for swapping two seq::deque.</p>
<p>The only exception is when providing a minimum bucket size (<em>MinBSize</em>) equals to the maximum bucket size (<em>MaxBSize</em>). In this case, inserting/deleting elements will <em>never</em> change the bucket size and move all elements within new buckets. This affects the members #emplace_back(), #push_back(), #emplace_front() and #push_front() that provide the same invalidation rules as for std::deque.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Memory layout</h2>
<p>If the <em>layout</em> template parameter is <em>OptimizeForMemory</em>, each bucket is independantly allocated using the provided allocator, and the buckets are automatically deallocated when empty.</p>
<p>When using the <em>OptimizeForSpeed</em> flag, the seq::deque will use a memory pool to allocate several buckets at once, still using the provided allocator. The memory pool uses a growing strategy to allocate more and more buckets based on a growth factor (SEQ_GROW_FACTOR define, defaulting to 1.6). Whenever the bucket size change, memory chunks used to store the previous buckets are kept as long as they are big enough to hold buckets of the new size. This avoid a lot of unnecessary allocations when continuously extending the seq::deque. The memory pool makes insertion tipically 50% faster (depending on value_type size) than the default allocation strategy, but will consume slightly more memory.</p>
<p>With <em>OptimizeForSpeed</em> flag, the deque will almost never release memory, except on calls to #shrink_to_fit().</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Performances</h2>
<p>seq::deque was optimized to match libc++ std::deque performances as close as possible. My benchmarhs shows that all members are actually faster than libc++ std::deque, except for #push_back(), #push_front(), #pop_back() and #pop_front() which are slightly slower due to the need to move all elements when the bucket size changes. This can be alievated by the <em>OptimizeForSpeed</em> flag that makes both ooperations faster than their std::deque counterparts.</p>
<p>Usually, iterating through a seq::deque is faster than through a std::deque. The random-access #operator[](size_t) is also faster. Making a lot of random access based on iterators can be slightly slower with seq::deque depending on the use case. For instance, sorting a seq::deque is slower than sorting a std::deque.</p>
<p>Inserting/deleting single elements on a seq::deque is several order of magnitudes faster than std::deque due to the tiered-vector implementation.</p>
<p>The standard conlusion is: you should always benchmark with your own use cases. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adde1d8dd3a0df9d66583c90e4a47cffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde1d8dd3a0df9d66583c90e4a47cffc">&#9670;&nbsp;</a></span>deque2() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classdeque2.html">deque2</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given allocator alloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14a4146ac9e9dc3ecc611d38d39612ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a4146ac9e9dc3ecc611d38d39612ba">&#9670;&nbsp;</a></span>deque2() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classdeque2.html">deque2</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with <em>count</em> copies of elements with value <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new deque size </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4816d7bcd290309366a7649b0008a1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4816d7bcd290309366a7649b0008a1e1">&#9670;&nbsp;</a></span>deque2() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classdeque2.html">deque2</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count default-inserted instances of T. No copies are made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new deque size </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a575b9355e93af26795de39c95a6c1a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575b9355e93af26795de39c95a6c1a03">&#9670;&nbsp;</a></span>deque2() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classdeque2.html">deque2</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. Constructs the container with the copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04d836281d75a3570875c1640e934a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d836281d75a3570875c1640e934a8c">&#9670;&nbsp;</a></span>deque2() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classdeque2.html">deque2</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the copy of the contents of other, using alloc as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allcoator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a514bcd4479f84e16dbab77f39486d4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514bcd4479f84e16dbab77f39486d4c9">&#9670;&nbsp;</a></span>deque2() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classdeque2.html">deque2</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad64584fe43e94684e880dee234e72cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64584fe43e94684e880dee234e72cda">&#9670;&nbsp;</a></span>deque2() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classdeque2.html">deque2</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8523a9a78856485c4a7d3e8c2cb40145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8523a9a78856485c4a7d3e8c2cb40145">&#9670;&nbsp;</a></span>deque2() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classdeque2.html">deque2</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list <em>init</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td>initializer list </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07b7f9aaa26245d0437fc4f6732bc010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b7f9aaa26245d0437fc4f6732bc010">&#9670;&nbsp;</a></span>deque2() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classdeque2.html">deque2</a> </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>last iterator of the range </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a081250f49736dbf48e5b844deacafdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081250f49736dbf48e5b844deacafdb1">&#9670;&nbsp;</a></span>emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before <em>pos</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator within the deque </td></tr>
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="ae9dbd414ccc60320f772c189cc4bb0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dbd414ccc60320f772c189cc4bb0a7">&#9670;&nbsp;</a></span>emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before <em>pos</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position within the deque </td></tr>
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a6efbb7f69a24333f38025294e0cb4a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6efbb7f69a24333f38025294e0cb4a79">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the end of the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </dd></dl>

</div>
</div>
<a id="aab0db81affe0ce2e5f28afcee9952403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0db81affe0ce2e5f28afcee9952403">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the beginning of the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </dd></dl>

</div>
</div>
<a id="a709f986b066ffbd1b2d9a774d78b9add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709f986b066ffbd1b2d9a774d78b9add">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element to erase </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the last (excluded) element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a0dcb557ffcf46f609cd37ebfcfe9c15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcb557ffcf46f609cd37ebfcfe9c15b">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the last removed element Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a0bc74c95ca7d62c10f6078020ada986f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc74c95ca7d62c10f6078020ada986f">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>absolute position of the first element to erase </td></tr>
    <tr><td class="paramname">last</td><td>absolute position of the last (excluded) element to erase Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d84531f6e31b03aa4d4af7346f069df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d84531f6e31b03aa4d4af7346f069df">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position of the element to erase Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08f33a0bc38953f17e476ae498df9040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f33a0bc38953f17e476ae498df9040">&#9670;&nbsp;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Fun &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Fun <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply unary function <em>fun</em> to all elements within the range [first,last). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fun</td><td>unary functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first element of the range to apply the functor <em>fun</em> </td></tr>
    <tr><td class="paramname">last</td><td>end of range </td></tr>
    <tr><td class="paramname">fun</td><td>unary functor of lambda function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unary functor (usefull for statefull functors). Using for_each is faster than walking through iterators as it uses the internal knowledge on bucket layout to fasten step increments. </dd></dl>

</div>
</div>
<a id="a3acff7357ef7605976812891c648dd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acff7357ef7605976812891c648dd10">&#9670;&nbsp;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Fun &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Fun <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply unary function <em>fun</em> to all elements within the range [first,last). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fun</td><td>unary functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first element of the range to apply the functor <em>fun</em> </td></tr>
    <tr><td class="paramname">last</td><td>end of range </td></tr>
    <tr><td class="paramname">fun</td><td>unary functor of lambda function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unary functor (usefull for statefull functors). Using for_each is faster than walking through iterators as it uses the internal knowledge on bucket layout to fasten step increments. </dd></dl>

</div>
</div>
<a id="a05b2833d3c9688cbda07fffff6c988b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b2833d3c9688cbda07fffff6c988b3">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>it</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator within the deque </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac32e48983e2596f4393a9def65ecf884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32e48983e2596f4393a9def65ecf884">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator within the deque </td></tr>
    <tr><td class="paramname">first</td><td>first iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>last iterator of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if first==last Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a55c295f4c8ae4c879c4b030fa92cddf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c295f4c8ae4c879c4b030fa92cddf6">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>it</em> using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator within the deque </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a839c9e8bff3303eaa6cc3470ce2df314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839c9e8bff3303eaa6cc3470ce2df314">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count copies of the value before pos. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if count==0 Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="ac1b56478cca246bfa99b3ef87e7e3e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b56478cca246bfa99b3ef87e7e3e69">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdetail_1_1deque__iterator.html">iterator</a> <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdetail_1_1deque__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist before pos. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if first==last. Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a6111a1c166b94923046f5ce9b5d05658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6111a1c166b94923046f5ce9b5d05658">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position within the deque </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a541c06978e7e6f577d2a2f8d1f08c598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541c06978e7e6f577d2a2f8d1f08c598">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position within the deque </td></tr>
    <tr><td class="paramname">first</td><td>first iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>last iterator of the range Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64249801c41d575c76c7e8920e007e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64249801c41d575c76c7e8920e007e90">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist before pos. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if first==last. Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a6c68a938bc2a298449c5aa36dfbecc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c68a938bc2a298449c5aa36dfbecc8a">&#9670;&nbsp;</a></span>insert() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>pos</em> using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position within the deque </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa27581d2e342d67b35c17076aa052d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27581d2e342d67b35c17076aa052d24">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&amp; <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="a3004e6e90143b036175d56d8bbfaa7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3004e6e90143b036175d56d8bbfaa7a1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeque2.html">deque2</a>&amp; <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="a3ca48f57aea391d037e676767ea2621c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca48f57aea391d037e676767ea2621c">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d7d2474b171536fcc899509293b94da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7d2474b171536fcc899509293b94da">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21c2ea4236b1def98b091b53566a5b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c2ea4236b1def98b091b53566a5b32">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the beginning of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cfb4c5a61549f5df100a82f9f02dc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfb4c5a61549f5df100a82f9f02dc00">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the beginning of the container using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a4f93360f8231415156b6861a09c739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4f93360f8231415156b6861a09c739">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-inserted elements are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7ed0942ed60505b86261e28daa3d769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ed0942ed60505b86261e28daa3d769">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of value are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5924e01065e92c41121c4b6490f0bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5924e01065e92c41121c4b6490f0bf8">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional default-inserted elements are prepended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e7d0148dd8ef08ad552afb3eadd30f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7d0148dd8ef08ad552afb3eadd30f6">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional copies of value are prepended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a413d4c2b4b2ab4b9ea496a15cb7086bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413d4c2b4b2ab4b9ea496a15cb7086bd">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, int MinBSize = SEQ_MIN_BUCKET_SIZE(T), int MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize  = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare  = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdeque2.html">deque2</a>&lt; T, Allocator, layout, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other sequence to swap with All iterators and references remain valid. An iterator holding the past-the-end value in this container will refer to the other container after the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="deque2_01-_01_copie_8hpp_source.html">deque2 - Copie.hpp</a></li>
<li><a class="el" href="deque2_8hpp_source.html">deque2.hpp</a></li>
<li><a class="el" href="deque2__union_8hpp_source.html">deque2_union.hpp</a></li>
<li><a class="el" href="deque__save_8hpp_source.html">deque_save.hpp</a></li>
<li>deque_save.txt</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classdeque2.html">deque2</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
