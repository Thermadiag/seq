<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::cvector&lt; T, Allocator, Acceleration, Encoder, block_size &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classseq_1_1cvector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classseq_1_1cvector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::cvector&lt; T, Allocator, Acceleration, Encoder, block_size &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>vector like class using compression to store its elements  
 <a href="classseq_1_1cvector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cvector_8hpp_source.html">cvector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a28e754f5f0e3cd4956c5ba39296dc927"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a28e754f5f0e3cd4956c5ba39296dc927">value_type</a> = T</td></tr>
<tr class="separator:a28e754f5f0e3cd4956c5ba39296dc927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06e4a8db2c4dbf96f996f85de08dce1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ae06e4a8db2c4dbf96f996f85de08dce1">reference</a> = T &amp;</td></tr>
<tr class="separator:ae06e4a8db2c4dbf96f996f85de08dce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398e47a0841982d7ef01b9e223b6571e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a398e47a0841982d7ef01b9e223b6571e">const_reference</a> = const T &amp;</td></tr>
<tr class="separator:a398e47a0841982d7ef01b9e223b6571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d6fe2ccde64de9f0fef3762898cf2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a11d6fe2ccde64de9f0fef3762898cf2c">pointer</a> = T *</td></tr>
<tr class="separator:a11d6fe2ccde64de9f0fef3762898cf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d05d4248e9240baaee71172b8a7d15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a15d05d4248e9240baaee71172b8a7d15">const_pointer</a> = const T *</td></tr>
<tr class="separator:a15d05d4248e9240baaee71172b8a7d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ccc184a493a23a6ad2d979fa5f0ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> = size_t</td></tr>
<tr class="separator:a082ccc184a493a23a6ad2d979fa5f0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8036c0e8b83580bf038dc5179db0ed5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a8036c0e8b83580bf038dc5179db0ed5b">difference_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1cvector.html#a8036c0e8b83580bf038dc5179db0ed5b">difference_type</a></td></tr>
<tr class="separator:a8036c0e8b83580bf038dc5179db0ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d48cb5fcf12b2d3599ec92c9771553"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a67d48cb5fcf12b2d3599ec92c9771553">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a67d48cb5fcf12b2d3599ec92c9771553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a45490e97733914947fb3c2e1db104"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a> = typename <a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#ab3c03229c7c5f73450385748fd6ce229">internal_type::iterator</a></td></tr>
<tr class="separator:a66a45490e97733914947fb3c2e1db104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a5bb758205dae72a8a630e7a742867"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> = typename <a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#ae63985a9db80723d6962091ffe48a05c">internal_type::const_iterator</a></td></tr>
<tr class="separator:a49a5bb758205dae72a8a630e7a742867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281b4dd5fe93aa08049aecd3254bcb5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a281b4dd5fe93aa08049aecd3254bcb5d">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a> &gt;</td></tr>
<tr class="separator:a281b4dd5fe93aa08049aecd3254bcb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff760f0430a5336522eeec659ca8879"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> &gt;</td></tr>
<tr class="separator:abff760f0430a5336522eeec659ca8879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac363cb2a798b618c052b764da73e5b8e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a> = typename <a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#ad8a97d7104a116b1425f92e2f6096862">internal_type::ref_type</a></td></tr>
<tr class="separator:ac363cb2a798b618c052b764da73e5b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af598808a78cef4f2f02b81cf3e3e04f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a> = typename <a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#a7310fc5dbab646943984e0b4672809b8">internal_type::const_ref_type</a></td></tr>
<tr class="separator:af598808a78cef4f2f02b81cf3e3e04f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec22d79fd748ff012376d7331ae28542"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#aec22d79fd748ff012376d7331ae28542">encoder_type</a> = Encoder</td></tr>
<tr class="separator:aec22d79fd748ff012376d7331ae28542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a410798f3504d348e9d253ae9329a3ecd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a410798f3504d348e9d253ae9329a3ecd">cvector</a> ()</td></tr>
<tr class="memdesc:a410798f3504d348e9d253ae9329a3ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, initialize the internal bucket manager.  <a href="classseq_1_1cvector.html#a410798f3504d348e9d253ae9329a3ecd">More...</a><br /></td></tr>
<tr class="separator:a410798f3504d348e9d253ae9329a3ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb64a63e82cd3fa0a370bc82a1810449"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#afb64a63e82cd3fa0a370bc82a1810449">cvector</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:afb64a63e82cd3fa0a370bc82a1810449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given allocator alloc.  <a href="classseq_1_1cvector.html#afb64a63e82cd3fa0a370bc82a1810449">More...</a><br /></td></tr>
<tr class="separator:afb64a63e82cd3fa0a370bc82a1810449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddc4320508bfd1916dee1598a6c3ca3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a5ddc4320508bfd1916dee1598a6c3ca3">cvector</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> count, const T &amp;value, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a5ddc4320508bfd1916dee1598a6c3ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with <em>count</em> copies of elements with value <em>value</em>.  <a href="classseq_1_1cvector.html#a5ddc4320508bfd1916dee1598a6c3ca3">More...</a><br /></td></tr>
<tr class="separator:a5ddc4320508bfd1916dee1598a6c3ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecefcda6c35915cc0d8f3bbd75f6b6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a1ecefcda6c35915cc0d8f3bbd75f6b6e">cvector</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> count, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a1ecefcda6c35915cc0d8f3bbd75f6b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count default-inserted instances of T. No copies are made.  <a href="classseq_1_1cvector.html#a1ecefcda6c35915cc0d8f3bbd75f6b6e">More...</a><br /></td></tr>
<tr class="separator:a1ecefcda6c35915cc0d8f3bbd75f6b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8207b536359c99702a582aea9eb9a22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ae8207b536359c99702a582aea9eb9a22">cvector</a> (const <a class="el" href="classseq_1_1cvector.html">cvector</a> &amp;other)</td></tr>
<tr class="memdesc:ae8207b536359c99702a582aea9eb9a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other.  <a href="classseq_1_1cvector.html#ae8207b536359c99702a582aea9eb9a22">More...</a><br /></td></tr>
<tr class="separator:ae8207b536359c99702a582aea9eb9a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5afbc71f3489cf558acb58acd78749"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ade5afbc71f3489cf558acb58acd78749">cvector</a> (const <a class="el" href="classseq_1_1cvector.html">cvector</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:ade5afbc71f3489cf558acb58acd78749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the copy of the contents of other, using alloc as the allocator.  <a href="classseq_1_1cvector.html#ade5afbc71f3489cf558acb58acd78749">More...</a><br /></td></tr>
<tr class="separator:ade5afbc71f3489cf558acb58acd78749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d51c2e3d3f9704f767ca622676877b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a97d51c2e3d3f9704f767ca622676877b">cvector</a> (<a class="el" href="classseq_1_1cvector.html">cvector</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a97d51c2e3d3f9704f767ca622676877b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other.  <a href="classseq_1_1cvector.html#a97d51c2e3d3f9704f767ca622676877b">More...</a><br /></td></tr>
<tr class="separator:a97d51c2e3d3f9704f767ca622676877b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef51bd29ea9c309d9ec01fc5f74e716"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#acef51bd29ea9c309d9ec01fc5f74e716">cvector</a> (<a class="el" href="classseq_1_1cvector.html">cvector</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:acef51bd29ea9c309d9ec01fc5f74e716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move.  <a href="classseq_1_1cvector.html#acef51bd29ea9c309d9ec01fc5f74e716">More...</a><br /></td></tr>
<tr class="separator:acef51bd29ea9c309d9ec01fc5f74e716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950e8268aabd54297180bacc88143eb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a950e8268aabd54297180bacc88143eb6">cvector</a> (const std::initializer_list&lt; T &gt; &amp;lst, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a950e8268aabd54297180bacc88143eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list <em>init</em>.  <a href="classseq_1_1cvector.html#a950e8268aabd54297180bacc88143eb6">More...</a><br /></td></tr>
<tr class="separator:a950e8268aabd54297180bacc88143eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd67a7551c6e75d03c741264cc56262"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a2bd67a7551c6e75d03c741264cc56262"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a2bd67a7551c6e75d03c741264cc56262">cvector</a> (Iter first, Iter last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a2bd67a7551c6e75d03c741264cc56262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="classseq_1_1cvector.html#a2bd67a7551c6e75d03c741264cc56262">More...</a><br /></td></tr>
<tr class="separator:a2bd67a7551c6e75d03c741264cc56262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487c0823d3ef230a6de9bbb486439084"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a487c0823d3ef230a6de9bbb486439084">~cvector</a> ()</td></tr>
<tr class="memdesc:a487c0823d3ef230a6de9bbb486439084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classseq_1_1cvector.html#a487c0823d3ef230a6de9bbb486439084">More...</a><br /></td></tr>
<tr class="separator:a487c0823d3ef230a6de9bbb486439084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec990e71a2ef05b2fcc9ad93d1349a6c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#aec990e71a2ef05b2fcc9ad93d1349a6c">operator=</a> (<a class="el" href="classseq_1_1cvector.html">cvector</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1cvector.html">cvector</a> &amp;</td></tr>
<tr class="memdesc:aec990e71a2ef05b2fcc9ad93d1349a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classseq_1_1cvector.html#aec990e71a2ef05b2fcc9ad93d1349a6c">More...</a><br /></td></tr>
<tr class="separator:aec990e71a2ef05b2fcc9ad93d1349a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59abb0b7ef2d5c37ae474f14bd306aa7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a59abb0b7ef2d5c37ae474f14bd306aa7">operator=</a> (const <a class="el" href="classseq_1_1cvector.html">cvector</a> &amp;other) -&gt; <a class="el" href="classseq_1_1cvector.html">cvector</a> &amp;</td></tr>
<tr class="memdesc:a59abb0b7ef2d5c37ae474f14bd306aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classseq_1_1cvector.html#a59abb0b7ef2d5c37ae474f14bd306aa7">More...</a><br /></td></tr>
<tr class="separator:a59abb0b7ef2d5c37ae474f14bd306aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4f755d6bc29ffc876f8397d6dca24a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#abe4f755d6bc29ffc876f8397d6dca24a">memory_footprint</a> () const noexcept -&gt; size_t</td></tr>
<tr class="memdesc:abe4f755d6bc29ffc876f8397d6dca24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total memory footprint in bytes of this cvector, excluding sizeof(*this)  <a href="classseq_1_1cvector.html#abe4f755d6bc29ffc876f8397d6dca24a">More...</a><br /></td></tr>
<tr class="separator:abe4f755d6bc29ffc876f8397d6dca24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6729b54071b92bbdda5587c3f12f03a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ad6729b54071b92bbdda5587c3f12f03a">compression_ratio</a> () const noexcept -&gt; float</td></tr>
<tr class="memdesc:ad6729b54071b92bbdda5587c3f12f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compression ratio achieved by the block encoder.  <a href="classseq_1_1cvector.html#ad6729b54071b92bbdda5587c3f12f03a">More...</a><br /></td></tr>
<tr class="separator:ad6729b54071b92bbdda5587c3f12f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f62e0efb88dffc0e5ae2d18b5960790"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a8f62e0efb88dffc0e5ae2d18b5960790">current_compression_ratio</a> () const noexcept -&gt; float</td></tr>
<tr class="memdesc:a8f62e0efb88dffc0e5ae2d18b5960790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current compression ratio, which is the total memory footprint of this container divided by its theoric size (<a class="el" href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4" title="Returns the container size.">size()</a>*sizeof(T))  <a href="classseq_1_1cvector.html#a8f62e0efb88dffc0e5ae2d18b5960790">More...</a><br /></td></tr>
<tr class="separator:a8f62e0efb88dffc0e5ae2d18b5960790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d693e3a04d7de42f63fa190e7c006db"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a8d693e3a04d7de42f63fa190e7c006db">max_contexts</a> () const noexcept -&gt; <a class="el" href="classseq_1_1context__ratio.html">context_ratio</a></td></tr>
<tr class="memdesc:a8d693e3a04d7de42f63fa190e7c006db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of decompression contexts.  <a href="classseq_1_1cvector.html#a8d693e3a04d7de42f63fa190e7c006db">More...</a><br /></td></tr>
<tr class="separator:a8d693e3a04d7de42f63fa190e7c006db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcd4a7e9d4bec8f43e41cd1cc6b4ffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a0bcd4a7e9d4bec8f43e41cd1cc6b4ffd">set_max_contexts</a> (<a class="el" href="classseq_1_1context__ratio.html">context_ratio</a> ratio)</td></tr>
<tr class="memdesc:a0bcd4a7e9d4bec8f43e41cd1cc6b4ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of allowed decompression contexts.  <a href="classseq_1_1cvector.html#a0bcd4a7e9d4bec8f43e41cd1cc6b4ffd">More...</a><br /></td></tr>
<tr class="separator:a0bcd4a7e9d4bec8f43e41cd1cc6b4ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e302e50ce54f0a2d8b797443884e7c4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4">size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a></td></tr>
<tr class="memdesc:a3e302e50ce54f0a2d8b797443884e7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size.  <a href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4">More...</a><br /></td></tr>
<tr class="separator:a3e302e50ce54f0a2d8b797443884e7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31fda617cb2e7fb8d9397d5e2e77e4b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#af31fda617cb2e7fb8d9397d5e2e77e4b">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:af31fda617cb2e7fb8d9397d5e2e77e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retruns true if the container is empty, false otherwise.  <a href="classseq_1_1cvector.html#af31fda617cb2e7fb8d9397d5e2e77e4b">More...</a><br /></td></tr>
<tr class="separator:af31fda617cb2e7fb8d9397d5e2e77e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18f3c96ac8d6b7069fe12b134fbbb8b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ac18f3c96ac8d6b7069fe12b134fbbb8b">get_allocator</a> () const noexcept -&gt; const Allocator &amp;</td></tr>
<tr class="memdesc:ac18f3c96ac8d6b7069fe12b134fbbb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="classseq_1_1cvector.html#ac18f3c96ac8d6b7069fe12b134fbbb8b">More...</a><br /></td></tr>
<tr class="separator:ac18f3c96ac8d6b7069fe12b134fbbb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c9a2eb29ea9bd2719f6d8ba9c468a4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a06c9a2eb29ea9bd2719f6d8ba9c468a4">get_allocator</a> () noexcept -&gt; Allocator &amp;</td></tr>
<tr class="memdesc:a06c9a2eb29ea9bd2719f6d8ba9c468a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="classseq_1_1cvector.html#a06c9a2eb29ea9bd2719f6d8ba9c468a4">More...</a><br /></td></tr>
<tr class="separator:a06c9a2eb29ea9bd2719f6d8ba9c468a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82040616ef0f44c3e4f106855564142a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a82040616ef0f44c3e4f106855564142a">swap</a> (<a class="el" href="classseq_1_1cvector.html">cvector</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a82040616ef0f44c3e4f106855564142a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.  <a href="classseq_1_1cvector.html#a82040616ef0f44c3e4f106855564142a">More...</a><br /></td></tr>
<tr class="separator:a82040616ef0f44c3e4f106855564142a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858442ce1a27fefa99c6e7a699e69b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a858442ce1a27fefa99c6e7a699e69b46">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a858442ce1a27fefa99c6e7a699e69b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all unused memory, and compress all dirty blocks. This function does NOT invalidate iterators, except if an exception is thrown. Basic exception guarantee only.  <a href="classseq_1_1cvector.html#a858442ce1a27fefa99c6e7a699e69b46">More...</a><br /></td></tr>
<tr class="separator:a858442ce1a27fefa99c6e7a699e69b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6352fe58e3fbfe11ee379cd816113056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a6352fe58e3fbfe11ee379cd816113056">resize</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> count)</td></tr>
<tr class="memdesc:a6352fe58e3fbfe11ee379cd816113056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classseq_1_1cvector.html#a6352fe58e3fbfe11ee379cd816113056">More...</a><br /></td></tr>
<tr class="separator:a6352fe58e3fbfe11ee379cd816113056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fda7cb61b9ad1702310de4702ae0dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a76fda7cb61b9ad1702310de4702ae0dd">resize</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a76fda7cb61b9ad1702310de4702ae0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classseq_1_1cvector.html#a76fda7cb61b9ad1702310de4702ae0dd">More...</a><br /></td></tr>
<tr class="separator:a76fda7cb61b9ad1702310de4702ae0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c80ccc15be31abcca35af0c43ae5091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a8c80ccc15be31abcca35af0c43ae5091">clear</a> () noexcept</td></tr>
<tr class="memdesc:a8c80ccc15be31abcca35af0c43ae5091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the container.  <a href="classseq_1_1cvector.html#a8c80ccc15be31abcca35af0c43ae5091">More...</a><br /></td></tr>
<tr class="separator:a8c80ccc15be31abcca35af0c43ae5091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b2be12dbc2384b173641fe66618df2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a11b2be12dbc2384b173641fe66618df2">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a11b2be12dbc2384b173641fe66618df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <a href="classseq_1_1cvector.html#a11b2be12dbc2384b173641fe66618df2">More...</a><br /></td></tr>
<tr class="separator:a11b2be12dbc2384b173641fe66618df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf9dd4ea3ef93e9b72d86f98fb5e41c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a5cf9dd4ea3ef93e9b72d86f98fb5e41c">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a5cf9dd4ea3ef93e9b72d86f98fb5e41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container using move semantic.  <a href="classseq_1_1cvector.html#a5cf9dd4ea3ef93e9b72d86f98fb5e41c">More...</a><br /></td></tr>
<tr class="separator:a5cf9dd4ea3ef93e9b72d86f98fb5e41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61746d238bdf93e234e3bc1afa82e70a"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a61746d238bdf93e234e3bc1afa82e70a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a61746d238bdf93e234e3bc1afa82e70a">emplace_back</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a></td></tr>
<tr class="memdesc:a61746d238bdf93e234e3bc1afa82e70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the end of the container.  <a href="classseq_1_1cvector.html#a61746d238bdf93e234e3bc1afa82e70a">More...</a><br /></td></tr>
<tr class="separator:a61746d238bdf93e234e3bc1afa82e70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadd759559326238d1534f056d593031"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#abadd759559326238d1534f056d593031">insert</a> (<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> it, const T &amp;value) -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:abadd759559326238d1534f056d593031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>it</em>.  <a href="classseq_1_1cvector.html#abadd759559326238d1534f056d593031">More...</a><br /></td></tr>
<tr class="separator:abadd759559326238d1534f056d593031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bdf8b080de8e683d5f277b95a3df8f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a29bdf8b080de8e683d5f277b95a3df8f">insert</a> (<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> it, T &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:a29bdf8b080de8e683d5f277b95a3df8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>it</em> using move semantic.  <a href="classseq_1_1cvector.html#a29bdf8b080de8e683d5f277b95a3df8f">More...</a><br /></td></tr>
<tr class="separator:a29bdf8b080de8e683d5f277b95a3df8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4d34336ecc3d7621dbe9040ed7a33a"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a7e4d34336ecc3d7621dbe9040ed7a33a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a7e4d34336ecc3d7621dbe9040ed7a33a">emplace</a> (<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:a7e4d34336ecc3d7621dbe9040ed7a33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before <em>pos</em>.  <a href="classseq_1_1cvector.html#a7e4d34336ecc3d7621dbe9040ed7a33a">More...</a><br /></td></tr>
<tr class="separator:a7e4d34336ecc3d7621dbe9040ed7a33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecad20f2dedf7fe965a003f8b8b1b4cf"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:aecad20f2dedf7fe965a003f8b8b1b4cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#aecad20f2dedf7fe965a003f8b8b1b4cf">insert</a> (<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> it, Iter first, Iter last) -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:aecad20f2dedf7fe965a003f8b8b1b4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before it.  <a href="classseq_1_1cvector.html#aecad20f2dedf7fe965a003f8b8b1b4cf">More...</a><br /></td></tr>
<tr class="separator:aecad20f2dedf7fe965a003f8b8b1b4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd547958d3e667e9977e9dbfcaff94fe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#acd547958d3e667e9977e9dbfcaff94fe">insert</a> (<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, std::initializer_list&lt; T &gt; ilist) -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:acd547958d3e667e9977e9dbfcaff94fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist before pos.  <a href="classseq_1_1cvector.html#acd547958d3e667e9977e9dbfcaff94fe">More...</a><br /></td></tr>
<tr class="separator:acd547958d3e667e9977e9dbfcaff94fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7f9fc8221799221ae8b0d5934eef49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a2e7f9fc8221799221ae8b0d5934eef49">insert</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, <a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a2e7f9fc8221799221ae8b0d5934eef49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before pos Basic exception guarantee. <br  />
  <a href="classseq_1_1cvector.html#a2e7f9fc8221799221ae8b0d5934eef49">More...</a><br /></td></tr>
<tr class="separator:a2e7f9fc8221799221ae8b0d5934eef49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674119b0669e2e805f863752e9376edc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a674119b0669e2e805f863752e9376edc">insert</a> (<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, <a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> count, const T &amp;value) -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:a674119b0669e2e805f863752e9376edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before pos.  <a href="classseq_1_1cvector.html#a674119b0669e2e805f863752e9376edc">More...</a><br /></td></tr>
<tr class="separator:a674119b0669e2e805f863752e9376edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb4b5367e4040ee7a15d68130cf45e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a0cb4b5367e4040ee7a15d68130cf45e2">pop_back</a> ()</td></tr>
<tr class="memdesc:a0cb4b5367e4040ee7a15d68130cf45e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container. Calling pop_back on an empty container results in undefined behavior. Strong exception guarantee.  <a href="classseq_1_1cvector.html#a0cb4b5367e4040ee7a15d68130cf45e2">More...</a><br /></td></tr>
<tr class="separator:a0cb4b5367e4040ee7a15d68130cf45e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8242d030ab8f3f3f71a3f0dc97b36dc9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a8242d030ab8f3f3f71a3f0dc97b36dc9">erase</a> (<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> it) -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:a8242d030ab8f3f3f71a3f0dc97b36dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given position.  <a href="classseq_1_1cvector.html#a8242d030ab8f3f3f71a3f0dc97b36dc9">More...</a><br /></td></tr>
<tr class="separator:a8242d030ab8f3f3f71a3f0dc97b36dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2a691bc0ab5485468e37db7c1a7a68"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a4d2a691bc0ab5485468e37db7c1a7a68">erase</a> (<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> first, <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> last) -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:a4d2a691bc0ab5485468e37db7c1a7a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last).  <a href="classseq_1_1cvector.html#a4d2a691bc0ab5485468e37db7c1a7a68">More...</a><br /></td></tr>
<tr class="separator:a4d2a691bc0ab5485468e37db7c1a7a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6c3f1426139def6ba1f692b8d8f480"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a3e6c3f1426139def6ba1f692b8d8f480">assign</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a3e6c3f1426139def6ba1f692b8d8f480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with <em>count</em> copies of value <em>value</em> Basic exception guarantee.  <a href="classseq_1_1cvector.html#a3e6c3f1426139def6ba1f692b8d8f480">More...</a><br /></td></tr>
<tr class="separator:a3e6c3f1426139def6ba1f692b8d8f480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef513b545b6bd99db29a035f5a50c4fd"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:aef513b545b6bd99db29a035f5a50c4fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#aef513b545b6bd99db29a035f5a50c4fd">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:aef513b545b6bd99db29a035f5a50c4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with copies of those in the range [first, last). The behavior is undefined if either argument is an iterator into *this. Basic exception guarantee.  <a href="classseq_1_1cvector.html#aef513b545b6bd99db29a035f5a50c4fd">More...</a><br /></td></tr>
<tr class="separator:aef513b545b6bd99db29a035f5a50c4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994d825680d2fc39328889e63cd710b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a994d825680d2fc39328889e63cd710b5">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a994d825680d2fc39328889e63cd710b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list ilist. Basic exception guarantee.  <a href="classseq_1_1cvector.html#a994d825680d2fc39328889e63cd710b5">More...</a><br /></td></tr>
<tr class="separator:a994d825680d2fc39328889e63cd710b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f09115258e1046f278a6daca7c6abf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a80f09115258e1046f278a6daca7c6abf">lock_block</a> (size_t block_pos) -&gt; <a class="el" href="classseq_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classseq_1_1spinlock.html">spinlock</a> &gt;</td></tr>
<tr class="separator:a80f09115258e1046f278a6daca7c6abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94708941b29d9913813e72ebaa0b190"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ac94708941b29d9913813e72ebaa0b190">lock</a> (size_t <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) -&gt; <a class="el" href="classseq_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classseq_1_1spinlock.html">spinlock</a> &gt;</td></tr>
<tr class="separator:ac94708941b29d9913813e72ebaa0b190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523698b4a0f59f02b2de77c19ae7df8c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a523698b4a0f59f02b2de77c19ae7df8c">at</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) const -&gt; <a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a></td></tr>
<tr class="memdesc:a523698b4a0f59f02b2de77c19ae7df8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference wrapper to the element at specified location pos, with bounds checking.  <a href="classseq_1_1cvector.html#a523698b4a0f59f02b2de77c19ae7df8c">More...</a><br /></td></tr>
<tr class="separator:a523698b4a0f59f02b2de77c19ae7df8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bce9ae633deaaaab944ff433a4e77da"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a2bce9ae633deaaaab944ff433a4e77da">at</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a></td></tr>
<tr class="memdesc:a2bce9ae633deaaaab944ff433a4e77da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference wrapper to the element at specified location pos, with bounds checking.  <a href="classseq_1_1cvector.html#a2bce9ae633deaaaab944ff433a4e77da">More...</a><br /></td></tr>
<tr class="separator:a2bce9ae633deaaaab944ff433a4e77da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda907cd780d2cd7d66a38431d378911"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#aeda907cd780d2cd7d66a38431d378911">operator[]</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a></td></tr>
<tr class="memdesc:aeda907cd780d2cd7d66a38431d378911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference wrapper to the element at specified location pos, without bounds checking.  <a href="classseq_1_1cvector.html#aeda907cd780d2cd7d66a38431d378911">More...</a><br /></td></tr>
<tr class="separator:aeda907cd780d2cd7d66a38431d378911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df5a2e5dc21b8c856165cfd46976f06"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a7df5a2e5dc21b8c856165cfd46976f06">operator[]</a> (<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a></td></tr>
<tr class="memdesc:a7df5a2e5dc21b8c856165cfd46976f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference wrapper to the element at specified location pos, without bounds checking.  <a href="classseq_1_1cvector.html#a7df5a2e5dc21b8c856165cfd46976f06">More...</a><br /></td></tr>
<tr class="separator:a7df5a2e5dc21b8c856165cfd46976f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e15c5f9108e615e519cda1a7bcf2bbe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a4e15c5f9108e615e519cda1a7bcf2bbe">back</a> () noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a></td></tr>
<tr class="memdesc:a4e15c5f9108e615e519cda1a7bcf2bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference wrapper to the last element in the container.  <a href="classseq_1_1cvector.html#a4e15c5f9108e615e519cda1a7bcf2bbe">More...</a><br /></td></tr>
<tr class="separator:a4e15c5f9108e615e519cda1a7bcf2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3254bbc14b626d8c45e6c253fce8354c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a3254bbc14b626d8c45e6c253fce8354c">back</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a></td></tr>
<tr class="memdesc:a3254bbc14b626d8c45e6c253fce8354c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference wrapper to the last element in the container.  <a href="classseq_1_1cvector.html#a3254bbc14b626d8c45e6c253fce8354c">More...</a><br /></td></tr>
<tr class="separator:a3254bbc14b626d8c45e6c253fce8354c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4fed85887d2f20f64e092e25bd3156"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a2b4fed85887d2f20f64e092e25bd3156">front</a> () noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a></td></tr>
<tr class="memdesc:a2b4fed85887d2f20f64e092e25bd3156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference wrapper to the first element in the container.  <a href="classseq_1_1cvector.html#a2b4fed85887d2f20f64e092e25bd3156">More...</a><br /></td></tr>
<tr class="separator:a2b4fed85887d2f20f64e092e25bd3156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd87ab6b187adf5fb4e0ae248e5ad47"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a7bd87ab6b187adf5fb4e0ae248e5ad47">front</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a></td></tr>
<tr class="memdesc:a7bd87ab6b187adf5fb4e0ae248e5ad47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference wrapper to the first element in the container.  <a href="classseq_1_1cvector.html#a7bd87ab6b187adf5fb4e0ae248e5ad47">More...</a><br /></td></tr>
<tr class="separator:a7bd87ab6b187adf5fb4e0ae248e5ad47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e3110c5a7986875f42d25b8d6d9246"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a></td></tr>
<tr class="memdesc:a96e3110c5a7986875f42d25b8d6d9246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the cvector.  <a href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">More...</a><br /></td></tr>
<tr class="separator:a96e3110c5a7986875f42d25b8d6d9246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb21c12cd6cadaa27796704006f6786"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#aeeb21c12cd6cadaa27796704006f6786">begin</a> () noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:aeeb21c12cd6cadaa27796704006f6786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the cvector.  <a href="classseq_1_1cvector.html#aeeb21c12cd6cadaa27796704006f6786">More...</a><br /></td></tr>
<tr class="separator:aeeb21c12cd6cadaa27796704006f6786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d287e5d3889e4c2eac9fb69152b21a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a></td></tr>
<tr class="memdesc:a72d287e5d3889e4c2eac9fb69152b21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the cvector.  <a href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">More...</a><br /></td></tr>
<tr class="separator:a72d287e5d3889e4c2eac9fb69152b21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934f5a2f9db4733edf230003cccd66a8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a934f5a2f9db4733edf230003cccd66a8">end</a> () noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a></td></tr>
<tr class="memdesc:a934f5a2f9db4733edf230003cccd66a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the cvector.  <a href="classseq_1_1cvector.html#a934f5a2f9db4733edf230003cccd66a8">More...</a><br /></td></tr>
<tr class="separator:a934f5a2f9db4733edf230003cccd66a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83181634663d7458c62fac5044e8d9f0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a83181634663d7458c62fac5044e8d9f0">rbegin</a> () noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a281b4dd5fe93aa08049aecd3254bcb5d">reverse_iterator</a></td></tr>
<tr class="memdesc:a83181634663d7458c62fac5044e8d9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1cvector.html#a83181634663d7458c62fac5044e8d9f0">More...</a><br /></td></tr>
<tr class="separator:a83181634663d7458c62fac5044e8d9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a80e370721ae1fed47f29de8be3bf33"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a4a80e370721ae1fed47f29de8be3bf33">rbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a4a80e370721ae1fed47f29de8be3bf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1cvector.html#a4a80e370721ae1fed47f29de8be3bf33">More...</a><br /></td></tr>
<tr class="separator:a4a80e370721ae1fed47f29de8be3bf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640b2b60ebca842ffc25463bc3ea6ea0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a640b2b60ebca842ffc25463bc3ea6ea0">rend</a> () noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a281b4dd5fe93aa08049aecd3254bcb5d">reverse_iterator</a></td></tr>
<tr class="memdesc:a640b2b60ebca842ffc25463bc3ea6ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1cvector.html#a640b2b60ebca842ffc25463bc3ea6ea0">More...</a><br /></td></tr>
<tr class="separator:a640b2b60ebca842ffc25463bc3ea6ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f492c9787793f998567ce0b697dc4dc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a2f492c9787793f998567ce0b697dc4dc">rend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a2f492c9787793f998567ce0b697dc4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1cvector.html#a2f492c9787793f998567ce0b697dc4dc">More...</a><br /></td></tr>
<tr class="separator:a2f492c9787793f998567ce0b697dc4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6c9edfac1f5222c247d7a669afa6c1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#afa6c9edfac1f5222c247d7a669afa6c1">cbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a></td></tr>
<tr class="memdesc:afa6c9edfac1f5222c247d7a669afa6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the cvector.  <a href="classseq_1_1cvector.html#afa6c9edfac1f5222c247d7a669afa6c1">More...</a><br /></td></tr>
<tr class="separator:afa6c9edfac1f5222c247d7a669afa6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fa08c69ea55b6215b2cd907c89cf56"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a62fa08c69ea55b6215b2cd907c89cf56">cend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a></td></tr>
<tr class="memdesc:a62fa08c69ea55b6215b2cd907c89cf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the cvector.  <a href="classseq_1_1cvector.html#a62fa08c69ea55b6215b2cd907c89cf56">More...</a><br /></td></tr>
<tr class="separator:a62fa08c69ea55b6215b2cd907c89cf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941035c5302b028414e11e1934f33012"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a941035c5302b028414e11e1934f33012">crbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a941035c5302b028414e11e1934f33012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1cvector.html#a941035c5302b028414e11e1934f33012">More...</a><br /></td></tr>
<tr class="separator:a941035c5302b028414e11e1934f33012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa5a72fd5f6aabef4ffeea6929a29e3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#aaaa5a72fd5f6aabef4ffeea6929a29e3">crend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aaaa5a72fd5f6aabef4ffeea6929a29e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1cvector.html#aaaa5a72fd5f6aabef4ffeea6929a29e3">More...</a><br /></td></tr>
<tr class="separator:aaaa5a72fd5f6aabef4ffeea6929a29e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50758b4a5e9245f46b78a7fd0058deff"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:a50758b4a5e9245f46b78a7fd0058deff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a50758b4a5e9245f46b78a7fd0058deff">for_each</a> (size_t start, size_t <a class="el" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a>, Functor fun) -&gt; Functor</td></tr>
<tr class="separator:a50758b4a5e9245f46b78a7fd0058deff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8c1b7fb109e6d4be4103680fb05308"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:a7e8c1b7fb109e6d4be4103680fb05308"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a7e8c1b7fb109e6d4be4103680fb05308">for_each</a> (size_t start, size_t <a class="el" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a>, Functor fun) const -&gt; Functor</td></tr>
<tr class="separator:a7e8c1b7fb109e6d4be4103680fb05308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20e7a9c68b92f44c3f4cb1bf0e9e4e4"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:ad20e7a9c68b92f44c3f4cb1bf0e9e4e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ad20e7a9c68b92f44c3f4cb1bf0e9e4e4">const_for_each</a> (size_t start, size_t <a class="el" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a>, Functor fun) const -&gt; Functor</td></tr>
<tr class="separator:ad20e7a9c68b92f44c3f4cb1bf0e9e4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a89b0ab698b706c242a0b18a6b267d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a24a89b0ab698b706c242a0b18a6b267d">block_count</a> () const noexcept</td></tr>
<tr class="memdesc:a24a89b0ab698b706c242a0b18a6b267d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of blocks. A block contains at most 256 elements.  <a href="classseq_1_1cvector.html#a24a89b0ab698b706c242a0b18a6b267d">More...</a><br /></td></tr>
<tr class="separator:a24a89b0ab698b706c242a0b18a6b267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4731d7a2ae1961b78a48d1d47e5e38a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a4731d7a2ae1961b78a48d1d47e5e38a7">mark_dirty_block</a> (size_t <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) noexcept</td></tr>
<tr class="memdesc:a4731d7a2ae1961b78a48d1d47e5e38a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the block at given position as dirty. Call this function if you modified the block using block(pos).  <a href="classseq_1_1cvector.html#a4731d7a2ae1961b78a48d1d47e5e38a7">More...</a><br /></td></tr>
<tr class="separator:a4731d7a2ae1961b78a48d1d47e5e38a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41490f1c68b5272783b217b54af71cf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const T *, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#aa41490f1c68b5272783b217b54af71cf">block</a> (size_t <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) const</td></tr>
<tr class="memdesc:aa41490f1c68b5272783b217b54af71cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair (block data pointer, block size) for given block position. This let you apply low level functions based on this block like simd based computations.  <a href="classseq_1_1cvector.html#aa41490f1c68b5272783b217b54af71cf">More...</a><br /></td></tr>
<tr class="separator:aa41490f1c68b5272783b217b54af71cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd065332d986f686be9ca58a5d624b2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; T *, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a7fd065332d986f686be9ca58a5d624b2">block</a> (size_t <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>)</td></tr>
<tr class="memdesc:a7fd065332d986f686be9ca58a5d624b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair (block data pointer, block size) for given block position. This let you apply low level functions on this block like simd based computations. If block data are modified, you must call yourself <a class="el" href="classseq_1_1cvector.html#a4731d7a2ae1961b78a48d1d47e5e38a7" title="Mark the block at given position as dirty. Call this function if you modified the block using block(p...">mark_dirty_block()</a>.  <a href="classseq_1_1cvector.html#a7fd065332d986f686be9ca58a5d624b2">More...</a><br /></td></tr>
<tr class="separator:a7fd065332d986f686be9ca58a5d624b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f1c0d1f8ac8dd22cf1d5fdc6f79404"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ae9f1c0d1f8ac8dd22cf1d5fdc6f79404">serialize</a> (std::ostream &amp;oss)</td></tr>
<tr class="memdesc:ae9f1c0d1f8ac8dd22cf1d5fdc6f79404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize cvector content into a std::ostream object.  <a href="classseq_1_1cvector.html#ae9f1c0d1f8ac8dd22cf1d5fdc6f79404">More...</a><br /></td></tr>
<tr class="separator:ae9f1c0d1f8ac8dd22cf1d5fdc6f79404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac149f6d62d3dcc778d01f1663bb31e38"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ac149f6d62d3dcc778d01f1663bb31e38">deserialize</a> (std::istream &amp;iss)</td></tr>
<tr class="memdesc:ac149f6d62d3dcc778d01f1663bb31e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize cvector from a std::istream object. Previous content of the cvector is cleared.  <a href="classseq_1_1cvector.html#ac149f6d62d3dcc778d01f1663bb31e38">More...</a><br /></td></tr>
<tr class="separator:ac149f6d62d3dcc778d01f1663bb31e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07512373e0626debcca31db25589eda6"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a07512373e0626debcca31db25589eda6">max_size</a> () noexcept -&gt; <a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a></td></tr>
<tr class="memdesc:a07512373e0626debcca31db25589eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size.  <a href="classseq_1_1cvector.html#a07512373e0626debcca31db25589eda6">More...</a><br /></td></tr>
<tr class="separator:a07512373e0626debcca31db25589eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad7958dcbe1fd2a306924e96344deb338"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ad7958dcbe1fd2a306924e96344deb338">acc</a> = Acceleration &gt; 7 ? 7 : Acceleration</td></tr>
<tr class="separator:ad7958dcbe1fd2a306924e96344deb338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d786b615987043cc5873317810d2db"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#a45d786b615987043cc5873317810d2db">max_block_size</a> = (<a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#a9c785f4c98049c345d4e1b6248d7a344">internal_type::elems_per_block</a> * sizeof(T)) - (<a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#a9c785f4c98049c345d4e1b6248d7a344">internal_type::elems_per_block</a> * sizeof(T)) / (10 - <a class="el" href="classseq_1_1cvector.html#ad7958dcbe1fd2a306924e96344deb338">acc</a>)</td></tr>
<tr class="separator:a45d786b615987043cc5873317810d2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2544822ebe3ca9fe51eaaab16abf0dc"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1cvector.html#ae2544822ebe3ca9fe51eaaab16abf0dc">acceleration</a> = Acceleration</td></tr>
<tr class="separator:ae2544822ebe3ca9fe51eaaab16abf0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder = detail::DefaultEncoder, unsigned block_size = 256&gt;<br />
class seq::cvector&lt; T, Allocator, Acceleration, Encoder, block_size &gt;</h3>

<p>vector like class using compression to store its elements </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value type, must be relocatable </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator type </td></tr>
    <tr><td class="paramname">Acceleration</td><td>acceleratio nparameter for the compression algorithm, from 0 to 7 </td></tr>
    <tr><td class="paramname">Encoder</td><td>encoder type, default to DefaultEncoder </td></tr>
    <tr><td class="paramname">block_size</td><td>number of elements per chunks, must be a power of 2</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1cvector.html" title="vector like class using compression to store its elements">seq::cvector</a> is a is a random-access container with an interface similar to std::vector but storing its element in a compressed way. Its goal is to reduce the memory footprint of the container while providing performances as close as possible to std::vector.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Internals</h2>
<p>By default, cvector stores its elements by chunks of 256 values. Whenever a chunk is filled (due for instance to calls to <a class="el" href="classseq_1_1cvector.html#a11b2be12dbc2384b173641fe66618df2" title="Appends the given element value to the end of the container.">push_back()</a>), it is compressed and the chunk itself is either kept internally (for further decompression) or deallocated. This means that cvector NEVER ensure reference stability, as a stored object might only exist in its compressed form.</p>
<p>When accessing a value using iterators or operator[], the corresponding chunk is first located. If this chunk was already decompressed, a reference wrapper to the corresponding element is returned. Otherwise, the memory chunk is decompressed first. If the accessed element is modified, the chunk is mark as dirty, meaning that it will require recompression at some point.</p>
<p>To avoid compressing/decompressing lots of chunks when performing heavy random-access operations, cvector allows multiple chunks to store their elements in their decompressed form, called <b>decompression contexts</b>. The maximum number of decompression contexts is defined using <a class="el" href="classseq_1_1cvector.html#a0bcd4a7e9d4bec8f43e41cd1cc6b4ffd" title="Set the maximum number of allowed decompression contexts.">cvector::set_max_contexts()</a>, and is either a fixed number or a fraction of the total number of chunks. By default, the number of decompression contexts is limited to 12.5% of the number of chunks. This means that the cvector memory footprint is at most 1.125 times higher than <a class="el" href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4" title="Returns the container size.">cvector::size()</a>*sizeof(value_type).</p>
<p>Whenever a chunk must be decompressed to access one of its element, it allocates a new decompression context if the maximum number of allowed contexts has not been reach yet, and this context is added to an internal list of all available contexts. Otherwise, it try to reuse an existing decompression context from this internal list. Note that the chunk might reuse a context already used by another chunk. In this case, this other chunk is recompressed if marked dirty, the context is detached from this chunk and attached to the new one which decompress its elements inside. This means that accessing an element (even with const members) might invalidate any other reference to elements within the container.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Element access</h2>
<p>Individual elements can be accessed using <a class="el" href="classseq_1_1cvector.html#aeda907cd780d2cd7d66a38431d378911" title="Returns a reference wrapper to the element at specified location pos, without bounds checking.">cvector::operator[]</a>, <a class="el" href="classseq_1_1cvector.html#a523698b4a0f59f02b2de77c19ae7df8c" title="Returns a reference wrapper to the element at specified location pos, with bounds checking.">cvector::at</a>, <a class="el" href="classseq_1_1cvector.html#a2b4fed85887d2f20f64e092e25bd3156" title="Returns a reference wrapper to the first element in the container.">cvector::front</a>, <a class="el" href="classseq_1_1cvector.html#a4e15c5f9108e615e519cda1a7bcf2bbe" title="Returns a reference wrapper to the last element in the container.">cvector::back</a> or iterators. As seen in previous section, accessing an element might invalidate all other references to the container elements (in fact, it might invalidate all elements that do not belong to the corresponding chunk).</p>
<p>That's why access members return a reference wrapper instead of a plain reference (types <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">cvector::ref_type</a> and <a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">cvector::const_ref_type</a>). A reference wrapper basically stores a pointer to cvector internal data and the coordinate of the corresponding element. When casting this wrapper to <b>value_type</b>, the corresponding chunk is decompressed (if needed) and the value at given location is returned. A reference wrapper can be casted to <b>value_type</b> or <b>const value_type&amp;</b>, in which case the reference should not be used after accessing another element.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Fill cvector</span></div>
<div class="line"><a class="code" href="classseq_1_1cvector.html">seq::cvector&lt;int&gt;</a> vec;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; 1000; ++i)</div>
<div class="line">    vec.<a class="code" href="classseq_1_1cvector.html#a11b2be12dbc2384b173641fe66618df2">push_back</a>(i);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// a is of type cvector&lt;int&gt;::ref_type</span></div>
<div class="line"><span class="keyword">auto</span> a = vec[0];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// copy element pointed by a to b</span></div>
<div class="line"><span class="keywordtype">int</span> b = a;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Store a const reference of element 0</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> &amp; c = vec[0];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// WARNING: accessing element at position 600 might invalidate reference c!</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> &amp; d = vec[600];</div>
</div><!-- fragment --><p>In order for cvector to work with all STL algorithms, some latitudes with C++ standard were taken:</p><ul>
<li><a class="el" href="namespacestd.html#a87a7b5732634d46429dee124bad4fdc3">std::swap</a> is overloaded for reference wrapper types. Overloading <a class="el" href="namespacestd.html#a87a7b5732634d46429dee124bad4fdc3">std::swap</a> is forbidden by the standard, but works in practive with msvc and gcc at least.</li>
<li><a class="el" href="namespacestd.html#af8821d6dc8543af6dc30cddfe0bd0584">std::move</a> is overloaded for reference wrapper types. This was mandatory for algorithms like std::move(first,last,dst) to work on move-only types.</li>
</ul>
<p>Thanks to this, it is possible to call std::sort or std::random_shuffle on a cvector. For instance, the following code snippet successively:</p><ul>
<li>Call <a class="el" href="classseq_1_1cvector.html#a11b2be12dbc2384b173641fe66618df2" title="Appends the given element value to the end of the container.">cvector::push_back</a> to fill the cvector with sorted data. In this case the compression ratio is very low due to high values correlation.</li>
<li>Call std::random_shuffle to shuffle the cvector: the compresion ratio become very high as compressing random data is not possible.</li>
<li>Sort again the cvector with std::sort to get back the initial compression ratio.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cvector_8hpp.html">cvector.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="utils_8hpp.html">utils.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="testing_8hpp.html">testing.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classseq_1_1cvector.html">cvector&lt;int&gt;</a> w;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// fill with consecutive values</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 10000000; ++i)</div>
<div class="line">    w.<a class="code" href="classseq_1_1cvector.html#a11b2be12dbc2384b173641fe66618df2">push_back</a>((<span class="keywordtype">int</span>)i);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;push_back: &quot;</span> &lt;&lt; w.<a class="code" href="classseq_1_1cvector.html#a8f62e0efb88dffc0e5ae2d18b5960790">current_compression_ratio</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// shuffle the cvector</span></div>
<div class="line"><a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line"><a class="code" href="namespaceseq.html#ad8b268bc53b846426ab17a84bb756fab">seq::random_shuffle</a>(w.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>(), w.<a class="code" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a>());</div>
<div class="line"><span class="keywordtype">size_t</span> el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;random_shuffle: &quot;</span> &lt;&lt; w.<a class="code" href="classseq_1_1cvector.html#a8f62e0efb88dffc0e5ae2d18b5960790">current_compression_ratio</a>() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; el &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// sort the cvector</span></div>
<div class="line"><a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line">std::sort(w.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>(), w.<a class="code" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a>());</div>
<div class="line">el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;sort: &quot;</span> &lt;&lt; w.<a class="code" href="classseq_1_1cvector.html#a8f62e0efb88dffc0e5ae2d18b5960790">current_compression_ratio</a>() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; el &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Below is a curve representing the program memory footprint during previous operations (extracted with Visual Studio diagnostic tools):</p>
<div class="image">
<img src="cvector_memory.png" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md13"></a>
Restrictions</h2>
<p>cvector only works with relocatable value types (relocation in terms of move plus destroy). <a class="el" href="structseq_1_1is__relocatable.html" title="Type trait telling if a class is relocatable or not.">seq::is_relocatable</a> type trait will be used to detect invalid data types. You can specialize <a class="el" href="structseq_1_1is__relocatable.html" title="Type trait telling if a class is relocatable or not.">seq::is_relocatable</a> for your custom types if you are certain they are indeed relocatable.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Compression algorithm</h2>
<p>In order for cvector to have any interset over a standard <b>std::vector</b> or <b>std::deque</b>, its compression algorithm must be:</p><ul>
<li>very fast or the performance gap will be to high compared to STL counterparts,</li>
<li>symetric if possible, as compression is performed almost as often as decompression,</li>
<li>efficient on small blocks of data to allow fast random access.</li>
</ul>
<p>It turns out I developed a compression algorithm a while back for lossless image compression that worked on small blocks of 16*16 pixels. I just had to adjust it to work on flat input and blocks of 256 elements. This algorithm relies on well known compression methods: it uses bit packing, delta coding and RLE (whichever is better) on the transposed block. All of this is performed using SSE4. Both compression and decompression run at more or less 2GB/s on a my laptop (Intel(R) Core(TM) i7-10850H CPU @ 2.70GHz).</p>
<p>If compared to other compression methods working on transposed input like <a href="https://www.blosc.org/">blosc</a> with <a href="https://github.com/lz4/lz4">LZ4</a>, my compression algorithm provides slighly lower values: it is slower and compress less by a small margin. However, it is way more efficient on small blocks (256 elements in this case) as it keeps its full strength: indeed, each block is compressed independently.</p>
<p>The compression algorithm supports an acceleration factor ranging from 0 (maximum compression) to 7 (fastest). It mainly changes the way near-uncompressible blocks are handled. The acceleration factor is given as a template parameter of cvector class.</p>
<p>It is possible to specify a different compression method using the <b>Encoder</b> template argument of cvector. For instance one can use the <b><a class="el" href="structseq_1_1detail_1_1_null_encoder.html" title="Encoder that relies on memcpy.">seq::detail::NullEncoder</a></b> that encode/decode blocks using... memcpy (transforming cvector to a poor deque-like class). For custom encoder, it is possible to specify a different block size instead of the default 256 elements (it must remain a power of 2). Note that increasing the block size might increase the compression ratio and bidirectional access patterns, but will slow down random-access patterns.</p>
<p>seq library provides seq::Lz4FlatEncoder and seq::Lz4TransposeEncoder (in <b>internal/lz4small.h</b>) as example of custom encoders that can be passed to cvector. They rely on a modified version of LZ4 compression algorithm suitable for small input length. seq::Lz4FlatEncoder is sometimes better than the default block encoder for cvector of <a class="el" href="classseq_1_1tiny__string.html" title="String class with a similar interface and requirements than std::string.">seq::tiny_string</a>.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Multithreading</h2>
<p>By default, cvector does not support multi-threaded access, even on read-only mode. Indeed, retrieving an element might trigger a block decompression, which in turn might trigger a recompression of another block in order to still its decompression context.</p>
<p>cvector supports a locking mechanism at the block level for concurrent accesses. Below is a commented example of several ways to apply std::cos function to all elements of a cvector, including multi-threading based on openmp and use of the low level block API.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cvector_8hpp.html">cvector.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="testing_8hpp.html">testing.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span>  main  (<span class="keywordtype">int</span> , <span class="keywordtype">char</span>** )</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create 10000000 random float values</span></div>
<div class="line">std::srand(0);</div>
<div class="line">std::vector&lt;float&gt;  random_vals(10000000);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">float</span>&amp; v : random_vals)</div>
<div class="line">    v = std::rand();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// fill a cvector with random values</span></div>
<div class="line"><a class="code" href="classseq_1_1cvector.html">cvector&lt;float&gt;</a> vec;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">float</span> v : random_vals)</div>
<div class="line">    vec.<a class="code" href="classseq_1_1cvector.html#a11b2be12dbc2384b173641fe66618df2">push_back</a>(v);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Standard loop over all values using operator[]</span></div>
<div class="line"><a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.<a class="code" href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4">size</a>(); ++i)</div>
<div class="line">{</div>
<div class="line">    vec[i] = std::cos((<span class="keywordtype">float</span>)vec[i]);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">size_t</span> el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;operator[]: &quot;</span> &lt;&lt; el &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// reset values</span></div>
<div class="line">std::copy(random_vals.begin(), random_vals.end(), vec.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Standard loop over all values using iterators</span></div>
<div class="line"><a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it = vec.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>(); it != vec.<a class="code" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a>(); ++it)</div>
<div class="line">{</div>
<div class="line">    *it = std::cos((<span class="keywordtype">float</span>)*it);</div>
<div class="line">}</div>
<div class="line">el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;iterator: &quot;</span> &lt;&lt; el &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">//reset values</span></div>
<div class="line">std::copy(random_vals.begin(), random_vals.end(), vec.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use cvector::for_each (mono threaded, but supports concurrent access).</span></div>
<div class="line"><span class="comment">// This should be as fast as working on a std::vector directly.</span></div>
<div class="line"><a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line">vec.<a class="code" href="classseq_1_1cvector.html#a50758b4a5e9245f46b78a7fd0058deff">for_each</a>(0, vec.<a class="code" href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4">size</a>(), [](<span class="keywordtype">float</span>&amp; v) {v = std::cos(v); });</div>
<div class="line">el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;cvector::for_each: &quot;</span> &lt;&lt; el &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">//reset values</span></div>
<div class="line">std::copy(random_vals.begin(), random_vals.end(), vec.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Multithreaded loop</span></div>
<div class="line"><a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line"><span class="preprocessor">#pragma omp parallel for</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int)vec.<a class="code" href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4">size</a>(); ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// lock position i since we multithreaded the loop</span></div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="classseq_1_1lock__guard.html">lock_guard</a> = vec.<a class="code" href="classseq_1_1cvector.html#ac94708941b29d9913813e72ebaa0b190">lock</a>(i);</div>
<div class="line">    vec[i] = std::cos((<span class="keywordtype">float</span>)vec[i]);</div>
<div class="line">}</div>
<div class="line">el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;operator[] multithreaded: &quot;</span> &lt;&lt; el &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">//reset values</span></div>
<div class="line">std::copy(random_vals.begin(), random_vals.end(), vec.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parallel loop over blocks instead of values, using cvector block API</span></div>
<div class="line"><a class="code" href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">tick</a>();</div>
<div class="line"><span class="preprocessor">#pragma omp parallel for</span></div>
<div class="line"><span class="comment">// loop over all blocks</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int)vec.<a class="code" href="classseq_1_1cvector.html#a24a89b0ab698b706c242a0b18a6b267d">block_count</a>(); ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// lock block since we multithreaded the loop</span></div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="classseq_1_1lock__guard.html">lock_guard</a> = vec.<a class="code" href="classseq_1_1cvector.html#a80f09115258e1046f278a6daca7c6abf">lock_block</a>(i);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// retrieve the block as a std::pair&lt;float*, unsigned&gt; (data pointer, block size)</span></div>
<div class="line">    <span class="keyword">auto</span> bl = vec.<a class="code" href="classseq_1_1cvector.html#aa41490f1c68b5272783b217b54af71cf">block</a>(i);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// apply std::cos functions on all elements of the block</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; bl.second; ++j)</div>
<div class="line">        bl.first[j] = std::cos(bl.first[j]);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// manually mark the block as dirty (need recompression at some point)</span></div>
<div class="line">    vec.<a class="code" href="classseq_1_1cvector.html#a4731d7a2ae1961b78a48d1d47e5e38a7">mark_dirty_block</a>(i);</div>
<div class="line">}</div>
<div class="line">el = <a class="code" href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">tock_ms</a>();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;block API multithreaded: &quot;</span> &lt;&lt; el &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Above example compiled with gcc 10.1.0 (-O3) for msys2 on Windows 10 on a Intel(R) Core(TM) i7-10850H at 2.70GHz gives the following output:</p>
<blockquote class="doxtable">
<p>operator[]: 454 ms</p>
<p>iterator: 444 ms</p>
<p><a class="el" href="classseq_1_1cvector.html#a50758b4a5e9245f46b78a7fd0058deff">cvector::for_each</a> : 418 ms</p>
<p>operator[] multithreaded : 179 ms</p>
<p>block API multithreaded : 59 ms </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md16"></a>
Serialization</h2>
<p>cvector provides serialization/deserialization functions working on compressed blocks. Use <a class="el" href="classseq_1_1cvector.html#ae9f1c0d1f8ac8dd22cf1d5fdc6f79404" title="Serialize cvector content into a std::ostream object.">cvector::serialize</a> to save the cvector content in a std::ostream object, and <a class="el" href="classseq_1_1cvector.html#ac149f6d62d3dcc778d01f1663bb31e38" title="Deserialize cvector from a std::istream object. Previous content of the cvector is cleared.">cvector::deserialize</a> to read back the cvector from a std::istream object. When deserializing a cvector object with <a class="el" href="classseq_1_1cvector.html#ac149f6d62d3dcc778d01f1663bb31e38" title="Deserialize cvector from a std::istream object. Previous content of the cvector is cleared.">cvector::deserialize</a>, the cvector template parameters must be the same as the ones used for serialization, except for the <b>Acceleration</b> parameter and the allocator type.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cvector_8hpp.html">cvector.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span>  main  (<span class="keywordtype">int</span> , <span class="keywordtype">char</span>** )</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create values we want to serialize</span></div>
<div class="line">std::vector&lt;int&gt; content(10000000);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; content.size(); ++i)</div>
<div class="line">    content[i] = i;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::string <a class="code" href="namespaceseq_1_1detail.html#ae55afe416e41adc12918f3deb7b62d68">saved</a>;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a cvector, fill it</span></div>
<div class="line">    <a class="code" href="classseq_1_1cvector.html">cvector&lt;int&gt;</a> vec;</div>
<div class="line">    std::copy(content.begin(), content.end(), std::back_inserter(vec));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Save cvector in &#39;saved&#39; string</span></div>
<div class="line">    std::ostringstream oss;</div>
<div class="line">    vec.<a class="code" href="classseq_1_1cvector.html#ae9f1c0d1f8ac8dd22cf1d5fdc6f79404">serialize</a>(oss);</div>
<div class="line">    <a class="code" href="namespaceseq_1_1detail.html#ae55afe416e41adc12918f3deb7b62d68">saved</a> = oss.str();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print the compression ratio based on &#39;saved&#39;</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;serialize compression ratio: &quot;</span> &lt;&lt; <a class="code" href="namespaceseq_1_1detail.html#ae55afe416e41adc12918f3deb7b62d68">saved</a>.size() / (double)(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * vec.<a class="code" href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4">size</a>()) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deserialize &#39;saved&#39; string</span></div>
<div class="line">std::istringstream iss(<a class="code" href="namespaceseq_1_1detail.html#ae55afe416e41adc12918f3deb7b62d68">saved</a>);</div>
<div class="line"><a class="code" href="classseq_1_1cvector.html">cvector&lt;int&gt;</a> vec;</div>
<div class="line">vec.<a class="code" href="classseq_1_1cvector.html#ac149f6d62d3dcc778d01f1663bb31e38">deserialize</a>(iss);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make sure the deserialized cvector is equal to the original vector</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;deserialization valid: &quot;</span> &lt;&lt; std::equal(vec.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>(), vec.<a class="code" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a>(), content.begin(), content.end()) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Custom comparison</h2>
<p>When using a custom comparator function with STL algorithms like std::sort or std::equal on cvector, there are chances that the algorithm won't work as expected or just crash. This is because 2 reference wrappers might be casted at the same time to real value_type references, that then will be passed to the custom comparator. However, since accessing a cvector value might invalidate all other references, the custom comparator might be applied on dangling objects. <br  />
 To avoid this error, you must use a comparator wrapper that will smoothly handle such situations using <a class="el" href="namespaceseq.html#ae02fc574f6876f28fef03044ed31569e" title="Create a comparison functor that can be used by algorithms working on cvector objects.">seq::make_comparator</a>. Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cvector_8hpp.html">cvector.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceseq.html">seq</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span>  main  (<span class="keywordtype">int</span> , <span class="keywordtype">char</span>** )</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> ptr_type = std::unique_ptr&lt;size_t&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a cvector of unique_ptr with random integers</span></div>
<div class="line">    <a class="code" href="classseq_1_1cvector.html">cvector&lt;ptr_type&gt;</a> vec;</div>
<div class="line">    std::srand(0);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; 1000000; ++i)</div>
<div class="line">        vec.<a class="code" href="classseq_1_1cvector.html#a61746d238bdf93e234e3bc1afa82e70a">emplace_back</a>(<span class="keyword">new</span> <span class="keywordtype">size_t</span>(std::rand()));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print the compression ratio</span></div>
<div class="line">    std::cout&lt;&lt; vec.<a class="code" href="classseq_1_1cvector.html#a8f62e0efb88dffc0e5ae2d18b5960790">current_compression_ratio</a>() &lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// sort the cvector using the defined comparison operator between 2 std::unique_ptr objects (sort by pointer address)</span></div>
<div class="line">    std::sort(vec.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>(),vec.<a class="code" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a>());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print again the compression ratio</span></div>
<div class="line">    std::cout&lt;&lt; vec.<a class="code" href="classseq_1_1cvector.html#a8f62e0efb88dffc0e5ae2d18b5960790">current_compression_ratio</a>() &lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now we want to sort by pointed value. </span></div>
<div class="line">    <span class="comment">// We need a custom comparison function that will be passed to seq::make_comparator</span></div>
<div class="line">    </div>
<div class="line">    std::sort(vec.<a class="code" href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">begin</a>(),vec.<a class="code" href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">end</a>(), <a class="code" href="namespaceseq.html#ae02fc574f6876f28fef03044ed31569e">make_comparator</a>([](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; a, <span class="keyword">const</span> <span class="keyword">auto</span> &amp; b){<span class="keywordflow">return</span> *a &lt; *b; }));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print again the compression ratio</span></div>
<div class="line">    std::cout&lt;&lt; vec.<a class="code" href="classseq_1_1cvector.html#a8f62e0efb88dffc0e5ae2d18b5960790">current_compression_ratio</a>() &lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a67d48cb5fcf12b2d3599ec92c9771553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d48cb5fcf12b2d3599ec92c9771553">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a67d48cb5fcf12b2d3599ec92c9771553">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49a5bb758205dae72a8a630e7a742867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a5bb758205dae72a8a630e7a742867">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> =  typename <a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#ae63985a9db80723d6962091ffe48a05c">internal_type::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15d05d4248e9240baaee71172b8a7d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d05d4248e9240baaee71172b8a7d15">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a15d05d4248e9240baaee71172b8a7d15">const_pointer</a> =  const T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af598808a78cef4f2f02b81cf3e3e04f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af598808a78cef4f2f02b81cf3e3e04f5">&#9670;&nbsp;</a></span>const_ref_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a> =  typename <a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#a7310fc5dbab646943984e0b4672809b8">internal_type::const_ref_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a398e47a0841982d7ef01b9e223b6571e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398e47a0841982d7ef01b9e223b6571e">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a398e47a0841982d7ef01b9e223b6571e">const_reference</a> =  const T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abff760f0430a5336522eeec659ca8879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff760f0430a5336522eeec659ca8879">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8036c0e8b83580bf038dc5179db0ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8036c0e8b83580bf038dc5179db0ed5b">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a8036c0e8b83580bf038dc5179db0ed5b">difference_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1cvector.html#a8036c0e8b83580bf038dc5179db0ed5b">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec22d79fd748ff012376d7331ae28542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec22d79fd748ff012376d7331ae28542">&#9670;&nbsp;</a></span>encoder_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#aec22d79fd748ff012376d7331ae28542">encoder_type</a> =  Encoder</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a45490e97733914947fb3c2e1db104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a45490e97733914947fb3c2e1db104">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a> =  typename <a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#ab3c03229c7c5f73450385748fd6ce229">internal_type::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11d6fe2ccde64de9f0fef3762898cf2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d6fe2ccde64de9f0fef3762898cf2c">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a11d6fe2ccde64de9f0fef3762898cf2c">pointer</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac363cb2a798b618c052b764da73e5b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac363cb2a798b618c052b764da73e5b8e">&#9670;&nbsp;</a></span>ref_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a> =  typename <a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#ad8a97d7104a116b1425f92e2f6096862">internal_type::ref_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae06e4a8db2c4dbf96f996f85de08dce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06e4a8db2c4dbf96f996f85de08dce1">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#ae06e4a8db2c4dbf96f996f85de08dce1">reference</a> =  T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a281b4dd5fe93aa08049aecd3254bcb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281b4dd5fe93aa08049aecd3254bcb5d">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a281b4dd5fe93aa08049aecd3254bcb5d">reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a082ccc184a493a23a6ad2d979fa5f0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082ccc184a493a23a6ad2d979fa5f0ab">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a> =  size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28e754f5f0e3cd4956c5ba39296dc927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e754f5f0e3cd4956c5ba39296dc927">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html#a28e754f5f0e3cd4956c5ba39296dc927">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a410798f3504d348e9d253ae9329a3ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410798f3504d348e9d253ae9329a3ecd">&#9670;&nbsp;</a></span>cvector() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, initialize the internal bucket manager. </p>

</div>
</div>
<a id="afb64a63e82cd3fa0a370bc82a1810449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb64a63e82cd3fa0a370bc82a1810449">&#9670;&nbsp;</a></span>cvector() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given allocator alloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ddc4320508bfd1916dee1598a6c3ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddc4320508bfd1916dee1598a6c3ca3">&#9670;&nbsp;</a></span>cvector() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with <em>count</em> copies of elements with value <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new cvector size </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ecefcda6c35915cc0d8f3bbd75f6b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecefcda6c35915cc0d8f3bbd75f6b6e">&#9670;&nbsp;</a></span>cvector() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count default-inserted instances of T. No copies are made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new cvector size </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8207b536359c99702a582aea9eb9a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8207b536359c99702a582aea9eb9a22">&#9670;&nbsp;</a></span>cvector() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvector.html">cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. Constructs the container with the copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade5afbc71f3489cf558acb58acd78749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5afbc71f3489cf558acb58acd78749">&#9670;&nbsp;</a></span>cvector() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvector.html">cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the copy of the contents of other, using alloc as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allcoator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97d51c2e3d3f9704f767ca622676877b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d51c2e3d3f9704f767ca622676877b">&#9670;&nbsp;</a></span>cvector() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html">cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acef51bd29ea9c309d9ec01fc5f74e716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef51bd29ea9c309d9ec01fc5f74e716">&#9670;&nbsp;</a></span>cvector() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html">cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a950e8268aabd54297180bacc88143eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950e8268aabd54297180bacc88143eb6">&#9670;&nbsp;</a></span>cvector() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list <em>init</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td>initializer list </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bd67a7551c6e75d03c741264cc56262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd67a7551c6e75d03c741264cc56262">&#9670;&nbsp;</a></span>cvector() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>last iterator of the range </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a487c0823d3ef230a6de9bbb486439084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487c0823d3ef230a6de9bbb486439084">&#9670;&nbsp;</a></span>~cvector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::~<a class="el" href="classseq_1_1cvector.html">cvector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aef513b545b6bd99db29a035f5a50c4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef513b545b6bd99db29a035f5a50c4fd">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with copies of those in the range [first, last). The behavior is undefined if either argument is an iterator into *this. Basic exception guarantee. </p>

</div>
</div>
<a id="a3e6c3f1426139def6ba1f692b8d8f480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6c3f1426139def6ba1f692b8d8f480">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with <em>count</em> copies of value <em>value</em> Basic exception guarantee. </p>

</div>
</div>
<a id="a994d825680d2fc39328889e63cd710b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994d825680d2fc39328889e63cd710b5">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with the elements from the initializer list ilist. Basic exception guarantee. </p>

</div>
</div>
<a id="a2bce9ae633deaaaab944ff433a4e77da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bce9ae633deaaaab944ff433a4e77da">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference wrapper to the element at specified location pos, with bounds checking. </p>

</div>
</div>
<a id="a523698b4a0f59f02b2de77c19ae7df8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523698b4a0f59f02b2de77c19ae7df8c">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference wrapper to the element at specified location pos, with bounds checking. </p>

</div>
</div>
<a id="a3254bbc14b626d8c45e6c253fce8354c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3254bbc14b626d8c45e6c253fce8354c">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference wrapper to the last element in the container. </p>

</div>
</div>
<a id="a4e15c5f9108e615e519cda1a7bcf2bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e15c5f9108e615e519cda1a7bcf2bbe">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference wrapper to the last element in the container. </p>

</div>
</div>
<a id="a96e3110c5a7986875f42d25b8d6d9246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e3110c5a7986875f42d25b8d6d9246">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the cvector. </p>

</div>
</div>
<a id="aeeb21c12cd6cadaa27796704006f6786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb21c12cd6cadaa27796704006f6786">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the cvector. </p>

</div>
</div>
<a id="a7fd065332d986f686be9ca58a5d624b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd065332d986f686be9ca58a5d624b2">&#9670;&nbsp;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T*, unsigned&gt; <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::block </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pair (block data pointer, block size) for given block position. This let you apply low level functions on this block like simd based computations. If block data are modified, you must call yourself <a class="el" href="classseq_1_1cvector.html#a4731d7a2ae1961b78a48d1d47e5e38a7" title="Mark the block at given position as dirty. Call this function if you modified the block using block(p...">mark_dirty_block()</a>. </p>

</div>
</div>
<a id="aa41490f1c68b5272783b217b54af71cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41490f1c68b5272783b217b54af71cf">&#9670;&nbsp;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const T*, unsigned&gt; <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::block </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pair (block data pointer, block size) for given block position. This let you apply low level functions based on this block like simd based computations. </p>

</div>
</div>
<a id="a24a89b0ab698b706c242a0b18a6b267d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a89b0ab698b706c242a0b18a6b267d">&#9670;&nbsp;</a></span>block_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::block_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of blocks. A block contains at most 256 elements. </p>

</div>
</div>
<a id="afa6c9edfac1f5222c247d7a669afa6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6c9edfac1f5222c247d7a669afa6c1">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the cvector. </p>

</div>
</div>
<a id="a62fa08c69ea55b6215b2cd907c89cf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62fa08c69ea55b6215b2cd907c89cf56">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the cvector. </p>

</div>
</div>
<a id="a8c80ccc15be31abcca35af0c43ae5091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c80ccc15be31abcca35af0c43ae5091">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the container. </p>

</div>
</div>
<a id="ad6729b54071b92bbdda5587c3f12f03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6729b54071b92bbdda5587c3f12f03a">&#9670;&nbsp;</a></span>compression_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::compression_ratio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; float
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the compression ratio achieved by the block encoder. </p>

</div>
</div>
<a id="ad20e7a9c68b92f44c3f4cb1bf0e9e4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20e7a9c68b92f44c3f4cb1bf0e9e4e4">&#9670;&nbsp;</a></span>const_for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::const_for_each </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; Functor
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a941035c5302b028414e11e1934f33012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941035c5302b028414e11e1934f33012">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="aaaa5a72fd5f6aabef4ffeea6929a29e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa5a72fd5f6aabef4ffeea6929a29e3">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a8f62e0efb88dffc0e5ae2d18b5960790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f62e0efb88dffc0e5ae2d18b5960790">&#9670;&nbsp;</a></span>current_compression_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::current_compression_ratio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; float
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current compression ratio, which is the total memory footprint of this container divided by its theoric size (<a class="el" href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4" title="Returns the container size.">size()</a>*sizeof(T)) </p>

</div>
</div>
<a id="ac149f6d62d3dcc778d01f1663bb31e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac149f6d62d3dcc778d01f1663bb31e38">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>iss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize cvector from a std::istream object. Previous content of the cvector is cleared. </p>

</div>
</div>
<a id="a7e4d34336ecc3d7621dbe9040ed7a33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4d34336ecc3d7621dbe9040ed7a33a">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before <em>pos</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator within the cvector </td></tr>
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a61746d238bdf93e234e3bc1afa82e70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61746d238bdf93e234e3bc1afa82e70a">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the end of the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="af31fda617cb2e7fb8d9397d5e2e77e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31fda617cb2e7fb8d9397d5e2e77e4b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retruns true if the container is empty, false otherwise. </p>

</div>
</div>
<a id="a72d287e5d3889e4c2eac9fb69152b21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d287e5d3889e4c2eac9fb69152b21a">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the cvector. </p>

</div>
</div>
<a id="a934f5a2f9db4733edf230003cccd66a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934f5a2f9db4733edf230003cccd66a8">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the cvector. </p>

</div>
</div>
<a id="a4d2a691bc0ab5485468e37db7c1a7a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2a691bc0ab5485468e37db7c1a7a68">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element to erase </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the last (excluded) element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a8242d030ab8f3f3f71a3f0dc97b36dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8242d030ab8f3f3f71a3f0dc97b36dc9">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the last removed element Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a50758b4a5e9245f46b78a7fd0058deff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50758b4a5e9245f46b78a7fd0058deff">&#9670;&nbsp;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Functor
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e8c1b7fb109e6d4be4103680fb05308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8c1b7fb109e6d4be4103680fb05308">&#9670;&nbsp;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; Functor
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bd87ab6b187adf5fb4e0ae248e5ad47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd87ab6b187adf5fb4e0ae248e5ad47">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference wrapper to the first element in the container. </p>

</div>
</div>
<a id="a2b4fed85887d2f20f64e092e25bd3156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4fed85887d2f20f64e092e25bd3156">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference wrapper to the first element in the container. </p>

</div>
</div>
<a id="ac18f3c96ac8d6b7069fe12b134fbbb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18f3c96ac8d6b7069fe12b134fbbb8b">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const Allocator&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>

</div>
</div>
<a id="a06c9a2eb29ea9bd2719f6d8ba9c468a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c9a2eb29ea9bd2719f6d8ba9c468a4">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; Allocator&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>

</div>
</div>
<a id="abadd759559326238d1534f056d593031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadd759559326238d1534f056d593031">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>it</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator within the cvector </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecad20f2dedf7fe965a003f8b8b1b4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecad20f2dedf7fe965a003f8b8b1b4cf">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator within the cvector </td></tr>
    <tr><td class="paramname">first</td><td>first iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>last iterator of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if first==last Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a29bdf8b080de8e683d5f277b95a3df8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bdf8b080de8e683d5f277b95a3df8f">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>it</em> using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator within the cvector </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674119b0669e2e805f863752e9376edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674119b0669e2e805f863752e9376edc">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count copies of the value before pos. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if count==0 Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="acd547958d3e667e9977e9dbfcaff94fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd547958d3e667e9977e9dbfcaff94fe">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a49a5bb758205dae72a8a630e7a742867">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1cvector.html#a66a45490e97733914947fb3c2e1db104">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist before pos. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if first==last. Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a2e7f9fc8221799221ae8b0d5934eef49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7f9fc8221799221ae8b0d5934eef49">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count copies of the value before pos Basic exception guarantee. <br  />
 </p>

</div>
</div>
<a id="ac94708941b29d9913813e72ebaa0b190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94708941b29d9913813e72ebaa0b190">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::lock </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1lock__guard.html">lock_guard</a>&lt;<a class="el" href="classseq_1_1spinlock.html">spinlock</a>&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80f09115258e1046f278a6daca7c6abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f09115258e1046f278a6daca7c6abf">&#9670;&nbsp;</a></span>lock_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::lock_block </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1lock__guard.html">lock_guard</a>&lt;<a class="el" href="classseq_1_1spinlock.html">spinlock</a>&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4731d7a2ae1961b78a48d1d47e5e38a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4731d7a2ae1961b78a48d1d47e5e38a7">&#9670;&nbsp;</a></span>mark_dirty_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::mark_dirty_block </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the block at given position as dirty. Call this function if you modified the block using block(pos). </p>

</div>
</div>
<a id="a8d693e3a04d7de42f63fa190e7c006db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d693e3a04d7de42f63fa190e7c006db">&#9670;&nbsp;</a></span>max_contexts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::max_contexts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1context__ratio.html">context_ratio</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of decompression contexts. </p>

</div>
</div>
<a id="a07512373e0626debcca31db25589eda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07512373e0626debcca31db25589eda6">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container maximum size. </p>

</div>
</div>
<a id="abe4f755d6bc29ffc876f8397d6dca24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4f755d6bc29ffc876f8397d6dca24a">&#9670;&nbsp;</a></span>memory_footprint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::memory_footprint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; size_t
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total memory footprint in bytes of this cvector, excluding sizeof(*this) </p>

</div>
</div>
<a id="a59abb0b7ef2d5c37ae474f14bd306aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59abb0b7ef2d5c37ae474f14bd306aa7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1cvector.html">cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html">cvector</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="aec990e71a2ef05b2fcc9ad93d1349a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec990e71a2ef05b2fcc9ad93d1349a6c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html">cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html">cvector</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="aeda907cd780d2cd7d66a38431d378911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda907cd780d2cd7d66a38431d378911">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#af598808a78cef4f2f02b81cf3e3e04f5">const_ref_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference wrapper to the element at specified location pos, without bounds checking. </p>

</div>
</div>
<a id="a7df5a2e5dc21b8c856165cfd46976f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df5a2e5dc21b8c856165cfd46976f06">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#ac363cb2a798b618c052b764da73e5b8e">ref_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference wrapper to the element at specified location pos, without bounds checking. </p>

</div>
</div>
<a id="a0cb4b5367e4040ee7a15d68130cf45e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb4b5367e4040ee7a15d68130cf45e2">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. Calling pop_back on an empty container results in undefined behavior. Strong exception guarantee. </p>

</div>
</div>
<a id="a11b2be12dbc2384b173641fe66618df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b2be12dbc2384b173641fe66618df2">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Strong exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cf9dd4ea3ef93e9b72d86f98fb5e41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf9dd4ea3ef93e9b72d86f98fb5e41c">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Strong exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a80e370721ae1fed47f29de8be3bf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a80e370721ae1fed47f29de8be3bf33">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a83181634663d7458c62fac5044e8d9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83181634663d7458c62fac5044e8d9f0">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#a281b4dd5fe93aa08049aecd3254bcb5d">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a2f492c9787793f998567ce0b697dc4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f492c9787793f998567ce0b697dc4dc">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#abff760f0430a5336522eeec659ca8879">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a640b2b60ebca842ffc25463bc3ea6ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640b2b60ebca842ffc25463bc3ea6ea0">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1cvector.html#a281b4dd5fe93aa08049aecd3254bcb5d">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a6352fe58e3fbfe11ee379cd816113056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6352fe58e3fbfe11ee379cd816113056">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-inserted elements are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76fda7cb61b9ad1702310de4702ae0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fda7cb61b9ad1702310de4702ae0dd">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of value are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9f1c0d1f8ac8dd22cf1d5fdc6f79404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f1c0d1f8ac8dd22cf1d5fdc6f79404">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>oss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize cvector content into a std::ostream object. </p>

</div>
</div>
<a id="a0bcd4a7e9d4bec8f43e41cd1cc6b4ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcd4a7e9d4bec8f43e41cd1cc6b4ffd">&#9670;&nbsp;</a></span>set_max_contexts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::set_max_contexts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1context__ratio.html">context_ratio</a>&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of allowed decompression contexts. </p>

</div>
</div>
<a id="a858442ce1a27fefa99c6e7a699e69b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858442ce1a27fefa99c6e7a699e69b46">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release all unused memory, and compress all dirty blocks. This function does NOT invalidate iterators, except if an exception is thrown. Basic exception guarantee only. </p>

</div>
</div>
<a id="a3e302e50ce54f0a2d8b797443884e7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e302e50ce54f0a2d8b797443884e7c4">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1cvector.html#a082ccc184a493a23a6ad2d979fa5f0ab">size_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size. </p>

</div>
</div>
<a id="a82040616ef0f44c3e4f106855564142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82040616ef0f44c3e4f106855564142a">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1cvector.html">cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other sequence to swap with All iterators and references remain valid. An iterator holding the past-the-end value in this container will refer to the other container after the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad7958dcbe1fd2a306924e96344deb338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7958dcbe1fd2a306924e96344deb338">&#9670;&nbsp;</a></span>acc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::acc = Acceleration &gt; 7 ? 7 : Acceleration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2544822ebe3ca9fe51eaaab16abf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2544822ebe3ca9fe51eaaab16abf0dc">&#9670;&nbsp;</a></span>acceleration</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::acceleration = Acceleration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45d786b615987043cc5873317810d2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d786b615987043cc5873317810d2db">&#9670;&nbsp;</a></span>max_block_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, unsigned Acceleration = 0, class Encoder  = detail::DefaultEncoder, unsigned block_size = 256&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classseq_1_1cvector.html">seq::cvector</a>&lt; T, Allocator, Acceleration, Encoder, block_size &gt;::max_block_size = (<a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#a9c785f4c98049c345d4e1b6248d7a344">internal_type::elems_per_block</a> * sizeof(T)) - (<a class="el" href="structseq_1_1detail_1_1_compressed_vector_internal.html#a9c785f4c98049c345d4e1b6248d7a344">internal_type::elems_per_block</a> * sizeof(T)) / (10 - <a class="el" href="classseq_1_1cvector.html#ad7958dcbe1fd2a306924e96344deb338">acc</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="cvector_8hpp_source.html">cvector.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassseq_1_1cvector_html_a72d287e5d3889e4c2eac9fb69152b21a"><div class="ttname"><a href="classseq_1_1cvector.html#a72d287e5d3889e4c2eac9fb69152b21a">seq::cvector::end</a></div><div class="ttdeci">auto end() const noexcept -&gt; const_iterator</div><div class="ttdoc">Returns an iterator to the element following the last element of the cvector.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3086</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_a50758b4a5e9245f46b78a7fd0058deff"><div class="ttname"><a href="classseq_1_1cvector.html#a50758b4a5e9245f46b78a7fd0058deff">seq::cvector::for_each</a></div><div class="ttdeci">auto for_each(size_t start, size_t end, Functor fun) -&gt; Functor</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3109</div></div>
<div class="ttc" id="autils_8hpp_html"><div class="ttname"><a href="utils_8hpp.html">utils.hpp</a></div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_a61746d238bdf93e234e3bc1afa82e70a"><div class="ttname"><a href="classseq_1_1cvector.html#a61746d238bdf93e234e3bc1afa82e70a">seq::cvector::emplace_back</a></div><div class="ttdeci">auto emplace_back(Args &amp;&amp;... args) -&gt; ref_type</div><div class="ttdoc">Appends a new element to the end of the container.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:2901</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_a24a89b0ab698b706c242a0b18a6b267d"><div class="ttname"><a href="classseq_1_1cvector.html#a24a89b0ab698b706c242a0b18a6b267d">seq::cvector::block_count</a></div><div class="ttdeci">size_t block_count() const noexcept</div><div class="ttdoc">Returns the number of blocks. A block contains at most 256 elements.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3142</div></div>
<div class="ttc" id="anamespaceseq_html"><div class="ttname"><a href="namespaceseq.html">seq</a></div><div class="ttdef"><b>Definition:</b> any.hpp:58</div></div>
<div class="ttc" id="anamespaceseq_html_ae02fc574f6876f28fef03044ed31569e"><div class="ttname"><a href="namespaceseq.html#ae02fc574f6876f28fef03044ed31569e">seq::make_comparator</a></div><div class="ttdeci">auto make_comparator(const Comp &amp;comp) -&gt; comp_wrapper&lt; Comp &gt;</div><div class="ttdoc">Create a comparison functor that can be used by algorithms working on cvector objects.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3334</div></div>
<div class="ttc" id="acvector_8hpp_html"><div class="ttname"><a href="cvector_8hpp.html">cvector.hpp</a></div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_ae9f1c0d1f8ac8dd22cf1d5fdc6f79404"><div class="ttname"><a href="classseq_1_1cvector.html#ae9f1c0d1f8ac8dd22cf1d5fdc6f79404">seq::cvector::serialize</a></div><div class="ttdeci">std::ostream &amp; serialize(std::ostream &amp;oss)</div><div class="ttdoc">Serialize cvector content into a std::ostream object.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3182</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html"><div class="ttname"><a href="classseq_1_1cvector.html">seq::cvector</a></div><div class="ttdoc">vector like class using compression to store its elements</div><div class="ttdef"><b>Definition:</b> cvector.hpp:2518</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_a8f62e0efb88dffc0e5ae2d18b5960790"><div class="ttname"><a href="classseq_1_1cvector.html#a8f62e0efb88dffc0e5ae2d18b5960790">seq::cvector::current_compression_ratio</a></div><div class="ttdeci">auto current_compression_ratio() const noexcept -&gt; float</div><div class="ttdoc">Returns the current compression ratio, which is the total memory footprint of this container divided ...</div><div class="ttdef"><b>Definition:</b> cvector.hpp:2773</div></div>
<div class="ttc" id="anamespaceseq_html_ad863fcfc143b646f5a2f2362a1327575"><div class="ttname"><a href="namespaceseq.html#ad863fcfc143b646f5a2f2362a1327575">seq::tick</a></div><div class="ttdeci">void tick()</div><div class="ttdoc">For tests only, reset timer for calling thread.</div><div class="ttdef"><b>Definition:</b> testing.hpp:176</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_a11b2be12dbc2384b173641fe66618df2"><div class="ttname"><a href="classseq_1_1cvector.html#a11b2be12dbc2384b173641fe66618df2">seq::cvector::push_back</a></div><div class="ttdeci">void push_back(const T &amp;value)</div><div class="ttdoc">Appends the given element value to the end of the container.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:2880</div></div>
<div class="ttc" id="anamespaceseq_html_ad8b268bc53b846426ab17a84bb756fab"><div class="ttname"><a href="namespaceseq.html#ad8b268bc53b846426ab17a84bb756fab">seq::random_shuffle</a></div><div class="ttdeci">void random_shuffle(Iter begin, Iter end, uint_fast32_t seed=0)</div><div class="ttdoc">Similar to C++11 (and deprecated) std::random_shuffle.</div><div class="ttdef"><b>Definition:</b> testing.hpp:196</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_a80f09115258e1046f278a6daca7c6abf"><div class="ttname"><a href="classseq_1_1cvector.html#a80f09115258e1046f278a6daca7c6abf">seq::cvector::lock_block</a></div><div class="ttdeci">auto lock_block(size_t block_pos) -&gt; lock_guard&lt; spinlock &gt;</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3035</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_ac94708941b29d9913813e72ebaa0b190"><div class="ttname"><a href="classseq_1_1cvector.html#ac94708941b29d9913813e72ebaa0b190">seq::cvector::lock</a></div><div class="ttdeci">auto lock(size_t pos) -&gt; lock_guard&lt; spinlock &gt;</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3040</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_ac149f6d62d3dcc778d01f1663bb31e38"><div class="ttname"><a href="classseq_1_1cvector.html#ac149f6d62d3dcc778d01f1663bb31e38">seq::cvector::deserialize</a></div><div class="ttdeci">std::istream &amp; deserialize(std::istream &amp;iss)</div><div class="ttdoc">Deserialize cvector from a std::istream object. Previous content of the cvector is cleared.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3219</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_a96e3110c5a7986875f42d25b8d6d9246"><div class="ttname"><a href="classseq_1_1cvector.html#a96e3110c5a7986875f42d25b8d6d9246">seq::cvector::begin</a></div><div class="ttdeci">auto begin() const noexcept -&gt; const_iterator</div><div class="ttdoc">Returns an iterator to the first element of the cvector.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3082</div></div>
<div class="ttc" id="anamespaceseq_1_1detail_html_ae55afe416e41adc12918f3deb7b62d68"><div class="ttname"><a href="namespaceseq_1_1detail.html#ae55afe416e41adc12918f3deb7b62d68">seq::detail::saved</a></div><div class="ttdeci">Integral saved</div><div class="ttdef"><b>Definition:</b> charconv.hpp:704</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_a4731d7a2ae1961b78a48d1d47e5e38a7"><div class="ttname"><a href="classseq_1_1cvector.html#a4731d7a2ae1961b78a48d1d47e5e38a7">seq::cvector::mark_dirty_block</a></div><div class="ttdeci">void mark_dirty_block(size_t pos) noexcept</div><div class="ttdoc">Mark the block at given position as dirty. Call this function if you modified the block using block(p...</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3146</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_aa41490f1c68b5272783b217b54af71cf"><div class="ttname"><a href="classseq_1_1cvector.html#aa41490f1c68b5272783b217b54af71cf">seq::cvector::block</a></div><div class="ttdeci">std::pair&lt; const T *, unsigned &gt; block(size_t pos) const</div><div class="ttdoc">Returns a pair (block data pointer, block size) for given block position. This let you apply low leve...</div><div class="ttdef"><b>Definition:</b> cvector.hpp:3153</div></div>
<div class="ttc" id="aclassseq_1_1cvector_html_a3e302e50ce54f0a2d8b797443884e7c4"><div class="ttname"><a href="classseq_1_1cvector.html#a3e302e50ce54f0a2d8b797443884e7c4">seq::cvector::size</a></div><div class="ttdeci">auto size() const noexcept -&gt; size_type</div><div class="ttdoc">Returns the container size.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:2791</div></div>
<div class="ttc" id="anamespaceseq_html_a576ae74a514ded550299e48e4c32cc64"><div class="ttname"><a href="namespaceseq.html#a576ae74a514ded550299e48e4c32cc64">seq::tock_ms</a></div><div class="ttdeci">auto tock_ms() -&gt; std::uint64_t</div><div class="ttdoc">For tests only, returns elapsed milliseconds since last call to tick()</div><div class="ttdef"><b>Definition:</b> testing.hpp:188</div></div>
<div class="ttc" id="aclassseq_1_1lock__guard_html"><div class="ttname"><a href="classseq_1_1lock__guard.html">seq::lock_guard</a></div><div class="ttdoc">Basic lock guard class.</div><div class="ttdef"><b>Definition:</b> cvector.hpp:148</div></div>
<div class="ttc" id="atesting_8hpp_html"><div class="ttname"><a href="testing_8hpp.html">testing.hpp</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1cvector.html">cvector</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
