<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::tiered_vector&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classseq_1_1tiered__vector.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseq_1_1tiered__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::tiered_vector&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> is a std::deque like container implemented as a tiered-vector.  
 <a href="classseq_1_1tiered__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tiered__vector_8hpp_source.html">tiered_vector.hpp</a>&gt;</code></p>

<p>Inherits Allocator.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2aaa20913d8c2931c7da304f3212d92b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classseq_1_1tiered__vector.html#a2aaa20913d8c2931c7da304f3212d92ba1a939f2c09253547e3fff0d8506a145e">min_block_size</a> = static_cast&lt;detail::cbuffer_pos&gt;(MinBSize)
 }</td></tr>
<tr class="separator:a2aaa20913d8c2931c7da304f3212d92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3a30b4551e883840e879364d2aa0a0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a> = <a class="el" href="structseq_1_1detail_1_1_bucket_manager.html">detail::BucketManager</a>&lt; T, Allocator, <a class="el" href="classseq_1_1tiered__vector.html#a2aaa20913d8c2931c7da304f3212d92ba1a939f2c09253547e3fff0d8506a145e">min_block_size</a>, max_block_size, StoreBackValues, ValueCompare &gt;</td></tr>
<tr class="separator:a2a3a30b4551e883840e879364d2aa0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618a9457a81653ec4feb8cf6ff28878b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a618a9457a81653ec4feb8cf6ff28878b">alloc_traits</a> = std::allocator_traits&lt; Allocator &gt;</td></tr>
<tr class="separator:a618a9457a81653ec4feb8cf6ff28878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c1330ed37e666fdb014a1333183cae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a08c1330ed37e666fdb014a1333183cae">this_type</a> = <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&lt; T, Allocator, <a class="el" href="classseq_1_1tiered__vector.html#a2aaa20913d8c2931c7da304f3212d92ba1a939f2c09253547e3fff0d8506a145e">min_block_size</a>, max_block_size, FindBSize, StoreBackValues, ValueCompare &gt;</td></tr>
<tr class="separator:a08c1330ed37e666fdb014a1333183cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2051ba26f6c5ee2ab263b4740cd4a11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aa2051ba26f6c5ee2ab263b4740cd4a11">find_bsize_type</a> = FindBSize</td></tr>
<tr class="separator:aa2051ba26f6c5ee2ab263b4740cd4a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe75a7d0109781d3477d8c30d3deac9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a8fe75a7d0109781d3477d8c30d3deac9">value_type</a> = T</td></tr>
<tr class="separator:a8fe75a7d0109781d3477d8c30d3deac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9d2a9d199801b2f3e61497fd4ec329"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a5a9d2a9d199801b2f3e61497fd4ec329">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a5a9d2a9d199801b2f3e61497fd4ec329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76d00258293233d34992d238b99cf87"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> = typename alloc_traits::size_type</td></tr>
<tr class="separator:ac76d00258293233d34992d238b99cf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac769f5d9fcbb702dc39baa87095fce2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ac769f5d9fcbb702dc39baa87095fce2c">difference_type</a> = typename alloc_traits::difference_type</td></tr>
<tr class="separator:ac769f5d9fcbb702dc39baa87095fce2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7534c050a80898036d6289f375a7480c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a7534c050a80898036d6289f375a7480c">pointer</a> = typename alloc_traits::pointer</td></tr>
<tr class="separator:a7534c050a80898036d6289f375a7480c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20706ad570fbd7d6ef16817e755bd249"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a20706ad570fbd7d6ef16817e755bd249">const_pointer</a> = typename alloc_traits::const_pointer</td></tr>
<tr class="separator:a20706ad570fbd7d6ef16817e755bd249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b6ecceb136a1ca151b4c0fd07f28ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aa0b6ecceb136a1ca151b4c0fd07f28ca">reference</a> = <a class="el" href="classseq_1_1tiered__vector.html#a8fe75a7d0109781d3477d8c30d3deac9">value_type</a> &amp;</td></tr>
<tr class="separator:aa0b6ecceb136a1ca151b4c0fd07f28ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2256291ff1ecd78cba07efe32aae3473"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a2256291ff1ecd78cba07efe32aae3473">const_reference</a> = const <a class="el" href="classseq_1_1tiered__vector.html#a8fe75a7d0109781d3477d8c30d3deac9">value_type</a> &amp;</td></tr>
<tr class="separator:a2256291ff1ecd78cba07efe32aae3473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dcd64bfba5cfefb45326174cbda4a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a> = <a class="el" href="structseq_1_1detail_1_1deque__iterator.html">detail::deque_iterator</a>&lt; <a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a> &gt;</td></tr>
<tr class="separator:a95dcd64bfba5cfefb45326174cbda4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae069568dee521495754c4fbd77461e5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> = <a class="el" href="structseq_1_1detail_1_1deque__const__iterator.html">detail::deque_const_iterator</a>&lt; <a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a> &gt;</td></tr>
<tr class="separator:ae069568dee521495754c4fbd77461e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843aeaf7d835a2f128fadfadcf46cd14"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a843aeaf7d835a2f128fadfadcf46cd14">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a> &gt;</td></tr>
<tr class="separator:a843aeaf7d835a2f128fadfadcf46cd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b832aafa9d019a441d300eb301e5b3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> &gt;</td></tr>
<tr class="separator:a6b832aafa9d019a441d300eb301e5b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a616327459ff47b3d2e39bfeecb4da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a56a616327459ff47b3d2e39bfeecb4da">value_compare</a> = ValueCompare</td></tr>
<tr class="separator:a56a616327459ff47b3d2e39bfeecb4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a022faff2efaab3fa6b50e74281605a19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a022faff2efaab3fa6b50e74281605a19">tiered_vector</a> ()</td></tr>
<tr class="memdesc:a022faff2efaab3fa6b50e74281605a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, initialize the internal bucket manager.  <a href="#a022faff2efaab3fa6b50e74281605a19">More...</a><br /></td></tr>
<tr class="separator:a022faff2efaab3fa6b50e74281605a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4343b5c158c9b670792f27a9e82cd5ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a4343b5c158c9b670792f27a9e82cd5ce">tiered_vector</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a4343b5c158c9b670792f27a9e82cd5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given allocator alloc.  <a href="#a4343b5c158c9b670792f27a9e82cd5ce">More...</a><br /></td></tr>
<tr class="separator:a4343b5c158c9b670792f27a9e82cd5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39529d8733f28c703007a1091db3deaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a39529d8733f28c703007a1091db3deaf">tiered_vector</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> count, const T &amp;value, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a39529d8733f28c703007a1091db3deaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with <em>count</em> copies of elements with value <em>value</em>.  <a href="#a39529d8733f28c703007a1091db3deaf">More...</a><br /></td></tr>
<tr class="separator:a39529d8733f28c703007a1091db3deaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3869841b247e6440d5e35e3187230c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#af3869841b247e6440d5e35e3187230c1">tiered_vector</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> count, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:af3869841b247e6440d5e35e3187230c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count default-inserted instances of T. No copies are made.  <a href="#af3869841b247e6440d5e35e3187230c1">More...</a><br /></td></tr>
<tr class="separator:af3869841b247e6440d5e35e3187230c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f2fae8d15a25ae0c6a0a865ad53090"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a43f2fae8d15a25ae0c6a0a865ad53090">tiered_vector</a> (const <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> &amp;other)</td></tr>
<tr class="memdesc:a43f2fae8d15a25ae0c6a0a865ad53090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other.  <a href="#a43f2fae8d15a25ae0c6a0a865ad53090">More...</a><br /></td></tr>
<tr class="separator:a43f2fae8d15a25ae0c6a0a865ad53090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5b2d4c8271684585fac7aa30d4ab8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a9cf5b2d4c8271684585fac7aa30d4ab8">tiered_vector</a> (const <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a9cf5b2d4c8271684585fac7aa30d4ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the copy of the contents of other, using alloc as the allocator.  <a href="#a9cf5b2d4c8271684585fac7aa30d4ab8">More...</a><br /></td></tr>
<tr class="separator:a9cf5b2d4c8271684585fac7aa30d4ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c33db644cf3af27dbfd7d5896b9aa3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a9c33db644cf3af27dbfd7d5896b9aa3b">tiered_vector</a> (<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a9c33db644cf3af27dbfd7d5896b9aa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other.  <a href="#a9c33db644cf3af27dbfd7d5896b9aa3b">More...</a><br /></td></tr>
<tr class="separator:a9c33db644cf3af27dbfd7d5896b9aa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf7e01431d9f4d8e34b0b43afe7ab95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a4cf7e01431d9f4d8e34b0b43afe7ab95">tiered_vector</a> (<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a4cf7e01431d9f4d8e34b0b43afe7ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move.  <a href="#a4cf7e01431d9f4d8e34b0b43afe7ab95">More...</a><br /></td></tr>
<tr class="separator:a4cf7e01431d9f4d8e34b0b43afe7ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dbe29c3cdfee305cb70d02304600a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a05dbe29c3cdfee305cb70d02304600a4">tiered_vector</a> (const std::initializer_list&lt; T &gt; &amp;lst, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a05dbe29c3cdfee305cb70d02304600a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list <em>init</em>.  <a href="#a05dbe29c3cdfee305cb70d02304600a4">More...</a><br /></td></tr>
<tr class="separator:a05dbe29c3cdfee305cb70d02304600a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7c0e33a5c6960851bbb99956e4f5c8"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:aed7c0e33a5c6960851bbb99956e4f5c8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aed7c0e33a5c6960851bbb99956e4f5c8">tiered_vector</a> (Iter first, Iter last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:aed7c0e33a5c6960851bbb99956e4f5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="#aed7c0e33a5c6960851bbb99956e4f5c8">More...</a><br /></td></tr>
<tr class="separator:aed7c0e33a5c6960851bbb99956e4f5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be33eb61a4efe67e85b22157816ede1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a6be33eb61a4efe67e85b22157816ede1">~tiered_vector</a> ()</td></tr>
<tr class="memdesc:a6be33eb61a4efe67e85b22157816ede1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a6be33eb61a4efe67e85b22157816ede1">More...</a><br /></td></tr>
<tr class="separator:a6be33eb61a4efe67e85b22157816ede1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bf2bd99d1c1a25bf13f2fb9d781ee4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ac6bf2bd99d1c1a25bf13f2fb9d781ee4">operator=</a> (<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> &amp;</td></tr>
<tr class="memdesc:ac6bf2bd99d1c1a25bf13f2fb9d781ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#ac6bf2bd99d1c1a25bf13f2fb9d781ee4">More...</a><br /></td></tr>
<tr class="separator:ac6bf2bd99d1c1a25bf13f2fb9d781ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184c566eec6f77dd14a31ec713022678"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a184c566eec6f77dd14a31ec713022678">operator=</a> (const <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> &amp;other) -&gt; <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> &amp;</td></tr>
<tr class="memdesc:a184c566eec6f77dd14a31ec713022678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a184c566eec6f77dd14a31ec713022678">More...</a><br /></td></tr>
<tr class="separator:a184c566eec6f77dd14a31ec713022678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0043f77c7d8b1dc44d599ca746484"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a7ec0043f77c7d8b1dc44d599ca746484">manager</a> () noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a> *</td></tr>
<tr class="memdesc:a7ec0043f77c7d8b1dc44d599ca746484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal bucket manager object.  <a href="#a7ec0043f77c7d8b1dc44d599ca746484">More...</a><br /></td></tr>
<tr class="separator:a7ec0043f77c7d8b1dc44d599ca746484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87165ea5dab19f2c1331307e25e97780"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a87165ea5dab19f2c1331307e25e97780">manager</a> () const noexcept -&gt; const <a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a> *</td></tr>
<tr class="memdesc:a87165ea5dab19f2c1331307e25e97780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal bucket manager object.  <a href="#a87165ea5dab19f2c1331307e25e97780">More...</a><br /></td></tr>
<tr class="separator:a87165ea5dab19f2c1331307e25e97780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bd66c9760bf899b96e6972b9ce072c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#af5bd66c9760bf899b96e6972b9ce072c">size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a></td></tr>
<tr class="memdesc:af5bd66c9760bf899b96e6972b9ce072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size.  <a href="#af5bd66c9760bf899b96e6972b9ce072c">More...</a><br /></td></tr>
<tr class="separator:af5bd66c9760bf899b96e6972b9ce072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79618f2e2c05e7cdfb6bb367b75e3976"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a79618f2e2c05e7cdfb6bb367b75e3976">max_size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a></td></tr>
<tr class="memdesc:a79618f2e2c05e7cdfb6bb367b75e3976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size.  <a href="#a79618f2e2c05e7cdfb6bb367b75e3976">More...</a><br /></td></tr>
<tr class="separator:a79618f2e2c05e7cdfb6bb367b75e3976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d8b0cecc83a1893b589295a69fcaf2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ac2d8b0cecc83a1893b589295a69fcaf2">bucket_count</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a></td></tr>
<tr class="memdesc:ac2d8b0cecc83a1893b589295a69fcaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of buckets within <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>.  <a href="#ac2d8b0cecc83a1893b589295a69fcaf2">More...</a><br /></td></tr>
<tr class="separator:ac2d8b0cecc83a1893b589295a69fcaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc0614762dffc54229aeb04cc4d7db4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a6fc0614762dffc54229aeb04cc4d7db4">bucket_size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a></td></tr>
<tr class="memdesc:a6fc0614762dffc54229aeb04cc4d7db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a bucket within <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>.  <a href="#a6fc0614762dffc54229aeb04cc4d7db4">More...</a><br /></td></tr>
<tr class="separator:a6fc0614762dffc54229aeb04cc4d7db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff396e369049c5b13c301997e8e8134"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a1ff396e369049c5b13c301997e8e8134">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a1ff396e369049c5b13c301997e8e8134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retruns true if the container is empty, false otherwise.  <a href="#a1ff396e369049c5b13c301997e8e8134">More...</a><br /></td></tr>
<tr class="separator:a1ff396e369049c5b13c301997e8e8134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa57840688e5703758c53cd88cc825a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#afaa57840688e5703758c53cd88cc825a">get_allocator</a> () const noexcept -&gt; const Allocator &amp;</td></tr>
<tr class="memdesc:afaa57840688e5703758c53cd88cc825a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="#afaa57840688e5703758c53cd88cc825a">More...</a><br /></td></tr>
<tr class="separator:afaa57840688e5703758c53cd88cc825a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560d14ef82cd24db8faaecfdeb8b2f56"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a560d14ef82cd24db8faaecfdeb8b2f56">get_allocator</a> () noexcept -&gt; Allocator &amp;</td></tr>
<tr class="memdesc:a560d14ef82cd24db8faaecfdeb8b2f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="#a560d14ef82cd24db8faaecfdeb8b2f56">More...</a><br /></td></tr>
<tr class="separator:a560d14ef82cd24db8faaecfdeb8b2f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1047948f13a1d0460c4b0a540bc4506b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a1047948f13a1d0460c4b0a540bc4506b">swap</a> (<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a1047948f13a1d0460c4b0a540bc4506b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.  <a href="#a1047948f13a1d0460c4b0a540bc4506b">More...</a><br /></td></tr>
<tr class="separator:a1047948f13a1d0460c4b0a540bc4506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6e5e16acaab480ad50ec617cb4ec0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a8e6e5e16acaab480ad50ec617cb4ec0e">resize</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> count)</td></tr>
<tr class="memdesc:a8e6e5e16acaab480ad50ec617cb4ec0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="#a8e6e5e16acaab480ad50ec617cb4ec0e">More...</a><br /></td></tr>
<tr class="separator:a8e6e5e16acaab480ad50ec617cb4ec0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc55317d437781eb0dceb7d0b380663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a5bc55317d437781eb0dceb7d0b380663">resize</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a5bc55317d437781eb0dceb7d0b380663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="#a5bc55317d437781eb0dceb7d0b380663">More...</a><br /></td></tr>
<tr class="separator:a5bc55317d437781eb0dceb7d0b380663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b2e4afd87b5e605b7a1bcc030ba9ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a17b2e4afd87b5e605b7a1bcc030ba9ca">resize_front</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> count)</td></tr>
<tr class="memdesc:a17b2e4afd87b5e605b7a1bcc030ba9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="#a17b2e4afd87b5e605b7a1bcc030ba9ca">More...</a><br /></td></tr>
<tr class="separator:a17b2e4afd87b5e605b7a1bcc030ba9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa692149cfcf02a18fe192a785b8e43d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aa692149cfcf02a18fe192a785b8e43d1">resize_front</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:aa692149cfcf02a18fe192a785b8e43d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="#aa692149cfcf02a18fe192a785b8e43d1">More...</a><br /></td></tr>
<tr class="separator:aa692149cfcf02a18fe192a785b8e43d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be758d5c112c43ef661f56f35ce1ecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a7be758d5c112c43ef661f56f35ce1ecd">clear</a> () noexcept</td></tr>
<tr class="memdesc:a7be758d5c112c43ef661f56f35ce1ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the container.  <a href="#a7be758d5c112c43ef661f56f35ce1ecd">More...</a><br /></td></tr>
<tr class="separator:a7be758d5c112c43ef661f56f35ce1ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad854917c4164207da523988af631d260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ad854917c4164207da523988af631d260">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ad854917c4164207da523988af631d260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <a href="#ad854917c4164207da523988af631d260">More...</a><br /></td></tr>
<tr class="separator:ad854917c4164207da523988af631d260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fc3fdfcb60e3dacd66dbd4db92abe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ae8fc3fdfcb60e3dacd66dbd4db92abe9">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:ae8fc3fdfcb60e3dacd66dbd4db92abe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container using move semantic.  <a href="#ae8fc3fdfcb60e3dacd66dbd4db92abe9">More...</a><br /></td></tr>
<tr class="separator:ae8fc3fdfcb60e3dacd66dbd4db92abe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fc6847bfa96a5da6d9229fc85e3c89"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a30fc6847bfa96a5da6d9229fc85e3c89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a30fc6847bfa96a5da6d9229fc85e3c89">emplace_back</a> (Args &amp;&amp;... args) -&gt; T &amp;</td></tr>
<tr class="memdesc:a30fc6847bfa96a5da6d9229fc85e3c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the end of the container.  <a href="#a30fc6847bfa96a5da6d9229fc85e3c89">More...</a><br /></td></tr>
<tr class="separator:a30fc6847bfa96a5da6d9229fc85e3c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f15440419bd04239cf5a743a873185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a24f15440419bd04239cf5a743a873185">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a24f15440419bd04239cf5a743a873185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the beginning of the container.  <a href="#a24f15440419bd04239cf5a743a873185">More...</a><br /></td></tr>
<tr class="separator:a24f15440419bd04239cf5a743a873185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d1cebc0f569c0fff80c74aef5a573a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a94d1cebc0f569c0fff80c74aef5a573a">push_front</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a94d1cebc0f569c0fff80c74aef5a573a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the beginning of the container using move semantic.  <a href="#a94d1cebc0f569c0fff80c74aef5a573a">More...</a><br /></td></tr>
<tr class="separator:a94d1cebc0f569c0fff80c74aef5a573a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dda03081a6c22bd4f35722732835e87"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a3dda03081a6c22bd4f35722732835e87"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a3dda03081a6c22bd4f35722732835e87">emplace_front</a> (Args &amp;&amp;... args) -&gt; T &amp;</td></tr>
<tr class="memdesc:a3dda03081a6c22bd4f35722732835e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the beginning of the container.  <a href="#a3dda03081a6c22bd4f35722732835e87">More...</a><br /></td></tr>
<tr class="separator:a3dda03081a6c22bd4f35722732835e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7603212eeabc9b1944ad474966dd8574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a7603212eeabc9b1944ad474966dd8574">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a7603212eeabc9b1944ad474966dd8574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>pos</em>.  <a href="#a7603212eeabc9b1944ad474966dd8574">More...</a><br /></td></tr>
<tr class="separator:a7603212eeabc9b1944ad474966dd8574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eab026c5e9d7856f81dbe61e659eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a35eab026c5e9d7856f81dbe61e659eea">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a35eab026c5e9d7856f81dbe61e659eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>pos</em> using move semantic.  <a href="#a35eab026c5e9d7856f81dbe61e659eea">More...</a><br /></td></tr>
<tr class="separator:a35eab026c5e9d7856f81dbe61e659eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488e8452aba972f8de4ada5027e49861"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a488e8452aba972f8de4ada5027e49861">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> it, const T &amp;value) -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:a488e8452aba972f8de4ada5027e49861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>it</em>.  <a href="#a488e8452aba972f8de4ada5027e49861">More...</a><br /></td></tr>
<tr class="separator:a488e8452aba972f8de4ada5027e49861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1611fe4689cc6f2fc0df08f960ef1543"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a1611fe4689cc6f2fc0df08f960ef1543">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> it, T &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:a1611fe4689cc6f2fc0df08f960ef1543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>value</em> before <em>it</em> using move semantic.  <a href="#a1611fe4689cc6f2fc0df08f960ef1543">More...</a><br /></td></tr>
<tr class="separator:a1611fe4689cc6f2fc0df08f960ef1543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa148acfe7398b904b97024977fdf3e8d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa148acfe7398b904b97024977fdf3e8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aa148acfe7398b904b97024977fdf3e8d">emplace</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, Args &amp;&amp;... args) -&gt; T &amp;</td></tr>
<tr class="memdesc:aa148acfe7398b904b97024977fdf3e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before <em>pos</em>.  <a href="#aa148acfe7398b904b97024977fdf3e8d">More...</a><br /></td></tr>
<tr class="separator:aa148acfe7398b904b97024977fdf3e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff4036521babbb99dcaf0e27ffcb4d9"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aaff4036521babbb99dcaf0e27ffcb4d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aaff4036521babbb99dcaf0e27ffcb4d9">emplace</a> (<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, Args &amp;&amp;... args) -&gt; T &amp;</td></tr>
<tr class="memdesc:aaff4036521babbb99dcaf0e27ffcb4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before <em>pos</em>.  <a href="#aaff4036521babbb99dcaf0e27ffcb4d9">More...</a><br /></td></tr>
<tr class="separator:aaff4036521babbb99dcaf0e27ffcb4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a9f1989e0b9025d56b1e7bca0a4f10"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:af0a9f1989e0b9025d56b1e7bca0a4f10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#af0a9f1989e0b9025d56b1e7bca0a4f10">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, Iter first, Iter last)</td></tr>
<tr class="memdesc:af0a9f1989e0b9025d56b1e7bca0a4f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos.  <a href="#af0a9f1989e0b9025d56b1e7bca0a4f10">More...</a><br /></td></tr>
<tr class="separator:af0a9f1989e0b9025d56b1e7bca0a4f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e58ea729f55b2eee082939adfb8f61d"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a0e58ea729f55b2eee082939adfb8f61d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a0e58ea729f55b2eee082939adfb8f61d">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> it, Iter first, Iter last) -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:a0e58ea729f55b2eee082939adfb8f61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before it.  <a href="#a0e58ea729f55b2eee082939adfb8f61d">More...</a><br /></td></tr>
<tr class="separator:a0e58ea729f55b2eee082939adfb8f61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae449f514b4872588fbf31b8cc29200cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ae449f514b4872588fbf31b8cc29200cf">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:ae449f514b4872588fbf31b8cc29200cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist before pos.  <a href="#ae449f514b4872588fbf31b8cc29200cf">More...</a><br /></td></tr>
<tr class="separator:ae449f514b4872588fbf31b8cc29200cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69190f3ca867bae1d21494cb668efc94"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a69190f3ca867bae1d21494cb668efc94">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, std::initializer_list&lt; T &gt; ilist) -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:a69190f3ca867bae1d21494cb668efc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist before pos.  <a href="#a69190f3ca867bae1d21494cb668efc94">More...</a><br /></td></tr>
<tr class="separator:a69190f3ca867bae1d21494cb668efc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9d7bd66ff1f096f9b17fd3d5e28afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a7f9d7bd66ff1f096f9b17fd3d5e28afe">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a7f9d7bd66ff1f096f9b17fd3d5e28afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before pos Basic exception guarantee.  <a href="#a7f9d7bd66ff1f096f9b17fd3d5e28afe">More...</a><br /></td></tr>
<tr class="separator:a7f9d7bd66ff1f096f9b17fd3d5e28afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11aad38f1a8f5ab99082a1c5bf6152b6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a11aad38f1a8f5ab99082a1c5bf6152b6">insert</a> (<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>, <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> count, const T &amp;value) -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:a11aad38f1a8f5ab99082a1c5bf6152b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before pos.  <a href="#a11aad38f1a8f5ab99082a1c5bf6152b6">More...</a><br /></td></tr>
<tr class="separator:a11aad38f1a8f5ab99082a1c5bf6152b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6facad675e66ae264ab88e3338dd534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ab6facad675e66ae264ab88e3338dd534">pop_back</a> ()</td></tr>
<tr class="memdesc:ab6facad675e66ae264ab88e3338dd534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container. Calling pop_back on an empty container results in undefined behavior. Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case).  <a href="#ab6facad675e66ae264ab88e3338dd534">More...</a><br /></td></tr>
<tr class="separator:ab6facad675e66ae264ab88e3338dd534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4de39daf7ecaef915981d9533832b61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#af4de39daf7ecaef915981d9533832b61">pop_front</a> ()</td></tr>
<tr class="memdesc:af4de39daf7ecaef915981d9533832b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of the container. Calling pop_front on an empty container results in undefined behavior. Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case).  <a href="#af4de39daf7ecaef915981d9533832b61">More...</a><br /></td></tr>
<tr class="separator:af4de39daf7ecaef915981d9533832b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5433a59411f0332c69ea29203737d4b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a5433a59411f0332c69ea29203737d4b5">erase</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>)</td></tr>
<tr class="memdesc:a5433a59411f0332c69ea29203737d4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given position.  <a href="#a5433a59411f0332c69ea29203737d4b5">More...</a><br /></td></tr>
<tr class="separator:a5433a59411f0332c69ea29203737d4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad64788bacd4a4c3eb572b56ca46140"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#afad64788bacd4a4c3eb572b56ca46140">erase</a> (<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> it) -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:afad64788bacd4a4c3eb572b56ca46140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given position.  <a href="#afad64788bacd4a4c3eb572b56ca46140">More...</a><br /></td></tr>
<tr class="separator:afad64788bacd4a4c3eb572b56ca46140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0a6da94b6fba8c91c8998625b1895e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a6c0a6da94b6fba8c91c8998625b1895e">erase</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> first, <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> last)</td></tr>
<tr class="memdesc:a6c0a6da94b6fba8c91c8998625b1895e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last).  <a href="#a6c0a6da94b6fba8c91c8998625b1895e">More...</a><br /></td></tr>
<tr class="separator:a6c0a6da94b6fba8c91c8998625b1895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c33b9b15845961b7c83764b27ed8d7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aa4c33b9b15845961b7c83764b27ed8d7">erase</a> (<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> first, <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> last) -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:aa4c33b9b15845961b7c83764b27ed8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last).  <a href="#aa4c33b9b15845961b7c83764b27ed8d7">More...</a><br /></td></tr>
<tr class="separator:aa4c33b9b15845961b7c83764b27ed8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978589fc9485a7c88190eb6bd677b5d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a978589fc9485a7c88190eb6bd677b5d2">assign</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a978589fc9485a7c88190eb6bd677b5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with <em>count</em> copies of value <em>value</em> Basic exception guarantee.  <a href="#a978589fc9485a7c88190eb6bd677b5d2">More...</a><br /></td></tr>
<tr class="separator:a978589fc9485a7c88190eb6bd677b5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8888799f8dd1b6e24d65758dd2b091af"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a8888799f8dd1b6e24d65758dd2b091af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a8888799f8dd1b6e24d65758dd2b091af">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:a8888799f8dd1b6e24d65758dd2b091af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with copies of those in the range [first, last). The behavior is undefined if either argument is an iterator into *this. Basic exception guarantee.  <a href="#a8888799f8dd1b6e24d65758dd2b091af">More...</a><br /></td></tr>
<tr class="separator:a8888799f8dd1b6e24d65758dd2b091af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aad5706f2a1f811ac9a3f8e64d93ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a8aad5706f2a1f811ac9a3f8e64d93ace">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a8aad5706f2a1f811ac9a3f8e64d93ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list ilist. Basic exception guarantee.  <a href="#a8aad5706f2a1f811ac9a3f8e64d93ace">More...</a><br /></td></tr>
<tr class="separator:a8aad5706f2a1f811ac9a3f8e64d93ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300895f6485fbba603b5b1d53db0f58d"><td class="memTemplParams" colspan="2">template&lt;class Fun &gt; </td></tr>
<tr class="memitem:a300895f6485fbba603b5b1d53db0f58d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a300895f6485fbba603b5b1d53db0f58d">for_each</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> first, <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> last, Fun fun) -&gt; Fun</td></tr>
<tr class="memdesc:a300895f6485fbba603b5b1d53db0f58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply unary function <em>fun</em> to all elements within the range [first,last).  <a href="#a300895f6485fbba603b5b1d53db0f58d">More...</a><br /></td></tr>
<tr class="separator:a300895f6485fbba603b5b1d53db0f58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d06c6086cafa5a45c8e59f6e372cbac"><td class="memTemplParams" colspan="2">template&lt;class Fun &gt; </td></tr>
<tr class="memitem:a7d06c6086cafa5a45c8e59f6e372cbac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a7d06c6086cafa5a45c8e59f6e372cbac">for_each</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> first, <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> last, Fun fun) const -&gt; Fun</td></tr>
<tr class="memdesc:a7d06c6086cafa5a45c8e59f6e372cbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply unary function <em>fun</em> to all elements within the range [first,last).  <a href="#a7d06c6086cafa5a45c8e59f6e372cbac">More...</a><br /></td></tr>
<tr class="separator:a7d06c6086cafa5a45c8e59f6e372cbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5a52831c4530ebf4c814ed12b58e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a4f5a52831c4530ebf4c814ed12b58e38">at</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) const -&gt; const T &amp;</td></tr>
<tr class="memdesc:a4f5a52831c4530ebf4c814ed12b58e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <a href="#a4f5a52831c4530ebf4c814ed12b58e38">More...</a><br /></td></tr>
<tr class="separator:a4f5a52831c4530ebf4c814ed12b58e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abeb2a225f5c0405784fd12201379f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a1abeb2a225f5c0405784fd12201379f0">at</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) -&gt; T &amp;</td></tr>
<tr class="memdesc:a1abeb2a225f5c0405784fd12201379f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <a href="#a1abeb2a225f5c0405784fd12201379f0">More...</a><br /></td></tr>
<tr class="separator:a1abeb2a225f5c0405784fd12201379f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c4f111e47b00012752410ea9349824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a58c4f111e47b00012752410ea9349824">operator[]</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) const noexcept -&gt; const T &amp;</td></tr>
<tr class="memdesc:a58c4f111e47b00012752410ea9349824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, without bounds checking.  <a href="#a58c4f111e47b00012752410ea9349824">More...</a><br /></td></tr>
<tr class="separator:a58c4f111e47b00012752410ea9349824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d52ff7a8509c102a492799986154f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a51d52ff7a8509c102a492799986154f7">operator[]</a> (<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:a51d52ff7a8509c102a492799986154f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, without bounds checking.  <a href="#a51d52ff7a8509c102a492799986154f7">More...</a><br /></td></tr>
<tr class="separator:a51d52ff7a8509c102a492799986154f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6335559c2fcc5adc2fe22dbe57cc59f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a6335559c2fcc5adc2fe22dbe57cc59f3">back</a> () noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:a6335559c2fcc5adc2fe22dbe57cc59f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a6335559c2fcc5adc2fe22dbe57cc59f3">More...</a><br /></td></tr>
<tr class="separator:a6335559c2fcc5adc2fe22dbe57cc59f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac347ad9347e7051c6a2d705d7e0e4d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ac347ad9347e7051c6a2d705d7e0e4d09">back</a> () const noexcept -&gt; const T &amp;</td></tr>
<tr class="memdesc:ac347ad9347e7051c6a2d705d7e0e4d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#ac347ad9347e7051c6a2d705d7e0e4d09">More...</a><br /></td></tr>
<tr class="separator:ac347ad9347e7051c6a2d705d7e0e4d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9985779f6066f42d47f9534cd2e47114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a9985779f6066f42d47f9534cd2e47114">front</a> () noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:a9985779f6066f42d47f9534cd2e47114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#a9985779f6066f42d47f9534cd2e47114">More...</a><br /></td></tr>
<tr class="separator:a9985779f6066f42d47f9534cd2e47114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eccdd60668f63797eb5b05ccb9b8956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a7eccdd60668f63797eb5b05ccb9b8956">front</a> () const noexcept -&gt; const T &amp;</td></tr>
<tr class="memdesc:a7eccdd60668f63797eb5b05ccb9b8956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#a7eccdd60668f63797eb5b05ccb9b8956">More...</a><br /></td></tr>
<tr class="separator:a7eccdd60668f63797eb5b05ccb9b8956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3910890acc2c286134c18ec11bcf710f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a3910890acc2c286134c18ec11bcf710f">begin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a></td></tr>
<tr class="memdesc:a3910890acc2c286134c18ec11bcf710f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>.  <a href="#a3910890acc2c286134c18ec11bcf710f">More...</a><br /></td></tr>
<tr class="separator:a3910890acc2c286134c18ec11bcf710f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cc90aa73560716ce5d6f25aafc038e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ac0cc90aa73560716ce5d6f25aafc038e">begin</a> () noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:ac0cc90aa73560716ce5d6f25aafc038e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>.  <a href="#ac0cc90aa73560716ce5d6f25aafc038e">More...</a><br /></td></tr>
<tr class="separator:ac0cc90aa73560716ce5d6f25aafc038e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5d833d3ec544b3de005b2dc10aa167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#afe5d833d3ec544b3de005b2dc10aa167">end</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a></td></tr>
<tr class="memdesc:afe5d833d3ec544b3de005b2dc10aa167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>.  <a href="#afe5d833d3ec544b3de005b2dc10aa167">More...</a><br /></td></tr>
<tr class="separator:afe5d833d3ec544b3de005b2dc10aa167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fd2c3f9fb5191a5610209179d9d9cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a86fd2c3f9fb5191a5610209179d9d9cb">end</a> () noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:a86fd2c3f9fb5191a5610209179d9d9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>.  <a href="#a86fd2c3f9fb5191a5610209179d9d9cb">More...</a><br /></td></tr>
<tr class="separator:a86fd2c3f9fb5191a5610209179d9d9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe0bc2beca3fc8bf9035157509e4238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aebe0bc2beca3fc8bf9035157509e4238">rbegin</a> () noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a843aeaf7d835a2f128fadfadcf46cd14">reverse_iterator</a></td></tr>
<tr class="memdesc:aebe0bc2beca3fc8bf9035157509e4238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="#aebe0bc2beca3fc8bf9035157509e4238">More...</a><br /></td></tr>
<tr class="separator:aebe0bc2beca3fc8bf9035157509e4238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6693994a142c5fc5d507cb98fd5e1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aba6693994a142c5fc5d507cb98fd5e1e">rbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aba6693994a142c5fc5d507cb98fd5e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="#aba6693994a142c5fc5d507cb98fd5e1e">More...</a><br /></td></tr>
<tr class="separator:aba6693994a142c5fc5d507cb98fd5e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40918ba16513ef4515d0242258224aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a40918ba16513ef4515d0242258224aff">rend</a> () noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a843aeaf7d835a2f128fadfadcf46cd14">reverse_iterator</a></td></tr>
<tr class="memdesc:a40918ba16513ef4515d0242258224aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="#a40918ba16513ef4515d0242258224aff">More...</a><br /></td></tr>
<tr class="separator:a40918ba16513ef4515d0242258224aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bd2f8b942000d01584495e1a64e594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ae8bd2f8b942000d01584495e1a64e594">rend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ae8bd2f8b942000d01584495e1a64e594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="#ae8bd2f8b942000d01584495e1a64e594">More...</a><br /></td></tr>
<tr class="separator:ae8bd2f8b942000d01584495e1a64e594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072bda5f08a06b36faa758dfa6f33937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a072bda5f08a06b36faa758dfa6f33937">cbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a></td></tr>
<tr class="memdesc:a072bda5f08a06b36faa758dfa6f33937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>.  <a href="#a072bda5f08a06b36faa758dfa6f33937">More...</a><br /></td></tr>
<tr class="separator:a072bda5f08a06b36faa758dfa6f33937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8648700cbb648db2d568d66abcadd668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a8648700cbb648db2d568d66abcadd668">cend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a></td></tr>
<tr class="memdesc:a8648700cbb648db2d568d66abcadd668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>.  <a href="#a8648700cbb648db2d568d66abcadd668">More...</a><br /></td></tr>
<tr class="separator:a8648700cbb648db2d568d66abcadd668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915c823dc7d4820da970e4498dae1301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a915c823dc7d4820da970e4498dae1301">crbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a915c823dc7d4820da970e4498dae1301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="#a915c823dc7d4820da970e4498dae1301">More...</a><br /></td></tr>
<tr class="separator:a915c823dc7d4820da970e4498dae1301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e4a1c04712648511507c94835371e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#ae6e4a1c04712648511507c94835371e3">crend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ae6e4a1c04712648511507c94835371e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="#ae6e4a1c04712648511507c94835371e3">More...</a><br /></td></tr>
<tr class="separator:ae6e4a1c04712648511507c94835371e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacff17b70f1d43cf347a782d6791f1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#aaacff17b70f1d43cf347a782d6791f1c">iterator_at</a> (size_t <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a></td></tr>
<tr class="memdesc:aaacff17b70f1d43cf347a782d6791f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to given absolute position. This is slightly faster than <a class="el" href="classseq_1_1tiered__vector.html#ac0cc90aa73560716ce5d6f25aafc038e" title="Returns an iterator to the first element of the tiered_vector. ">begin()</a>+pos.  <a href="#aaacff17b70f1d43cf347a782d6791f1c">More...</a><br /></td></tr>
<tr class="separator:aaacff17b70f1d43cf347a782d6791f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0546adc1d5ffe2e1b932d59c321216dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1tiered__vector.html#a0546adc1d5ffe2e1b932d59c321216dd">iterator_at</a> (size_t <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) const noexcept -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a></td></tr>
<tr class="memdesc:a0546adc1d5ffe2e1b932d59c321216dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to given absolute position. This is slightly faster than <a class="el" href="classseq_1_1tiered__vector.html#ac0cc90aa73560716ce5d6f25aafc038e" title="Returns an iterator to the first element of the tiered_vector. ">begin()</a>+pos.  <a href="#a0546adc1d5ffe2e1b932d59c321216dd">More...</a><br /></td></tr>
<tr class="separator:a0546adc1d5ffe2e1b932d59c321216dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt;<br />
class seq::tiered_vector&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;</h3>

<p><a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> is a std::deque like container implemented as a tiered-vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator type </td></tr>
    <tr><td class="paramname">MinBSize</td><td>minimum bucket size, depends on the value_type size </td></tr>
    <tr><td class="paramname">MaxBSize</td><td>maximum bucket size </td></tr>
    <tr><td class="paramname">FindBSize</td><td>struct used to find the bucket size for a given <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> size </td></tr>
    <tr><td class="paramname">ValueCompare</td><td>internal use only</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> is a random-access, bucket based container providing a similar interface to std::deque. Its internals are however very different as it is implemented as a <a href="http://cs.brown.edu/cgc/jdsl/papers/tiered-vector.pdf">tiered vector</a>. Instead of maintaining a vector of fixed size buckets, <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> uses a bucket size close to sqrt(size()). The bucket size is always a power of 2 for fast division and modulo. Furtheremore, the bucket is not a linear buffer but is instead implemented as a circular buffer. This allows a complexity of O(sqrt(N)) for insertion and deletion in the middle of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> instead of O(N) for std::deque. Inserting and deleting elements at both ends is still O(1).</p>
<p><a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> internally uses <a class="el" href="classseq_1_1devector.html" title="Double-ending vector implementation which can be optimized for several use case. ">seq::devector</a> to store the buckets. <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> is used as the backend container for <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a>, <a class="el" href="classseq_1_1flat__map.html" title="flat sorted associative container that contains key-value pairs with unique keys similar to boost::fl...">seq::flat_map</a>, <a class="el" href="classseq_1_1flat__multiset.html" title="flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values...">seq::flat_multiset</a> and <a class="el" href="classseq_1_1flat__multimap.html" title="flat sorted container similar to boost::flat_multimap with faster insertion/deletion of single values...">seq::flat_multimap</a>.</p>
<p><a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> interface is the same as std::deque, with the additional members:</p><ul>
<li><a class="el" href="classseq_1_1tiered__vector.html#a300895f6485fbba603b5b1d53db0f58d" title="Apply unary function fun to all elements within the range [first,last). ">for_each()</a> providing a faster way to walk through the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> than iterators,</li>
<li><a class="el" href="classseq_1_1tiered__vector.html#a17b2e4afd87b5e605b7a1bcc030ba9ca" title="Resizes the container to contain count elements. ">resize_front()</a> to resize the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> from the front instead of the back of the container,</li>
</ul>
<p>The <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> maintains internally an array of circular buffers (or buckets). At any moment, all buckets have the same size which is a power of 2. At container initialization, the bucket size is given by template parameter <em>MinBSize</em> which is, by default, between 64 and 8 depending on value_type size. Whenever <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> grows (through <a class="el" href="classseq_1_1tiered__vector.html#ad854917c4164207da523988af631d260" title="Appends the given element value to the end of the container. ">push_back()</a>, <a class="el" href="classseq_1_1tiered__vector.html#a24f15440419bd04239cf5a743a873185" title="Appends the given element value to the beginning of the container. ">push_front()</a>, <a class="el" href="classseq_1_1tiered__vector.html#a7603212eeabc9b1944ad474966dd8574" title="Insert value before pos. ">insert()</a>, <a class="el" href="classseq_1_1tiered__vector.html#a8e6e5e16acaab480ad50ec617cb4ec0e" title="Resizes the container to contain count elements. ">resize()</a> ...), the new bucket size is computed using the template parameter <em>FindBSize</em>. <em>FindBSize</em> must provide the member </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span>  FindBSize::operator() (<span class="keywordtype">size_t</span> <a class="code" href="classseq_1_1tiered__vector.html#af5bd66c9760bf899b96e6972b9ce072c">size</a>, <span class="keywordtype">unsigned</span> MinBSize, <span class="keywordtype">unsigned</span> MaxBSize) <span class="keyword">const</span> noexcept ;</div></div><!-- fragment --><p> returning the new bucket size based on the container size, the minimum and maximum bucket size. Default implementation returns a value close to sqrt(size()) rounded up to the next power of 2.</p>
<p>If the new bucket size is different than the current one, new buckets are created and elements from the old buckets are moved to the new ones. This has the practical consequence to <b> invalidate all iterators and references on growing or shrinking </b>, as opposed to std::deque which maintains references when inserting/deleting at both ends.</p>
<p>Inserting or deleting elements at the back or the front behaves the same way as for std::deque, except if the bucket size is updated (as explained above).</p>
<p>Inerting an element in the middle of <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> follows these steps:</p><ul>
<li>The bucket index and the element position within the bucket are first computed</li>
<li>The back element of the bucket is extracted and removed from the bucket</li>
<li>The new element is inserted at the right position. Since the bucket is implemented as a dense circular buffer, at most half of the bucket elements must be moved (toward the left or the right, whichever is the shortest path)</li>
<li>The back value that was previously removed is inserted at the front of the next bucket</li>
<li>The next bucket back value is extracted and inserted at the front of the following bucket</li>
<li>....</li>
<li>And so forth until we reach the last bucket.</li>
</ul>
<p>This operation of <em>insert front/pop back</em> is very fast on a circular buffer as it involves only two element moves and shifting the begin index of the buffer. If the bucket size is exactly sqrt(size()), inserting an element in the middle performs in O(sqrt(N)) as it involves as many element moves within a single bucket than between buckets.</p>
<p>In practice the buckets size should be greater than sqrt(size()) as moving elements within a bucket is much faster than between buckets due to cache locality.</p>
<p>Note that, depending on the insertion location, elements can be shifted toward the front bucket instead of the back one if this is the shortest path. This practically divides by 2 (on average) the number of moved elements.</p>
<p>Erasing an element in the middle follows the exact same logic.</p>
<p>Note that inserting/removing relocatable types (where <a class="el" href="structseq_1_1is__relocatable.html#a9bc3104d310961a601c2185957f846ad">seq::is_relocatable&lt;T&gt;::value</a> is true) is faster than for other types.</p>
<p>All insertion/deletion operations on a <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> are much more complex than for a std::deque. Especially, each operation might change the bucket size, and therefore trigger the allocation of new buckets plus moving all elements within the new buckets.</p>
<p>Although possible, providing strong exception guarantee on <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> operations would have added a very complex layer hurting its performances. Therefore, all <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> operations only provide <b>basic exception guarantee</b>.</p>
<p>As explained above, all <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> operations invalidate iterators and references, except for swapping two <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a>.</p>
<p>The only exception is when providing a minimum bucket size (<em>MinBSize</em>) equals to the maximum bucket size (<em>MaxBSize</em>). In this case, inserting/deleting elements will <em>never</em> change the bucket size and move all elements within new buckets. This affects the members <a class="el" href="classseq_1_1tiered__vector.html#a30fc6847bfa96a5da6d9229fc85e3c89" title="Appends a new element to the end of the container. ">emplace_back()</a>, <a class="el" href="classseq_1_1tiered__vector.html#ad854917c4164207da523988af631d260" title="Appends the given element value to the end of the container. ">push_back()</a>, <a class="el" href="classseq_1_1tiered__vector.html#a3dda03081a6c22bd4f35722732835e87" title="Appends a new element to the beginning of the container. ">emplace_front()</a> and <a class="el" href="classseq_1_1tiered__vector.html#a24f15440419bd04239cf5a743a873185" title="Appends the given element value to the beginning of the container. ">push_front()</a> that provide the same invalidation rules as for std::deque.</p>
<p><a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> was optimized to match libstdc++ std::deque performances as close as possible. My benchmarhs show that most members are actually faster than libstdc++ std::deque, except for <a class="el" href="classseq_1_1tiered__vector.html#ad854917c4164207da523988af631d260" title="Appends the given element value to the end of the container. ">push_back()</a>, <a class="el" href="classseq_1_1tiered__vector.html#a24f15440419bd04239cf5a743a873185" title="Appends the given element value to the beginning of the container. ">push_front()</a>, <a class="el" href="classseq_1_1tiered__vector.html#ab6facad675e66ae264ab88e3338dd534" title="Removes the last element of the container. Calling pop_back on an empty container results in undefine...">pop_back()</a> and <a class="el" href="classseq_1_1tiered__vector.html#af4de39daf7ecaef915981d9533832b61" title="Removes the first element of the container. Calling pop_front on an empty container results in undefi...">pop_front()</a> which are slightly slower due to the need to move all elements when the bucket size changes. This can be alievated by the <em>OptimizeForSpeed</em> flag that makes both operations as fast as their std::deque counterparts (see 'seq/seq/benchs/bench_tiered_vector.hpp' for more details).</p>
<p>Usually, iterating through a <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> is faster than through a std::deque, and the random-access #operator[](size_t) is also faster. Making a lot of random access based on iterators can be slightly slower with <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> depending on the use case. For instance, sorting a <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> is slower than sorting a std::deque.</p>
<p>Inserting/deleting single elements in the middle of a <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> is several order of magnitudes faster than std::deque due to the tiered-vector implementation.</p>
<p><a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> is faster when working with relocatable types (where <a class="el" href="structseq_1_1is__relocatable.html#a9bc3104d310961a601c2185957f846ad">seq::is_relocatable&lt;T&gt;::value</a> == true).</p>
<p>The standard conlusion is: you should always benchmark with your own use cases. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a618a9457a81653ec4feb8cf6ff28878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618a9457a81653ec4feb8cf6ff28878b">&#9670;&nbsp;</a></span>alloc_traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a618a9457a81653ec4feb8cf6ff28878b">alloc_traits</a> =  std::allocator_traits&lt;Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a9d2a9d199801b2f3e61497fd4ec329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9d2a9d199801b2f3e61497fd4ec329">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a5a9d2a9d199801b2f3e61497fd4ec329">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a3a30b4551e883840e879364d2aa0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3a30b4551e883840e879364d2aa0a0">&#9670;&nbsp;</a></span>bucket_manager</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a> =  <a class="el" href="structseq_1_1detail_1_1_bucket_manager.html">detail::BucketManager</a>&lt;T, Allocator, <a class="el" href="classseq_1_1tiered__vector.html#a2aaa20913d8c2931c7da304f3212d92ba1a939f2c09253547e3fff0d8506a145e">min_block_size</a>, max_block_size, StoreBackValues, ValueCompare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae069568dee521495754c4fbd77461e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae069568dee521495754c4fbd77461e5f">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> =  <a class="el" href="structseq_1_1detail_1_1deque__const__iterator.html">detail::deque_const_iterator</a>&lt;<a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20706ad570fbd7d6ef16817e755bd249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20706ad570fbd7d6ef16817e755bd249">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a20706ad570fbd7d6ef16817e755bd249">const_pointer</a> =  typename alloc_traits::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2256291ff1ecd78cba07efe32aae3473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2256291ff1ecd78cba07efe32aae3473">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a2256291ff1ecd78cba07efe32aae3473">const_reference</a> =  const <a class="el" href="classseq_1_1tiered__vector.html#a8fe75a7d0109781d3477d8c30d3deac9">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b832aafa9d019a441d300eb301e5b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b832aafa9d019a441d300eb301e5b3a">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac769f5d9fcbb702dc39baa87095fce2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac769f5d9fcbb702dc39baa87095fce2c">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#ac769f5d9fcbb702dc39baa87095fce2c">difference_type</a> =  typename alloc_traits::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2051ba26f6c5ee2ab263b4740cd4a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2051ba26f6c5ee2ab263b4740cd4a11">&#9670;&nbsp;</a></span>find_bsize_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#aa2051ba26f6c5ee2ab263b4740cd4a11">find_bsize_type</a> =  FindBSize</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95dcd64bfba5cfefb45326174cbda4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dcd64bfba5cfefb45326174cbda4a2">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a> =  <a class="el" href="structseq_1_1detail_1_1deque__iterator.html">detail::deque_iterator</a>&lt;<a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7534c050a80898036d6289f375a7480c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7534c050a80898036d6289f375a7480c">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a7534c050a80898036d6289f375a7480c">pointer</a> =  typename alloc_traits::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0b6ecceb136a1ca151b4c0fd07f28ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b6ecceb136a1ca151b4c0fd07f28ca">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#aa0b6ecceb136a1ca151b4c0fd07f28ca">reference</a> =  <a class="el" href="classseq_1_1tiered__vector.html#a8fe75a7d0109781d3477d8c30d3deac9">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a843aeaf7d835a2f128fadfadcf46cd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843aeaf7d835a2f128fadfadcf46cd14">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a843aeaf7d835a2f128fadfadcf46cd14">reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac76d00258293233d34992d238b99cf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76d00258293233d34992d238b99cf87">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> =  typename alloc_traits::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08c1330ed37e666fdb014a1333183cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c1330ed37e666fdb014a1333183cae">&#9670;&nbsp;</a></span>this_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a08c1330ed37e666fdb014a1333183cae">this_type</a> =  <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&lt;T, Allocator, <a class="el" href="classseq_1_1tiered__vector.html#a2aaa20913d8c2931c7da304f3212d92ba1a939f2c09253547e3fff0d8506a145e">min_block_size</a>, max_block_size, FindBSize, StoreBackValues, ValueCompare&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56a616327459ff47b3d2e39bfeecb4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a616327459ff47b3d2e39bfeecb4da">&#9670;&nbsp;</a></span>value_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a56a616327459ff47b3d2e39bfeecb4da">value_compare</a> =  ValueCompare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fe75a7d0109781d3477d8c30d3deac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe75a7d0109781d3477d8c30d3deac9">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html#a8fe75a7d0109781d3477d8c30d3deac9">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2aaa20913d8c2931c7da304f3212d92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aaa20913d8c2931c7da304f3212d92b">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2aaa20913d8c2931c7da304f3212d92ba1a939f2c09253547e3fff0d8506a145e"></a>min_block_size&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a022faff2efaab3fa6b50e74281605a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022faff2efaab3fa6b50e74281605a19">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, initialize the internal bucket manager. </p>

</div>
</div>
<a id="a4343b5c158c9b670792f27a9e82cd5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4343b5c158c9b670792f27a9e82cd5ce">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given allocator alloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39529d8733f28c703007a1091db3deaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39529d8733f28c703007a1091db3deaf">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with <em>count</em> copies of elements with value <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> size </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3869841b247e6440d5e35e3187230c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3869841b247e6440d5e35e3187230c1">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count default-inserted instances of T. No copies are made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> size </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43f2fae8d15a25ae0c6a0a865ad53090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f2fae8d15a25ae0c6a0a865ad53090">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. Constructs the container with the copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cf5b2d4c8271684585fac7aa30d4ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf5b2d4c8271684585fac7aa30d4ab8">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the copy of the contents of other, using alloc as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allcoator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c33db644cf3af27dbfd7d5896b9aa3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c33db644cf3af27dbfd7d5896b9aa3b">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cf7e01431d9f4d8e34b0b43afe7ab95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf7e01431d9f4d8e34b0b43afe7ab95">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05dbe29c3cdfee305cb70d02304600a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dbe29c3cdfee305cb70d02304600a4">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list <em>init</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td>initializer list </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed7c0e33a5c6960851bbb99956e4f5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7c0e33a5c6960851bbb99956e4f5c8">&#9670;&nbsp;</a></span>tiered_vector() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>last iterator of the range </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6be33eb61a4efe67e85b22157816ede1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be33eb61a4efe67e85b22157816ede1">&#9670;&nbsp;</a></span>~tiered_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::~<a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a978589fc9485a7c88190eb6bd677b5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978589fc9485a7c88190eb6bd677b5d2">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with <em>count</em> copies of value <em>value</em> Basic exception guarantee. </p>

</div>
</div>
<a id="a8888799f8dd1b6e24d65758dd2b091af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8888799f8dd1b6e24d65758dd2b091af">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with copies of those in the range [first, last). The behavior is undefined if either argument is an iterator into *this. Basic exception guarantee. </p>

</div>
</div>
<a id="a8aad5706f2a1f811ac9a3f8e64d93ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aad5706f2a1f811ac9a3f8e64d93ace">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with the elements from the initializer list ilist. Basic exception guarantee. </p>

</div>
</div>
<a id="a4f5a52831c4530ebf4c814ed12b58e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5a52831c4530ebf4c814ed12b58e38">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const -&gt; const T&amp;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. </p>

</div>
</div>
<a id="a1abeb2a225f5c0405784fd12201379f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abeb2a225f5c0405784fd12201379f0">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; T&amp; 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. </p>

</div>
</div>
<a id="a6335559c2fcc5adc2fe22dbe57cc59f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6335559c2fcc5adc2fe22dbe57cc59f3">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>

</div>
</div>
<a id="ac347ad9347e7051c6a2d705d7e0e4d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac347ad9347e7051c6a2d705d7e0e4d09">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>

</div>
</div>
<a id="a3910890acc2c286134c18ec11bcf710f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3910890acc2c286134c18ec11bcf710f">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. </p>

</div>
</div>
<a id="ac0cc90aa73560716ce5d6f25aafc038e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cc90aa73560716ce5d6f25aafc038e">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. </p>

</div>
</div>
<a id="ac2d8b0cecc83a1893b589295a69fcaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d8b0cecc83a1893b589295a69fcaf2">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of buckets within <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. </p>

</div>
</div>
<a id="a6fc0614762dffc54229aeb04cc4d7db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc0614762dffc54229aeb04cc4d7db4">&#9670;&nbsp;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a> 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of a bucket within <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. </p>

</div>
</div>
<a id="a072bda5f08a06b36faa758dfa6f33937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072bda5f08a06b36faa758dfa6f33937">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. </p>

</div>
</div>
<a id="a8648700cbb648db2d568d66abcadd668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8648700cbb648db2d568d66abcadd668">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. </p>

</div>
</div>
<a id="a7be758d5c112c43ef661f56f35ce1ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be758d5c112c43ef661f56f35ce1ecd">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the container. </p>

</div>
</div>
<a id="a915c823dc7d4820da970e4498dae1301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915c823dc7d4820da970e4498dae1301">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="ae6e4a1c04712648511507c94835371e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e4a1c04712648511507c94835371e3">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="aa148acfe7398b904b97024977fdf3e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa148acfe7398b904b97024977fdf3e8d">&#9670;&nbsp;</a></span>emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T&amp; 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before <em>pos</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> </td></tr>
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="aaff4036521babbb99dcaf0e27ffcb4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff4036521babbb99dcaf0e27ffcb4d9">&#9670;&nbsp;</a></span>emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before <em>pos</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> </td></tr>
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a30fc6847bfa96a5da6d9229fc85e3c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fc6847bfa96a5da6d9229fc85e3c89">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; T&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the end of the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </dd></dl>

</div>
</div>
<a id="a3dda03081a6c22bd4f35722732835e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dda03081a6c22bd4f35722732835e87">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; T&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the beginning of the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>T constructor arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to inserted element Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </dd></dl>

</div>
</div>
<a id="a1ff396e369049c5b13c301997e8e8134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff396e369049c5b13c301997e8e8134">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retruns true if the container is empty, false otherwise. </p>

</div>
</div>
<a id="afe5d833d3ec544b3de005b2dc10aa167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5d833d3ec544b3de005b2dc10aa167">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. </p>

</div>
</div>
<a id="a86fd2c3f9fb5191a5610209179d9d9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fd2c3f9fb5191a5610209179d9d9cb">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. </p>

</div>
</div>
<a id="a5433a59411f0332c69ea29203737d4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5433a59411f0332c69ea29203737d4b5">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position of the element to erase Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad64788bacd4a4c3eb572b56ca46140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad64788bacd4a4c3eb572b56ca46140">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the last removed element Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a6c0a6da94b6fba8c91c8998625b1895e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0a6da94b6fba8c91c8998625b1895e">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>absolute position of the first element to erase </td></tr>
    <tr><td class="paramname">last</td><td>absolute position of the last (excluded) element to erase Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4c33b9b15845961b7c83764b27ed8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c33b9b15845961b7c83764b27ed8d7">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element to erase </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the last (excluded) element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a300895f6485fbba603b5b1d53db0f58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300895f6485fbba603b5b1d53db0f58d">&#9670;&nbsp;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Fun &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Fun </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply unary function <em>fun</em> to all elements within the range [first,last). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fun</td><td>unary functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first element of the range to apply the functor <em>fun</em> </td></tr>
    <tr><td class="paramname">last</td><td>end of range </td></tr>
    <tr><td class="paramname">fun</td><td>unary functor of lambda function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unary functor (usefull for statefull functors). Using for_each is faster than walking through iterators as it uses the internal knowledge on bucket layout to fasten step increments. </dd></dl>

</div>
</div>
<a id="a7d06c6086cafa5a45c8e59f6e372cbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d06c6086cafa5a45c8e59f6e372cbac">&#9670;&nbsp;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Fun &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; Fun </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply unary function <em>fun</em> to all elements within the range [first,last). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fun</td><td>unary functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first element of the range to apply the functor <em>fun</em> </td></tr>
    <tr><td class="paramname">last</td><td>end of range </td></tr>
    <tr><td class="paramname">fun</td><td>unary functor of lambda function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unary functor (usefull for statefull functors). Using for_each is faster than walking through iterators as it uses the internal knowledge on bucket layout to fasten step increments. </dd></dl>

</div>
</div>
<a id="a9985779f6066f42d47f9534cd2e47114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9985779f6066f42d47f9534cd2e47114">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; T&amp;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>

</div>
</div>
<a id="a7eccdd60668f63797eb5b05ccb9b8956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eccdd60668f63797eb5b05ccb9b8956">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>

</div>
</div>
<a id="afaa57840688e5703758c53cd88cc825a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa57840688e5703758c53cd88cc825a">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const Allocator&amp; 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>

</div>
</div>
<a id="a560d14ef82cd24db8faaecfdeb8b2f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560d14ef82cd24db8faaecfdeb8b2f56">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; Allocator&amp;  
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>

</div>
</div>
<a id="a7603212eeabc9b1944ad474966dd8574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7603212eeabc9b1944ad474966dd8574">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35eab026c5e9d7856f81dbe61e659eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35eab026c5e9d7856f81dbe61e659eea">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>pos</em> using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a488e8452aba972f8de4ada5027e49861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488e8452aba972f8de4ada5027e49861">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>it</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1611fe4689cc6f2fc0df08f960ef1543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1611fe4689cc6f2fc0df08f960ef1543">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>value</em> before <em>it</em> using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> </td></tr>
    <tr><td class="paramname">value</td><td>element to insert Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0a9f1989e0b9025d56b1e7bca0a4f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a9f1989e0b9025d56b1e7bca0a4f10">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>absolute position within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> </td></tr>
    <tr><td class="paramname">first</td><td>first iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>last iterator of the range Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e58ea729f55b2eee082939adfb8f61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e58ea729f55b2eee082939adfb8f61d">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> </td></tr>
    <tr><td class="paramname">first</td><td>first iterator of the range </td></tr>
    <tr><td class="paramname">last</td><td>last iterator of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if first==last Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="ae449f514b4872588fbf31b8cc29200cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae449f514b4872588fbf31b8cc29200cf">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist before pos. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if first==last. Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a69190f3ca867bae1d21494cb668efc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69190f3ca867bae1d21494cb668efc94">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist before pos. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if first==last. Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="a7f9d7bd66ff1f096f9b17fd3d5e28afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9d7bd66ff1f096f9b17fd3d5e28afe">&#9670;&nbsp;</a></span>insert() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count copies of the value before pos Basic exception guarantee. </p>

</div>
</div>
<a id="a11aad38f1a8f5ab99082a1c5bf6152b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11aad38f1a8f5ab99082a1c5bf6152b6">&#9670;&nbsp;</a></span>insert() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count copies of the value before pos. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or it if count==0 Basic exception guarantee. </dd></dl>

</div>
</div>
<a id="aaacff17b70f1d43cf347a782d6791f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacff17b70f1d43cf347a782d6791f1c">&#9670;&nbsp;</a></span>iterator_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::iterator_at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a95dcd64bfba5cfefb45326174cbda4a2">iterator</a> 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to given absolute position. This is slightly faster than <a class="el" href="classseq_1_1tiered__vector.html#ac0cc90aa73560716ce5d6f25aafc038e" title="Returns an iterator to the first element of the tiered_vector. ">begin()</a>+pos. </p>

</div>
</div>
<a id="a0546adc1d5ffe2e1b932d59c321216dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0546adc1d5ffe2e1b932d59c321216dd">&#9670;&nbsp;</a></span>iterator_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::iterator_at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ae069568dee521495754c4fbd77461e5f">const_iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator to given absolute position. This is slightly faster than <a class="el" href="classseq_1_1tiered__vector.html#ac0cc90aa73560716ce5d6f25aafc038e" title="Returns an iterator to the first element of the tiered_vector. ">begin()</a>+pos. </p>

</div>
</div>
<a id="a7ec0043f77c7d8b1dc44d599ca746484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec0043f77c7d8b1dc44d599ca746484">&#9670;&nbsp;</a></span>manager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a>* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal bucket manager object. </p>

</div>
</div>
<a id="a87165ea5dab19f2c1331307e25e97780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87165ea5dab19f2c1331307e25e97780">&#9670;&nbsp;</a></span>manager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const <a class="el" href="classseq_1_1tiered__vector.html#a2a3a30b4551e883840e879364d2aa0a0">bucket_manager</a>* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal bucket manager object. </p>

</div>
</div>
<a id="a79618f2e2c05e7cdfb6bb367b75e3976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79618f2e2c05e7cdfb6bb367b75e3976">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container maximum size. </p>

</div>
</div>
<a id="ac6bf2bd99d1c1a25bf13f2fb9d781ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bf2bd99d1c1a25bf13f2fb9d781ee4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="a184c566eec6f77dd14a31ec713022678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184c566eec6f77dd14a31ec713022678">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&amp; 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="a58c4f111e47b00012752410ea9349824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c4f111e47b00012752410ea9349824">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const -&gt; const T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, without bounds checking. </p>

</div>
</div>
<a id="a51d52ff7a8509c102a492799986154f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d52ff7a8509c102a492799986154f7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, without bounds checking. </p>

</div>
</div>
<a id="ab6facad675e66ae264ab88e3338dd534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6facad675e66ae264ab88e3338dd534">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. Calling pop_back on an empty container results in undefined behavior. Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </p>

</div>
</div>
<a id="af4de39daf7ecaef915981d9533832b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4de39daf7ecaef915981d9533832b61">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element of the container. Calling pop_front on an empty container results in undefined behavior. Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </p>

</div>
</div>
<a id="ad854917c4164207da523988af631d260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad854917c4164207da523988af631d260">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8fc3fdfcb60e3dacd66dbd4db92abe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fc3fdfcb60e3dacd66dbd4db92abe9">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f15440419bd04239cf5a743a873185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f15440419bd04239cf5a743a873185">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the beginning of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94d1cebc0f569c0fff80c74aef5a573a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d1cebc0f569c0fff80c74aef5a573a">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the beginning of the container using move semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append Basic exception guarantee, except if <em>MinBSize == MaxBSize</em> (strong guarantee in this case). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebe0bc2beca3fc8bf9035157509e4238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe0bc2beca3fc8bf9035157509e4238">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a843aeaf7d835a2f128fadfadcf46cd14">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="aba6693994a142c5fc5d507cb98fd5e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6693994a142c5fc5d507cb98fd5e1e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a40918ba16513ef4515d0242258224aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40918ba16513ef4515d0242258224aff">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a843aeaf7d835a2f128fadfadcf46cd14">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="ae8bd2f8b942000d01584495e1a64e594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bd2f8b942000d01584495e1a64e594">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#a6b832aafa9d019a441d300eb301e5b3a">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a8e6e5e16acaab480ad50ec617cb4ec0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6e5e16acaab480ad50ec617cb4ec0e">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-inserted elements are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bc55317d437781eb0dceb7d0b380663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc55317d437781eb0dceb7d0b380663">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of value are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17b2e4afd87b5e605b7a1bcc030ba9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b2e4afd87b5e605b7a1bcc030ba9ca">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional default-inserted elements are prepended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa692149cfcf02a18fe192a785b8e43d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa692149cfcf02a18fe192a785b8e43d1">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional copies of value are prepended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5bd66c9760bf899b96e6972b9ce072c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bd66c9760bf899b96e6972b9ce072c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1tiered__vector.html#ac76d00258293233d34992d238b99cf87">size_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size. </p>

</div>
</div>
<a id="a1047948f13a1d0460c4b0a540bc4506b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1047948f13a1d0460c4b0a540bc4506b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, unsigned MinBSize = SEQ_MIN_BUCKET_SIZE(T), unsigned MaxBSize = SEQ_MAX_BUCKET_SIZE, class FindBSize = detail::FindBucketSize&lt;T&gt;, bool StoreBackValues = false, class ValueCompare = detail::NullValueCompare&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1tiered__vector.html">seq::tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a>&lt; T, Allocator, MinBSize, MaxBSize, FindBSize, StoreBackValues, ValueCompare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other sequence to swap with All iterators and references remain valid. An iterator holding the past-the-end value in this container will refer to the other container after the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="tiered__vector_8hpp_source.html">tiered_vector.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1tiered__vector.html">tiered_vector</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
