<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::parallel_object_pool&lt; T, Allocator, Align, object_allocation, GenerateStats &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classseq_1_1parallel__object__pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classseq_1_1parallel__object__pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::parallel_object_pool&lt; T, Allocator, Align, object_allocation, GenerateStats &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Lock-free parallel object pool.  
 <a href="classseq_1_1parallel__object__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory_8hpp_source.html">memory.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="structseq_1_1detail_1_1base__object__pool.html">seq::detail::base_object_pool&lt; T &gt;</a>, and <a class="el" href="structseq_1_1detail_1_1parallel__stats__data_3_01false_01_4.html">seq::detail::parallel_stats_data&lt; false &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1parallel__object__pool_1_1rebind.html">rebind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5d954326ffa295bfbb512964e44fe51c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a5d954326ffa295bfbb512964e44fe51c">value_type</a> = T</td></tr>
<tr class="separator:a5d954326ffa295bfbb512964e44fe51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5012d96f9197c1d254db6753aeec177b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a5012d96f9197c1d254db6753aeec177b">pointer</a> = T *</td></tr>
<tr class="separator:a5012d96f9197c1d254db6753aeec177b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70efc99d525388bc2cefd276f694e641"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a70efc99d525388bc2cefd276f694e641">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a70efc99d525388bc2cefd276f694e641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3939d98c0364bb96f9e787740bdabf0d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a3939d98c0364bb96f9e787740bdabf0d">unique_ptr</a> = std::unique_ptr&lt; T, <a class="el" href="structseq_1_1unique__ptr__deleter.html">unique_ptr_deleter</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a3939d98c0364bb96f9e787740bdabf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6414b959aa5e36635d8dcbd4bcde59b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a6414b959aa5e36635d8dcbd4bcde59b9">shared_ptr</a> = std::shared_ptr&lt; T &gt;</td></tr>
<tr class="separator:a6414b959aa5e36635d8dcbd4bcde59b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cb591bef2cab46b99627dc76f51013"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a98cb591bef2cab46b99627dc76f51013">allocation_type</a> = object_allocation</td></tr>
<tr class="separator:a98cb591bef2cab46b99627dc76f51013"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aebc6eeb70110313ccfbf7bfd982b24a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#aebc6eeb70110313ccfbf7bfd982b24a4">parallel_object_pool</a> (const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:aebc6eeb70110313ccfbf7bfd982b24a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classseq_1_1parallel__object__pool.html#aebc6eeb70110313ccfbf7bfd982b24a4">More...</a><br /></td></tr>
<tr class="separator:aebc6eeb70110313ccfbf7bfd982b24a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ad2b1f748dc1ff76c06432f56f0643"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a12ad2b1f748dc1ff76c06432f56f0643">~parallel_object_pool</a> ()</td></tr>
<tr class="separator:a12ad2b1f748dc1ff76c06432f56f0643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7308d1a796b49fb4b421eb289cc0701"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#ad7308d1a796b49fb4b421eb289cc0701">parallel_object_pool</a> (const <a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a> &amp;)=delete</td></tr>
<tr class="separator:ad7308d1a796b49fb4b421eb289cc0701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5981bb92e28d5ccc7ee2792fdc18cde1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a5981bb92e28d5ccc7ee2792fdc18cde1">operator=</a> (const <a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a> &amp;) -&gt; <a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a> &amp;=delete</td></tr>
<tr class="separator:a5981bb92e28d5ccc7ee2792fdc18cde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cefaf1dc30789c3588ee610151d0345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a2cefaf1dc30789c3588ee610151d0345">reserve</a> (size_t, size_t)</td></tr>
<tr class="memdesc:a2cefaf1dc30789c3588ee610151d0345"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op, only provided for compatibility with <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a>.  <a href="classseq_1_1parallel__object__pool.html#a2cefaf1dc30789c3588ee610151d0345">More...</a><br /></td></tr>
<tr class="separator:a2cefaf1dc30789c3588ee610151d0345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764df54429b3bb6a198d096da11248ed"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a764df54429b3bb6a198d096da11248ed">get_allocator</a> () const noexcept -&gt; Allocator</td></tr>
<tr class="memdesc:a764df54429b3bb6a198d096da11248ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying allocator.  <a href="classseq_1_1parallel__object__pool.html#a764df54429b3bb6a198d096da11248ed">More...</a><br /></td></tr>
<tr class="separator:a764df54429b3bb6a198d096da11248ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cda23e8ab59a2746b495699895ce3e9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a1cda23e8ab59a2746b495699895ce3e9">get_allocator</a> () noexcept -&gt; Allocator &amp;</td></tr>
<tr class="memdesc:a1cda23e8ab59a2746b495699895ce3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying allocator.  <a href="classseq_1_1parallel__object__pool.html#a1cda23e8ab59a2746b495699895ce3e9">More...</a><br /></td></tr>
<tr class="separator:a1cda23e8ab59a2746b495699895ce3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d7870a5611ea2c96281a5d45a3f253"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a14d7870a5611ea2c96281a5d45a3f253">memory_footprint</a> () const noexcept -&gt; size_t</td></tr>
<tr class="memdesc:a14d7870a5611ea2c96281a5d45a3f253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory footprint in bytes excluding sizeof(*this).  <a href="classseq_1_1parallel__object__pool.html#a14d7870a5611ea2c96281a5d45a3f253">More...</a><br /></td></tr>
<tr class="separator:a14d7870a5611ea2c96281a5d45a3f253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa863937a3906273d5ea87079db80a30c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#aa863937a3906273d5ea87079db80a30c">peak_memory_footprint</a> () const noexcept -&gt; size_t</td></tr>
<tr class="memdesc:aa863937a3906273d5ea87079db80a30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the peak memory footprint in bytes excluding sizeof(*this).  <a href="classseq_1_1parallel__object__pool.html#aa863937a3906273d5ea87079db80a30c">More...</a><br /></td></tr>
<tr class="separator:aa863937a3906273d5ea87079db80a30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743de3a7f26697b9924b8283e9d133fa"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a743de3a7f26697b9924b8283e9d133fa">reclaim_memory</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a743de3a7f26697b9924b8283e9d133fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pool reclaims freed memory, false otherwise.  <a href="classseq_1_1parallel__object__pool.html#a743de3a7f26697b9924b8283e9d133fa">More...</a><br /></td></tr>
<tr class="separator:a743de3a7f26697b9924b8283e9d133fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eee0a4998740efaaf1ad68c5b1bc1ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a9eee0a4998740efaaf1ad68c5b1bc1ec">set_reclaim_memory</a> (bool reclaim)</td></tr>
<tr class="memdesc:a9eee0a4998740efaaf1ad68c5b1bc1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reclaim_memory flag.  <a href="classseq_1_1parallel__object__pool.html#a9eee0a4998740efaaf1ad68c5b1bc1ec">More...</a><br /></td></tr>
<tr class="separator:a9eee0a4998740efaaf1ad68c5b1bc1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b2bbb8a68e01e169f3b88593140bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a23b2bbb8a68e01e169f3b88593140bef">dump_statistics</a> (<a class="el" href="structseq_1_1object__pool__stats.html">object_pool_stats</a> &amp;stats)</td></tr>
<tr class="memdesc:a23b2bbb8a68e01e169f3b88593140bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a> statistics into a <a class="el" href="structseq_1_1object__pool__stats.html" title="Class gathering statistics for seq::object_pool or seq::parallel_object_pool.">object_pool_stats</a>.  <a href="classseq_1_1parallel__object__pool.html#a23b2bbb8a68e01e169f3b88593140bef">More...</a><br /></td></tr>
<tr class="separator:a23b2bbb8a68e01e169f3b88593140bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a75ce8c8eec26b1053beb27a91f147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a90a75ce8c8eec26b1053beb27a91f147">reset_statistics</a> (<a class="el" href="structseq_1_1object__pool__stats.html">object_pool_stats</a> &amp;stats)</td></tr>
<tr class="memdesc:a90a75ce8c8eec26b1053beb27a91f147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset statistics.  <a href="classseq_1_1parallel__object__pool.html#a90a75ce8c8eec26b1053beb27a91f147">More...</a><br /></td></tr>
<tr class="separator:a90a75ce8c8eec26b1053beb27a91f147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc501f1b08098ef3b4408e5107424a4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#aabc501f1b08098ef3b4408e5107424a4">clear</a> () -&gt; size_t</td></tr>
<tr class="memdesc:aabc501f1b08098ef3b4408e5107424a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all blocks.  <a href="classseq_1_1parallel__object__pool.html#aabc501f1b08098ef3b4408e5107424a4">More...</a><br /></td></tr>
<tr class="separator:aabc501f1b08098ef3b4408e5107424a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023f89352b932f04d0446db9af092b5c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a023f89352b932f04d0446db9af092b5c">reset</a> () -&gt; size_t</td></tr>
<tr class="memdesc:a023f89352b932f04d0446db9af092b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a>.  <a href="classseq_1_1parallel__object__pool.html#a023f89352b932f04d0446db9af092b5c">More...</a><br /></td></tr>
<tr class="separator:a023f89352b932f04d0446db9af092b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19202a94fcef784bd4eed942387c73e1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a19202a94fcef784bd4eed942387c73e1">release_unused_memory</a> () -&gt; size_t</td></tr>
<tr class="memdesc:a19202a94fcef784bd4eed942387c73e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate all unused memory blocks. This only makes sense if <a class="el" href="classseq_1_1parallel__object__pool.html#a743de3a7f26697b9924b8283e9d133fa" title="Returns true if this pool reclaims freed memory, false otherwise.">reclaim_memory()</a> is false.  <a href="classseq_1_1parallel__object__pool.html#a19202a94fcef784bd4eed942387c73e1">More...</a><br /></td></tr>
<tr class="separator:a19202a94fcef784bd4eed942387c73e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128d1dead3c25a24d4ae746a007e28ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a128d1dead3c25a24d4ae746a007e28ea">allocate</a> (size_t size) -&gt; T *</td></tr>
<tr class="memdesc:a128d1dead3c25a24d4ae746a007e28ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate size objects.  <a href="classseq_1_1parallel__object__pool.html#a128d1dead3c25a24d4ae746a007e28ea">More...</a><br /></td></tr>
<tr class="separator:a128d1dead3c25a24d4ae746a007e28ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c39c2c5cf32251dd27f5947058e167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a53c39c2c5cf32251dd27f5947058e167">deallocate</a> (T *ptr, size_t size)</td></tr>
<tr class="memdesc:a53c39c2c5cf32251dd27f5947058e167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate size objects. Non POD objects must have been destroyed previously.  <a href="classseq_1_1parallel__object__pool.html#a53c39c2c5cf32251dd27f5947058e167">More...</a><br /></td></tr>
<tr class="separator:a53c39c2c5cf32251dd27f5947058e167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9f5603fd5d92224ba1a40b0190b173"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a8e9f5603fd5d92224ba1a40b0190b173"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a8e9f5603fd5d92224ba1a40b0190b173">make_unique</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1parallel__object__pool.html#a3939d98c0364bb96f9e787740bdabf0d">unique_ptr</a></td></tr>
<tr class="memdesc:a8e9f5603fd5d92224ba1a40b0190b173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique_ptr object constructed from the forwarded argument.  <a href="classseq_1_1parallel__object__pool.html#a8e9f5603fd5d92224ba1a40b0190b173">More...</a><br /></td></tr>
<tr class="separator:a8e9f5603fd5d92224ba1a40b0190b173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structseq_1_1detail_1_1base__object__pool"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structseq_1_1detail_1_1base__object__pool')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structseq_1_1detail_1_1base__object__pool.html">seq::detail::base_object_pool&lt; T &gt;</a></td></tr>
<tr class="memitem:a07aaca7767486e800033bd9d77452ec9 inherit pub_methods_structseq_1_1detail_1_1base__object__pool"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1detail_1_1base__object__pool.html#a07aaca7767486e800033bd9d77452ec9">~base_object_pool</a> ()</td></tr>
<tr class="separator:a07aaca7767486e800033bd9d77452ec9 inherit pub_methods_structseq_1_1detail_1_1base__object__pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5b5384326e4223342454ce9dbbbc81e7"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a5b5384326e4223342454ce9dbbbc81e7">max_objects</a> = object_allocation::max_objects</td></tr>
<tr class="separator:a5b5384326e4223342454ce9dbbbc81e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7540dbb9a515ff198c9171030f82a022"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a7540dbb9a515ff198c9171030f82a022">alignment</a> = (Align == 0 || Align &lt; <a class="el" href="group__bits.html#ga4358957bf3c41e772ade27671699c4e6">SEQ_DEFAULT_ALIGNMENT</a>) ? <a class="el" href="group__bits.html#ga4358957bf3c41e772ade27671699c4e6">SEQ_DEFAULT_ALIGNMENT</a> : Align</td></tr>
<tr class="separator:a7540dbb9a515ff198c9171030f82a022"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3494f5bb0141e8c38ce58167ba42ed05"><td class="memTemplParams" colspan="2">template&lt;class U , class Pool &gt; </td></tr>
<tr class="memitem:a3494f5bb0141e8c38ce58167ba42ed05"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1parallel__object__pool.html#a3494f5bb0141e8c38ce58167ba42ed05">detail::allocator_for_shared_ptr</a></td></tr>
<tr class="separator:a3494f5bb0141e8c38ce58167ba42ed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt;<br />
class seq::parallel_object_pool&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;</h3>

<p>Lock-free parallel object pool. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of object to be allocated </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator type </td></tr>
    <tr><td class="paramname">object_allocation</td><td>object allocation pattern</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool.">seq::parallel_object_pool</a> is very similar to <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">seq::object_pool</a>, but is a fully thread-safe alternative.</p>
<p><a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool.">seq::parallel_object_pool</a> relies on independant thread-local memory blocks. Allocating is quite straightforward, and is very similar to using a thread_local <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a>.</p>
<p>Deallocating is more complex, as a memory region can only be deallocated by the thread that created it (except if the thread was destroyed). Therefore, <a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool.">parallel_object_pool</a> uses the notion of deffered deletion:</p><ul>
<li>The deletion request is added to a list of requests</li>
<li>On further calls to parallel_object_pool::allocate() or <a class="el" href="classseq_1_1parallel__object__pool.html#a53c39c2c5cf32251dd27f5947058e167" title="Deallocate size objects. Non POD objects must have been destroyed previously.">parallel_object_pool::deallocate()</a>, all pending deletion are processed for this thread.</li>
</ul>
<p>When a thread is destroyed, several options are checked:</p><ul>
<li>All memory blocks belonging to this thread are gathered</li>
<li>Empty memory blocks are destroyed (<a class="el" href="classseq_1_1parallel__object__pool.html#a743de3a7f26697b9924b8283e9d133fa" title="Returns true if this pool reclaims freed memory, false otherwise.">reclaim_memory()</a>==true) or added to a global list of free blocks (<a class="el" href="classseq_1_1parallel__object__pool.html#a743de3a7f26697b9924b8283e9d133fa" title="Returns true if this pool reclaims freed memory, false otherwise.">reclaim_memory()</a>==false) that can be used later by any thread.</li>
<li>Non empty blocks are added to a list of blocks to 'clean'. <a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool.">parallel_object_pool</a> will try to reuse blocks from the clean list whenever they become empty.</li>
</ul>
<p><a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool.">parallel_object_pool</a> is almost lock-free, and should be several times faster than the default malloc()/free() implementation in multi-threaded scenarios.</p>
<p>All members of <a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool.">parallel_object_pool</a> are thread safe.</p>
<p>For more details, see the documentation of <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">seq::object_pool</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a98cb591bef2cab46b99627dc76f51013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cb591bef2cab46b99627dc76f51013">&#9670;&nbsp;</a></span>allocation_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::<a class="el" href="classseq_1_1parallel__object__pool.html#a98cb591bef2cab46b99627dc76f51013">allocation_type</a> =  object_allocation</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70efc99d525388bc2cefd276f694e641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70efc99d525388bc2cefd276f694e641">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::<a class="el" href="classseq_1_1parallel__object__pool.html#a70efc99d525388bc2cefd276f694e641">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5012d96f9197c1d254db6753aeec177b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5012d96f9197c1d254db6753aeec177b">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::<a class="el" href="classseq_1_1parallel__object__pool.html#a5012d96f9197c1d254db6753aeec177b">pointer</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6414b959aa5e36635d8dcbd4bcde59b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6414b959aa5e36635d8dcbd4bcde59b9">&#9670;&nbsp;</a></span>shared_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::<a class="el" href="classseq_1_1parallel__object__pool.html#a6414b959aa5e36635d8dcbd4bcde59b9">shared_ptr</a> =  std::shared_ptr&lt;T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3939d98c0364bb96f9e787740bdabf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3939d98c0364bb96f9e787740bdabf0d">&#9670;&nbsp;</a></span>unique_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::<a class="el" href="classseq_1_1parallel__object__pool.html#a3939d98c0364bb96f9e787740bdabf0d">unique_ptr</a> =  std::unique_ptr&lt;T, <a class="el" href="structseq_1_1unique__ptr__deleter.html">unique_ptr_deleter</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d954326ffa295bfbb512964e44fe51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d954326ffa295bfbb512964e44fe51c">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::<a class="el" href="classseq_1_1parallel__object__pool.html#a5d954326ffa295bfbb512964e44fe51c">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aebc6eeb70110313ccfbf7bfd982b24a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc6eeb70110313ccfbf7bfd982b24a4">&#9670;&nbsp;</a></span>parallel_object_pool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::<a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12ad2b1f748dc1ff76c06432f56f0643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ad2b1f748dc1ff76c06432f56f0643">&#9670;&nbsp;</a></span>~parallel_object_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::~<a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7308d1a796b49fb4b421eb289cc0701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7308d1a796b49fb4b421eb289cc0701">&#9670;&nbsp;</a></span>parallel_object_pool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::<a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a128d1dead3c25a24d4ae746a007e28ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128d1dead3c25a24d4ae746a007e28ea">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> -&gt; T*
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate size objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of objects to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated objects</dd></dl>
<p>If size &lt;= object_allocation::max_object, use the memory block mechanism. If size &gt; object_allocation::max_object, directly use the supplied allocator.</p>
<p>Might throw std::bad_alloc. </p>

<p>Implements <a class="el" href="structseq_1_1detail_1_1base__object__pool.html#a901146a91f522302842181dc455ad0cf">seq::detail::base_object_pool&lt; T &gt;</a>.</p>

</div>
</div>
<a id="aabc501f1b08098ef3b4408e5107424a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc501f1b08098ef3b4408e5107424a4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; size_t 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all blocks. </p>
<p>Free all memory blocks, except those managing at least one unique_ptr. This will invalidate all previously allocated pointers.</p>
<p>Note that the objects are not destroyed, only deallocated. </p>

</div>
</div>
<a id="a53c39c2c5cf32251dd27f5947058e167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c39c2c5cf32251dd27f5947058e167">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate size objects. Non POD objects must have been destroyed previously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to objects to deallocate </td></tr>
    <tr><td class="paramname">size</td><td>number of objects to deallocate </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structseq_1_1detail_1_1base__object__pool.html#a94c3d29a9aa75d5efdaa6e03e866b5d5">seq::detail::base_object_pool&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a23b2bbb8a68e01e169f3b88593140bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b2bbb8a68e01e169f3b88593140bef">&#9670;&nbsp;</a></span>dump_statistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::dump_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1object__pool__stats.html">object_pool_stats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a> statistics into a <a class="el" href="structseq_1_1object__pool__stats.html" title="Class gathering statistics for seq::object_pool or seq::parallel_object_pool.">object_pool_stats</a>. </p>

</div>
</div>
<a id="a764df54429b3bb6a198d096da11248ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764df54429b3bb6a198d096da11248ed">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; Allocator 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying allocator. </p>

</div>
</div>
<a id="a1cda23e8ab59a2746b495699895ce3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cda23e8ab59a2746b495699895ce3e9">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; Allocator&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying allocator. </p>

</div>
</div>
<a id="a8e9f5603fd5d92224ba1a40b0190b173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9f5603fd5d92224ba1a40b0190b173">&#9670;&nbsp;</a></span>make_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::make_unique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1parallel__object__pool.html#a3939d98c0364bb96f9e787740bdabf0d">unique_ptr</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a unique_ptr object constructed from the forwarded argument. </p>
<p>This function is similar to std::make_unique(), except that it relies on the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a> to allocate the memory. The created unique_ptr will outlive the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a>. Never deallocate a unique_ptr pointer with <a class="el" href="classseq_1_1object__pool.html#a99af259462a246f9b6c46a6b00a9a782" title="Deallocate size objects. Non POD objects must have been destroyed previously.">object_pool::deallocate()</a>. If unique_ptr::release() is called, the pointer must be destroyed with <a class="el" href="namespaceseq.html#a1349a44a2ff37300a5c72a03780780fe" title="Deallocate pointer previously held by a std::unqiue_ptr&lt;T,unique_ptr_deleter&lt;T&gt; &gt;">seq::unique_ptr_delete()</a>, which calls the object destructor and release the memory if needed. </p>

</div>
</div>
<a id="a14d7870a5611ea2c96281a5d45a3f253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d7870a5611ea2c96281a5d45a3f253">&#9670;&nbsp;</a></span>memory_footprint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::memory_footprint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; size_t 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the memory footprint in bytes excluding sizeof(*this). </p>

</div>
</div>
<a id="a5981bb92e28d5ccc7ee2792fdc18cde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5981bb92e28d5ccc7ee2792fdc18cde1">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a> &amp;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa863937a3906273d5ea87079db80a30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa863937a3906273d5ea87079db80a30c">&#9670;&nbsp;</a></span>peak_memory_footprint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::peak_memory_footprint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; size_t 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the peak memory footprint in bytes excluding sizeof(*this). </p>

</div>
</div>
<a id="a743de3a7f26697b9924b8283e9d133fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743de3a7f26697b9924b8283e9d133fa">&#9670;&nbsp;</a></span>reclaim_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::reclaim_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pool reclaims freed memory, false otherwise. </p>

</div>
</div>
<a id="a19202a94fcef784bd4eed942387c73e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19202a94fcef784bd4eed942387c73e1">&#9670;&nbsp;</a></span>release_unused_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::release_unused_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; size_t
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate all unused memory blocks. This only makes sense if <a class="el" href="classseq_1_1parallel__object__pool.html#a743de3a7f26697b9924b8283e9d133fa" title="Returns true if this pool reclaims freed memory, false otherwise.">reclaim_memory()</a> is false. </p>

</div>
</div>
<a id="a2cefaf1dc30789c3588ee610151d0345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cefaf1dc30789c3588ee610151d0345">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No-op, only provided for compatibility with <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a>. </p>

</div>
</div>
<a id="a023f89352b932f04d0446db9af092b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023f89352b932f04d0446db9af092b5c">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; size_t
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a>. </p>
<p>Reset this object by clearing all memory blocks and make them ready for new allocations. This effectively invalidates all previously allocated pointers, even if the underlying memory segment has not been deallocated.</p>
<p>Has no effect on block managing at least one unique_ptr. </p>

</div>
</div>
<a id="a90a75ce8c8eec26b1053beb27a91f147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a75ce8c8eec26b1053beb27a91f147">&#9670;&nbsp;</a></span>reset_statistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::reset_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1object__pool__stats.html">object_pool_stats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset statistics. </p>
<p>Reset the following statistics:</p><ul>
<li>peak memory (reseted to the current memory footprint)</li>
<li>total number of allocated object (reseted to 0, only meaningful if GenerateStats is true)</li>
<li>total number of deallocated object (reseted to 0, only meaningful if GenerateStats is true) </li>
</ul>

</div>
</div>
<a id="a9eee0a4998740efaaf1ad68c5b1bc1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eee0a4998740efaaf1ad68c5b1bc1ec">&#9670;&nbsp;</a></span>set_reclaim_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::set_reclaim_memory </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reclaim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the reclaim_memory flag. </p>
<p>If false, the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T.">object_pool</a> will not deallocate memory on calls to <a class="el" href="classseq_1_1parallel__object__pool.html#a53c39c2c5cf32251dd27f5947058e167" title="Deallocate size objects. Non POD objects must have been destroyed previously.">deallocate()</a>. Instead, free memory blocks will be added to an internal list and reuse on calls to allocate(). This is the only way to move a memory block dedicated to an object count for another object count.</p>
<p>If true, calls to deallocate will deallocate any free block. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3494f5bb0141e8c38ce58167ba42ed05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3494f5bb0141e8c38ce58167ba42ed05">&#9670;&nbsp;</a></span>detail::allocator_for_shared_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<div class="memtemplate">
template&lt;class U , class Pool &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classseq_1_1detail_1_1allocator__for__shared__ptr.html">detail::allocator_for_shared_ptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7540dbb9a515ff198c9171030f82a022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7540dbb9a515ff198c9171030f82a022">&#9670;&nbsp;</a></span>alignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::alignment = (Align == 0 || Align &lt; <a class="el" href="group__bits.html#ga4358957bf3c41e772ade27671699c4e6">SEQ_DEFAULT_ALIGNMENT</a>) ? <a class="el" href="group__bits.html#ga4358957bf3c41e772ade27671699c4e6">SEQ_DEFAULT_ALIGNMENT</a> : Align</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b5384326e4223342454ce9dbbbc81e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5384326e4223342454ce9dbbbc81e7">&#9670;&nbsp;</a></span>max_objects</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, size_t Align = 0, class object_allocation  = linear_object_allocation&lt;1&gt;, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classseq_1_1parallel__object__pool.html">seq::parallel_object_pool</a>&lt; T, Allocator, Align, object_allocation, GenerateStats &gt;::max_objects = object_allocation::max_objects</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="memory_8hpp_source.html">memory.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1parallel__object__pool.html">parallel_object_pool</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
