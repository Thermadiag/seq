<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::sequence&lt; T, Allocator, layout, ForceAlign64 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classseq_1_1sequence.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classseq_1_1sequence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::sequence&lt; T, Allocator, layout, ForceAlign64 &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>sequence is an ordered container supporting constant time insertion at both end and constant removal anywhere.  
 <a href="classseq_1_1sequence.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sequence_8hpp_source.html">sequence.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a13defe50f14aa6e1023a7bd3671f0feb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a13defe50f14aa6e1023a7bd3671f0feb">value_type</a> = T</td></tr>
<tr class="separator:a13defe50f14aa6e1023a7bd3671f0feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdd221c3de222009df566403df0ca1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#acabdd221c3de222009df566403df0ca1">pointer</a> = T *</td></tr>
<tr class="separator:acabdd221c3de222009df566403df0ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fd41c14102120ece2ef329e643bc49"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a24fd41c14102120ece2ef329e643bc49">reference</a> = T &amp;</td></tr>
<tr class="separator:a24fd41c14102120ece2ef329e643bc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add42b097218600cdea80260595f9d4af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#add42b097218600cdea80260595f9d4af">const_pointer</a> = const T *</td></tr>
<tr class="separator:add42b097218600cdea80260595f9d4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eea1d1e4d1e27cd662163a9fbbe20d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aa1eea1d1e4d1e27cd662163a9fbbe20d">allocator_type</a> = Allocator</td></tr>
<tr class="separator:aa1eea1d1e4d1e27cd662163a9fbbe20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6090a614e298f8427de83867a6a6d5a5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a6090a614e298f8427de83867a6a6d5a5">difference_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1sequence.html#a6090a614e298f8427de83867a6a6d5a5">difference_type</a></td></tr>
<tr class="separator:a6090a614e298f8427de83867a6a6d5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd184f2899a4f88b9c0f4ae80c4c87d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a></td></tr>
<tr class="separator:a7dd184f2899a4f88b9c0f4ae80c4c87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a07a0366c0a33e89a2faa4602528833"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a> = <a class="el" href="classseq_1_1detail_1_1sequence__iterator.html">detail::sequence_iterator</a>&lt; <a class="el" href="classseq_1_1sequence.html">this_type</a> &gt;</td></tr>
<tr class="separator:a7a07a0366c0a33e89a2faa4602528833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4c3f39d42b9d1c0cc33f3f85c93e0d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> = <a class="el" href="classseq_1_1detail_1_1sequence__const__iterator.html">detail::sequence_const_iterator</a>&lt; <a class="el" href="classseq_1_1sequence.html">this_type</a> &gt;</td></tr>
<tr class="separator:a7f4c3f39d42b9d1c0cc33f3f85c93e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb25931272360700029c5ee234a33d55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#afb25931272360700029c5ee234a33d55">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a> &gt;</td></tr>
<tr class="separator:afb25931272360700029c5ee234a33d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab014bbe6eb79dd6e79d0f24cdac13485"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> &gt;</td></tr>
<tr class="separator:ab014bbe6eb79dd6e79d0f24cdac13485"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a55e251b438d7af784967f5d268b86332"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a55e251b438d7af784967f5d268b86332">sequence</a> ()</td></tr>
<tr class="memdesc:a55e251b438d7af784967f5d268b86332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, initialize internal data.  <a href="classseq_1_1sequence.html#a55e251b438d7af784967f5d268b86332">More...</a><br /></td></tr>
<tr class="separator:a55e251b438d7af784967f5d268b86332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa7c515eab5fe015f20f9879b6346d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a0aa7c515eab5fe015f20f9879b6346d8">sequence</a> (const Allocator &amp;al)</td></tr>
<tr class="memdesc:a0aa7c515eab5fe015f20f9879b6346d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an allocator object.  <a href="classseq_1_1sequence.html#a0aa7c515eab5fe015f20f9879b6346d8">More...</a><br /></td></tr>
<tr class="separator:a0aa7c515eab5fe015f20f9879b6346d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ddbd2300b9a82a6362e43351bde878"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a14ddbd2300b9a82a6362e43351bde878">sequence</a> (<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> count, const T &amp;value, const Allocator &amp;al=Allocator())</td></tr>
<tr class="memdesc:a14ddbd2300b9a82a6362e43351bde878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with an initial size and a fill value.  <a href="classseq_1_1sequence.html#a14ddbd2300b9a82a6362e43351bde878">More...</a><br /></td></tr>
<tr class="separator:a14ddbd2300b9a82a6362e43351bde878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402c55a55b9a9b3acd2517fb88497e6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a402c55a55b9a9b3acd2517fb88497e6a">sequence</a> (<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> count, const Allocator &amp;al=Allocator())</td></tr>
<tr class="memdesc:a402c55a55b9a9b3acd2517fb88497e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with an initial size. Objects will be value initialize.  <a href="classseq_1_1sequence.html#a402c55a55b9a9b3acd2517fb88497e6a">More...</a><br /></td></tr>
<tr class="separator:a402c55a55b9a9b3acd2517fb88497e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb600487cc318a71f41377ec755d8a08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#afb600487cc318a71f41377ec755d8a08">sequence</a> (const <a class="el" href="classseq_1_1sequence.html">sequence</a> &amp;other)</td></tr>
<tr class="memdesc:afb600487cc318a71f41377ec755d8a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1sequence.html#afb600487cc318a71f41377ec755d8a08">More...</a><br /></td></tr>
<tr class="separator:afb600487cc318a71f41377ec755d8a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8347c5afdb32cca4d5c91c5da820c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a7d8347c5afdb32cca4d5c91c5da820c2">sequence</a> (const <a class="el" href="classseq_1_1sequence.html">sequence</a> &amp;other, const Allocator &amp;al)</td></tr>
<tr class="memdesc:a7d8347c5afdb32cca4d5c91c5da820c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1sequence.html#a7d8347c5afdb32cca4d5c91c5da820c2">More...</a><br /></td></tr>
<tr class="separator:a7d8347c5afdb32cca4d5c91c5da820c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d815a5628cc6f8037465017dae6558"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a77d815a5628cc6f8037465017dae6558">sequence</a> (<a class="el" href="classseq_1_1sequence.html">sequence</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a77d815a5628cc6f8037465017dae6558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classseq_1_1sequence.html#a77d815a5628cc6f8037465017dae6558">More...</a><br /></td></tr>
<tr class="separator:a77d815a5628cc6f8037465017dae6558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd969dd2081e6ab9c6acbdc8e7475c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a2cd969dd2081e6ab9c6acbdc8e7475c1">sequence</a> (<a class="el" href="classseq_1_1sequence.html">sequence</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a2cd969dd2081e6ab9c6acbdc8e7475c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move.  <a href="classseq_1_1sequence.html#a2cd969dd2081e6ab9c6acbdc8e7475c1">More...</a><br /></td></tr>
<tr class="separator:a2cd969dd2081e6ab9c6acbdc8e7475c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc0b4e6e117b2c63c3d124068ab81ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a6bc0b4e6e117b2c63c3d124068ab81ba">sequence</a> (const std::initializer_list&lt; T &gt; &amp;lst, const Allocator &amp;al=Allocator())</td></tr>
<tr class="memdesc:a6bc0b4e6e117b2c63c3d124068ab81ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the sequence with the contents of the initializer list <em>lst</em>.  <a href="classseq_1_1sequence.html#a6bc0b4e6e117b2c63c3d124068ab81ba">More...</a><br /></td></tr>
<tr class="separator:a6bc0b4e6e117b2c63c3d124068ab81ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218407716e827960ecf70c3b40dee140"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a218407716e827960ecf70c3b40dee140"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a218407716e827960ecf70c3b40dee140">sequence</a> (Iter first, Iter last, const Allocator &amp;al=Allocator())</td></tr>
<tr class="memdesc:a218407716e827960ecf70c3b40dee140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the sequence with the contents of the range [first, last).  <a href="classseq_1_1sequence.html#a218407716e827960ecf70c3b40dee140">More...</a><br /></td></tr>
<tr class="separator:a218407716e827960ecf70c3b40dee140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15ffd990a824f160fbe8fb66878d8ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#ad15ffd990a824f160fbe8fb66878d8ff">~sequence</a> ()</td></tr>
<tr class="memdesc:ad15ffd990a824f160fbe8fb66878d8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classseq_1_1sequence.html#ad15ffd990a824f160fbe8fb66878d8ff">More...</a><br /></td></tr>
<tr class="separator:ad15ffd990a824f160fbe8fb66878d8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe31dfa20f873fe2e541d37efacb6d4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a3fe31dfa20f873fe2e541d37efacb6d4">operator=</a> (const <a class="el" href="classseq_1_1sequence.html">sequence</a> &amp;other) -&gt; <a class="el" href="classseq_1_1sequence.html">sequence</a> &amp;</td></tr>
<tr class="memdesc:a3fe31dfa20f873fe2e541d37efacb6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator, basic exception guarantee.  <a href="classseq_1_1sequence.html#a3fe31dfa20f873fe2e541d37efacb6d4">More...</a><br /></td></tr>
<tr class="separator:a3fe31dfa20f873fe2e541d37efacb6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f4acbccef9afb88836ca12d7fba1f3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a24f4acbccef9afb88836ca12d7fba1f3">operator=</a> (<a class="el" href="classseq_1_1sequence.html">sequence</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1sequence.html">sequence</a> &amp;</td></tr>
<tr class="memdesc:a24f4acbccef9afb88836ca12d7fba1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classseq_1_1sequence.html#a24f4acbccef9afb88836ca12d7fba1f3">More...</a><br /></td></tr>
<tr class="separator:a24f4acbccef9afb88836ca12d7fba1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eb2f85de25d69ca79a3e9e426f487b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#ac4eb2f85de25d69ca79a3e9e426f487b">swap</a> (<a class="el" href="classseq_1_1sequence.html">sequence</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ac4eb2f85de25d69ca79a3e9e426f487b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.  <a href="classseq_1_1sequence.html#ac4eb2f85de25d69ca79a3e9e426f487b">More...</a><br /></td></tr>
<tr class="separator:ac4eb2f85de25d69ca79a3e9e426f487b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cf8f2fe37e422bcc119ebd2f064dce"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a24cf8f2fe37e422bcc119ebd2f064dce">data</a> () noexcept -&gt; Data *</td></tr>
<tr class="memdesc:a24cf8f2fe37e422bcc119ebd2f064dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sequence internal data. Internal use only.  <a href="classseq_1_1sequence.html#a24cf8f2fe37e422bcc119ebd2f064dce">More...</a><br /></td></tr>
<tr class="separator:a24cf8f2fe37e422bcc119ebd2f064dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425737526395c84ed6b57b6297bcb410"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a425737526395c84ed6b57b6297bcb410">data</a> () const noexcept -&gt; const Data *</td></tr>
<tr class="separator:a425737526395c84ed6b57b6297bcb410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7cb1d4d77ba5476930bfdffef65e09"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aef7cb1d4d77ba5476930bfdffef65e09">memory_footprint</a> () const noexcept -&gt; std::size_t</td></tr>
<tr class="memdesc:aef7cb1d4d77ba5476930bfdffef65e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full memory footprint of this sequence in bytes, excluding sizeof(*this).  <a href="classseq_1_1sequence.html#aef7cb1d4d77ba5476930bfdffef65e09">More...</a><br /></td></tr>
<tr class="separator:aef7cb1d4d77ba5476930bfdffef65e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065df7dfb6b5495249346d377d94b0dc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a065df7dfb6b5495249346d377d94b0dc">get_allocator</a> () noexcept -&gt; Allocator &amp;</td></tr>
<tr class="memdesc:a065df7dfb6b5495249346d377d94b0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="classseq_1_1sequence.html#a065df7dfb6b5495249346d377d94b0dc">More...</a><br /></td></tr>
<tr class="separator:a065df7dfb6b5495249346d377d94b0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f868260d86160cfb072ad362db4b6d3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a9f868260d86160cfb072ad362db4b6d3">get_allocator</a> () const noexcept -&gt; Allocator</td></tr>
<tr class="memdesc:a9f868260d86160cfb072ad362db4b6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="classseq_1_1sequence.html#a9f868260d86160cfb072ad362db4b6d3">More...</a><br /></td></tr>
<tr class="separator:a9f868260d86160cfb072ad362db4b6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1171dafc78357c61afd896f15d87884"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#af1171dafc78357c61afd896f15d87884">size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a></td></tr>
<tr class="memdesc:af1171dafc78357c61afd896f15d87884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns thenumber of elements in this sequence.  <a href="classseq_1_1sequence.html#af1171dafc78357c61afd896f15d87884">More...</a><br /></td></tr>
<tr class="separator:af1171dafc78357c61afd896f15d87884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367842660b634699aca64fa00af6743a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a367842660b634699aca64fa00af6743a">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="separator:a367842660b634699aca64fa00af6743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39900c1d6c4189f852298857a3ef7938"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a39900c1d6c4189f852298857a3ef7938">capacity</a> () const noexcept -&gt; size_t</td></tr>
<tr class="memdesc:a39900c1d6c4189f852298857a3ef7938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container has currently allocated space for.  <a href="classseq_1_1sequence.html#a39900c1d6c4189f852298857a3ef7938">More...</a><br /></td></tr>
<tr class="separator:a39900c1d6c4189f852298857a3ef7938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84eae0de15058ca5a708264a241564b6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a84eae0de15058ca5a708264a241564b6">back</a> () const noexcept -&gt; const T &amp;</td></tr>
<tr class="memdesc:a84eae0de15058ca5a708264a241564b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the back sequence value.  <a href="classseq_1_1sequence.html#a84eae0de15058ca5a708264a241564b6">More...</a><br /></td></tr>
<tr class="separator:a84eae0de15058ca5a708264a241564b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da4f80e918b45025b44eef043b1d4a9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a6da4f80e918b45025b44eef043b1d4a9">back</a> () noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:a6da4f80e918b45025b44eef043b1d4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the back sequence value.  <a href="classseq_1_1sequence.html#a6da4f80e918b45025b44eef043b1d4a9">More...</a><br /></td></tr>
<tr class="separator:a6da4f80e918b45025b44eef043b1d4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b2a98cd2c9a3249e6cc592f774a720"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a41b2a98cd2c9a3249e6cc592f774a720">front</a> () const noexcept -&gt; const T &amp;</td></tr>
<tr class="memdesc:a41b2a98cd2c9a3249e6cc592f774a720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the front sequence value.  <a href="classseq_1_1sequence.html#a41b2a98cd2c9a3249e6cc592f774a720">More...</a><br /></td></tr>
<tr class="separator:a41b2a98cd2c9a3249e6cc592f774a720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaf970d1c536112aec1153bd5d8c0e8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#acaaf970d1c536112aec1153bd5d8c0e8">front</a> () noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:acaaf970d1c536112aec1153bd5d8c0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the front sequence value.  <a href="classseq_1_1sequence.html#acaaf970d1c536112aec1153bd5d8c0e8">More...</a><br /></td></tr>
<tr class="separator:acaaf970d1c536112aec1153bd5d8c0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3e3d448af95c0bf3a7e897ae02f193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#afa3e3d448af95c0bf3a7e897ae02f193">clear</a> () noexcept</td></tr>
<tr class="memdesc:afa3e3d448af95c0bf3a7e897ae02f193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents. Erases all elements from the container. After this call, size() returns zero. Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid.  <a href="classseq_1_1sequence.html#afa3e3d448af95c0bf3a7e897ae02f193">More...</a><br /></td></tr>
<tr class="separator:afa3e3d448af95c0bf3a7e897ae02f193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb2a3944e4ad72fbbf625b1aa816d04"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a0fb2a3944e4ad72fbbf625b1aa816d04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a0fb2a3944e4ad72fbbf625b1aa816d04">emplace_back</a> (Args &amp;&amp;... args) -&gt; T &amp;</td></tr>
<tr class="memdesc:a0fb2a3944e4ad72fbbf625b1aa816d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the end.  <a href="classseq_1_1sequence.html#a0fb2a3944e4ad72fbbf625b1aa816d04">More...</a><br /></td></tr>
<tr class="separator:a0fb2a3944e4ad72fbbf625b1aa816d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1f0b067719f2bec80eb54dc8496d06"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a8d1f0b067719f2bec80eb54dc8496d06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a8d1f0b067719f2bec80eb54dc8496d06">emplace_back_iter</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:a8d1f0b067719f2bec80eb54dc8496d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the end and returns an iterator pointing to this element.  <a href="classseq_1_1sequence.html#a8d1f0b067719f2bec80eb54dc8496d06">More...</a><br /></td></tr>
<tr class="separator:a8d1f0b067719f2bec80eb54dc8496d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a6dfc0af059f7d3c6dd0b255bea08f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#ab7a6dfc0af059f7d3c6dd0b255bea08f">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ab7a6dfc0af059f7d3c6dd0b255bea08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the sequence.  <a href="classseq_1_1sequence.html#ab7a6dfc0af059f7d3c6dd0b255bea08f">More...</a><br /></td></tr>
<tr class="separator:ab7a6dfc0af059f7d3c6dd0b255bea08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5154399bbe3d92e1e34eac5fade4a0ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a5154399bbe3d92e1e34eac5fade4a0ea">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a5154399bbe3d92e1e34eac5fade4a0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the sequence. value is moved into the new element.  <a href="classseq_1_1sequence.html#a5154399bbe3d92e1e34eac5fade4a0ea">More...</a><br /></td></tr>
<tr class="separator:a5154399bbe3d92e1e34eac5fade4a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a78cc8cb63af2c9e17251472179e07"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a83a78cc8cb63af2c9e17251472179e07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a83a78cc8cb63af2c9e17251472179e07">emplace_front</a> (Args &amp;&amp;... args) -&gt; T &amp;</td></tr>
<tr class="memdesc:a83a78cc8cb63af2c9e17251472179e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the beginning.  <a href="classseq_1_1sequence.html#a83a78cc8cb63af2c9e17251472179e07">More...</a><br /></td></tr>
<tr class="separator:a83a78cc8cb63af2c9e17251472179e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847e4347db76f3cdc324440565aeae64"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a847e4347db76f3cdc324440565aeae64"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a847e4347db76f3cdc324440565aeae64">emplace_front_iter</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:a847e4347db76f3cdc324440565aeae64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the beginning and returns an iterator pointing to this element.  <a href="classseq_1_1sequence.html#a847e4347db76f3cdc324440565aeae64">More...</a><br /></td></tr>
<tr class="separator:a847e4347db76f3cdc324440565aeae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1a3369b5343e9941d069ccc7cd4639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a1b1a3369b5343e9941d069ccc7cd4639">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a1b1a3369b5343e9941d069ccc7cd4639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element value to the beginning of the sequence.  <a href="classseq_1_1sequence.html#a1b1a3369b5343e9941d069ccc7cd4639">More...</a><br /></td></tr>
<tr class="separator:a1b1a3369b5343e9941d069ccc7cd4639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cfebf5c6fca8cee3b3c225efc897fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a89cfebf5c6fca8cee3b3c225efc897fa">push_front</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a89cfebf5c6fca8cee3b3c225efc897fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element value to the beginning of the sequence. value is moved into the new element.  <a href="classseq_1_1sequence.html#a89cfebf5c6fca8cee3b3c225efc897fa">More...</a><br /></td></tr>
<tr class="separator:a89cfebf5c6fca8cee3b3c225efc897fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed44589323e8dc1df5cd7d02dfe995f"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aaed44589323e8dc1df5cd7d02dfe995f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aaed44589323e8dc1df5cd7d02dfe995f">emplace</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:aaed44589323e8dc1df5cd7d02dfe995f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place anywhere into the sequence.  <a href="classseq_1_1sequence.html#aaed44589323e8dc1df5cd7d02dfe995f">More...</a><br /></td></tr>
<tr class="separator:aaed44589323e8dc1df5cd7d02dfe995f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcbce0b90160f9479bfcb7a09f3277e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a7dcbce0b90160f9479bfcb7a09f3277e">insert</a> (const T &amp;value) -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:a7dcbce0b90160f9479bfcb7a09f3277e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given element into the sequence.  <a href="classseq_1_1sequence.html#a7dcbce0b90160f9479bfcb7a09f3277e">More...</a><br /></td></tr>
<tr class="separator:a7dcbce0b90160f9479bfcb7a09f3277e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734f8d8f9158aa059d0c9f554febc7f9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a734f8d8f9158aa059d0c9f554febc7f9">insert</a> (T &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:a734f8d8f9158aa059d0c9f554febc7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given element into the sequence. value is moved into the new element.  <a href="classseq_1_1sequence.html#a734f8d8f9158aa059d0c9f554febc7f9">More...</a><br /></td></tr>
<tr class="separator:a734f8d8f9158aa059d0c9f554febc7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac210c62cf9931e32cff1e0d0334e260a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#ac210c62cf9931e32cff1e0d0334e260a">resize</a> (<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> count)</td></tr>
<tr class="memdesc:ac210c62cf9931e32cff1e0d0334e260a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classseq_1_1sequence.html#ac210c62cf9931e32cff1e0d0334e260a">More...</a><br /></td></tr>
<tr class="separator:ac210c62cf9931e32cff1e0d0334e260a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8f6e9f1d13c8d117c5366be9f7f511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#abe8f6e9f1d13c8d117c5366be9f7f511">resize</a> (<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:abe8f6e9f1d13c8d117c5366be9f7f511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classseq_1_1sequence.html#abe8f6e9f1d13c8d117c5366be9f7f511">More...</a><br /></td></tr>
<tr class="separator:abe8f6e9f1d13c8d117c5366be9f7f511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8496f2670bef2a4bd401f6671d8fc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a6e8496f2670bef2a4bd401f6671d8fc9">resize_front</a> (<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> count)</td></tr>
<tr class="memdesc:a6e8496f2670bef2a4bd401f6671d8fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classseq_1_1sequence.html#a6e8496f2670bef2a4bd401f6671d8fc9">More...</a><br /></td></tr>
<tr class="separator:a6e8496f2670bef2a4bd401f6671d8fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c60dbf30ac1ca742225813f7c0a9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a32c60dbf30ac1ca742225813f7c0a9dc">resize_front</a> (<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a32c60dbf30ac1ca742225813f7c0a9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classseq_1_1sequence.html#a32c60dbf30ac1ca742225813f7c0a9dc">More...</a><br /></td></tr>
<tr class="separator:a32c60dbf30ac1ca742225813f7c0a9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abfb382009477db4267abcd8ab447a4"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a6abfb382009477db4267abcd8ab447a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a6abfb382009477db4267abcd8ab447a4">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:a6abfb382009477db4267abcd8ab447a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container.  <a href="classseq_1_1sequence.html#a6abfb382009477db4267abcd8ab447a4">More...</a><br /></td></tr>
<tr class="separator:a6abfb382009477db4267abcd8ab447a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4723033549ea0170964bac18d10a1ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aa4723033549ea0170964bac18d10a1ef">assign</a> (const std::initializer_list&lt; T &gt; &amp;lst)</td></tr>
<tr class="memdesc:aa4723033549ea0170964bac18d10a1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container.  <a href="classseq_1_1sequence.html#aa4723033549ea0170964bac18d10a1ef">More...</a><br /></td></tr>
<tr class="separator:aa4723033549ea0170964bac18d10a1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782ba46f95e18c518c19899f39afa092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a782ba46f95e18c518c19899f39afa092">assign</a> (<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a782ba46f95e18c518c19899f39afa092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with count copies of value <em>value</em>.  <a href="classseq_1_1sequence.html#a782ba46f95e18c518c19899f39afa092">More...</a><br /></td></tr>
<tr class="separator:a782ba46f95e18c518c19899f39afa092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf494125859119c2748a7a5e59588fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a1bf494125859119c2748a7a5e59588fa">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a1bf494125859119c2748a7a5e59588fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack the sequence to remove empty slots and release unused memory. All empty slots created by calls to <a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb" title="Erases the specified element from the container.">erase()</a> are filled by moving each element toward the beginning. This function might deallocate unused buckets created by the shrinking operation, but never allocates memory. Invalidates all references and iterators. Basic exception guarantee. <br  />
  <a href="classseq_1_1sequence.html#a1bf494125859119c2748a7a5e59588fa">More...</a><br /></td></tr>
<tr class="separator:a1bf494125859119c2748a7a5e59588fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54647e26b4fb0be48e05fc345c3272d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a54647e26b4fb0be48e05fc345c3272d3">reserve</a> (size_t new_cap)</td></tr>
<tr class="memdesc:a54647e26b4fb0be48e05fc345c3272d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the vector to a value that's greater or equal to new_cap.  <a href="classseq_1_1sequence.html#a54647e26b4fb0be48e05fc345c3272d3">More...</a><br /></td></tr>
<tr class="separator:a54647e26b4fb0be48e05fc345c3272d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad484e68bb32cfabe38cc19f5821afaec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#ad484e68bb32cfabe38cc19f5821afaec">pop_front</a> () noexcept</td></tr>
<tr class="memdesc:ad484e68bb32cfabe38cc19f5821afaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of the container. Calling pop_front on an empty container results in undefined behavior. Iterators and references to the first element are invalidated. Other iterators and references remain valid.  <a href="classseq_1_1sequence.html#ad484e68bb32cfabe38cc19f5821afaec">More...</a><br /></td></tr>
<tr class="separator:ad484e68bb32cfabe38cc19f5821afaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af358418e79ad4c4839bd2516bd44a945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#af358418e79ad4c4839bd2516bd44a945">pop_back</a> () noexcept</td></tr>
<tr class="memdesc:af358418e79ad4c4839bd2516bd44a945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container. Calling pop_back on an empty container results in undefined behavior. Iterators and references to the last element are invalidated. Other iterators and references remain valid.  <a href="classseq_1_1sequence.html#af358418e79ad4c4839bd2516bd44a945">More...</a><br /></td></tr>
<tr class="separator:af358418e79ad4c4839bd2516bd44a945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1425047a741f1e239666424ed66825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a2c1425047a741f1e239666424ed66825">iterator_at</a> (<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:a2c1425047a741f1e239666424ed66825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to given position.  <a href="classseq_1_1sequence.html#a2c1425047a741f1e239666424ed66825">More...</a><br /></td></tr>
<tr class="separator:a2c1425047a741f1e239666424ed66825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafef3a1834ec72ea64cddb03b13ada89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aafef3a1834ec72ea64cddb03b13ada89">iterator_at</a> (<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a></td></tr>
<tr class="memdesc:aafef3a1834ec72ea64cddb03b13ada89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to given position.  <a href="classseq_1_1sequence.html#aafef3a1834ec72ea64cddb03b13ada89">More...</a><br /></td></tr>
<tr class="separator:aafef3a1834ec72ea64cddb03b13ada89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f8636e2d4b36354c8f88e2ed7eafdb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb">erase</a> (<a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> it) noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:ac1f8636e2d4b36354c8f88e2ed7eafdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the specified element from the container.  <a href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb">More...</a><br /></td></tr>
<tr class="separator:ac1f8636e2d4b36354c8f88e2ed7eafdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4660a1a0547cbdac749b20f59f251c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aed4660a1a0547cbdac749b20f59f251c">erase</a> (<a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> first, <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> last) noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:aed4660a1a0547cbdac749b20f59f251c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the specified elements from the container.  <a href="classseq_1_1sequence.html#aed4660a1a0547cbdac749b20f59f251c">More...</a><br /></td></tr>
<tr class="separator:aed4660a1a0547cbdac749b20f59f251c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2005c28e8537de74b4c1e588180463"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a0c2005c28e8537de74b4c1e588180463">sort</a> ()</td></tr>
<tr class="memdesc:a0c2005c28e8537de74b4c1e588180463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator. <a class="el" href="classseq_1_1sequence.html#a0c2005c28e8537de74b4c1e588180463" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">sort()</a> relies on the <a href="https://github.com/orlp/pdqsort">pdqsort</a> implementation from Orson Peters, and should be as fast as sorting a std::deque. This invalidates all iterators and references.  <a href="classseq_1_1sequence.html#a0c2005c28e8537de74b4c1e588180463">More...</a><br /></td></tr>
<tr class="separator:a0c2005c28e8537de74b4c1e588180463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca5c3fc0cc7a2660c90b601b075ca97"><td class="memTemplParams" colspan="2">template&lt;class Less &gt; </td></tr>
<tr class="memitem:a5ca5c3fc0cc7a2660c90b601b075ca97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a5ca5c3fc0cc7a2660c90b601b075ca97">sort</a> (Less less)</td></tr>
<tr class="memdesc:a5ca5c3fc0cc7a2660c90b601b075ca97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the sequence using given comparator. <a class="el" href="classseq_1_1sequence.html#a0c2005c28e8537de74b4c1e588180463" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">sort()</a> relies on the <a href="https://github.com/orlp/pdqsort">pdqsort</a> implementation from Orson Peters, and should be as fast as sorting a std::deque. This invalidates all iterators and references.  <a href="classseq_1_1sequence.html#a5ca5c3fc0cc7a2660c90b601b075ca97">More...</a><br /></td></tr>
<tr class="separator:a5ca5c3fc0cc7a2660c90b601b075ca97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaca3cd0a83c4637c28599ac55d70a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a5aaca3cd0a83c4637c28599ac55d70a0">stable_sort</a> ()</td></tr>
<tr class="memdesc:a5aaca3cd0a83c4637c28599ac55d70a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator. <a class="el" href="classseq_1_1sequence.html#a5aaca3cd0a83c4637c28599ac55d70a0" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">stable_sort()</a> relies on std::stable_sort. This invalidates all iterators and references.  <a href="classseq_1_1sequence.html#a5aaca3cd0a83c4637c28599ac55d70a0">More...</a><br /></td></tr>
<tr class="separator:a5aaca3cd0a83c4637c28599ac55d70a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa979daac3cf88f256f9902ac150ae687"><td class="memTemplParams" colspan="2">template&lt;class Less &gt; </td></tr>
<tr class="memitem:aa979daac3cf88f256f9902ac150ae687"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aa979daac3cf88f256f9902ac150ae687">stable_sort</a> (Less less)</td></tr>
<tr class="memdesc:aa979daac3cf88f256f9902ac150ae687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the sequence using given comparator. The sequence is sorted using the std::less&lt;value_type&gt; comparator. <a class="el" href="classseq_1_1sequence.html#a5aaca3cd0a83c4637c28599ac55d70a0" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">stable_sort()</a> relies on std::stable_sort. This invalidates all iterators and references.  <a href="classseq_1_1sequence.html#aa979daac3cf88f256f9902ac150ae687">More...</a><br /></td></tr>
<tr class="separator:aa979daac3cf88f256f9902ac150ae687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c8eb8d6b9da3a1c11e5435a2f5cddd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#ac3c8eb8d6b9da3a1c11e5435a2f5cddd">begin</a> () noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:ac3c8eb8d6b9da3a1c11e5435a2f5cddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the sequence.  <a href="classseq_1_1sequence.html#ac3c8eb8d6b9da3a1c11e5435a2f5cddd">More...</a><br /></td></tr>
<tr class="separator:ac3c8eb8d6b9da3a1c11e5435a2f5cddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c7dc5ed7ae9b77b1f03d62598e6c85"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a99c7dc5ed7ae9b77b1f03d62598e6c85">end</a> () noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a></td></tr>
<tr class="memdesc:a99c7dc5ed7ae9b77b1f03d62598e6c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the sequence.  <a href="classseq_1_1sequence.html#a99c7dc5ed7ae9b77b1f03d62598e6c85">More...</a><br /></td></tr>
<tr class="separator:a99c7dc5ed7ae9b77b1f03d62598e6c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3bfec20491f31f9ceb15edeaff641d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a3d3bfec20491f31f9ceb15edeaff641d">begin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a></td></tr>
<tr class="memdesc:a3d3bfec20491f31f9ceb15edeaff641d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the sequence.  <a href="classseq_1_1sequence.html#a3d3bfec20491f31f9ceb15edeaff641d">More...</a><br /></td></tr>
<tr class="separator:a3d3bfec20491f31f9ceb15edeaff641d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be22cdbf4dc4c8e7a04ca4cb10f678a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a5be22cdbf4dc4c8e7a04ca4cb10f678a">end</a> () const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a></td></tr>
<tr class="memdesc:a5be22cdbf4dc4c8e7a04ca4cb10f678a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the sequence.  <a href="classseq_1_1sequence.html#a5be22cdbf4dc4c8e7a04ca4cb10f678a">More...</a><br /></td></tr>
<tr class="separator:a5be22cdbf4dc4c8e7a04ca4cb10f678a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9351f606e19c97ff8bca5e3c14c523"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a9b9351f606e19c97ff8bca5e3c14c523">cbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a></td></tr>
<tr class="memdesc:a9b9351f606e19c97ff8bca5e3c14c523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the sequence.  <a href="classseq_1_1sequence.html#a9b9351f606e19c97ff8bca5e3c14c523">More...</a><br /></td></tr>
<tr class="separator:a9b9351f606e19c97ff8bca5e3c14c523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a623ad2c1f33d8f77f0fc72bc595f3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a29a623ad2c1f33d8f77f0fc72bc595f3">cend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a></td></tr>
<tr class="memdesc:a29a623ad2c1f33d8f77f0fc72bc595f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the sequence.  <a href="classseq_1_1sequence.html#a29a623ad2c1f33d8f77f0fc72bc595f3">More...</a><br /></td></tr>
<tr class="separator:a29a623ad2c1f33d8f77f0fc72bc595f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171dbeb2ec92ce2e1ec8276d7dca62b0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a171dbeb2ec92ce2e1ec8276d7dca62b0">rbegin</a> () noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#afb25931272360700029c5ee234a33d55">reverse_iterator</a></td></tr>
<tr class="memdesc:a171dbeb2ec92ce2e1ec8276d7dca62b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1sequence.html#a171dbeb2ec92ce2e1ec8276d7dca62b0">More...</a><br /></td></tr>
<tr class="separator:a171dbeb2ec92ce2e1ec8276d7dca62b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa294972460ea6901c67f3ecdabbbd5aa"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aa294972460ea6901c67f3ecdabbbd5aa">rbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aa294972460ea6901c67f3ecdabbbd5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1sequence.html#aa294972460ea6901c67f3ecdabbbd5aa">More...</a><br /></td></tr>
<tr class="separator:aa294972460ea6901c67f3ecdabbbd5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721f798702b525261cc0222391fadf10"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a721f798702b525261cc0222391fadf10">rend</a> () noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#afb25931272360700029c5ee234a33d55">reverse_iterator</a></td></tr>
<tr class="memdesc:a721f798702b525261cc0222391fadf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1sequence.html#a721f798702b525261cc0222391fadf10">More...</a><br /></td></tr>
<tr class="separator:a721f798702b525261cc0222391fadf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae36ffbf91cbc860849d54bd0d16c07"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a4ae36ffbf91cbc860849d54bd0d16c07">rend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a4ae36ffbf91cbc860849d54bd0d16c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1sequence.html#a4ae36ffbf91cbc860849d54bd0d16c07">More...</a><br /></td></tr>
<tr class="separator:a4ae36ffbf91cbc860849d54bd0d16c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47895059d05970a477403e51f5452aad"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a47895059d05970a477403e51f5452aad">crbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a47895059d05970a477403e51f5452aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1sequence.html#a47895059d05970a477403e51f5452aad">More...</a><br /></td></tr>
<tr class="separator:a47895059d05970a477403e51f5452aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eb7d88d82120094c2239e379c4673e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aa6eb7d88d82120094c2239e379c4673e">crend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aa6eb7d88d82120094c2239e379c4673e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1sequence.html#aa6eb7d88d82120094c2239e379c4673e">More...</a><br /></td></tr>
<tr class="separator:aa6eb7d88d82120094c2239e379c4673e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a21013b95f15468be8a88bded677a45de"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a21013b95f15468be8a88bded677a45de">max_size</a> () noexcept -&gt; <a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a></td></tr>
<tr class="memdesc:a21013b95f15468be8a88bded677a45de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sequence maximum size.  <a href="classseq_1_1sequence.html#a21013b95f15468be8a88bded677a45de">More...</a><br /></td></tr>
<tr class="separator:a21013b95f15468be8a88bded677a45de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aeb6ac52d4ab37a2cace3a9c45e6dfe50"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#aeb6ac52d4ab37a2cace3a9c45e6dfe50">detail::sequence_const_iterator&lt; this_type &gt;</a></td></tr>
<tr class="separator:aeb6ac52d4ab37a2cace3a9c45e6dfe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678594126fb1327768c3931311cad470"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1sequence.html#a678594126fb1327768c3931311cad470">detail::sequence_iterator&lt; this_type &gt;</a></td></tr>
<tr class="separator:a678594126fb1327768c3931311cad470"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Allocator = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt;<br />
class seq::sequence&lt; T, Allocator, layout, ForceAlign64 &gt;</h3>

<p>sequence is an ordered container supporting constant time insertion at both end and constant removal anywhere. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator type</td></tr>
  </table>
  </dd>
</dl>
<p>The sequence container behaves like a hybrid version of std::deque and std::list. It provides:</p><ul>
<li>Constant time insertion at the back or the front using members <a class="el" href="classseq_1_1sequence.html#ab7a6dfc0af059f7d3c6dd0b255bea08f" title="Appends the given element value to the end of the sequence.">push_back()</a>, <a class="el" href="classseq_1_1sequence.html#a0fb2a3944e4ad72fbbf625b1aa816d04" title="Constructs an element in-place at the end.">emplace_back()</a>, <a class="el" href="classseq_1_1sequence.html#a1b1a3369b5343e9941d069ccc7cd4639" title="Prepends the given element value to the beginning of the sequence.">push_front()</a> and <a class="el" href="classseq_1_1sequence.html#a83a78cc8cb63af2c9e17251472179e07" title="Constructs an element in-place at the beginning.">emplace_front()</a></li>
<li>Constant time removal of one or more elements with <a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb" title="Erases the specified element from the container.">erase()</a></li>
<li>Stability of references and iterators (except end iterator).</li>
</ul>
<p>Unlike std::list, the sequence container does not provide insertion anywhere in the container. Instead, sequence provides unordered insertion through its member <a class="el" href="classseq_1_1sequence.html#a7dcbce0b90160f9479bfcb7a09f3277e" title="Insert the given element into the sequence.">insert()</a>, much like the <a href="https://plflib.org/colony.htm">plf::colony</a> class. Unordered insertion is usually prefered to back or front insertion as it can reuse free slots created by <a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb" title="Erases the specified element from the container.">erase()</a> and avoid potential allocations. In addition, its <a class="el" href="classseq_1_1sequence.html#a0c2005c28e8537de74b4c1e588180463" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">sort()</a>, <a class="el" href="classseq_1_1sequence.html#a5aaca3cd0a83c4637c28599ac55d70a0" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">stable_sort()</a> and <a class="el" href="classseq_1_1sequence.html#a1bf494125859119c2748a7a5e59588fa" title="Pack the sequence to remove empty slots and release unused memory. All empty slots created by calls t...">shrink_to_fit()</a> members do not preserve reference and iterator stability.</p>
<p>Its main advantages other std::list (and other containers) are:</p><ul>
<li>Insertion at both ends is faster than a std::deque or std::vector (without reserve)</li>
<li>Walking through the sequence with iterators is usually faster than walking through a std::deque</li>
<li>Sorting a sequence (with <a class="el" href="classseq_1_1sequence.html#a0c2005c28e8537de74b4c1e588180463" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">sort()</a> or <a class="el" href="classseq_1_1sequence.html#a5aaca3cd0a83c4637c28599ac55d70a0" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">stable_sort()</a>) is usually as fast as sorting a std::deque. Note that #sequence::sort() uses <a href="https://github.com/orlp/pdqsort">pdqsort</a> from Orson Peters.</li>
<li>Its memory overhead is lower than a std::list: around 1 byte per element.</li>
</ul>
<p>The sequence container is a perfect candidate for std::queue and std::stack. It is used by the seq library as the backend container for <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> and <a class="el" href="classseq_1_1ordered__map.html" title="Associative container that contains key-value pairs with unique keys. Search, insertion,...">seq::ordered_map</a>.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Technical description</h2>
<p>sequence container is implemented as a linked list of buckets. Each bucket holds (up to) 64 elements in a contiguous storage, and a 64 bits integer telling if a slot is empty or occupied.</p>
<p>In order to retrieve the index of the first (or last) used slot in a bucket, or to get the number of occupied slots, the sequence container uses OS intrinsics to scan the 64 bits integer. For instance, on Windows, <em>_BitScanForward64</em>, <em>_BitScanRevers64</em> and <em>_mm_popcnt_u64</em> are used. Removing an element from the sequence will set the corresponding bit to 0, inserting will set the bit to 1.</p>
<p>In addition, the sequence maintains another linked list of partially free buckets in order to perform fast unordered insertion using <a class="el" href="classseq_1_1sequence.html#a7dcbce0b90160f9479bfcb7a09f3277e" title="Insert the given element into the sequence.">insert()</a> member and therefore reuse slots previously deleted by <a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb" title="Erases the specified element from the container.">erase()</a>.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Iterators</h2>
<p>sequence iterator and const_iterator are bidirectional iterators. However, they provide all the members to behave like random access iterator, except the std::random_access_iterator_tag typedef.</p>
<p>Indeed, using <em><a class="el" href="classseq_1_1detail_1_1sequence__iterator.html#a9ecbbe579745bd34a8b183b0000e5700">iterator::operator+=</a></em> is, for instance, much faster than <em>std::advance</em> as it can skip whole buckets to reach the required location. Likewise subtracting 2 iterators is much faster than using <em>std::distance</em>.</p>
<p>sequence iterator also provide comparison operators &lt;, &gt;, &lt;= and &gt;=.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Memory managment</h2>
<p>When using the <em>OptimizeForMemory</em> flag, the sequence will allocate each bucket independently using the provided allocator.</p>
<p>When using the <em>OptimizeForSpeed</em> flag, the sequence will use a memory pool to allocate several buckets at once, still using the provided allocator. The memory pool uses a growing strategy to allocate more and more buckets based on a growth factor (SEQ_GROW_FACTOR define, defaulting to 1.6). The memory pool makes insertion tipically 50% faster than the default allocation strategy, but will consume slightly more memory.</p>
<p>Whenever a bucket is empty (by calls to <a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb" title="Erases the specified element from the container.">erase()</a>, <a class="el" href="classseq_1_1sequence.html#afa3e3d448af95c0bf3a7e897ae02f193" title="Clears the contents. Erases all elements from the container. After this call, size() returns zero....">clear()</a>, <a class="el" href="classseq_1_1sequence.html#ac210c62cf9931e32cff1e0d0334e260a" title="Resizes the container to contain count elements.">resize()</a>, <a class="el" href="classseq_1_1sequence.html#a6e8496f2670bef2a4bd401f6671d8fc9" title="Resizes the container to contain count elements.">resize_front()</a> or <a class="el" href="classseq_1_1sequence.html#a1bf494125859119c2748a7a5e59588fa" title="Pack the sequence to remove empty slots and release unused memory. All empty slots created by calls t...">shrink_to_fit()</a>), the sequence releases the occupied memory. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa1eea1d1e4d1e27cd662163a9fbbe20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1eea1d1e4d1e27cd662163a9fbbe20d">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#aa1eea1d1e4d1e27cd662163a9fbbe20d">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f4c3f39d42b9d1c0cc33f3f85c93e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> =  <a class="el" href="classseq_1_1detail_1_1sequence__const__iterator.html">detail::sequence_const_iterator</a>&lt; <a class="el" href="classseq_1_1sequence.html">this_type</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add42b097218600cdea80260595f9d4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add42b097218600cdea80260595f9d4af">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#add42b097218600cdea80260595f9d4af">const_pointer</a> =  const T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab014bbe6eb79dd6e79d0f24cdac13485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab014bbe6eb79dd6e79d0f24cdac13485">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6090a614e298f8427de83867a6a6d5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6090a614e298f8427de83867a6a6d5a5">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#a6090a614e298f8427de83867a6a6d5a5">difference_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1sequence.html#a6090a614e298f8427de83867a6a6d5a5">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a07a0366c0a33e89a2faa4602528833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a07a0366c0a33e89a2faa4602528833">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a> =  <a class="el" href="classseq_1_1detail_1_1sequence__iterator.html">detail::sequence_iterator</a>&lt; <a class="el" href="classseq_1_1sequence.html">this_type</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acabdd221c3de222009df566403df0ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabdd221c3de222009df566403df0ca1">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#acabdd221c3de222009df566403df0ca1">pointer</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24fd41c14102120ece2ef329e643bc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fd41c14102120ece2ef329e643bc49">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#a24fd41c14102120ece2ef329e643bc49">reference</a> =  T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb25931272360700029c5ee234a33d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb25931272360700029c5ee234a33d55">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#afb25931272360700029c5ee234a33d55">reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dd184f2899a4f88b9c0f4ae80c4c87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd184f2899a4f88b9c0f4ae80c4c87d">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13defe50f14aa6e1023a7bd3671f0feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13defe50f14aa6e1023a7bd3671f0feb">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html#a13defe50f14aa6e1023a7bd3671f0feb">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a55e251b438d7af784967f5d268b86332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e251b438d7af784967f5d268b86332">&#9670;&nbsp;</a></span>sequence() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, initialize internal data. </p>

</div>
</div>
<a id="a0aa7c515eab5fe015f20f9879b6346d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa7c515eab5fe015f20f9879b6346d8">&#9670;&nbsp;</a></span>sequence() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an allocator object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14ddbd2300b9a82a6362e43351bde878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ddbd2300b9a82a6362e43351bde878">&#9670;&nbsp;</a></span>sequence() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with an initial size and a fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>initial size </td></tr>
    <tr><td class="paramname">value</td><td>fill value </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a402c55a55b9a9b3acd2517fb88497e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402c55a55b9a9b3acd2517fb88497e6a">&#9670;&nbsp;</a></span>sequence() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with an initial size. Objects will be value initialize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>initial size </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb600487cc318a71f41377ec755d8a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb600487cc318a71f41377ec755d8a08">&#9670;&nbsp;</a></span>sequence() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1sequence.html">sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>input sequence to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d8347c5afdb32cca4d5c91c5da820c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8347c5afdb32cca4d5c91c5da820c2">&#9670;&nbsp;</a></span>sequence() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1sequence.html">sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>input sequence to copy </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77d815a5628cc6f8037465017dae6558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d815a5628cc6f8037465017dae6558">&#9670;&nbsp;</a></span>sequence() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html">sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cd969dd2081e6ab9c6acbdc8e7475c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd969dd2081e6ab9c6acbdc8e7475c1">&#9670;&nbsp;</a></span>sequence() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html">sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bc0b4e6e117b2c63c3d124068ab81ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc0b4e6e117b2c63c3d124068ab81ba">&#9670;&nbsp;</a></span>sequence() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the sequence with the contents of the initializer list <em>lst</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td>initializer list </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a218407716e827960ecf70c3b40dee140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218407716e827960ecf70c3b40dee140">&#9670;&nbsp;</a></span>sequence() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the sequence with the contents of the range [first, last). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>begin iterator </td></tr>
    <tr><td class="paramname">last</td><td>end iterator </td></tr>
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad15ffd990a824f160fbe8fb66878d8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15ffd990a824f160fbe8fb66878d8ff">&#9670;&nbsp;</a></span>~sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::~<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa4723033549ea0170964bac18d10a1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4723033549ea0170964bac18d10a1ef">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td>initializer list to copy the values from Basic exception guarantee. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6abfb382009477db4267abcd8ab447a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abfb382009477db4267abcd8ab447a4">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>LegacyInputIterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>range to copy the elements from Basic exception guarantee. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a782ba46f95e18c518c19899f39afa092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782ba46f95e18c518c19899f39afa092">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with count copies of value <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with Basic exception guarantee. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84eae0de15058ca5a708264a241564b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84eae0de15058ca5a708264a241564b6">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the back sequence value. </p>

</div>
</div>
<a id="a6da4f80e918b45025b44eef043b1d4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da4f80e918b45025b44eef043b1d4a9">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the back sequence value. </p>

</div>
</div>
<a id="a3d3bfec20491f31f9ceb15edeaff641d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3bfec20491f31f9ceb15edeaff641d">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the sequence. </p>

</div>
</div>
<a id="ac3c8eb8d6b9da3a1c11e5435a2f5cddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c8eb8d6b9da3a1c11e5435a2f5cddd">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the sequence. </p>

</div>
</div>
<a id="a39900c1d6c4189f852298857a3ef7938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39900c1d6c4189f852298857a3ef7938">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that the container has currently allocated space for. </p>

</div>
</div>
<a id="a9b9351f606e19c97ff8bca5e3c14c523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9351f606e19c97ff8bca5e3c14c523">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the sequence. </p>

</div>
</div>
<a id="a29a623ad2c1f33d8f77f0fc72bc595f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a623ad2c1f33d8f77f0fc72bc595f3">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the sequence. </p>

</div>
</div>
<a id="afa3e3d448af95c0bf3a7e897ae02f193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3e3d448af95c0bf3a7e897ae02f193">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the contents. Erases all elements from the container. After this call, size() returns zero. Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid. </p>

</div>
</div>
<a id="a47895059d05970a477403e51f5452aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47895059d05970a477403e51f5452aad">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="aa6eb7d88d82120094c2239e379c4673e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6eb7d88d82120094c2239e379c4673e">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a425737526395c84ed6b57b6297bcb410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425737526395c84ed6b57b6297bcb410">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const Data* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a24cf8f2fe37e422bcc119ebd2f064dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cf8f2fe37e422bcc119ebd2f064dce">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; Data*  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sequence internal data. Internal use only. </p>

</div>
</div>
<a id="aaed44589323e8dc1df5cd7d02dfe995f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed44589323e8dc1df5cd7d02dfe995f">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place anywhere into the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to newly inserted element The element could be inserted anywhere inside the sequence, including at the back or front. This function tries to recyclate free slots after calls to <a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb" title="Erases the specified element from the container.">erase()</a>. You should favor this function if you don't care about the sequence ordering. No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a0fb2a3944e4ad72fbbf625b1aa816d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb2a3944e4ad72fbbf625b1aa816d04">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; T&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the end. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the newly constructed object No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a8d1f0b067719f2bec80eb54dc8496d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1f0b067719f2bec80eb54dc8496d06">&#9670;&nbsp;</a></span>emplace_back_iter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::emplace_back_iter </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the end and returns an iterator pointing to this element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the inserted element No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a83a78cc8cb63af2c9e17251472179e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a78cc8cb63af2c9e17251472179e07">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; T&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the beginning. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the newly constructed object No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a847e4347db76f3cdc324440565aeae64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847e4347db76f3cdc324440565aeae64">&#9670;&nbsp;</a></span>emplace_front_iter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::emplace_front_iter </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the beginning and returns an iterator pointing to this element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the inserted element No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a367842660b634699aca64fa00af6743a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367842660b634699aca64fa00af6743a">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5be22cdbf4dc4c8e7a04ca4cb10f678a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be22cdbf4dc4c8e7a04ca4cb10f678a">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the sequence. </p>

</div>
</div>
<a id="a99c7dc5ed7ae9b77b1f03d62598e6c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c7dc5ed7ae9b77b1f03d62598e6c85">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the sequence. </p>

</div>
</div>
<a id="aed4660a1a0547cbdac749b20f59f251c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4660a1a0547cbdac749b20f59f251c">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the specified elements from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the element to remove </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element This function performs in O(1). Iterators and references to the erased elements are invalidated. Iterators and references to other elements in the sequence remain valid. </dd></dl>

</div>
</div>
<a id="ac1f8636e2d4b36354c8f88e2ed7eafdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f8636e2d4b36354c8f88e2ed7eafdb">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the specified element from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element This function performs in O(1). Iterators and references to the erased element are invalidated. Iterators and references to other elements in the sequence remain valid. </dd></dl>

</div>
</div>
<a id="a41b2a98cd2c9a3249e6cc592f774a720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b2a98cd2c9a3249e6cc592f774a720">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the front sequence value. </p>

</div>
</div>
<a id="acaaf970d1c536112aec1153bd5d8c0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaf970d1c536112aec1153bd5d8c0e8">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the front sequence value. </p>

</div>
</div>
<a id="a9f868260d86160cfb072ad362db4b6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f868260d86160cfb072ad362db4b6d3">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; Allocator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>

</div>
</div>
<a id="a065df7dfb6b5495249346d377d94b0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065df7dfb6b5495249346d377d94b0dc">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; Allocator&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>

</div>
</div>
<a id="a7dcbce0b90160f9479bfcb7a09f3277e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcbce0b90160f9479bfcb7a09f3277e">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given element into the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to newly inserted element The element could be inserted anywhere inside the sequence, including at the back or front. This function tries to recyclate free slots after calls to <a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb" title="Erases the specified element from the container.">erase()</a>. You should favor this function if you don't care about the sequence ordering. No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="a734f8d8f9158aa059d0c9f554febc7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734f8d8f9158aa059d0c9f554febc7f9">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given element into the sequence. value is moved into the new element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to newly inserted element The element could be inserted anywhere inside the sequence, including at the back or front. This function tries to recyclate free slots after calls to <a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb" title="Erases the specified element from the container.">erase()</a>. You should favor this function if you don't care about the sequence ordering. No iterators or references are invalidated. Strong exception guarantee. </dd></dl>

</div>
</div>
<a id="aafef3a1834ec72ea64cddb03b13ada89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafef3a1834ec72ea64cddb03b13ada89">&#9670;&nbsp;</a></span>iterator_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::iterator_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#a7f4c3f39d42b9d1c0cc33f3f85c93e0d">const_iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator to given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position in the sequence While sequence is not a random access container, operations on iterators are still faster than for a conventional std::list. This function is faster than using <a class="el" href="classseq_1_1sequence.html#ac3c8eb8d6b9da3a1c11e5435a2f5cddd" title="Returns an iterator to the first element of the sequence.">begin()</a>+pos as it might start from the end to reach the required position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c1425047a741f1e239666424ed66825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1425047a741f1e239666424ed66825">&#9670;&nbsp;</a></span>iterator_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::iterator_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7a07a0366c0a33e89a2faa4602528833">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position in the sequence While sequence is not a random access container, operations on iterators are still faster than for a conventional std::list. This function is faster than using <a class="el" href="classseq_1_1sequence.html#ac3c8eb8d6b9da3a1c11e5435a2f5cddd" title="Returns an iterator to the first element of the sequence.">begin()</a>+pos as it might start from the end to reach the required position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21013b95f15468be8a88bded677a45de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21013b95f15468be8a88bded677a45de">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sequence maximum size. </p>

</div>
</div>
<a id="aef7cb1d4d77ba5476930bfdffef65e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7cb1d4d77ba5476930bfdffef65e09">&#9670;&nbsp;</a></span>memory_footprint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::memory_footprint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the full memory footprint of this sequence in bytes, excluding sizeof(*this). </p>

</div>
</div>
<a id="a3fe31dfa20f873fe2e541d37efacb6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe31dfa20f873fe2e541d37efacb6d4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1sequence.html">sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html">sequence</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator, basic exception guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>input sequence object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="a24f4acbccef9afb88836ca12d7fba1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f4acbccef9afb88836ca12d7fba1f3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html">sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html">sequence</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>input sequence object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

</div>
</div>
<a id="af358418e79ad4c4839bd2516bd44a945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af358418e79ad4c4839bd2516bd44a945">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. Calling pop_back on an empty container results in undefined behavior. Iterators and references to the last element are invalidated. Other iterators and references remain valid. </p>

</div>
</div>
<a id="ad484e68bb32cfabe38cc19f5821afaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad484e68bb32cfabe38cc19f5821afaec">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element of the container. Calling pop_front on an empty container results in undefined behavior. Iterators and references to the first element are invalidated. Other iterators and references remain valid. </p>

</div>
</div>
<a id="ab7a6dfc0af059f7d3c6dd0b255bea08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a6dfc0af059f7d3c6dd0b255bea08f">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>No iterators or references are invalidated. Strong exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5154399bbe3d92e1e34eac5fade4a0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5154399bbe3d92e1e34eac5fade4a0ea">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the sequence. value is moved into the new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b1a3369b5343e9941d069ccc7cd4639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1a3369b5343e9941d069ccc7cd4639">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element value to the beginning of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>No iterators or references are invalidated. Strong exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89cfebf5c6fca8cee3b3c225efc897fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cfebf5c6fca8cee3b3c225efc897fa">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element value to the beginning of the sequence. value is moved into the new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>No iterators or references are invalidated. Strong exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa294972460ea6901c67f3ecdabbbd5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa294972460ea6901c67f3ecdabbbd5aa">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a171dbeb2ec92ce2e1ec8276d7dca62b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171dbeb2ec92ce2e1ec8276d7dca62b0">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#afb25931272360700029c5ee234a33d55">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a4ae36ffbf91cbc860849d54bd0d16c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae36ffbf91cbc860849d54bd0d16c07">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#ab014bbe6eb79dd6e79d0f24cdac13485">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a721f798702b525261cc0222391fadf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721f798702b525261cc0222391fadf10">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1sequence.html#afb25931272360700029c5ee234a33d55">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a54647e26b4fb0be48e05fc345c3272d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54647e26b4fb0be48e05fc345c3272d3">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity of the vector to a value that's greater or equal to new_cap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>new capacity of the sequence If new_cap is greater than the current <a class="el" href="classseq_1_1sequence.html#a39900c1d6c4189f852298857a3ef7938" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, new storage is allocated, otherwise the function does nothing. <a class="el" href="classseq_1_1sequence.html#a54647e26b4fb0be48e05fc345c3272d3" title="Increase the capacity of the vector to a value that&#39;s greater or equal to new_cap.">reserve()</a> does not change the size of the sequence. Note that <a class="el" href="classseq_1_1sequence.html#a54647e26b4fb0be48e05fc345c3272d3" title="Increase the capacity of the vector to a value that&#39;s greater or equal to new_cap.">reserve()</a> only works with <em>OptimizeForSpeed</em> flag. Basic exception guarantee. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac210c62cf9931e32cff1e0d0334e260a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac210c62cf9931e32cff1e0d0334e260a">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-inserted elements are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe8f6e9f1d13c8d117c5366be9f7f511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8f6e9f1d13c8d117c5366be9f7f511">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of value are appended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e8496f2670bef2a4bd401f6671d8fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8496f2670bef2a4bd401f6671d8fc9">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional default-inserted elements are prepended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32c60dbf30ac1ca742225813f7c0a9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c60dbf30ac1ca742225813f7c0a9dc">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional copies of value are prepended. Basic exception guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bf494125859119c2748a7a5e59588fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf494125859119c2748a7a5e59588fa">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack the sequence to remove empty slots and release unused memory. All empty slots created by calls to <a class="el" href="classseq_1_1sequence.html#ac1f8636e2d4b36354c8f88e2ed7eafdb" title="Erases the specified element from the container.">erase()</a> are filled by moving each element toward the beginning. This function might deallocate unused buckets created by the shrinking operation, but never allocates memory. Invalidates all references and iterators. Basic exception guarantee. <br  />
 </p>

</div>
</div>
<a id="af1171dafc78357c61afd896f15d87884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1171dafc78357c61afd896f15d87884">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1sequence.html#a7dd184f2899a4f88b9c0f4ae80c4c87d">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns thenumber of elements in this sequence. </p>

</div>
</div>
<a id="a0c2005c28e8537de74b4c1e588180463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2005c28e8537de74b4c1e588180463">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator. <a class="el" href="classseq_1_1sequence.html#a0c2005c28e8537de74b4c1e588180463" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">sort()</a> relies on the <a href="https://github.com/orlp/pdqsort">pdqsort</a> implementation from Orson Peters, and should be as fast as sorting a std::deque. This invalidates all iterators and references. </p>

</div>
</div>
<a id="a5ca5c3fc0cc7a2660c90b601b075ca97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca5c3fc0cc7a2660c90b601b075ca97">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<div class="memtemplate">
template&lt;class Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>less</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the sequence using given comparator. <a class="el" href="classseq_1_1sequence.html#a0c2005c28e8537de74b4c1e588180463" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">sort()</a> relies on the <a href="https://github.com/orlp/pdqsort">pdqsort</a> implementation from Orson Peters, and should be as fast as sorting a std::deque. This invalidates all iterators and references. </p>

</div>
</div>
<a id="a5aaca3cd0a83c4637c28599ac55d70a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aaca3cd0a83c4637c28599ac55d70a0">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::stable_sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator. <a class="el" href="classseq_1_1sequence.html#a5aaca3cd0a83c4637c28599ac55d70a0" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">stable_sort()</a> relies on std::stable_sort. This invalidates all iterators and references. </p>

</div>
</div>
<a id="aa979daac3cf88f256f9902ac150ae687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa979daac3cf88f256f9902ac150ae687">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<div class="memtemplate">
template&lt;class Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::stable_sort </td>
          <td>(</td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>less</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the sequence using given comparator. The sequence is sorted using the std::less&lt;value_type&gt; comparator. <a class="el" href="classseq_1_1sequence.html#a5aaca3cd0a83c4637c28599ac55d70a0" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">stable_sort()</a> relies on std::stable_sort. This invalidates all iterators and references. </p>

</div>
</div>
<a id="ac4eb2f85de25d69ca79a3e9e426f487b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4eb2f85de25d69ca79a3e9e426f487b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1sequence.html">seq::sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1sequence.html">sequence</a>&lt; T, Allocator, layout, ForceAlign64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other sequence to swap with All iterators and references remain valid. An iterator holding the past-the-end value in this container will refer to the other container after the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aeb6ac52d4ab37a2cace3a9c45e6dfe50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6ac52d4ab37a2cace3a9c45e6dfe50">&#9670;&nbsp;</a></span>detail::sequence_const_iterator&lt; this_type &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classseq_1_1detail_1_1sequence__const__iterator.html">detail::sequence_const_iterator</a>&lt; <a class="el" href="classseq_1_1sequence.html">this_type</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a678594126fb1327768c3931311cad470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678594126fb1327768c3931311cad470">&#9670;&nbsp;</a></span>detail::sequence_iterator&lt; this_type &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;, LayoutManagement layout = OptimizeForSpeed, bool ForceAlign64 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classseq_1_1detail_1_1sequence__iterator.html">detail::sequence_iterator</a>&lt; <a class="el" href="classseq_1_1sequence.html">this_type</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="sequence_8hpp_source.html">sequence.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1sequence.html">sequence</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
