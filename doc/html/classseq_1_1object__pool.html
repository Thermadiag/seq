<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::object_pool&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classseq_1_1object__pool.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classseq_1_1object__pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::object_pool&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Object pool class used to allocate objects of type T.  
 <a href="classseq_1_1object__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory_8hpp_source.html">memory.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="structseq_1_1detail_1_1base__object__pool.html">seq::detail::base_object_pool&lt; T &gt;</a>, <a class="el" href="structseq_1_1detail_1_1stats__data.html">seq::detail::stats_data&lt; GenerateStats &gt;</a>, and Allocator.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1object__pool_1_1rebind.html">rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind struct, used for <a class="el" href="classseq_1_1object__allocator.html" title="Stl conforming allocator based on an object pool class. ">seq::object_allocator</a>.  <a href="structseq_1_1object__pool_1_1rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8b6a4b58f45dfb4560a16c9b4a6454e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a8b6a4b58f45dfb4560a16c9b4a6454e0">value_type</a> = T</td></tr>
<tr class="memdesc:a8b6a4b58f45dfb4560a16c9b4a6454e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">object type  <a href="#a8b6a4b58f45dfb4560a16c9b4a6454e0">More...</a><br /></td></tr>
<tr class="separator:a8b6a4b58f45dfb4560a16c9b4a6454e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72539665f913721acd4787fedaa5a2c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a72539665f913721acd4787fedaa5a2c7">pointer</a> = T *</td></tr>
<tr class="memdesc:a72539665f913721acd4787fedaa5a2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer type  <a href="#a72539665f913721acd4787fedaa5a2c7">More...</a><br /></td></tr>
<tr class="separator:a72539665f913721acd4787fedaa5a2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe372637946e7d71e0d77363bcec812"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a4fe372637946e7d71e0d77363bcec812">allocator_type</a> = Allocator</td></tr>
<tr class="memdesc:a4fe372637946e7d71e0d77363bcec812"><td class="mdescLeft">&#160;</td><td class="mdescRight">supplied allocator type  <a href="#a4fe372637946e7d71e0d77363bcec812">More...</a><br /></td></tr>
<tr class="separator:a4fe372637946e7d71e0d77363bcec812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e3596ddb1309e36ebc321386d6dc5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a38e3596ddb1309e36ebc321386d6dc5d">unique_ptr</a> = std::unique_ptr&lt; T, <a class="el" href="structseq_1_1unique__ptr__deleter.html">unique_ptr_deleter</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a38e3596ddb1309e36ebc321386d6dc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">unique_ptr type if EnableUniquePtr is true  <a href="#a38e3596ddb1309e36ebc321386d6dc5d">More...</a><br /></td></tr>
<tr class="separator:a38e3596ddb1309e36ebc321386d6dc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deaec289a41210128d70792113aaeed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a2deaec289a41210128d70792113aaeed">shared_ptr</a> = std::shared_ptr&lt; T &gt;</td></tr>
<tr class="memdesc:a2deaec289a41210128d70792113aaeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">shared_ptr type if <a class="el" href="structseq_1_1shared__ptr__allocation.html">shared_ptr_allocation</a> is used with EnableUniquePtr  <a href="#a2deaec289a41210128d70792113aaeed">More...</a><br /></td></tr>
<tr class="separator:a2deaec289a41210128d70792113aaeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72acd76f831a3e0c65fdcbde44f9f6fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a72acd76f831a3e0c65fdcbde44f9f6fa">allocation_type</a> = object_allocation</td></tr>
<tr class="memdesc:a72acd76f831a3e0c65fdcbde44f9f6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocation pattern  <a href="#a72acd76f831a3e0c65fdcbde44f9f6fa">More...</a><br /></td></tr>
<tr class="separator:a72acd76f831a3e0c65fdcbde44f9f6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a799aee7e762678e020cd05b8cb27631f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a799aee7e762678e020cd05b8cb27631f">object_pool</a> (const Allocator &amp;al=Allocator()) noexcept</td></tr>
<tr class="memdesc:a799aee7e762678e020cd05b8cb27631f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a799aee7e762678e020cd05b8cb27631f">More...</a><br /></td></tr>
<tr class="separator:a799aee7e762678e020cd05b8cb27631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715fe6fa1710441724bebd93a565f17d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a715fe6fa1710441724bebd93a565f17d">~object_pool</a> () override</td></tr>
<tr class="separator:a715fe6fa1710441724bebd93a565f17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab508ba0903b7b60224c116c1016be050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#ab508ba0903b7b60224c116c1016be050">clear</a> ()</td></tr>
<tr class="memdesc:ab508ba0903b7b60224c116c1016be050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all blocks.  <a href="#ab508ba0903b7b60224c116c1016be050">More...</a><br /></td></tr>
<tr class="separator:ab508ba0903b7b60224c116c1016be050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12613b106f8af2a86e9084da4e2cd4bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a12613b106f8af2a86e9084da4e2cd4bb">reset</a> ()</td></tr>
<tr class="memdesc:a12613b106f8af2a86e9084da4e2cd4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a>.  <a href="#a12613b106f8af2a86e9084da4e2cd4bb">More...</a><br /></td></tr>
<tr class="separator:a12613b106f8af2a86e9084da4e2cd4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba0e2834a30fa3cbb4a1d895eb0f687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a5ba0e2834a30fa3cbb4a1d895eb0f687">reset_statistics</a> () noexcept</td></tr>
<tr class="memdesc:a5ba0e2834a30fa3cbb4a1d895eb0f687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset statistics.  <a href="#a5ba0e2834a30fa3cbb4a1d895eb0f687">More...</a><br /></td></tr>
<tr class="separator:a5ba0e2834a30fa3cbb4a1d895eb0f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2eeb6dbde18dbe45eba8527db0dec52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#ae2eeb6dbde18dbe45eba8527db0dec52">dump_statistics</a> (<a class="el" href="structseq_1_1object__pool__stats.html">object_pool_stats</a> &amp;stats)</td></tr>
<tr class="memdesc:ae2eeb6dbde18dbe45eba8527db0dec52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> statistics into a <a class="el" href="structseq_1_1object__pool__stats.html" title="Class gathering statistics for seq::object_pool or seq::parallel_object_pool. ">object_pool_stats</a>.  <a href="#ae2eeb6dbde18dbe45eba8527db0dec52">More...</a><br /></td></tr>
<tr class="separator:ae2eeb6dbde18dbe45eba8527db0dec52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f2219bf1f9dc09c5c1e67948febd70"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#aa7f2219bf1f9dc09c5c1e67948febd70">get_allocator</a> () const noexcept -&gt; const Allocator &amp;</td></tr>
<tr class="memdesc:aa7f2219bf1f9dc09c5c1e67948febd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying allocator object.  <a href="#aa7f2219bf1f9dc09c5c1e67948febd70">More...</a><br /></td></tr>
<tr class="separator:aa7f2219bf1f9dc09c5c1e67948febd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2286444dc9ce69a944f9465f0e12b37d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a2286444dc9ce69a944f9465f0e12b37d">get_allocator</a> () noexcept -&gt; Allocator &amp;</td></tr>
<tr class="memdesc:a2286444dc9ce69a944f9465f0e12b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying allocator object.  <a href="#a2286444dc9ce69a944f9465f0e12b37d">More...</a><br /></td></tr>
<tr class="separator:a2286444dc9ce69a944f9465f0e12b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb78702499af1357a871e3a0aadf0d8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#adcb78702499af1357a871e3a0aadf0d8">memory_footprint</a> () const noexcept -&gt; std::size_t</td></tr>
<tr class="memdesc:adcb78702499af1357a871e3a0aadf0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> memory footprint in bytes excluding sizeof(*this).  <a href="#adcb78702499af1357a871e3a0aadf0d8">More...</a><br /></td></tr>
<tr class="separator:adcb78702499af1357a871e3a0aadf0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38fbf8d66be889bb4b075b917942c89"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#aa38fbf8d66be889bb4b075b917942c89">peak_memory_footprint</a> () const noexcept -&gt; std::size_t</td></tr>
<tr class="memdesc:aa38fbf8d66be889bb4b075b917942c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> peak memory footprint in bytes excluding sizeof(*this).  <a href="#aa38fbf8d66be889bb4b075b917942c89">More...</a><br /></td></tr>
<tr class="separator:aa38fbf8d66be889bb4b075b917942c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97abff55ea874b6a6d1777fc3da9e15"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#ad97abff55ea874b6a6d1777fc3da9e15">reclaim_memory</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:ad97abff55ea874b6a6d1777fc3da9e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> reclaim freed memory, false otherwise.  <a href="#ad97abff55ea874b6a6d1777fc3da9e15">More...</a><br /></td></tr>
<tr class="separator:ad97abff55ea874b6a6d1777fc3da9e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9c75a122612306b3a95466946afddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#aee9c75a122612306b3a95466946afddc">set_reclaim_memory</a> (bool reclaim)</td></tr>
<tr class="memdesc:aee9c75a122612306b3a95466946afddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reclaim_memory flag.  <a href="#aee9c75a122612306b3a95466946afddc">More...</a><br /></td></tr>
<tr class="separator:aee9c75a122612306b3a95466946afddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575391a7d2cc25c2e8d0394d6057a5a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a575391a7d2cc25c2e8d0394d6057a5a9">release_unused_memory</a> ()</td></tr>
<tr class="memdesc:a575391a7d2cc25c2e8d0394d6057a5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate all unused memory blocks. This only makes sense if <a class="el" href="classseq_1_1object__pool.html#ad97abff55ea874b6a6d1777fc3da9e15" title="Returns true if the object_pool reclaim freed memory, false otherwise. ">reclaim_memory()</a> is false.  <a href="#a575391a7d2cc25c2e8d0394d6057a5a9">More...</a><br /></td></tr>
<tr class="separator:a575391a7d2cc25c2e8d0394d6057a5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef410e4c552ff1e537ee2fe40d07c5c0"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#aef410e4c552ff1e537ee2fe40d07c5c0">allocate</a> (size_t size) -&gt; T *override</td></tr>
<tr class="memdesc:aef410e4c552ff1e537ee2fe40d07c5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate size objects.  <a href="#aef410e4c552ff1e537ee2fe40d07c5c0">More...</a><br /></td></tr>
<tr class="separator:aef410e4c552ff1e537ee2fe40d07c5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298a62e82b2d3417fd72bee90184f5b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a298a62e82b2d3417fd72bee90184f5b7">deallocate</a> (T *ptr, size_t size) override</td></tr>
<tr class="memdesc:a298a62e82b2d3417fd72bee90184f5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate size objects. Non POD objects must have been destroyed previously.  <a href="#a298a62e82b2d3417fd72bee90184f5b7">More...</a><br /></td></tr>
<tr class="separator:a298a62e82b2d3417fd72bee90184f5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96fd22de10478226d8d5650ef4efb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#aa96fd22de10478226d8d5650ef4efb1a">reserve</a> (size_t alloc_size, size_t count)</td></tr>
<tr class="memdesc:aa96fd22de10478226d8d5650ef4efb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> in order to hold at least count free slots for calls to allocate(alloc_size).  <a href="#aa96fd22de10478226d8d5650ef4efb1a">More...</a><br /></td></tr>
<tr class="separator:aa96fd22de10478226d8d5650ef4efb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c693c5b972f21af9ab51a7fd22d15ba"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6c693c5b972f21af9ab51a7fd22d15ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a6c693c5b972f21af9ab51a7fd22d15ba">make_unique</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1object__pool.html#a38e3596ddb1309e36ebc321386d6dc5d">unique_ptr</a></td></tr>
<tr class="memdesc:a6c693c5b972f21af9ab51a7fd22d15ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique_ptr object constructed from the forwarded argument.  <a href="#a6c693c5b972f21af9ab51a7fd22d15ba">More...</a><br /></td></tr>
<tr class="separator:a6c693c5b972f21af9ab51a7fd22d15ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structseq_1_1detail_1_1base__object__pool"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structseq_1_1detail_1_1base__object__pool')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structseq_1_1detail_1_1base__object__pool.html">seq::detail::base_object_pool&lt; T &gt;</a></td></tr>
<tr class="memitem:a07aaca7767486e800033bd9d77452ec9 inherit pub_methods_structseq_1_1detail_1_1base__object__pool"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1detail_1_1base__object__pool.html#a07aaca7767486e800033bd9d77452ec9">~base_object_pool</a> ()</td></tr>
<tr class="separator:a07aaca7767486e800033bd9d77452ec9 inherit pub_methods_structseq_1_1detail_1_1base__object__pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:abc4e125e5f6034ba3dc855b58a778793"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#abc4e125e5f6034ba3dc855b58a778793">enable_unique_ptr</a> = EnableUniquePtr</td></tr>
<tr class="memdesc:abc4e125e5f6034ba3dc855b58a778793"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable/disable unique_ptr support  <a href="#abc4e125e5f6034ba3dc855b58a778793">More...</a><br /></td></tr>
<tr class="separator:abc4e125e5f6034ba3dc855b58a778793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73ff4e98c97ead724eda2b28e2aa49"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a0e73ff4e98c97ead724eda2b28e2aa49">generate_statistics</a> = GenerateStats</td></tr>
<tr class="memdesc:a0e73ff4e98c97ead724eda2b28e2aa49"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate temporal statistics  <a href="#a0e73ff4e98c97ead724eda2b28e2aa49">More...</a><br /></td></tr>
<tr class="separator:a0e73ff4e98c97ead724eda2b28e2aa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eedc50e4260ce1b3431ddfc420c2a6"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a32eedc50e4260ce1b3431ddfc420c2a6">alignment</a> = (Align == 0 || Align &lt; <a class="el" href="bits_8hpp.html#a4358957bf3c41e772ade27671699c4e6">SEQ_DEFAULT_ALIGNMENT</a>) ? <a class="el" href="bits_8hpp.html#a4358957bf3c41e772ade27671699c4e6">SEQ_DEFAULT_ALIGNMENT</a> : Align</td></tr>
<tr class="memdesc:a32eedc50e4260ce1b3431ddfc420c2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">object alignment  <a href="#a32eedc50e4260ce1b3431ddfc420c2a6">More...</a><br /></td></tr>
<tr class="separator:a32eedc50e4260ce1b3431ddfc420c2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4f2381a8e4c48db4b5ae4510f80f63"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a2b4f2381a8e4c48db4b5ae4510f80f63">max_objects</a> = object_allocation::max_objects</td></tr>
<tr class="memdesc:a2b4f2381a8e4c48db4b5ae4510f80f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of objects per allocation before going right through the allocator  <a href="#a2b4f2381a8e4c48db4b5ae4510f80f63">More...</a><br /></td></tr>
<tr class="separator:a2b4f2381a8e4c48db4b5ae4510f80f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3494f5bb0141e8c38ce58167ba42ed05"><td class="memTemplParams" colspan="2">template&lt;class U , class Pool &gt; </td></tr>
<tr class="memitem:a3494f5bb0141e8c38ce58167ba42ed05"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1object__pool.html#a3494f5bb0141e8c38ce58167ba42ed05">detail::allocator_for_shared_ptr</a></td></tr>
<tr class="separator:a3494f5bb0141e8c38ce58167ba42ed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt;<br />
class seq::object_pool&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;</h3>

<p>Object pool class used to allocate objects of type T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>object type </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator type used by this <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> </td></tr>
    <tr><td class="paramname">object_allocation</td><td>allocation pattern </td></tr>
    <tr><td class="paramname">EnableUniquePtr</td><td>allow creating std::unique_ptr with this <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> </td></tr>
    <tr><td class="paramname">GenerateStats</td><td>maintains temporal statistics</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">seq::object_pool</a> is a memory pool class used to allocate objects of type T. It does so by managing internally contiguous memory blocks of increasing size, based on the growth factor SEQ_GROW_FACTOR (default to 1.6).</p>
<p><a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">seq::object_pool</a> has the following properties:</p><ul>
<li>It is fast for allocating single objects, typically 10 times faster than the default malloc/free implementation.</li>
<li>It reduces memory fragmentation for small data types.</li>
<li>It can allocate more than one object at a time based on the provided object_allocation template parameter.</li>
<li>It provides statistics: memory footprint, peak memory footprint, number of objects, total number of allocated/deallocated objects (if GenerateStats is true).</li>
<li>The memory blocks are released on destruction or on calls to <a class="el" href="classseq_1_1object__pool.html#ab508ba0903b7b60224c116c1016be050" title="Free all blocks. ">clear()</a> or <a class="el" href="classseq_1_1object__pool.html#a575391a7d2cc25c2e8d0394d6057a5a9" title="Deallocate all unused memory blocks. This only makes sense if reclaim_memory() is false...">release_unused_memory()</a>.</li>
<li>It can generate std::unique_ptr object (if EnableUniquePtr is true) that outlive the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> object.</li>
</ul>
<p><a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> is NOT thread safe. For a thread safe alternative, see <a class="el" href="classseq_1_1parallel__object__pool.html" title="Lock-free parallel object pool. ">seq::parallel_object_pool</a>.</p>
<p>Use <a class="el" href="classseq_1_1object__pool.html#aef410e4c552ff1e537ee2fe40d07c5c0" title="Allocate size objects. ">object_pool::allocate()</a> to allocate one or more objects. If the requested number of objects is lower or equal to object_allocation::max_objects, the pool will look for a memory block able to allocate the requested size. If no such block exists, a new block is created based on provided allocator. If the object count is greater than object_allocation::max_objects, <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> will directly use the supplied allocator object.</p>
<p>Each memory block is a contiguous memory chunk, where new objects are extracted by incrementing a head pointer (this is a simplification as the provided alignment must be taken into account). On deallocation, the created free slot is added to a monodirectional linked list of free slots and ready to be used for further allocations. The allocation process always performs in O(1), except when a new memory block must be created (in which case the behavior depends on the provided allocator).</p>
<p><a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> can potentially allocate more than one object using the internal block mechanism. This depends on the provided object_allocation type, which defines the maximum number of objects a user can request, and the allocation pattern. The default type is linear_object_allocation&lt;1&gt; that can only allocate 1 object per call using the block mechanism. The possible object_allocation types are:</p><ul>
<li>linear_object_allocation&lt;MaxSize&gt;: can allocate up to MaxSize contiguous objects at once. For instance, when using MaxObject == 2, the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> will manage 2 types of memory blocks: those than can allocate 1 object, and those that can allocate 2 objects. These types of block are managed independently, and grow independently based on user requests. This is, in fact, very similar to managing 2 different <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a>, except that a free memory block used initially to allocate 1 object can be reused later to allocate 2 objects.</li>
<li>block_object_allocation&lt;MaxSize,BlockSize&gt;: can allocate up to MaxSize contiguous objects by step of BlockSize. For instance with block_object_allocation&lt;12,4&gt;, if the user ask for 10 objects, these objects will be extracted from a block managing 12 objects.</li>
<li>pow_object_allocation&lt;MaxSize&gt;: can allocate up to MaxSize contiguous objects by steps which are power of 2. For pow_object_allocation&lt;16&gt;, the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> manages 5 types of memory block, which can allocate 1, 2, 4, 8 or 16 objects.</li>
</ul>
<p>As explained above, <a class="el" href="classseq_1_1object__pool.html#aef410e4c552ff1e537ee2fe40d07c5c0" title="Allocate size objects. ">object_pool::allocate()</a> never fails (except with a potential std::bad_alloc), and will fallback to the supplied allocator if requested number of objects is not managed by the provided object_allocation type.</p>
<p>Usage example:</p>
<div class="fragment"><div class="line"><a class="code" href="classseq_1_1object__pool.html">seq::object_pool&lt;int, std::allocator&lt;int&gt;</a>, <a class="code" href="namespaceseq.html#adac07c5c5e3d6da3ebb03f7ddd1e7cdea668d551cd99226655e9e973b6d5be517">seq::DefaultAlignment</a>, <a class="code" href="structseq_1_1linear__object__allocation.html">seq::linear_object_allocation&lt;2&gt;</a> &gt; pool;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> *p1 = pool.<a class="code" href="classseq_1_1object__pool.html#aef410e4c552ff1e537ee2fe40d07c5c0">allocate</a>(1); <span class="comment">// use memory blocks dedicated to allocate 1 object</span></div><div class="line"><span class="keywordtype">int</span> *p2 = pool.<a class="code" href="classseq_1_1object__pool.html#aef410e4c552ff1e537ee2fe40d07c5c0">allocate</a>(2); <span class="comment">// use memory blocks dedicated to allocate 2 object2</span></div><div class="line"><span class="keywordtype">int</span> *p3 = pool.<a class="code" href="classseq_1_1object__pool.html#aef410e4c552ff1e537ee2fe40d07c5c0">allocate</a>(3); <span class="comment">// directly call std::allocator&lt;int&gt;::allocate(3)</span></div><div class="line"></div><div class="line"><span class="comment">// deallocate all</span></div><div class="line">pool.<a class="code" href="classseq_1_1object__pool.html#a298a62e82b2d3417fd72bee90184f5b7">deallocate</a>(p1,1);</div><div class="line">pool.<a class="code" href="classseq_1_1object__pool.html#a298a62e82b2d3417fd72bee90184f5b7">deallocate</a>(p2,2);</div><div class="line">pool.<a class="code" href="classseq_1_1object__pool.html#a298a62e82b2d3417fd72bee90184f5b7">deallocate</a>(p3,3);  <span class="comment">// directly call std::allocator&lt;int&gt;::deallocate(p3,3)</span></div></div><!-- fragment --><p>Use <a class="el" href="classseq_1_1object__pool.html#a298a62e82b2d3417fd72bee90184f5b7" title="Deallocate size objects. Non POD objects must have been destroyed previously. ">object_pool::deallocate()</a> to deallocate a memory region previously allocated with <a class="el" href="classseq_1_1object__pool.html#aef410e4c552ff1e537ee2fe40d07c5c0" title="Allocate size objects. ">object_pool::allocate()</a>. A deallocation can trigger 2 types of mechanism:</p><ul>
<li>If the number of objects to deallocate is greater than object_allocation::max_objects, the supplied allocator is directly used for the deallocation.</li>
<li>Otherwise:<ol type="1">
<li>The memory block to which belong the objects is found,</li>
<li>The objects are marked as free slots and added to a free list</li>
<li>If the memory block is empty (no more objects inside), it is either:<ul>
<li>Deallocated if <a class="el" href="classseq_1_1object__pool.html#ad97abff55ea874b6a6d1777fc3da9e15" title="Returns true if the object_pool reclaim freed memory, false otherwise. ">reclaim_memory()</a> is true</li>
<li>Kept internally for further reuse if <a class="el" href="classseq_1_1object__pool.html#ad97abff55ea874b6a6d1777fc3da9e15" title="Returns true if the object_pool reclaim freed memory, false otherwise. ">reclaim_memory()</a> is false.</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>Memory blocks do not outlive the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a>. On destruction or calls to <a class="el" href="classseq_1_1object__pool.html#ab508ba0903b7b60224c116c1016be050" title="Free all blocks. ">clear()</a> or <a class="el" href="classseq_1_1object__pool.html#a575391a7d2cc25c2e8d0394d6057a5a9" title="Deallocate all unused memory blocks. This only makes sense if reclaim_memory() is false...">release_unused_memory()</a>, all memory blocks are freed (this invalidates pointers referencing these blocks). Note, however, that the memory allocated with supplied allocator when requested object count is greater than object_allocation::max_objects is not automatically deallocated.</p>
<p>Another exception is when dealing with std::unique_ptr (see next section).</p>
<p>An <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> can create std::unique_ptr objects only if EnableUniquePtr is true. In this case the unique_ptr type is given by the typedef <a class="el" href="classseq_1_1object__pool.html#a38e3596ddb1309e36ebc321386d6dc5d" title="unique_ptr type if EnableUniquePtr is true ">object_pool&lt;T&gt;::unique_ptr</a>. This is basically a std::unique_ptr with a custom deleter class.</p>
<p>Use <a class="el" href="classseq_1_1object__pool.html#a6c693c5b972f21af9ab51a7fd22d15ba" title="Returns a unique_ptr object constructed from the forwarded argument. ">object_pool::make_unique()</a> to create unique_ptr objects. These objects will outlive the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a>. When destroying the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> or on calls to <a class="el" href="classseq_1_1object__pool.html#ab508ba0903b7b60224c116c1016be050" title="Free all blocks. ">object_pool::clear()</a> or <a class="el" href="classseq_1_1object__pool.html#a575391a7d2cc25c2e8d0394d6057a5a9" title="Deallocate all unused memory blocks. This only makes sense if reclaim_memory() is false...">release_unused_memory()</a>, all memory blocks that contain at least one object stored in a unique_ptr are not destroyed. These blocks contain a thread-safe reference counter that is decremented whenever a unique_ptr is destroyed, and is eventually deallocated when the last unique_ptr referencing it is destroyed.</p>
<p>You should never call <a class="el" href="classseq_1_1object__pool.html#a298a62e82b2d3417fd72bee90184f5b7" title="Deallocate size objects. Non POD objects must have been destroyed previously. ">object_pool::deallocate()</a> on a pointer held by a unique_ptr, this will lead to a segfault on unique_ptr destruction.</p>
<p>You can still release the pointer using std::unique_ptr::release(), but the pointer must then be destroyed with <a class="el" href="namespaceseq.html#a1349a44a2ff37300a5c72a03780780fe" title="Deallocate pointer previously held by a std::unqiue_ptr&lt;T,unique_ptr_deleter&lt;T&gt; &gt; ...">seq::unique_ptr_delete()</a>, which calls the object destructor and deallocate the memory if needed.</p>
<p>Usage example:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> pool_type = <a class="code" href="classseq_1_1object__pool.html">seq::object_pool&lt;int, std::allocator&lt;int&gt;</a>, <a class="code" href="namespaceseq.html#adac07c5c5e3d6da3ebb03f7ddd1e7cdea668d551cd99226655e9e973b6d5be517">seq::DefaultAlignment</a>, <a class="code" href="structseq_1_1linear__object__allocation.html">seq::linear_object_allocation&lt;1&gt;</a>, <span class="keyword">true</span> &gt;;</div><div class="line"><span class="keyword">using</span> <a class="code" href="classseq_1_1object__pool.html#a38e3596ddb1309e36ebc321386d6dc5d">unique_ptr</a> = <span class="keyword">typename</span> pool_type::unique_ptr;</div><div class="line"></div><div class="line"><a class="code" href="classseq_1_1object__pool.html#a38e3596ddb1309e36ebc321386d6dc5d">unique_ptr</a> p1, p2;</div><div class="line">{</div><div class="line">pool_type pool;</div><div class="line"></div><div class="line">p1 = pool.<a class="code" href="classseq_1_1object__pool.html#a6c693c5b972f21af9ab51a7fd22d15ba">make_unique</a>(1);   <span class="comment">//unique ptr containing int(1)</span></div><div class="line">p2 = pool.make_unique(2);   <span class="comment">//unique ptr containing int(2)</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// p1 and p2 are still valid</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> * ptr = p1.release();</div><div class="line"></div><div class="line"><span class="comment">//ptr is still valid, but must now be release with seq::unique_ptr_delete()</span></div><div class="line"></div><div class="line"><a class="code" href="namespaceseq.html#a1349a44a2ff37300a5c72a03780780fe">seq::unique_ptr_delete</a>(ptr);</div></div><!-- fragment --><p>The unique_ptr generation is not enabled by default as it makes the allocation process slightly slower and require more memory (one additional pointer per allocation).</p>
<p>At any point, the total memory footprint of an <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> can be retrieved with <a class="el" href="classseq_1_1object__pool.html#adcb78702499af1357a871e3a0aadf0d8" title="Returns the object_pool memory footprint in bytes excluding sizeof(*this). ">object_pool::memory_footprint()</a>. The peak memory footprint can be retrieved with <a class="el" href="classseq_1_1object__pool.html#aa38fbf8d66be889bb4b075b917942c89" title="Returns the object_pool peak memory footprint in bytes excluding sizeof(*this). ">peak_memory_footprint()</a>.</p>
<p>To access to more detailed statistics, the function <a class="el" href="classseq_1_1object__pool.html#ae2eeb6dbde18dbe45eba8527db0dec52" title="Dump object_pool statistics into a object_pool_stats. ">object_pool::dump_statistics()</a> will provide the following information through a <a class="el" href="structseq_1_1object__pool__stats.html" title="Class gathering statistics for seq::object_pool or seq::parallel_object_pool. ">object_pool_stats</a> object:</p><ul>
<li>memory: current memory footprint in bytes</li>
<li>peak_memory: highest recorded memory footprint</li>
<li>objects: current number of allocated objects</li>
<li>total_created: total number of objects that has been allocated (GenerateStats must be true)</li>
<li>total_freed: total number of object that has been deallocated (GenerateStats must be true)</li>
<li>thread_count: total number of threads using this pool (always 0 for <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a>)</li>
</ul>
<p>The peak_memory, total_created and total_freed can be reseted using <a class="el" href="classseq_1_1object__pool.html#a5ba0e2834a30fa3cbb4a1d895eb0f687" title="Reset statistics. ">object_pool::reset_statistics()</a>. The peak_memory will be set to the current memory footprint, total_created and total_freed will be set to 0. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a72acd76f831a3e0c65fdcbde44f9f6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72acd76f831a3e0c65fdcbde44f9f6fa">&#9670;&nbsp;</a></span>allocation_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::<a class="el" href="classseq_1_1object__pool.html#a72acd76f831a3e0c65fdcbde44f9f6fa">allocation_type</a> =  object_allocation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocation pattern </p>

</div>
</div>
<a id="a4fe372637946e7d71e0d77363bcec812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe372637946e7d71e0d77363bcec812">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::<a class="el" href="classseq_1_1object__pool.html#a4fe372637946e7d71e0d77363bcec812">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>supplied allocator type </p>

</div>
</div>
<a id="a72539665f913721acd4787fedaa5a2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72539665f913721acd4787fedaa5a2c7">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::<a class="el" href="classseq_1_1object__pool.html#a72539665f913721acd4787fedaa5a2c7">pointer</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer type </p>

</div>
</div>
<a id="a2deaec289a41210128d70792113aaeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2deaec289a41210128d70792113aaeed">&#9670;&nbsp;</a></span>shared_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::<a class="el" href="classseq_1_1object__pool.html#a2deaec289a41210128d70792113aaeed">shared_ptr</a> =  std::shared_ptr&lt;T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shared_ptr type if <a class="el" href="structseq_1_1shared__ptr__allocation.html">shared_ptr_allocation</a> is used with EnableUniquePtr </p>

</div>
</div>
<a id="a38e3596ddb1309e36ebc321386d6dc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e3596ddb1309e36ebc321386d6dc5d">&#9670;&nbsp;</a></span>unique_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::<a class="el" href="classseq_1_1object__pool.html#a38e3596ddb1309e36ebc321386d6dc5d">unique_ptr</a> =  std::unique_ptr&lt;T, <a class="el" href="structseq_1_1unique__ptr__deleter.html">unique_ptr_deleter</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unique_ptr type if EnableUniquePtr is true </p>

</div>
</div>
<a id="a8b6a4b58f45dfb4560a16c9b4a6454e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6a4b58f45dfb4560a16c9b4a6454e0">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::<a class="el" href="classseq_1_1object__pool.html#a8b6a4b58f45dfb4560a16c9b4a6454e0">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>object type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a799aee7e762678e020cd05b8cb27631f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799aee7e762678e020cd05b8cb27631f">&#9670;&nbsp;</a></span>object_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::<a class="el" href="classseq_1_1object__pool.html">object_pool</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em> = <code>Allocator()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">al</td><td>allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a715fe6fa1710441724bebd93a565f17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715fe6fa1710441724bebd93a565f17d">&#9670;&nbsp;</a></span>~object_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::~<a class="el" href="classseq_1_1object__pool.html">object_pool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aef410e4c552ff1e537ee2fe40d07c5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef410e4c552ff1e537ee2fe40d07c5c0">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual auto <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> -&gt; T*</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate size objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of objects to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated objects</dd></dl>
<p>If size &lt;= object_allocation::max_object, use the memory block mechanism. If size &gt; object_allocation::max_object, directly use the supplied allocator.</p>
<p>Might throw std::bad_alloc. </p>

<p>Implements <a class="el" href="structseq_1_1detail_1_1base__object__pool.html#a901146a91f522302842181dc455ad0cf">seq::detail::base_object_pool&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ab508ba0903b7b60224c116c1016be050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab508ba0903b7b60224c116c1016be050">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all blocks. </p>
<p>Free all memory blocks, except those managing at least one unique_ptr. This will invalidate all previously allocated pointers.</p>
<p>Note that the objects are not destroyed, only deallocated. </p>

</div>
</div>
<a id="a298a62e82b2d3417fd72bee90184f5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298a62e82b2d3417fd72bee90184f5b7">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate size objects. Non POD objects must have been destroyed previously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to objects to deallocate </td></tr>
    <tr><td class="paramname">size</td><td>number of objects to deallocate </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structseq_1_1detail_1_1base__object__pool.html#a94c3d29a9aa75d5efdaa6e03e866b5d5">seq::detail::base_object_pool&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ae2eeb6dbde18dbe45eba8527db0dec52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2eeb6dbde18dbe45eba8527db0dec52">&#9670;&nbsp;</a></span>dump_statistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::dump_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1object__pool__stats.html">object_pool_stats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> statistics into a <a class="el" href="structseq_1_1object__pool__stats.html" title="Class gathering statistics for seq::object_pool or seq::parallel_object_pool. ">object_pool_stats</a>. </p>

</div>
</div>
<a id="aa7f2219bf1f9dc09c5c1e67948febd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f2219bf1f9dc09c5c1e67948febd70">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const Allocator&amp; 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying allocator object. </p>

</div>
</div>
<a id="a2286444dc9ce69a944f9465f0e12b37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2286444dc9ce69a944f9465f0e12b37d">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; Allocator&amp; 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying allocator object. </p>

</div>
</div>
<a id="a6c693c5b972f21af9ab51a7fd22d15ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c693c5b972f21af9ab51a7fd22d15ba">&#9670;&nbsp;</a></span>make_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::make_unique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1object__pool.html#a38e3596ddb1309e36ebc321386d6dc5d">unique_ptr</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a unique_ptr object constructed from the forwarded argument. </p>
<p>This function is similar to std::make_unique(), except that it relies on the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> to allocate the memory. The created unique_ptr will outlive the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a>. Never deallocate a unique_ptr pointer with <a class="el" href="classseq_1_1object__pool.html#a298a62e82b2d3417fd72bee90184f5b7" title="Deallocate size objects. Non POD objects must have been destroyed previously. ">object_pool::deallocate()</a>. If unique_ptr::release() is called, the pointer must be destroyed with <a class="el" href="namespaceseq.html#a1349a44a2ff37300a5c72a03780780fe" title="Deallocate pointer previously held by a std::unqiue_ptr&lt;T,unique_ptr_deleter&lt;T&gt; &gt; ...">seq::unique_ptr_delete()</a>, which calls the object destructor and release the memory if needed. </p>

</div>
</div>
<a id="adcb78702499af1357a871e3a0aadf0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb78702499af1357a871e3a0aadf0d8">&#9670;&nbsp;</a></span>memory_footprint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::memory_footprint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::size_t 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> memory footprint in bytes excluding sizeof(*this). </p>

</div>
</div>
<a id="aa38fbf8d66be889bb4b075b917942c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38fbf8d66be889bb4b075b917942c89">&#9670;&nbsp;</a></span>peak_memory_footprint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::peak_memory_footprint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::size_t 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> peak memory footprint in bytes excluding sizeof(*this). </p>

</div>
</div>
<a id="ad97abff55ea874b6a6d1777fc3da9e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97abff55ea874b6a6d1777fc3da9e15">&#9670;&nbsp;</a></span>reclaim_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::reclaim_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> reclaim freed memory, false otherwise. </p>

</div>
</div>
<a id="a575391a7d2cc25c2e8d0394d6057a5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575391a7d2cc25c2e8d0394d6057a5a9">&#9670;&nbsp;</a></span>release_unused_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::release_unused_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate all unused memory blocks. This only makes sense if <a class="el" href="classseq_1_1object__pool.html#ad97abff55ea874b6a6d1777fc3da9e15" title="Returns true if the object_pool reclaim freed memory, false otherwise. ">reclaim_memory()</a> is false. </p>

</div>
</div>
<a id="aa96fd22de10478226d8d5650ef4efb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96fd22de10478226d8d5650ef4efb1a">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> in order to hold at least count free slots for calls to allocate(alloc_size). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc_size</td><td>only extend the pool in order to allocate alloc_size objects per calls to <a class="el" href="classseq_1_1object__pool.html#aef410e4c552ff1e537ee2fe40d07c5c0" title="Allocate size objects. ">allocate()</a> </td></tr>
    <tr><td class="paramname">count</td><td>make sure that at least count calls to allocate(alloc_size) will not trigger a memory allocation</td></tr>
  </table>
  </dd>
</dl>
<p>Might throw a std::bad_alloc </p>

</div>
</div>
<a id="a12613b106f8af2a86e9084da4e2cd4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12613b106f8af2a86e9084da4e2cd4bb">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a>. </p>
<p>Reset this object by clearing all memory blocks and make them ready for new allocations. This effectively invalidates all previously allocated pointers, even if the underlying memory segment has not been deallocated.</p>
<p>Has no effect on block managing at least one unique_ptr. </p>

</div>
</div>
<a id="a5ba0e2834a30fa3cbb4a1d895eb0f687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba0e2834a30fa3cbb4a1d895eb0f687">&#9670;&nbsp;</a></span>reset_statistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::reset_statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset statistics. </p>
<p>Reset the following statistics:</p><ul>
<li>peak memory (reseted to the current memory footprint)</li>
<li>total number of allocated object (reseted to 0, only meaningful if GenerateStats is true)</li>
<li>total number of deallocated object (reseted to 0, only meaningful if GenerateStats is true) </li>
</ul>

</div>
</div>
<a id="aee9c75a122612306b3a95466946afddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9c75a122612306b3a95466946afddc">&#9670;&nbsp;</a></span>set_reclaim_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::set_reclaim_memory </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reclaim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the reclaim_memory flag. </p>
<p>If false, the <a class="el" href="classseq_1_1object__pool.html" title="Object pool class used to allocate objects of type T. ">object_pool</a> will not deallocate memory on calls to <a class="el" href="classseq_1_1object__pool.html#a298a62e82b2d3417fd72bee90184f5b7" title="Deallocate size objects. Non POD objects must have been destroyed previously. ">deallocate()</a>. Instead, free memory blocks will be added to an internal list and reuse on calls to <a class="el" href="classseq_1_1object__pool.html#aef410e4c552ff1e537ee2fe40d07c5c0" title="Allocate size objects. ">allocate()</a>. This is the only way to move a memory block dedicated to an object count for another object count.</p>
<p>If true, calls to deallocate will deallocate any free block. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3494f5bb0141e8c38ce58167ba42ed05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3494f5bb0141e8c38ce58167ba42ed05">&#9670;&nbsp;</a></span>detail::allocator_for_shared_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<div class="memtemplate">
template&lt;class U , class Pool &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classseq_1_1detail_1_1allocator__for__shared__ptr.html">detail::allocator_for_shared_ptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a32eedc50e4260ce1b3431ddfc420c2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32eedc50e4260ce1b3431ddfc420c2a6">&#9670;&nbsp;</a></span>alignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::alignment = (Align == 0 || Align &lt; <a class="el" href="bits_8hpp.html#a4358957bf3c41e772ade27671699c4e6">SEQ_DEFAULT_ALIGNMENT</a>) ? <a class="el" href="bits_8hpp.html#a4358957bf3c41e772ade27671699c4e6">SEQ_DEFAULT_ALIGNMENT</a> : Align</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>object alignment </p>

</div>
</div>
<a id="abc4e125e5f6034ba3dc855b58a778793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4e125e5f6034ba3dc855b58a778793">&#9670;&nbsp;</a></span>enable_unique_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::enable_unique_ptr = EnableUniquePtr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enable/disable unique_ptr support </p>

</div>
</div>
<a id="a0e73ff4e98c97ead724eda2b28e2aa49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e73ff4e98c97ead724eda2b28e2aa49">&#9670;&nbsp;</a></span>generate_statistics</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::generate_statistics = GenerateStats</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate temporal statistics </p>

</div>
</div>
<a id="a2b4f2381a8e4c48db4b5ae4510f80f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4f2381a8e4c48db4b5ae4510f80f63">&#9670;&nbsp;</a></span>max_objects</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Allocator = std::allocator&lt;T&gt;, size_t Align = DefaultAlignment, class object_allocation = linear_object_allocation&lt;1&gt;, bool EnableUniquePtr = false, bool GenerateStats = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classseq_1_1object__pool.html">seq::object_pool</a>&lt; T, Allocator, Align, object_allocation, EnableUniquePtr, GenerateStats &gt;::max_objects = object_allocation::max_objects</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maximum number of objects per allocation before going right through the allocator </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="memory_8hpp_source.html">memory.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1object__pool.html">object_pool</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
