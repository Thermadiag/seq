<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::flat_multiset&lt; Key, Compare, Allocator, layout, Stable &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classseq_1_1flat__multiset.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseq_1_1flat__multiset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::flat_multiset&lt; Key, Compare, Allocator, layout, Stable &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values  
 <a href="classseq_1_1flat__multiset.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="flat__map_8hpp_source.html">flat_map.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="classseq_1_1flat__set.html">seq::flat_set&lt; Key, std::less&lt; Key &gt;, std::allocator&lt; Key &gt;, OptimizeForMemory, false, false &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac8d0c0eca9a5079957fe5f7fda9f5967"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ac8d0c0eca9a5079957fe5f7fda9f5967">key_type</a> = Key</td></tr>
<tr class="separator:ac8d0c0eca9a5079957fe5f7fda9f5967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9f8264e3e53764cfae47bd03a18d8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> = Key</td></tr>
<tr class="separator:aac9f8264e3e53764cfae47bd03a18d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc8ba21e60beee2752e6a3c202602eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a6fc8ba21e60beee2752e6a3c202602eb">difference_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a6fc8ba21e60beee2752e6a3c202602eb">difference_type</a></td></tr>
<tr class="separator:a6fc8ba21e60beee2752e6a3c202602eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1151b2ccc5b0068c3a66ddb390691c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#af1151b2ccc5b0068c3a66ddb390691c7">size_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#af1151b2ccc5b0068c3a66ddb390691c7">size_type</a></td></tr>
<tr class="separator:af1151b2ccc5b0068c3a66ddb390691c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a1ac7d77c88e7bbd22ff3f8849e923"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ae1a1ac7d77c88e7bbd22ff3f8849e923">key_compare</a> = Compare</td></tr>
<tr class="separator:ae1a1ac7d77c88e7bbd22ff3f8849e923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd81cccf7490e9ead18b447ae4c473"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a9abd81cccf7490e9ead18b447ae4c473">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a9abd81cccf7490e9ead18b447ae4c473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb12309bb26912ed6f2216177e0de406"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#acb12309bb26912ed6f2216177e0de406">reference</a> = Key &amp;</td></tr>
<tr class="separator:acb12309bb26912ed6f2216177e0de406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f75594ce52484b1d41b7f94db41218"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a58f75594ce52484b1d41b7f94db41218">const_reference</a> = const Key &amp;</td></tr>
<tr class="separator:a58f75594ce52484b1d41b7f94db41218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e5b4fdbf23fb6a5544aaf4a3f481fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">pointer</a></td></tr>
<tr class="separator:aa5e5b4fdbf23fb6a5544aaf4a3f481fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2335cb7eff2b949c387aaca474b8046a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a2335cb7eff2b949c387aaca474b8046a">const_pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a2335cb7eff2b949c387aaca474b8046a">const_pointer</a></td></tr>
<tr class="separator:a2335cb7eff2b949c387aaca474b8046a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7abcd8c332f777c1ec9ad0b4c432f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">base_type::iterator</a></td></tr>
<tr class="separator:abf7abcd8c332f777c1ec9ad0b4c432f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec78ce95ab35003a8e76ca861f03859"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a2ec78ce95ab35003a8e76ca861f03859">const_iterator</a> = typename <a class="el" href="structseq_1_1flat__set_1_1const__iterator.html">base_type::const_iterator</a></td></tr>
<tr class="separator:a2ec78ce95ab35003a8e76ca861f03859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf04f204152e12fbb7bea08b639cca3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a9bf04f204152e12fbb7bea08b639cca3">reverse_iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">base_type::reverse_iterator</a></td></tr>
<tr class="separator:a9bf04f204152e12fbb7bea08b639cca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892d2e8da8ef3eb9dfbf63911fd73e5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a892d2e8da8ef3eb9dfbf63911fd73e5f">const_reverse_iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">base_type::const_reverse_iterator</a></td></tr>
<tr class="separator:a892d2e8da8ef3eb9dfbf63911fd73e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classseq_1_1flat__set"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classseq_1_1flat__set')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classseq_1_1flat__set.html">seq::flat_set&lt; Key, std::less&lt; Key &gt;, std::allocator&lt; Key &gt;, OptimizeForMemory, false, false &gt;</a></td></tr>
<tr class="memitem:a1a99d74a2c1b1287883c1aa8f77b9d23 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1a99d74a2c1b1287883c1aa8f77b9d23">deque_type</a> = typename <a class="el" href="structseq_1_1detail_1_1flat__tree.html#a3ce69acdeb2df26a94c72eb659d11762">flat_tree_type::deque_type</a></td></tr>
<tr class="separator:a1a99d74a2c1b1287883c1aa8f77b9d23 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b64c5f701a2ab7921e34ce3d5b5d1a6 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a> = const_iterator</td></tr>
<tr class="separator:a1b64c5f701a2ab7921e34ce3d5b5d1a6 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c948977310c47866584a268790a6f0 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a95c948977310c47866584a268790a6f0">key_type</a> = Key</td></tr>
<tr class="separator:a95c948977310c47866584a268790a6f0 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423dfd403dcf1078aa0400ceb34aca10 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> = Key</td></tr>
<tr class="separator:a423dfd403dcf1078aa0400ceb34aca10 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8481828c9f2f74c4e061acfdc1e02a inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9d8481828c9f2f74c4e061acfdc1e02a">difference_type</a> = typename std::allocator_traits&lt; std::allocator&lt; Key &gt; &gt;::<a class="el" href="classseq_1_1flat__set.html#a9d8481828c9f2f74c4e061acfdc1e02a">difference_type</a></td></tr>
<tr class="separator:a9d8481828c9f2f74c4e061acfdc1e02a inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2f707cf8f7944eda425023d33003e7 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a> = typename std::allocator_traits&lt; std::allocator&lt; Key &gt; &gt;::<a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a></td></tr>
<tr class="separator:a4c2f707cf8f7944eda425023d33003e7 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1d4b80fd721e98fd252d5f2dbc674d inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0a1d4b80fd721e98fd252d5f2dbc674d">key_compare</a> = std::less&lt; Key &gt;</td></tr>
<tr class="separator:a0a1d4b80fd721e98fd252d5f2dbc674d inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e750bb1eb6ece2521d164c022287d7 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a45e750bb1eb6ece2521d164c022287d7">allocator_type</a> = std::allocator&lt; Key &gt;</td></tr>
<tr class="separator:a45e750bb1eb6ece2521d164c022287d7 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dac755c1568229cf24798257217d0b3 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a3dac755c1568229cf24798257217d0b3">reference</a> = Key &amp;</td></tr>
<tr class="separator:a3dac755c1568229cf24798257217d0b3 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aa14284b49ee04935c41c6e8c01a55 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac3aa14284b49ee04935c41c6e8c01a55">const_reference</a> = const Key &amp;</td></tr>
<tr class="separator:ac3aa14284b49ee04935c41c6e8c01a55 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c4082dfe9ef37b2894e9a785830887 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a32c4082dfe9ef37b2894e9a785830887">pointer</a> = typename std::allocator_traits&lt; std::allocator&lt; Key &gt; &gt;::<a class="el" href="classseq_1_1flat__set.html#a32c4082dfe9ef37b2894e9a785830887">pointer</a></td></tr>
<tr class="separator:a32c4082dfe9ef37b2894e9a785830887 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56ed1e8f1b1fee2c4f8a26f16969210 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac56ed1e8f1b1fee2c4f8a26f16969210">const_pointer</a> = typename std::allocator_traits&lt; std::allocator&lt; Key &gt; &gt;::<a class="el" href="classseq_1_1flat__set.html#ac56ed1e8f1b1fee2c4f8a26f16969210">const_pointer</a></td></tr>
<tr class="separator:ac56ed1e8f1b1fee2c4f8a26f16969210 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa005e31dc3f4c6de57c78c08579c0350 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a> &gt;</td></tr>
<tr class="separator:aa005e31dc3f4c6de57c78c08579c0350 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f0b73c32e563991fa077115d501c69 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a> = std::reverse_iterator&lt; const_iterator &gt;</td></tr>
<tr class="separator:a59f0b73c32e563991fa077115d501c69 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a837ce53e1ed9c749770df9e1ec3541dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a837ce53e1ed9c749770df9e1ec3541dc">flat_multiset</a> ()</td></tr>
<tr class="separator:a837ce53e1ed9c749770df9e1ec3541dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231f0bcbfcb21972e4cdf089ddf5fb77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a231f0bcbfcb21972e4cdf089ddf5fb77">flat_multiset</a> (const Compare &amp;comp, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a231f0bcbfcb21972e4cdf089ddf5fb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995f51fc40e3429596a29f475ff106c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a995f51fc40e3429596a29f475ff106c0">flat_multiset</a> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:a995f51fc40e3429596a29f475ff106c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b2454113754b7bd8d3c922119ff41f"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ab6b2454113754b7bd8d3c922119ff41f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ab6b2454113754b7bd8d3c922119ff41f">flat_multiset</a> (InputIt first, InputIt last, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:ab6b2454113754b7bd8d3c922119ff41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3078805e2694e24a1107ecc9e3ace5"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a2c3078805e2694e24a1107ecc9e3ace5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a2c3078805e2694e24a1107ecc9e3ace5">flat_multiset</a> (InputIt first, InputIt last, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a2c3078805e2694e24a1107ecc9e3ace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8986285103b6b8b8ff113f5de551d3d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a8986285103b6b8b8ff113f5de551d3d3">flat_multiset</a> (const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;other)</td></tr>
<tr class="separator:a8986285103b6b8b8ff113f5de551d3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983e596648725c407017bd6561fca0bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a983e596648725c407017bd6561fca0bd">flat_multiset</a> (const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a983e596648725c407017bd6561fca0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cca6165cc057921692869414c37c55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a55cca6165cc057921692869414c37c55">flat_multiset</a> (<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a55cca6165cc057921692869414c37c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f16cb6d01d65d73acb6370e353b4e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a19f16cb6d01d65d73acb6370e353b4e5">flat_multiset</a> (<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&amp;other, const Allocator &amp;alloc) noexcept</td></tr>
<tr class="separator:a19f16cb6d01d65d73acb6370e353b4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2dcc536430281e13477a9a08915020"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a1a2dcc536430281e13477a9a08915020">flat_multiset</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; init, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a1a2dcc536430281e13477a9a08915020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44549f25eaaa5708d7328673e6ecebbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a44549f25eaaa5708d7328673e6ecebbe">flat_multiset</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; init, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a44549f25eaaa5708d7328673e6ecebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e14bd00f41754dd0b5247d2b5c89f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a4e14bd00f41754dd0b5247d2b5c89f22">operator=</a> (<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a4e14bd00f41754dd0b5247d2b5c89f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9eac45d865c6a1fd8140bcd5985a89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a1f9eac45d865c6a1fd8140bcd5985a89">operator=</a> (const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;other)</td></tr>
<tr class="separator:a1f9eac45d865c6a1fd8140bcd5985a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf428ee5534e54336119ca8ec503c50d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aaf428ee5534e54336119ca8ec503c50d">operator=</a> (const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; &amp;init)</td></tr>
<tr class="separator:aaf428ee5534e54336119ca8ec503c50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f7b55294542ff1e4413e155d9a2be0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a33f7b55294542ff1e4413e155d9a2be0">insert</a> (const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;value)</td></tr>
<tr class="separator:a33f7b55294542ff1e4413e155d9a2be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09dc5666c44b0d83650f97ebb3642f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aa09dc5666c44b0d83650f97ebb3642f3">insert</a> (<a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:aa09dc5666c44b0d83650f97ebb3642f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b713ad5a9521009dcf11823e6cb928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a40b713ad5a9521009dcf11823e6cb928">insert_pos</a> (const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;value)</td></tr>
<tr class="separator:a40b713ad5a9521009dcf11823e6cb928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2513c47c66bb97e6db8489654888ffc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a2513c47c66bb97e6db8489654888ffc2">insert_pos</a> (<a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a2513c47c66bb97e6db8489654888ffc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d6e572441e94bad0797fffeb3f8052"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a51d6e572441e94bad0797fffeb3f8052"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a51d6e572441e94bad0797fffeb3f8052">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a51d6e572441e94bad0797fffeb3f8052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d6eee175fb11dfd71ce59509b8fdb7"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a62d6eee175fb11dfd71ce59509b8fdb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a62d6eee175fb11dfd71ce59509b8fdb7">emplace_pos</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a62d6eee175fb11dfd71ce59509b8fdb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e08bf6a4096c80cbe5a80edd361f41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a52e08bf6a4096c80cbe5a80edd361f41">insert</a> (const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a52e08bf6a4096c80cbe5a80edd361f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__multiset.html#a52e08bf6a4096c80cbe5a80edd361f41">More...</a><br /></td></tr>
<tr class="separator:a52e08bf6a4096c80cbe5a80edd361f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1435d186c4db6f9b21079eccbd4dc74f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a1435d186c4db6f9b21079eccbd4dc74f">insert</a> (<a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a1435d186c4db6f9b21079eccbd4dc74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__multiset.html#a1435d186c4db6f9b21079eccbd4dc74f">More...</a><br /></td></tr>
<tr class="separator:a1435d186c4db6f9b21079eccbd4dc74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46efdc1301a11289b38c0e43d240845d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a46efdc1301a11289b38c0e43d240845d">insert</a> (<a class="el" href="classseq_1_1flat__multiset.html#a2ec78ce95ab35003a8e76ca861f03859">const_iterator</a> hint, const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a46efdc1301a11289b38c0e43d240845d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__multiset.html#a46efdc1301a11289b38c0e43d240845d">More...</a><br /></td></tr>
<tr class="separator:a46efdc1301a11289b38c0e43d240845d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06a754a07ae3ed7b4c2536856e78754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ab06a754a07ae3ed7b4c2536856e78754">insert</a> (<a class="el" href="classseq_1_1flat__multiset.html#a2ec78ce95ab35003a8e76ca861f03859">const_iterator</a> hint, <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ab06a754a07ae3ed7b4c2536856e78754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__multiset.html#ab06a754a07ae3ed7b4c2536856e78754">More...</a><br /></td></tr>
<tr class="separator:ab06a754a07ae3ed7b4c2536856e78754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370336c5106645ee45fec8a2a26eadc4"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a370336c5106645ee45fec8a2a26eadc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a370336c5106645ee45fec8a2a26eadc4">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a370336c5106645ee45fec8a2a26eadc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying deque, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one.  <a href="classseq_1_1flat__multiset.html#a370336c5106645ee45fec8a2a26eadc4">More...</a><br /></td></tr>
<tr class="separator:a370336c5106645ee45fec8a2a26eadc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace98a525dfd46ea113f9f151c63f2411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ace98a525dfd46ea113f9f151c63f2411">insert</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ace98a525dfd46ea113f9f151c63f2411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__multiset.html#ace98a525dfd46ea113f9f151c63f2411">More...</a><br /></td></tr>
<tr class="separator:ace98a525dfd46ea113f9f151c63f2411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classseq_1_1flat__set"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classseq_1_1flat__set')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classseq_1_1flat__set.html">seq::flat_set&lt; Key, std::less&lt; Key &gt;, std::allocator&lt; Key &gt;, OptimizeForMemory, false, false &gt;</a></td></tr>
<tr class="memitem:af28779bd30528cfb05dbdd6738a5e230 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af28779bd30528cfb05dbdd6738a5e230">flat_set</a> ()</td></tr>
<tr class="memdesc:af28779bd30528cfb05dbdd6738a5e230 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classseq_1_1flat__set.html#af28779bd30528cfb05dbdd6738a5e230">More...</a><br /></td></tr>
<tr class="separator:af28779bd30528cfb05dbdd6738a5e230 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43495f719ac2a6337b70580292767eab inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a43495f719ac2a6337b70580292767eab">flat_set</a> (const std::less&lt; Key &gt; &amp;comp, const std::allocator&lt; Key &gt; &amp;alloc=std::allocator&lt; Key &gt;())</td></tr>
<tr class="memdesc:a43495f719ac2a6337b70580292767eab inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from comparator function and optional allocator object.  <a href="classseq_1_1flat__set.html#a43495f719ac2a6337b70580292767eab">More...</a><br /></td></tr>
<tr class="separator:a43495f719ac2a6337b70580292767eab inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ca0e8e62ba5e2400f60678eb8e038f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a96ca0e8e62ba5e2400f60678eb8e038f">flat_set</a> (const std::allocator&lt; Key &gt; &amp;alloc)</td></tr>
<tr class="memdesc:a96ca0e8e62ba5e2400f60678eb8e038f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from allocator object.  <a href="classseq_1_1flat__set.html#a96ca0e8e62ba5e2400f60678eb8e038f">More...</a><br /></td></tr>
<tr class="separator:a96ca0e8e62ba5e2400f60678eb8e038f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e6b15d9f9e06b35f91e61f35f73862 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab3e6b15d9f9e06b35f91e61f35f73862">flat_set</a> (InputIt first, InputIt last, const std::less&lt; Key &gt; &amp;comp=std::less&lt; Key &gt;(), const std::allocator&lt; Key &gt; &amp;alloc=std::allocator&lt; Key &gt;())</td></tr>
<tr class="memdesc:ab3e6b15d9f9e06b35f91e61f35f73862 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#ab3e6b15d9f9e06b35f91e61f35f73862">More...</a><br /></td></tr>
<tr class="separator:ab3e6b15d9f9e06b35f91e61f35f73862 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37d39789987ad2558c9c44ed3d0785 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a5e37d39789987ad2558c9c44ed3d0785">flat_set</a> (InputIt first, InputIt last, const std::allocator&lt; Key &gt; &amp;alloc)</td></tr>
<tr class="memdesc:a5e37d39789987ad2558c9c44ed3d0785 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#a5e37d39789987ad2558c9c44ed3d0785">More...</a><br /></td></tr>
<tr class="separator:a5e37d39789987ad2558c9c44ed3d0785 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ba984f81b0db26a01612988d610318 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a55ba984f81b0db26a01612988d610318">flat_set</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other)</td></tr>
<tr class="memdesc:a55ba984f81b0db26a01612988d610318 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1flat__set.html#a55ba984f81b0db26a01612988d610318">More...</a><br /></td></tr>
<tr class="separator:a55ba984f81b0db26a01612988d610318 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebb1cbcd91fd9baf92dd692511796b0 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6ebb1cbcd91fd9baf92dd692511796b0">flat_set</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other, const std::allocator&lt; Key &gt; &amp;alloc)</td></tr>
<tr class="memdesc:a6ebb1cbcd91fd9baf92dd692511796b0 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1flat__set.html#a6ebb1cbcd91fd9baf92dd692511796b0">More...</a><br /></td></tr>
<tr class="separator:a6ebb1cbcd91fd9baf92dd692511796b0 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5ef5410087dbbfac294b6c3863838f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0a5ef5410087dbbfac294b6c3863838f">flat_set</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a0a5ef5410087dbbfac294b6c3863838f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="classseq_1_1flat__set.html#a0a5ef5410087dbbfac294b6c3863838f">More...</a><br /></td></tr>
<tr class="separator:a0a5ef5410087dbbfac294b6c3863838f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c9734ff27566340dd880f205c51a83 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a99c9734ff27566340dd880f205c51a83">flat_set</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other, const std::allocator&lt; Key &gt; &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a99c9734ff27566340dd880f205c51a83 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="classseq_1_1flat__set.html#a99c9734ff27566340dd880f205c51a83">More...</a><br /></td></tr>
<tr class="separator:a99c9734ff27566340dd880f205c51a83 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834fe917b40b91a984b0b6e6a873fb77 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a834fe917b40b91a984b0b6e6a873fb77">flat_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &gt; init, const std::less&lt; Key &gt; &amp;comp=std::less&lt; Key &gt;(), const std::allocator&lt; Key &gt; &amp;alloc=std::allocator&lt; Key &gt;())</td></tr>
<tr class="memdesc:a834fe917b40b91a984b0b6e6a873fb77 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#a834fe917b40b91a984b0b6e6a873fb77">More...</a><br /></td></tr>
<tr class="separator:a834fe917b40b91a984b0b6e6a873fb77 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad129f6187e0badecbcf74e653813b751 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ad129f6187e0badecbcf74e653813b751">flat_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &gt; init, const std::allocator&lt; Key &gt; &amp;alloc)</td></tr>
<tr class="memdesc:ad129f6187e0badecbcf74e653813b751 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#ad129f6187e0badecbcf74e653813b751">More...</a><br /></td></tr>
<tr class="separator:ad129f6187e0badecbcf74e653813b751 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cbe39482ad32110ac9dc53e0451b12 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a82cbe39482ad32110ac9dc53e0451b12">operator=</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a82cbe39482ad32110ac9dc53e0451b12 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classseq_1_1flat__set.html#a82cbe39482ad32110ac9dc53e0451b12">More...</a><br /></td></tr>
<tr class="separator:a82cbe39482ad32110ac9dc53e0451b12 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730794b40e85b2693c5419f66daaa8d9 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a730794b40e85b2693c5419f66daaa8d9">operator=</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other)</td></tr>
<tr class="memdesc:a730794b40e85b2693c5419f66daaa8d9 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator.  <a href="classseq_1_1flat__set.html#a730794b40e85b2693c5419f66daaa8d9">More...</a><br /></td></tr>
<tr class="separator:a730794b40e85b2693c5419f66daaa8d9 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2144afbc99399209338c9b542e9eca80 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2144afbc99399209338c9b542e9eca80">operator=</a> (const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &gt; &amp;init)</td></tr>
<tr class="memdesc:a2144afbc99399209338c9b542e9eca80 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign initializer-list.  <a href="classseq_1_1flat__set.html#a2144afbc99399209338c9b542e9eca80">More...</a><br /></td></tr>
<tr class="separator:a2144afbc99399209338c9b542e9eca80 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13817841f15077b5f646036098920ec4 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::allocator&lt; Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a13817841f15077b5f646036098920ec4">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:a13817841f15077b5f646036098920ec4 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns container's allocator.  <a href="classseq_1_1flat__set.html#a13817841f15077b5f646036098920ec4">More...</a><br /></td></tr>
<tr class="separator:a13817841f15077b5f646036098920ec4 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51a6125055eef9e18fdcf7873342b4d inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab51a6125055eef9e18fdcf7873342b4d">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ab51a6125055eef9e18fdcf7873342b4d inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if container is empty, false otherwise.  <a href="classseq_1_1flat__set.html#ab51a6125055eef9e18fdcf7873342b4d">More...</a><br /></td></tr>
<tr class="separator:ab51a6125055eef9e18fdcf7873342b4d inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcf1c8daa0d191632807ff662c49566 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0fcf1c8daa0d191632807ff662c49566">size</a> () const noexcept</td></tr>
<tr class="memdesc:a0fcf1c8daa0d191632807ff662c49566 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size.  <a href="classseq_1_1flat__set.html#a0fcf1c8daa0d191632807ff662c49566">More...</a><br /></td></tr>
<tr class="separator:a0fcf1c8daa0d191632807ff662c49566 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae96fc79efd269475d80f7af6e88aa0 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aeae96fc79efd269475d80f7af6e88aa0">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:aeae96fc79efd269475d80f7af6e88aa0 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size.  <a href="classseq_1_1flat__set.html#aeae96fc79efd269475d80f7af6e88aa0">More...</a><br /></td></tr>
<tr class="separator:aeae96fc79efd269475d80f7af6e88aa0 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48d76f5df8ae9b333e7d947e7132505 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af48d76f5df8ae9b333e7d947e7132505">clear</a> () noexcept</td></tr>
<tr class="memdesc:af48d76f5df8ae9b333e7d947e7132505 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container.  <a href="classseq_1_1flat__set.html#af48d76f5df8ae9b333e7d947e7132505">More...</a><br /></td></tr>
<tr class="separator:af48d76f5df8ae9b333e7d947e7132505 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a8c0071d070fc5f1f4ceb03bb595e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a145a8c0071d070fc5f1f4ceb03bb595e">swap</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a145a8c0071d070fc5f1f4ceb03bb595e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this container's content with another. Iterators to both containers remain valid, including end iterators.  <a href="classseq_1_1flat__set.html#a145a8c0071d070fc5f1f4ceb03bb595e">More...</a><br /></td></tr>
<tr class="separator:a145a8c0071d070fc5f1f4ceb03bb595e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433db4cba9db5d263537724ae83530f6 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1a99d74a2c1b1287883c1aa8f77b9d23">deque_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a433db4cba9db5d263537724ae83530f6">deque</a> () noexcept</td></tr>
<tr class="memdesc:a433db4cba9db5d263537724ae83530f6 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying deque. Calling this function will mark the container as dirty. Any further attempts to call members like <a class="el" href="classseq_1_1flat__set.html#a89fcfee941936620861ea8d2d6b5fdb7" title="Finds an element with key that compares equivalent to the value key. This overload participates in ov...">find()</a>, lower_bound, upper_bound... will raise a std::logic_error. To mark the container as non dirty anymore, the user must call flat_set::sort().  <a href="classseq_1_1flat__set.html#a433db4cba9db5d263537724ae83530f6">More...</a><br /></td></tr>
<tr class="separator:a433db4cba9db5d263537724ae83530f6 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec74aae6c51be738bea634fe78b8418 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const <a class="el" href="classseq_1_1flat__set.html#a1a99d74a2c1b1287883c1aa8f77b9d23">deque_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2ec74aae6c51be738bea634fe78b8418">deque</a> () const noexcept</td></tr>
<tr class="memdesc:a2ec74aae6c51be738bea634fe78b8418 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the underlying deque. The container will NOT be marked as dirty.  <a href="classseq_1_1flat__set.html#a2ec74aae6c51be738bea634fe78b8418">More...</a><br /></td></tr>
<tr class="separator:a2ec74aae6c51be738bea634fe78b8418 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1864025f6e532f636ee8c6dc363670 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const <a class="el" href="classseq_1_1flat__set.html#a1a99d74a2c1b1287883c1aa8f77b9d23">deque_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2a1864025f6e532f636ee8c6dc363670">cdeque</a> () const noexcept</td></tr>
<tr class="memdesc:a2a1864025f6e532f636ee8c6dc363670 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the underlying deque. The container will NOT be marked as dirty.  <a href="classseq_1_1flat__set.html#a2a1864025f6e532f636ee8c6dc363670">More...</a><br /></td></tr>
<tr class="separator:a2a1864025f6e532f636ee8c6dc363670 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e08bf6a4096c80cbe5a80edd361f41 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a52e08bf6a4096c80cbe5a80edd361f41">insert</a> (const <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a52e08bf6a4096c80cbe5a80edd361f41 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__set.html#a52e08bf6a4096c80cbe5a80edd361f41">More...</a><br /></td></tr>
<tr class="separator:a52e08bf6a4096c80cbe5a80edd361f41 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1435d186c4db6f9b21079eccbd4dc74f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1435d186c4db6f9b21079eccbd4dc74f">insert</a> (<a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a1435d186c4db6f9b21079eccbd4dc74f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__set.html#a1435d186c4db6f9b21079eccbd4dc74f">More...</a><br /></td></tr>
<tr class="separator:a1435d186c4db6f9b21079eccbd4dc74f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46efdc1301a11289b38c0e43d240845d inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a46efdc1301a11289b38c0e43d240845d">insert</a> (const_iterator hint, const <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a46efdc1301a11289b38c0e43d240845d inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__set.html#a46efdc1301a11289b38c0e43d240845d">More...</a><br /></td></tr>
<tr class="separator:a46efdc1301a11289b38c0e43d240845d inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06a754a07ae3ed7b4c2536856e78754 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab06a754a07ae3ed7b4c2536856e78754">insert</a> (const_iterator hint, <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ab06a754a07ae3ed7b4c2536856e78754 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__set.html#ab06a754a07ae3ed7b4c2536856e78754">More...</a><br /></td></tr>
<tr class="separator:ab06a754a07ae3ed7b4c2536856e78754 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370336c5106645ee45fec8a2a26eadc4 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a370336c5106645ee45fec8a2a26eadc4">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a370336c5106645ee45fec8a2a26eadc4 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying deque, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one.  <a href="classseq_1_1flat__set.html#a370336c5106645ee45fec8a2a26eadc4">More...</a><br /></td></tr>
<tr class="separator:a370336c5106645ee45fec8a2a26eadc4 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace98a525dfd46ea113f9f151c63f2411 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ace98a525dfd46ea113f9f151c63f2411">insert</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ace98a525dfd46ea113f9f151c63f2411 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#ace98a525dfd46ea113f9f151c63f2411">More...</a><br /></td></tr>
<tr class="separator:ace98a525dfd46ea113f9f151c63f2411 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b520b1a7b336fdf30a32a2c5faf0b5 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; size_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae1b520b1a7b336fdf30a32a2c5faf0b5">insert_pos</a> (const <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:ae1b520b1a7b336fdf30a32a2c5faf0b5 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a52e08bf6a4096c80cbe5a80edd361f41" title="See std::set::insert.">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a0fcf1c8daa0d191632807ff662c49566" title="Returns the container size.">size()</a> if no element was inserted).  <a href="classseq_1_1flat__set.html#ae1b520b1a7b336fdf30a32a2c5faf0b5">More...</a><br /></td></tr>
<tr class="separator:ae1b520b1a7b336fdf30a32a2c5faf0b5 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47bbe940ef29c189a385afbcf78ca2e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; size_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae47bbe940ef29c189a385afbcf78ca2e">insert_pos</a> (<a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ae47bbe940ef29c189a385afbcf78ca2e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a52e08bf6a4096c80cbe5a80edd361f41" title="See std::set::insert.">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a0fcf1c8daa0d191632807ff662c49566" title="Returns the container size.">size()</a> if no element was inserted).  <a href="classseq_1_1flat__set.html#ae47bbe940ef29c189a385afbcf78ca2e">More...</a><br /></td></tr>
<tr class="separator:ae47bbe940ef29c189a385afbcf78ca2e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744c8fedac312da4f72e395ad248c1d4 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a744c8fedac312da4f72e395ad248c1d4">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a744c8fedac312da4f72e395ad248c1d4 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::emplace().  <a href="classseq_1_1flat__set.html#a744c8fedac312da4f72e395ad248c1d4">More...</a><br /></td></tr>
<tr class="separator:a744c8fedac312da4f72e395ad248c1d4 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3259f1c7d5ba06b1d96e361bde6631d inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; size_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af3259f1c7d5ba06b1d96e361bde6631d">emplace_pos</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af3259f1c7d5ba06b1d96e361bde6631d inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a744c8fedac312da4f72e395ad248c1d4" title="See std::set::emplace().">emplace()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a0fcf1c8daa0d191632807ff662c49566" title="Returns the container size.">size()</a> if no element was inserted).  <a href="classseq_1_1flat__set.html#af3259f1c7d5ba06b1d96e361bde6631d">More...</a><br /></td></tr>
<tr class="separator:af3259f1c7d5ba06b1d96e361bde6631d inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520c644aa8ca5e49e67b359df4b4bfc8 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a520c644aa8ca5e49e67b359df4b4bfc8">emplace_hint</a> (const_iterator hint, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a520c644aa8ca5e49e67b359df4b4bfc8 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::emplace_hint.  <a href="classseq_1_1flat__set.html#a520c644aa8ca5e49e67b359df4b4bfc8">More...</a><br /></td></tr>
<tr class="separator:a520c644aa8ca5e49e67b359df4b4bfc8 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51062a09feb26117423c5e2637cdd91 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae51062a09feb26117423c5e2637cdd91">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:ae51062a09feb26117423c5e2637cdd91 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the content of the range [first, last) to this container, discarding previous values.  <a href="classseq_1_1flat__set.html#ae51062a09feb26117423c5e2637cdd91">More...</a><br /></td></tr>
<tr class="separator:ae51062a09feb26117423c5e2637cdd91 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa211185e183f54d722afea2e38769f6b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa211185e183f54d722afea2e38769f6b">erase_pos</a> (<a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a> <a class="el" href="classseq_1_1flat__set.html#a4459cc493e6cbd6dd2e082f3140e632c">pos</a>)</td></tr>
<tr class="memdesc:aa211185e183f54d722afea2e38769f6b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given position in the container. This is slightly faster than calling <a class="el" href="classseq_1_1flat__set.html#a43e8a0a878a14a18f5f806a5e03c6974" title="Erase element at given location.">erase(iterator)</a>.  <a href="classseq_1_1flat__set.html#aa211185e183f54d722afea2e38769f6b">More...</a><br /></td></tr>
<tr class="separator:aa211185e183f54d722afea2e38769f6b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e8a0a878a14a18f5f806a5e03c6974 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a43e8a0a878a14a18f5f806a5e03c6974">erase</a> (const_iterator <a class="el" href="classseq_1_1flat__set.html#a4459cc493e6cbd6dd2e082f3140e632c">pos</a>)</td></tr>
<tr class="memdesc:a43e8a0a878a14a18f5f806a5e03c6974 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given location.  <a href="classseq_1_1flat__set.html#a43e8a0a878a14a18f5f806a5e03c6974">More...</a><br /></td></tr>
<tr class="separator:a43e8a0a878a14a18f5f806a5e03c6974 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8196e2cb52370c82e87730e4b0b768 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2f8196e2cb52370c82e87730e4b0b768">erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr class="memdesc:a2f8196e2cb52370c82e87730e4b0b768 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the range [first, last)  <a href="classseq_1_1flat__set.html#a2f8196e2cb52370c82e87730e4b0b768">More...</a><br /></td></tr>
<tr class="separator:a2f8196e2cb52370c82e87730e4b0b768 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5bf6cec1d8e7106f6c34a5cae2850e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aaf5bf6cec1d8e7106f6c34a5cae2850e">erase</a> (size_t first, size_t last)</td></tr>
<tr class="memdesc:aaf5bf6cec1d8e7106f6c34a5cae2850e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the range [first, last)  <a href="classseq_1_1flat__set.html#aaf5bf6cec1d8e7106f6c34a5cae2850e">More...</a><br /></td></tr>
<tr class="separator:aaf5bf6cec1d8e7106f6c34a5cae2850e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbb5bd603e023b8f73c6e0f40f5661b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a3dbb5bd603e023b8f73c6e0f40f5661b">erase</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a3dbb5bd603e023b8f73c6e0f40f5661b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type, and neither iterator nor const_iterator is implicitly convertible from K. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a3dbb5bd603e023b8f73c6e0f40f5661b">More...</a><br /></td></tr>
<tr class="separator:a3dbb5bd603e023b8f73c6e0f40f5661b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73de28607a842edeff2370e453564ae5 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a73de28607a842edeff2370e453564ae5">erase</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a73de28607a842edeff2370e453564ae5 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="classseq_1_1flat__set.html#a73de28607a842edeff2370e453564ae5">More...</a><br /></td></tr>
<tr class="separator:a73de28607a842edeff2370e453564ae5 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fcfee941936620861ea8d2d6b5fdb7 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a89fcfee941936620861ea8d2d6b5fdb7">find</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a89fcfee941936620861ea8d2d6b5fdb7 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a89fcfee941936620861ea8d2d6b5fdb7">More...</a><br /></td></tr>
<tr class="separator:a89fcfee941936620861ea8d2d6b5fdb7 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444355d18fda499bc865b1a5f6535c11 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a444355d18fda499bc865b1a5f6535c11">find</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a444355d18fda499bc865b1a5f6535c11 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1flat__set.html#a444355d18fda499bc865b1a5f6535c11">More...</a><br /></td></tr>
<tr class="separator:a444355d18fda499bc865b1a5f6535c11 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2a1d39fc0fe779c88cebd6a14f7c18 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a5c2a1d39fc0fe779c88cebd6a14f7c18">find</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a5c2a1d39fc0fe779c88cebd6a14f7c18 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a5c2a1d39fc0fe779c88cebd6a14f7c18">More...</a><br /></td></tr>
<tr class="separator:a5c2a1d39fc0fe779c88cebd6a14f7c18 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37675f6f5ec7ca65ad885affaa0c4920 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a37675f6f5ec7ca65ad885affaa0c4920">find</a> (const Key &amp;x) const</td></tr>
<tr class="memdesc:a37675f6f5ec7ca65ad885affaa0c4920 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1flat__set.html#a37675f6f5ec7ca65ad885affaa0c4920">More...</a><br /></td></tr>
<tr class="separator:a37675f6f5ec7ca65ad885affaa0c4920 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801ac421548770b371335b0bfd8acc69 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a801ac421548770b371335b0bfd8acc69">find_pos</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a801ac421548770b371335b0bfd8acc69 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a801ac421548770b371335b0bfd8acc69">More...</a><br /></td></tr>
<tr class="separator:a801ac421548770b371335b0bfd8acc69 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0404ffe72e0e121ec5a6e6632e856c inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aac0404ffe72e0e121ec5a6e6632e856c">find_pos</a> (const Key &amp;x) const</td></tr>
<tr class="memdesc:aac0404ffe72e0e121ec5a6e6632e856c inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1flat__set.html#aac0404ffe72e0e121ec5a6e6632e856c">More...</a><br /></td></tr>
<tr class="separator:aac0404ffe72e0e121ec5a6e6632e856c inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4459cc493e6cbd6dd2e082f3140e632c inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a4459cc493e6cbd6dd2e082f3140e632c">pos</a> (size_t i) const noexcept</td></tr>
<tr class="memdesc:a4459cc493e6cbd6dd2e082f3140e632c inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value at given flat position.  <a href="classseq_1_1flat__set.html#a4459cc493e6cbd6dd2e082f3140e632c">More...</a><br /></td></tr>
<tr class="separator:a4459cc493e6cbd6dd2e082f3140e632c inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802e8121bc400cece5bbfcd3b2d10327 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a802e8121bc400cece5bbfcd3b2d10327">lower_bound</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a802e8121bc400cece5bbfcd3b2d10327 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a802e8121bc400cece5bbfcd3b2d10327">More...</a><br /></td></tr>
<tr class="separator:a802e8121bc400cece5bbfcd3b2d10327 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df753072ae179f0a1f252bb3e5b1a5 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a06df753072ae179f0a1f252bb3e5b1a5">lower_bound</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a06df753072ae179f0a1f252bb3e5b1a5 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="classseq_1_1flat__set.html#a06df753072ae179f0a1f252bb3e5b1a5">More...</a><br /></td></tr>
<tr class="separator:a06df753072ae179f0a1f252bb3e5b1a5 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca42a22eaeaa7defee7d3a57d8fb980 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a8ca42a22eaeaa7defee7d3a57d8fb980">lower_bound</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a8ca42a22eaeaa7defee7d3a57d8fb980 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a8ca42a22eaeaa7defee7d3a57d8fb980">More...</a><br /></td></tr>
<tr class="separator:a8ca42a22eaeaa7defee7d3a57d8fb980 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76da030b6adcaff2fced8ae2583ef00a inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a76da030b6adcaff2fced8ae2583ef00a">lower_bound</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a76da030b6adcaff2fced8ae2583ef00a inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="classseq_1_1flat__set.html#a76da030b6adcaff2fced8ae2583ef00a">More...</a><br /></td></tr>
<tr class="separator:a76da030b6adcaff2fced8ae2583ef00a inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d8792c5e6c96243c7a7f03a5ce5757 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af2d8792c5e6c96243c7a7f03a5ce5757">lower_bound_pos</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:af2d8792c5e6c96243c7a7f03a5ce5757 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#af2d8792c5e6c96243c7a7f03a5ce5757">More...</a><br /></td></tr>
<tr class="separator:af2d8792c5e6c96243c7a7f03a5ce5757 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc41264fd062ecf3c987c92f787fab1 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1cc41264fd062ecf3c987c92f787fab1">lower_bound_pos</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a1cc41264fd062ecf3c987c92f787fab1 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that is not less than (i.e. greater or equal to) key.  <a href="classseq_1_1flat__set.html#a1cc41264fd062ecf3c987c92f787fab1">More...</a><br /></td></tr>
<tr class="separator:a1cc41264fd062ecf3c987c92f787fab1 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52e1251352df4f07dda15b78377d918 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae52e1251352df4f07dda15b78377d918">upper_bound</a> (const K &amp;key)</td></tr>
<tr class="memdesc:ae52e1251352df4f07dda15b78377d918 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#ae52e1251352df4f07dda15b78377d918">More...</a><br /></td></tr>
<tr class="separator:ae52e1251352df4f07dda15b78377d918 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa308271010c50a795f8be1eefa74fbaf inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa308271010c50a795f8be1eefa74fbaf">upper_bound</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:aa308271010c50a795f8be1eefa74fbaf inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classseq_1_1flat__set.html#aa308271010c50a795f8be1eefa74fbaf">More...</a><br /></td></tr>
<tr class="separator:aa308271010c50a795f8be1eefa74fbaf inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee2165fc31a4838fea980733516349b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#acee2165fc31a4838fea980733516349b">upper_bound</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:acee2165fc31a4838fea980733516349b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#acee2165fc31a4838fea980733516349b">More...</a><br /></td></tr>
<tr class="separator:acee2165fc31a4838fea980733516349b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d6b7e07f19962d73297ff956067f5f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a24d6b7e07f19962d73297ff956067f5f">upper_bound</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a24d6b7e07f19962d73297ff956067f5f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classseq_1_1flat__set.html#a24d6b7e07f19962d73297ff956067f5f">More...</a><br /></td></tr>
<tr class="separator:a24d6b7e07f19962d73297ff956067f5f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cbd65771b4da1ebd44ef3e733050a6 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a82cbd65771b4da1ebd44ef3e733050a6">upper_bound_pos</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a82cbd65771b4da1ebd44ef3e733050a6 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a82cbd65771b4da1ebd44ef3e733050a6">More...</a><br /></td></tr>
<tr class="separator:a82cbd65771b4da1ebd44ef3e733050a6 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646e6f6a7742d2f9a8b40537cba6d031 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a646e6f6a7742d2f9a8b40537cba6d031">upper_bound_pos</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a646e6f6a7742d2f9a8b40537cba6d031 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that is greater than key.  <a href="classseq_1_1flat__set.html#a646e6f6a7742d2f9a8b40537cba6d031">More...</a><br /></td></tr>
<tr class="separator:a646e6f6a7742d2f9a8b40537cba6d031 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ffce825378ecf1577ec86079e9f726 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae8ffce825378ecf1577ec86079e9f726">contains</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:ae8ffce825378ecf1577ec86079e9f726 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#ae8ffce825378ecf1577ec86079e9f726">More...</a><br /></td></tr>
<tr class="separator:ae8ffce825378ecf1577ec86079e9f726 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025ef46233dfe75c9026273742cfbbe2 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a025ef46233dfe75c9026273742cfbbe2">contains</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a025ef46233dfe75c9026273742cfbbe2 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key equivalent to key in the container.  <a href="classseq_1_1flat__set.html#a025ef46233dfe75c9026273742cfbbe2">More...</a><br /></td></tr>
<tr class="separator:a025ef46233dfe75c9026273742cfbbe2 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8246158b9b81d318a4905b384e4c2380 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a8246158b9b81d318a4905b384e4c2380">count</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a8246158b9b81d318a4905b384e4c2380 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key key (either 1 or 0 for flat_set and flat_map). This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a8246158b9b81d318a4905b384e4c2380">More...</a><br /></td></tr>
<tr class="separator:a8246158b9b81d318a4905b384e4c2380 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe88b070d7f275b06298efb9fb552757 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#abe88b070d7f275b06298efb9fb552757">count</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:abe88b070d7f275b06298efb9fb552757 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key key (either 1 or 0 for flat_set and flat_map).  <a href="classseq_1_1flat__set.html#abe88b070d7f275b06298efb9fb552757">More...</a><br /></td></tr>
<tr class="separator:abe88b070d7f275b06298efb9fb552757 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b965a32a61a5e977a1772307e58f5b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a61b965a32a61a5e977a1772307e58f5b">equal_range</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a61b965a32a61a5e977a1772307e58f5b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a802e8121bc400cece5bbfcd3b2d10327" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#ae52e1251352df4f07dda15b78377d918" title="Returns an iterator pointing to the first element that compares greater to the value key....">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#a61b965a32a61a5e977a1772307e58f5b">More...</a><br /></td></tr>
<tr class="separator:a61b965a32a61a5e977a1772307e58f5b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c4a3b154b0228472c4c220c5cdcf22 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a59c4a3b154b0228472c4c220c5cdcf22">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a59c4a3b154b0228472c4c220c5cdcf22 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a802e8121bc400cece5bbfcd3b2d10327" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#ae52e1251352df4f07dda15b78377d918" title="Returns an iterator pointing to the first element that compares greater to the value key....">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#a59c4a3b154b0228472c4c220c5cdcf22">More...</a><br /></td></tr>
<tr class="separator:a59c4a3b154b0228472c4c220c5cdcf22 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ecd4978bc0cedfdd1579ac463f2952 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac6ecd4978bc0cedfdd1579ac463f2952">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:ac6ecd4978bc0cedfdd1579ac463f2952 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a802e8121bc400cece5bbfcd3b2d10327" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#ae52e1251352df4f07dda15b78377d918" title="Returns an iterator pointing to the first element that compares greater to the value key....">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#ac6ecd4978bc0cedfdd1579ac463f2952">More...</a><br /></td></tr>
<tr class="separator:ac6ecd4978bc0cedfdd1579ac463f2952 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c4a070e4dc888f3111b01908a67b17 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac6c4a070e4dc888f3111b01908a67b17">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:ac6c4a070e4dc888f3111b01908a67b17 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a802e8121bc400cece5bbfcd3b2d10327" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#ae52e1251352df4f07dda15b78377d918" title="Returns an iterator pointing to the first element that compares greater to the value key....">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#ac6c4a070e4dc888f3111b01908a67b17">More...</a><br /></td></tr>
<tr class="separator:ac6c4a070e4dc888f3111b01908a67b17 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2d6d22cc758ed551f2836be4c6752c inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a5c2d6d22cc758ed551f2836be4c6752c">equal_range_pos</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a5c2d6d22cc758ed551f2836be4c6752c inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#af2d8792c5e6c96243c7a7f03a5ce5757" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a82cbd65771b4da1ebd44ef3e733050a6" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>.  <a href="classseq_1_1flat__set.html#a5c2d6d22cc758ed551f2836be4c6752c">More...</a><br /></td></tr>
<tr class="separator:a5c2d6d22cc758ed551f2836be4c6752c inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605d3ebaeb22e521f8dde1ef5b298a6f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a605d3ebaeb22e521f8dde1ef5b298a6f">equal_range_pos</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a605d3ebaeb22e521f8dde1ef5b298a6f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#af2d8792c5e6c96243c7a7f03a5ce5757" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a82cbd65771b4da1ebd44ef3e733050a6" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>.  <a href="classseq_1_1flat__set.html#a605d3ebaeb22e521f8dde1ef5b298a6f">More...</a><br /></td></tr>
<tr class="separator:a605d3ebaeb22e521f8dde1ef5b298a6f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53ba988a2774436198f857105de9969 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ad53ba988a2774436198f857105de9969">merge</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, C2, std::allocator&lt; Key &gt;, layout2 &gt; &amp;source)</td></tr>
<tr class="memdesc:ad53ba988a2774436198f857105de9969 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract each element in source and insert it into this using the comparison object of this. If there is an element in this with key equivalent to the key of an element from source, then that element is not extracted from source. Note that elements from source are moved to this.  <a href="classseq_1_1flat__set.html#ad53ba988a2774436198f857105de9969">More...</a><br /></td></tr>
<tr class="separator:ad53ba988a2774436198f857105de9969 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f5e252eaab72e82ccb162f53cda28d inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a84f5e252eaab72e82ccb162f53cda28d">begin</a> () noexcept</td></tr>
<tr class="memdesc:a84f5e252eaab72e82ccb162f53cda28d inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1flat__set.html#a84f5e252eaab72e82ccb162f53cda28d">More...</a><br /></td></tr>
<tr class="separator:a84f5e252eaab72e82ccb162f53cda28d inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad647d502ccc7cc1db99ee0991b21f109 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ad647d502ccc7cc1db99ee0991b21f109">begin</a> () const noexcept</td></tr>
<tr class="memdesc:ad647d502ccc7cc1db99ee0991b21f109 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1flat__set.html#ad647d502ccc7cc1db99ee0991b21f109">More...</a><br /></td></tr>
<tr class="separator:ad647d502ccc7cc1db99ee0991b21f109 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75194920729399ed66114c311f94f38 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa75194920729399ed66114c311f94f38">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aa75194920729399ed66114c311f94f38 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1flat__set.html#aa75194920729399ed66114c311f94f38">More...</a><br /></td></tr>
<tr class="separator:aa75194920729399ed66114c311f94f38 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831651fd4e4e8c9fa93c10ff4828d599 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a831651fd4e4e8c9fa93c10ff4828d599">end</a> () noexcept</td></tr>
<tr class="memdesc:a831651fd4e4e8c9fa93c10ff4828d599 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1flat__set.html#a831651fd4e4e8c9fa93c10ff4828d599">More...</a><br /></td></tr>
<tr class="separator:a831651fd4e4e8c9fa93c10ff4828d599 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18fa26df06aca52b142039d0463b109 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa18fa26df06aca52b142039d0463b109">end</a> () const noexcept</td></tr>
<tr class="memdesc:aa18fa26df06aca52b142039d0463b109 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1flat__set.html#aa18fa26df06aca52b142039d0463b109">More...</a><br /></td></tr>
<tr class="separator:aa18fa26df06aca52b142039d0463b109 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311724f148ec3194e24a65300948bf17 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a311724f148ec3194e24a65300948bf17">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a311724f148ec3194e24a65300948bf17 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1flat__set.html#a311724f148ec3194e24a65300948bf17">More...</a><br /></td></tr>
<tr class="separator:a311724f148ec3194e24a65300948bf17 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d0f9e5c065005e23e43eef7134200b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a28d0f9e5c065005e23e43eef7134200b">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a28d0f9e5c065005e23e43eef7134200b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1flat__set.html#a28d0f9e5c065005e23e43eef7134200b">More...</a><br /></td></tr>
<tr class="separator:a28d0f9e5c065005e23e43eef7134200b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504f9024366f3fc62f2794f139410645 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a504f9024366f3fc62f2794f139410645">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a504f9024366f3fc62f2794f139410645 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1flat__set.html#a504f9024366f3fc62f2794f139410645">More...</a><br /></td></tr>
<tr class="separator:a504f9024366f3fc62f2794f139410645 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2421f54c6bb9ef870a7177185f32ab81 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2421f54c6bb9ef870a7177185f32ab81">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a2421f54c6bb9ef870a7177185f32ab81 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1flat__set.html#a2421f54c6bb9ef870a7177185f32ab81">More...</a><br /></td></tr>
<tr class="separator:a2421f54c6bb9ef870a7177185f32ab81 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa335de83b0598f3e54ff7a84a0088a05 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa335de83b0598f3e54ff7a84a0088a05">rend</a> () noexcept</td></tr>
<tr class="memdesc:aa335de83b0598f3e54ff7a84a0088a05 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1flat__set.html#aa335de83b0598f3e54ff7a84a0088a05">More...</a><br /></td></tr>
<tr class="separator:aa335de83b0598f3e54ff7a84a0088a05 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da051e82b02ac0fb6795d444031dd22 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1da051e82b02ac0fb6795d444031dd22">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a1da051e82b02ac0fb6795d444031dd22 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1flat__set.html#a1da051e82b02ac0fb6795d444031dd22">More...</a><br /></td></tr>
<tr class="separator:a1da051e82b02ac0fb6795d444031dd22 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca9cd66f7322cf6505dde6cea29b675 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adca9cd66f7322cf6505dde6cea29b675">crend</a> () const noexcept</td></tr>
<tr class="memdesc:adca9cd66f7322cf6505dde6cea29b675 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1flat__set.html#adca9cd66f7322cf6505dde6cea29b675">More...</a><br /></td></tr>
<tr class="separator:adca9cd66f7322cf6505dde6cea29b675 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb70baa5b98497fc9c1c9d165cf488f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__set.html#a0a1d4b80fd721e98fd252d5f2dbc674d">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aedb70baa5b98497fc9c1c9d165cf488f">key_comp</a> () const</td></tr>
<tr class="memdesc:aedb70baa5b98497fc9c1c9d165cf488f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the comparison object.  <a href="classseq_1_1flat__set.html#aedb70baa5b98497fc9c1c9d165cf488f">More...</a><br /></td></tr>
<tr class="separator:aedb70baa5b98497fc9c1c9d165cf488f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2aa28ae90743b550fd6543126d6138 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aed2aa28ae90743b550fd6543126d6138">sort</a> ()</td></tr>
<tr class="memdesc:aed2aa28ae90743b550fd6543126d6138 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container. This function sort again the container only if:  <a href="classseq_1_1flat__set.html#aed2aa28ae90743b550fd6543126d6138">More...</a><br /></td></tr>
<tr class="separator:aed2aa28ae90743b550fd6543126d6138 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt;<br />
class seq::flat_multiset&lt; Key, Compare, Allocator, layout, Stable &gt;</h3>

<p>flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>key type </td></tr>
    <tr><td class="paramname">Compare</td><td>comparison function </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator </td></tr>
    <tr><td class="paramname">layout</td><td>memory layout of the underlying <a class="el" href="classseq_1_1deque.html" title="seq::deque is a std::deque like container implemented as a tiered-vector.">seq::deque</a> </td></tr>
    <tr><td class="paramname">Stable</td><td>insertion order stability</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1flat__multiset.html" title="flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values">seq::flat_multiset</a> is a sorted associative container similar to <a href="https://www.boost.org/doc/libs/1_64_0/doc/html/boost/container/flat_multiset.html">boost::flat_multiset</a>, but relying on a <a class="el" href="classseq_1_1deque.html" title="seq::deque is a std::deque like container implemented as a tiered-vector.">seq::deque</a> instead of a flat array. It supports multiple equal keys.</p>
<p><a class="el" href="classseq_1_1flat__multiset.html" title="flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values">seq::flat_multiset</a> directly inherits <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values">seq::flat_set</a> and behaves similarly, except for the support of multiple equal keys. Its interface is similar to std::multiset, except for the node based members.</p>
<p>All references and iterators are invalidated when inserting/removing keys. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9abd81cccf7490e9ead18b447ae4c473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abd81cccf7490e9ead18b447ae4c473">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a9abd81cccf7490e9ead18b447ae4c473">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ec78ce95ab35003a8e76ca861f03859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec78ce95ab35003a8e76ca861f03859">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a2ec78ce95ab35003a8e76ca861f03859">const_iterator</a> =  typename <a class="el" href="structseq_1_1flat__set_1_1const__iterator.html">base_type::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2335cb7eff2b949c387aaca474b8046a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2335cb7eff2b949c387aaca474b8046a">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a2335cb7eff2b949c387aaca474b8046a">const_pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#a2335cb7eff2b949c387aaca474b8046a">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58f75594ce52484b1d41b7f94db41218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f75594ce52484b1d41b7f94db41218">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a58f75594ce52484b1d41b7f94db41218">const_reference</a> =  const Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a892d2e8da8ef3eb9dfbf63911fd73e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892d2e8da8ef3eb9dfbf63911fd73e5f">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a892d2e8da8ef3eb9dfbf63911fd73e5f">const_reverse_iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">base_type::const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fc8ba21e60beee2752e6a3c202602eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc8ba21e60beee2752e6a3c202602eb">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a6fc8ba21e60beee2752e6a3c202602eb">difference_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#a6fc8ba21e60beee2752e6a3c202602eb">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf7abcd8c332f777c1ec9ad0b4c432f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7abcd8c332f777c1ec9ad0b4c432f6">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">base_type::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1a1ac7d77c88e7bbd22ff3f8849e923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a1ac7d77c88e7bbd22ff3f8849e923">&#9670;&nbsp;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#ae1a1ac7d77c88e7bbd22ff3f8849e923">key_compare</a> =  Compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8d0c0eca9a5079957fe5f7fda9f5967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d0c0eca9a5079957fe5f7fda9f5967">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#ac8d0c0eca9a5079957fe5f7fda9f5967">key_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5e5b4fdbf23fb6a5544aaf4a3f481fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb12309bb26912ed6f2216177e0de406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb12309bb26912ed6f2216177e0de406">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#acb12309bb26912ed6f2216177e0de406">reference</a> =  Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bf04f204152e12fbb7bea08b639cca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf04f204152e12fbb7bea08b639cca3">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a9bf04f204152e12fbb7bea08b639cca3">reverse_iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">base_type::reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1151b2ccc5b0068c3a66ddb390691c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1151b2ccc5b0068c3a66ddb390691c7">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#af1151b2ccc5b0068c3a66ddb390691c7">size_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#af1151b2ccc5b0068c3a66ddb390691c7">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac9f8264e3e53764cfae47bd03a18d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9f8264e3e53764cfae47bd03a18d8d">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a837ce53e1ed9c749770df9e1ec3541dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837ce53e1ed9c749770df9e1ec3541dc">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a231f0bcbfcb21972e4cdf089ddf5fb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231f0bcbfcb21972e4cdf089ddf5fb77">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a995f51fc40e3429596a29f475ff106c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995f51fc40e3429596a29f475ff106c0">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6b2454113754b7bd8d3c922119ff41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b2454113754b7bd8d3c922119ff41f">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c3078805e2694e24a1107ecc9e3ace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3078805e2694e24a1107ecc9e3ace5">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8986285103b6b8b8ff113f5de551d3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8986285103b6b8b8ff113f5de551d3d3">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a983e596648725c407017bd6561fca0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983e596648725c407017bd6561fca0bd">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55cca6165cc057921692869414c37c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cca6165cc057921692869414c37c55">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19f16cb6d01d65d73acb6370e353b4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f16cb6d01d65d73acb6370e353b4e5">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a2dcc536430281e13477a9a08915020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2dcc536430281e13477a9a08915020">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44549f25eaaa5708d7328673e6ecebbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44549f25eaaa5708d7328673e6ecebbe">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a51d6e572441e94bad0797fffeb3f8052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d6e572441e94bad0797fffeb3f8052">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62d6eee175fb11dfd71ce59509b8fdb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d6eee175fb11dfd71ce59509b8fdb7">&#9670;&nbsp;</a></span>emplace_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::emplace_pos </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52e08bf6a4096c80cbe5a80edd361f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e08bf6a4096c80cbe5a80edd361f41">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt;<a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>, bool&gt; <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::insert. </p>

</div>
</div>
<a id="a33f7b55294542ff1e4413e155d9a2be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f7b55294542ff1e4413e155d9a2be0">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46efdc1301a11289b38c0e43d240845d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46efdc1301a11289b38c0e43d240845d">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::insert() </p>

</div>
</div>
<a id="ab06a754a07ae3ed7b4c2536856e78754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06a754a07ae3ed7b4c2536856e78754">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::insert() </p>

</div>
</div>
<a id="a370336c5106645ee45fec8a2a26eadc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370336c5106645ee45fec8a2a26eadc4">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">class InputIt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying deque, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one. </p>

</div>
</div>
<a id="ace98a525dfd46ea113f9f151c63f2411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace98a525dfd46ea113f9f151c63f2411">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>

</div>
</div>
<a id="a1435d186c4db6f9b21079eccbd4dc74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1435d186c4db6f9b21079eccbd4dc74f">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> std::pair&lt;<a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>, bool&gt; <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::insert. </p>

</div>
</div>
<a id="aa09dc5666c44b0d83650f97ebb3642f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09dc5666c44b0d83650f97ebb3642f3">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40b713ad5a9521009dcf11823e6cb928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b713ad5a9521009dcf11823e6cb928">&#9670;&nbsp;</a></span>insert_pos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2513c47c66bb97e6db8489654888ffc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2513c47c66bb97e6db8489654888ffc2">&#9670;&nbsp;</a></span>insert_pos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> size_t <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f9eac45d865c6a1fd8140bcd5985a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9eac45d865c6a1fd8140bcd5985a89">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&amp; <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf428ee5534e54336119ca8ec503c50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf428ee5534e54336119ca8ec503c50d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&amp; <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e14bd00f41754dd0b5247d2b5c89f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e14bd00f41754dd0b5247d2b5c89f22">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&amp; <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="flat__map_8hpp_source.html">flat_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
