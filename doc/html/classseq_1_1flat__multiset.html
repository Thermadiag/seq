<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::flat_multiset&lt; Key, Compare, Allocator, Stable &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classseq_1_1flat__multiset.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseq_1_1flat__multiset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::flat_multiset&lt; Key, Compare, Allocator, Stable &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values  
 <a href="classseq_1_1flat__multiset.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="flat__map_8hpp_source.html">flat_map.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="classseq_1_1flat__set.html">seq::flat_set&lt; Key, Compare, Allocator, Stable, false &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aee30ec0cf46cc5516db5f99e0b7f3c88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aee30ec0cf46cc5516db5f99e0b7f3c88">key_type</a> = Key</td></tr>
<tr class="separator:aee30ec0cf46cc5516db5f99e0b7f3c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefc3f06c69d7fc615cafe21447be1ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> = Key</td></tr>
<tr class="separator:aaefc3f06c69d7fc615cafe21447be1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb7081c362c2d3f1991377f654470f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#adfb7081c362c2d3f1991377f654470f2">difference_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#adfb7081c362c2d3f1991377f654470f2">difference_type</a></td></tr>
<tr class="separator:adfb7081c362c2d3f1991377f654470f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169ff02024172d4b250908068fa372ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a169ff02024172d4b250908068fa372ee">size_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a169ff02024172d4b250908068fa372ee">size_type</a></td></tr>
<tr class="separator:a169ff02024172d4b250908068fa372ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0333bb2b0baf706d6b937649b6c21760"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a0333bb2b0baf706d6b937649b6c21760">key_compare</a> = Compare</td></tr>
<tr class="separator:a0333bb2b0baf706d6b937649b6c21760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acb47d25447dc7113a4b382986ea1a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a2acb47d25447dc7113a4b382986ea1a4">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a2acb47d25447dc7113a4b382986ea1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae484a1332361478f03cd1d0558f734b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ae484a1332361478f03cd1d0558f734b5">reference</a> = Key &amp;</td></tr>
<tr class="separator:ae484a1332361478f03cd1d0558f734b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5d372c2e24008f11a9e4e498f448e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aec5d372c2e24008f11a9e4e498f448e6">const_reference</a> = const Key &amp;</td></tr>
<tr class="separator:aec5d372c2e24008f11a9e4e498f448e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119ed1b0468bc376f60924ff74c6d06c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a119ed1b0468bc376f60924ff74c6d06c">pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a119ed1b0468bc376f60924ff74c6d06c">pointer</a></td></tr>
<tr class="separator:a119ed1b0468bc376f60924ff74c6d06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6747e1b7b64fa370494285e0f27781ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a6747e1b7b64fa370494285e0f27781ba">const_pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a6747e1b7b64fa370494285e0f27781ba">const_pointer</a></td></tr>
<tr class="separator:a6747e1b7b64fa370494285e0f27781ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d1b7d9eb727886437213e308b20dfd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a63d1b7d9eb727886437213e308b20dfd">iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">base_type::iterator</a></td></tr>
<tr class="separator:a63d1b7d9eb727886437213e308b20dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5303e7efe773475176936142c7c2ba4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aa5303e7efe773475176936142c7c2ba4">const_iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">base_type::const_iterator</a></td></tr>
<tr class="separator:aa5303e7efe773475176936142c7c2ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbb24f35b3f76321b219693a506bbaf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a3bbb24f35b3f76321b219693a506bbaf">reverse_iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">base_type::reverse_iterator</a></td></tr>
<tr class="separator:a3bbb24f35b3f76321b219693a506bbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a71fd411a04e07080ac35125651124a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a3a71fd411a04e07080ac35125651124a">const_reverse_iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">base_type::const_reverse_iterator</a></td></tr>
<tr class="separator:a3a71fd411a04e07080ac35125651124a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classseq_1_1flat__set"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classseq_1_1flat__set')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classseq_1_1flat__set.html">seq::flat_set&lt; Key, Compare, Allocator, Stable, false &gt;</a></td></tr>
<tr class="memitem:a21b0bac611ecd8732e6282084f533b9c inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a> = typename <a class="el" href="structseq_1_1detail_1_1flat__tree.html#af41da69c0cf605bd81accf294e4a96d6">flat_tree_type::deque_type</a></td></tr>
<tr class="separator:a21b0bac611ecd8732e6282084f533b9c inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77879fbd7d9f8f9e59c1ff8b4d2ea144 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> = typename deque_type::const_iterator</td></tr>
<tr class="separator:a77879fbd7d9f8f9e59c1ff8b4d2ea144 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999dddbf15eb6553aa7e91be08ce6222 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> = typename deque_type::const_iterator</td></tr>
<tr class="separator:a999dddbf15eb6553aa7e91be08ce6222 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ad7f5537b59b28ec7fd2a4ab32df07 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">reverse_iterator</a> = typename deque_type::const_reverse_iterator</td></tr>
<tr class="separator:a25ad7f5537b59b28ec7fd2a4ab32df07 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1957a91d7d434300b953843676c2ed inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a> = typename deque_type::const_reverse_iterator</td></tr>
<tr class="separator:aeb1957a91d7d434300b953843676c2ed inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6e0b374be4defba15ff71873ceee01 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aac6e0b374be4defba15ff71873ceee01">key_type</a> = Key</td></tr>
<tr class="separator:aac6e0b374be4defba15ff71873ceee01 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacbd6819f205822a6c898e5257dad95 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> = Key</td></tr>
<tr class="separator:aeacbd6819f205822a6c898e5257dad95 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4f850cd1b727e52d9e3b5c5291afb0 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1b4f850cd1b727e52d9e3b5c5291afb0">difference_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__set.html#a1b4f850cd1b727e52d9e3b5c5291afb0">difference_type</a></td></tr>
<tr class="separator:a1b4f850cd1b727e52d9e3b5c5291afb0 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f202fe21ed7de6f559b38740fe0b5a inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="separator:a30f202fe21ed7de6f559b38740fe0b5a inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6bb6b87f93185e1512bc25216b37df inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#afa6bb6b87f93185e1512bc25216b37df">key_compare</a> = Compare</td></tr>
<tr class="separator:afa6bb6b87f93185e1512bc25216b37df inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dd536447c118abbfa74b8551d49061 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a79dd536447c118abbfa74b8551d49061">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a79dd536447c118abbfa74b8551d49061 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b80e04ba844d8e26f452ca4d3ceece inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a25b80e04ba844d8e26f452ca4d3ceece">reference</a> = Key &amp;</td></tr>
<tr class="separator:a25b80e04ba844d8e26f452ca4d3ceece inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16c86bbdc8b0bca507d35927b7bb985 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac16c86bbdc8b0bca507d35927b7bb985">const_reference</a> = const Key &amp;</td></tr>
<tr class="separator:ac16c86bbdc8b0bca507d35927b7bb985 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370d857cf97fed3323fbb5cc6977eee4 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a370d857cf97fed3323fbb5cc6977eee4">pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__set.html#a370d857cf97fed3323fbb5cc6977eee4">pointer</a></td></tr>
<tr class="separator:a370d857cf97fed3323fbb5cc6977eee4 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dbf894f94d85541c14db4ab6eb3a65 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab1dbf894f94d85541c14db4ab6eb3a65">const_pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__set.html#ab1dbf894f94d85541c14db4ab6eb3a65">const_pointer</a></td></tr>
<tr class="separator:ab1dbf894f94d85541c14db4ab6eb3a65 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3acc0932e6511a48d3c2c70591347f43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a3acc0932e6511a48d3c2c70591347f43">flat_multiset</a> ()</td></tr>
<tr class="separator:a3acc0932e6511a48d3c2c70591347f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd552d1886a2c9ecfa4f07e29338b4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#addd552d1886a2c9ecfa4f07e29338b4e">flat_multiset</a> (const Compare &amp;comp, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:addd552d1886a2c9ecfa4f07e29338b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5f2bc676efa23d30b62c64332b115"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a6de5f2bc676efa23d30b62c64332b115">flat_multiset</a> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:a6de5f2bc676efa23d30b62c64332b115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed85b43953afa88e43e02214ea55db8"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a1ed85b43953afa88e43e02214ea55db8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a1ed85b43953afa88e43e02214ea55db8">flat_multiset</a> (InputIt first, InputIt last, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a1ed85b43953afa88e43e02214ea55db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad964fe874ae8408f98eda4a5ed61beed"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ad964fe874ae8408f98eda4a5ed61beed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ad964fe874ae8408f98eda4a5ed61beed">flat_multiset</a> (InputIt first, InputIt last, const Allocator &amp;alloc)</td></tr>
<tr class="separator:ad964fe874ae8408f98eda4a5ed61beed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3205866bd305392eb545123c467fb17c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a3205866bd305392eb545123c467fb17c">flat_multiset</a> (const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;other)</td></tr>
<tr class="separator:a3205866bd305392eb545123c467fb17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af664227fe839419ad2ead43dca64550f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#af664227fe839419ad2ead43dca64550f">flat_multiset</a> (const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="separator:af664227fe839419ad2ead43dca64550f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f1571c3377d7c802d852167c271537"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a18f1571c3377d7c802d852167c271537">flat_multiset</a> (<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a18f1571c3377d7c802d852167c271537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef0fd96156da1fdc35ea3bd6a19f47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ae4ef0fd96156da1fdc35ea3bd6a19f47">flat_multiset</a> (<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="separator:ae4ef0fd96156da1fdc35ea3bd6a19f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b0c5882ba3dc33935f622b31410913"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ad4b0c5882ba3dc33935f622b31410913">flat_multiset</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &gt; init, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:ad4b0c5882ba3dc33935f622b31410913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab527548fe301516334d403dbc6a2e089"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ab527548fe301516334d403dbc6a2e089">flat_multiset</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &gt; init, const Allocator &amp;alloc)</td></tr>
<tr class="separator:ab527548fe301516334d403dbc6a2e089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea7732c616a2584b5b7a080a60a6970"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a6ea7732c616a2584b5b7a080a60a6970">operator=</a> (<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;</td></tr>
<tr class="separator:a6ea7732c616a2584b5b7a080a60a6970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df8e3b44107daf11fe77aae2691395f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a3df8e3b44107daf11fe77aae2691395f">operator=</a> (const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;other) -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;</td></tr>
<tr class="separator:a3df8e3b44107daf11fe77aae2691395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25ca3f78a5b5fb66be90d8c58b8c1ac"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ac25ca3f78a5b5fb66be90d8c58b8c1ac">operator=</a> (const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &gt; &amp;init) -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;</td></tr>
<tr class="separator:ac25ca3f78a5b5fb66be90d8c58b8c1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15712d35d2870d9a558b3ff621671460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a15712d35d2870d9a558b3ff621671460">insert</a> (const <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &amp;value) -&gt; <a class="el" href="classseq_1_1flat__multiset.html#a63d1b7d9eb727886437213e308b20dfd">iterator</a></td></tr>
<tr class="separator:a15712d35d2870d9a558b3ff621671460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5793dc78a0a5767bf8be64a02eae91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a0c5793dc78a0a5767bf8be64a02eae91">insert</a> (<a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1flat__multiset.html#a63d1b7d9eb727886437213e308b20dfd">iterator</a></td></tr>
<tr class="separator:a0c5793dc78a0a5767bf8be64a02eae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aed3b1323da5963b3ba61fafac1806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aa0aed3b1323da5963b3ba61fafac1806">insert_pos</a> (const <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &amp;value) -&gt; size_t</td></tr>
<tr class="separator:aa0aed3b1323da5963b3ba61fafac1806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea24f7c708d29f6240fbee777e7eb220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aea24f7c708d29f6240fbee777e7eb220">insert_pos</a> (<a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &amp;&amp;value) -&gt; size_t</td></tr>
<tr class="separator:aea24f7c708d29f6240fbee777e7eb220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc75a9e8c008280d94fc186365db05fa"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:afc75a9e8c008280d94fc186365db05fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#afc75a9e8c008280d94fc186365db05fa">emplace</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1flat__multiset.html#a63d1b7d9eb727886437213e308b20dfd">iterator</a></td></tr>
<tr class="separator:afc75a9e8c008280d94fc186365db05fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65566f4fd4d826e7a4b0520a88157647"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a65566f4fd4d826e7a4b0520a88157647"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a65566f4fd4d826e7a4b0520a88157647">emplace_pos</a> (Args &amp;&amp;... args) -&gt; size_t</td></tr>
<tr class="separator:a65566f4fd4d826e7a4b0520a88157647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classseq_1_1flat__set"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classseq_1_1flat__set')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classseq_1_1flat__set.html">seq::flat_set&lt; Key, Compare, Allocator, Stable, false &gt;</a></td></tr>
<tr class="memitem:ae603afa34949ebea033565d2d1d89cce inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae603afa34949ebea033565d2d1d89cce">flat_set</a> ()</td></tr>
<tr class="memdesc:ae603afa34949ebea033565d2d1d89cce inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classseq_1_1flat__set.html#ae603afa34949ebea033565d2d1d89cce">More...</a><br /></td></tr>
<tr class="separator:ae603afa34949ebea033565d2d1d89cce inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e9bb2e33267ee0d9ad81100eedd7dc inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a72e9bb2e33267ee0d9ad81100eedd7dc">flat_set</a> (const Compare &amp;comp, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a72e9bb2e33267ee0d9ad81100eedd7dc inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from comparator function and optional allocator object.  <a href="classseq_1_1flat__set.html#a72e9bb2e33267ee0d9ad81100eedd7dc">More...</a><br /></td></tr>
<tr class="separator:a72e9bb2e33267ee0d9ad81100eedd7dc inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797ec01f149442f508e8f915373071b6 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a797ec01f149442f508e8f915373071b6">flat_set</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a797ec01f149442f508e8f915373071b6 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from allocator object.  <a href="classseq_1_1flat__set.html#a797ec01f149442f508e8f915373071b6">More...</a><br /></td></tr>
<tr class="separator:a797ec01f149442f508e8f915373071b6 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20afaa6733d1f49cfbbf7ea33bce1485 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a20afaa6733d1f49cfbbf7ea33bce1485">flat_set</a> (InputIt first, InputIt last, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a20afaa6733d1f49cfbbf7ea33bce1485 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#a20afaa6733d1f49cfbbf7ea33bce1485">More...</a><br /></td></tr>
<tr class="separator:a20afaa6733d1f49cfbbf7ea33bce1485 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac553b49836b4069726a1e609ec6a538f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac553b49836b4069726a1e609ec6a538f">flat_set</a> (InputIt first, InputIt last, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:ac553b49836b4069726a1e609ec6a538f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#ac553b49836b4069726a1e609ec6a538f">More...</a><br /></td></tr>
<tr class="separator:ac553b49836b4069726a1e609ec6a538f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af129b4ab9563a1029550a02049b7f171 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af129b4ab9563a1029550a02049b7f171">flat_set</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other)</td></tr>
<tr class="memdesc:af129b4ab9563a1029550a02049b7f171 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1flat__set.html#af129b4ab9563a1029550a02049b7f171">More...</a><br /></td></tr>
<tr class="separator:af129b4ab9563a1029550a02049b7f171 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2369e182eed80289a53705d80ee826 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aca2369e182eed80289a53705d80ee826">flat_set</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:aca2369e182eed80289a53705d80ee826 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1flat__set.html#aca2369e182eed80289a53705d80ee826">More...</a><br /></td></tr>
<tr class="separator:aca2369e182eed80289a53705d80ee826 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b89e289a324ea94e64c1f4f489d2912 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6b89e289a324ea94e64c1f4f489d2912">flat_set</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a6b89e289a324ea94e64c1f4f489d2912 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="classseq_1_1flat__set.html#a6b89e289a324ea94e64c1f4f489d2912">More...</a><br /></td></tr>
<tr class="separator:a6b89e289a324ea94e64c1f4f489d2912 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44961e5e4a80765f854d6279793e9303 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a44961e5e4a80765f854d6279793e9303">flat_set</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a44961e5e4a80765f854d6279793e9303 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="classseq_1_1flat__set.html#a44961e5e4a80765f854d6279793e9303">More...</a><br /></td></tr>
<tr class="separator:a44961e5e4a80765f854d6279793e9303 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae238a65551109cfd46d305e6d7792156 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae238a65551109cfd46d305e6d7792156">flat_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt; init, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:ae238a65551109cfd46d305e6d7792156 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#ae238a65551109cfd46d305e6d7792156">More...</a><br /></td></tr>
<tr class="separator:ae238a65551109cfd46d305e6d7792156 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070e001a5cad36bf9a068a91c2693544 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a070e001a5cad36bf9a068a91c2693544">flat_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt; init, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a070e001a5cad36bf9a068a91c2693544 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#a070e001a5cad36bf9a068a91c2693544">More...</a><br /></td></tr>
<tr class="separator:a070e001a5cad36bf9a068a91c2693544 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9cc850f1e573e675f3d3245db82485 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1b9cc850f1e573e675f3d3245db82485">operator=</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;</td></tr>
<tr class="memdesc:a1b9cc850f1e573e675f3d3245db82485 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classseq_1_1flat__set.html#a1b9cc850f1e573e675f3d3245db82485">More...</a><br /></td></tr>
<tr class="separator:a1b9cc850f1e573e675f3d3245db82485 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4b686521bb9cc5d0507e917627fe68 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a4f4b686521bb9cc5d0507e917627fe68">operator=</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other) -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;</td></tr>
<tr class="memdesc:a4f4b686521bb9cc5d0507e917627fe68 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator.  <a href="classseq_1_1flat__set.html#a4f4b686521bb9cc5d0507e917627fe68">More...</a><br /></td></tr>
<tr class="separator:a4f4b686521bb9cc5d0507e917627fe68 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296d675a8e4951def139df9fe800529e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a296d675a8e4951def139df9fe800529e">operator=</a> (const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt; &amp;init) -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;</td></tr>
<tr class="memdesc:a296d675a8e4951def139df9fe800529e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign initializer-list.  <a href="classseq_1_1flat__set.html#a296d675a8e4951def139df9fe800529e">More...</a><br /></td></tr>
<tr class="separator:a296d675a8e4951def139df9fe800529e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9288683c58c2cd6f6da6d813d5c93a inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9f9288683c58c2cd6f6da6d813d5c93a">get_allocator</a> () const noexcept -&gt; const Allocator &amp;</td></tr>
<tr class="memdesc:a9f9288683c58c2cd6f6da6d813d5c93a inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns container's allocator.  <a href="classseq_1_1flat__set.html#a9f9288683c58c2cd6f6da6d813d5c93a">More...</a><br /></td></tr>
<tr class="separator:a9f9288683c58c2cd6f6da6d813d5c93a inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacada284f479e651b636864157f5acf inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adacada284f479e651b636864157f5acf">get_allocator</a> () noexcept -&gt; Allocator &amp;</td></tr>
<tr class="separator:adacada284f479e651b636864157f5acf inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6652e65d040fe2f445f1addc37cf83b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab6652e65d040fe2f445f1addc37cf83b">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:ab6652e65d040fe2f445f1addc37cf83b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if container is empty, false otherwise.  <a href="classseq_1_1flat__set.html#ab6652e65d040fe2f445f1addc37cf83b">More...</a><br /></td></tr>
<tr class="separator:ab6652e65d040fe2f445f1addc37cf83b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c8886d204becfa074d92ce15c1874d inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d">size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:a23c8886d204becfa074d92ce15c1874d inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size.  <a href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d">More...</a><br /></td></tr>
<tr class="separator:a23c8886d204becfa074d92ce15c1874d inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93a8ed38a83b36d0a89ca600395aa22 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae93a8ed38a83b36d0a89ca600395aa22">max_size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:ae93a8ed38a83b36d0a89ca600395aa22 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size.  <a href="classseq_1_1flat__set.html#ae93a8ed38a83b36d0a89ca600395aa22">More...</a><br /></td></tr>
<tr class="separator:ae93a8ed38a83b36d0a89ca600395aa22 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692fd5619b00f4034158d580ffc06a2a inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a692fd5619b00f4034158d580ffc06a2a">clear</a> () noexcept</td></tr>
<tr class="memdesc:a692fd5619b00f4034158d580ffc06a2a inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container.  <a href="classseq_1_1flat__set.html#a692fd5619b00f4034158d580ffc06a2a">More...</a><br /></td></tr>
<tr class="separator:a692fd5619b00f4034158d580ffc06a2a inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abfe0f7dd40f799cbe7aad1dfe95257 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a5abfe0f7dd40f799cbe7aad1dfe95257">swap</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a5abfe0f7dd40f799cbe7aad1dfe95257 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this container's content with another. Iterators to both containers remain valid, including end iterators.  <a href="classseq_1_1flat__set.html#a5abfe0f7dd40f799cbe7aad1dfe95257">More...</a><br /></td></tr>
<tr class="separator:a5abfe0f7dd40f799cbe7aad1dfe95257 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa7fbd752589e8564aa0c3ad67dbc7e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9fa7fbd752589e8564aa0c3ad67dbc7e">tvector</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a> &amp;</td></tr>
<tr class="memdesc:a9fa7fbd752589e8564aa0c3ad67dbc7e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying tiered_vector. Calling this function will mark the container as dirty. Any further attempts to call members like <a class="el" href="classseq_1_1flat__set.html#aabcb0e7c7ad9bf0bdb5c548eda361306" title="Finds an element with key that compares equivalent to the value key. This overload participates in ov...">find()</a>, lower_bound, upper_bound... will raise a std::logic_error. To mark the container as non dirty anymore, the user must call flat_set::sort().  <a href="classseq_1_1flat__set.html#a9fa7fbd752589e8564aa0c3ad67dbc7e">More...</a><br /></td></tr>
<tr class="separator:a9fa7fbd752589e8564aa0c3ad67dbc7e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ecee637d5934dd496bb1516f0e85c8 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a64ecee637d5934dd496bb1516f0e85c8">tvector</a> () const noexcept -&gt; const <a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a> &amp;</td></tr>
<tr class="memdesc:a64ecee637d5934dd496bb1516f0e85c8 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the underlying tiered_vector. The container will NOT be marked as dirty.  <a href="classseq_1_1flat__set.html#a64ecee637d5934dd496bb1516f0e85c8">More...</a><br /></td></tr>
<tr class="separator:a64ecee637d5934dd496bb1516f0e85c8 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ea61c3eff4beb05bb561a1488e02ee inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a89ea61c3eff4beb05bb561a1488e02ee">ctvector</a> () const noexcept -&gt; const <a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a> &amp;</td></tr>
<tr class="memdesc:a89ea61c3eff4beb05bb561a1488e02ee inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the underlying tiered_vector. The container will NOT be marked as dirty.  <a href="classseq_1_1flat__set.html#a89ea61c3eff4beb05bb561a1488e02ee">More...</a><br /></td></tr>
<tr class="separator:a89ea61c3eff4beb05bb561a1488e02ee inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90998eda17f1d133efa03a852f73342 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa90998eda17f1d133efa03a852f73342">emplace</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:aa90998eda17f1d133efa03a852f73342 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::emplace().  <a href="classseq_1_1flat__set.html#aa90998eda17f1d133efa03a852f73342">More...</a><br /></td></tr>
<tr class="separator:aa90998eda17f1d133efa03a852f73342 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824394ff33504f5b923ea708d057451c inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c">insert</a> (const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a824394ff33504f5b923ea708d057451c inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c">More...</a><br /></td></tr>
<tr class="separator:a824394ff33504f5b923ea708d057451c inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c3798d946d17f1bdcc2eba6c2522c2 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae7c3798d946d17f1bdcc2eba6c2522c2">insert</a> (<a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:ae7c3798d946d17f1bdcc2eba6c2522c2 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__set.html#ae7c3798d946d17f1bdcc2eba6c2522c2">More...</a><br /></td></tr>
<tr class="separator:ae7c3798d946d17f1bdcc2eba6c2522c2 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd49dfd48ccd3057e13ee4a7549094f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#affd49dfd48ccd3057e13ee4a7549094f">insert</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> hint, const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;value) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:affd49dfd48ccd3057e13ee4a7549094f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__set.html#affd49dfd48ccd3057e13ee4a7549094f">More...</a><br /></td></tr>
<tr class="separator:affd49dfd48ccd3057e13ee4a7549094f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b0f2b618c92c54c7a7b56aea0509bf inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a22b0f2b618c92c54c7a7b56aea0509bf">insert</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> hint, <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a22b0f2b618c92c54c7a7b56aea0509bf inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__set.html#a22b0f2b618c92c54c7a7b56aea0509bf">More...</a><br /></td></tr>
<tr class="separator:a22b0f2b618c92c54c7a7b56aea0509bf inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ed9fadc8b03e3d3a03543dd114640e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af4ed9fadc8b03e3d3a03543dd114640e">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:af4ed9fadc8b03e3d3a03543dd114640e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying tiered_vector, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one.  <a href="classseq_1_1flat__set.html#af4ed9fadc8b03e3d3a03543dd114640e">More...</a><br /></td></tr>
<tr class="separator:af4ed9fadc8b03e3d3a03543dd114640e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f41daa22558743458cbfdce680f720 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab7f41daa22558743458cbfdce680f720">insert</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ab7f41daa22558743458cbfdce680f720 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#ab7f41daa22558743458cbfdce680f720">More...</a><br /></td></tr>
<tr class="separator:ab7f41daa22558743458cbfdce680f720 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3995b3e1a3cfa248d7246992bbacac0 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa3995b3e1a3cfa248d7246992bbacac0">insert_pos</a> (const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;value) -&gt; std::pair&lt; size_t, bool &gt;</td></tr>
<tr class="memdesc:aa3995b3e1a3cfa248d7246992bbacac0 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c" title="See std::set::insert. ">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> if no element was inserted).  <a href="classseq_1_1flat__set.html#aa3995b3e1a3cfa248d7246992bbacac0">More...</a><br /></td></tr>
<tr class="separator:aa3995b3e1a3cfa248d7246992bbacac0 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be4cbf48c48067da32a6ec329c62bf2 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a7be4cbf48c48067da32a6ec329c62bf2">insert_pos</a> (<a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; size_t, bool &gt;</td></tr>
<tr class="memdesc:a7be4cbf48c48067da32a6ec329c62bf2 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c" title="See std::set::insert. ">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> if no element was inserted).  <a href="classseq_1_1flat__set.html#a7be4cbf48c48067da32a6ec329c62bf2">More...</a><br /></td></tr>
<tr class="separator:a7be4cbf48c48067da32a6ec329c62bf2 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc0b5c9d6064ece331587d3d54da760 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0bc0b5c9d6064ece331587d3d54da760">emplace_pos</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; size_t, bool &gt;</td></tr>
<tr class="memdesc:a0bc0b5c9d6064ece331587d3d54da760 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#aa90998eda17f1d133efa03a852f73342" title="See std::set::emplace(). ">emplace()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> if no element was inserted).  <a href="classseq_1_1flat__set.html#a0bc0b5c9d6064ece331587d3d54da760">More...</a><br /></td></tr>
<tr class="separator:a0bc0b5c9d6064ece331587d3d54da760 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d642b59b512aa4876c3507224cbe73 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa2d642b59b512aa4876c3507224cbe73">emplace_hint</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> hint, Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:aa2d642b59b512aa4876c3507224cbe73 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::emplace_hint.  <a href="classseq_1_1flat__set.html#aa2d642b59b512aa4876c3507224cbe73">More...</a><br /></td></tr>
<tr class="separator:aa2d642b59b512aa4876c3507224cbe73 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3620f84e2d615134e8e4df04b20a53 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#afa3620f84e2d615134e8e4df04b20a53">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:afa3620f84e2d615134e8e4df04b20a53 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the content of the range [first, last) to this container, discarding previous values.  <a href="classseq_1_1flat__set.html#afa3620f84e2d615134e8e4df04b20a53">More...</a><br /></td></tr>
<tr class="separator:afa3620f84e2d615134e8e4df04b20a53 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bf6d75dba07b09fb05326d37bf2b56 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa7bf6d75dba07b09fb05326d37bf2b56">erase_pos</a> (<a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a> <a class="el" href="classseq_1_1flat__set.html#ab50bb3faf656740d6080aab6569990f9">pos</a>)</td></tr>
<tr class="memdesc:aa7bf6d75dba07b09fb05326d37bf2b56 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given position in the container. This is slightly faster than calling <a class="el" href="classseq_1_1flat__set.html#adc66a0e8125c797462812cc1fad29ae9" title="Erase element at given location. ">erase(iterator)</a>.  <a href="classseq_1_1flat__set.html#aa7bf6d75dba07b09fb05326d37bf2b56">More...</a><br /></td></tr>
<tr class="separator:aa7bf6d75dba07b09fb05326d37bf2b56 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc66a0e8125c797462812cc1fad29ae9 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adc66a0e8125c797462812cc1fad29ae9">erase</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> <a class="el" href="classseq_1_1flat__set.html#ab50bb3faf656740d6080aab6569990f9">pos</a>) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:adc66a0e8125c797462812cc1fad29ae9 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given location.  <a href="classseq_1_1flat__set.html#adc66a0e8125c797462812cc1fad29ae9">More...</a><br /></td></tr>
<tr class="separator:adc66a0e8125c797462812cc1fad29ae9 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fabdfc9d2d46b9fd29e16154d6cc324 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9fabdfc9d2d46b9fd29e16154d6cc324">erase</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> first, <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> last) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a9fabdfc9d2d46b9fd29e16154d6cc324 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the range [first, last)  <a href="classseq_1_1flat__set.html#a9fabdfc9d2d46b9fd29e16154d6cc324">More...</a><br /></td></tr>
<tr class="separator:a9fabdfc9d2d46b9fd29e16154d6cc324 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88ff2047f7bb5426d5dce534db6caeb inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa88ff2047f7bb5426d5dce534db6caeb">erase</a> (size_t first, size_t last)</td></tr>
<tr class="memdesc:aa88ff2047f7bb5426d5dce534db6caeb inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the range [first, last)  <a href="classseq_1_1flat__set.html#aa88ff2047f7bb5426d5dce534db6caeb">More...</a><br /></td></tr>
<tr class="separator:aa88ff2047f7bb5426d5dce534db6caeb inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd873b83ff14b355f3e10ad70a151aee inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#afd873b83ff14b355f3e10ad70a151aee">erase</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:afd873b83ff14b355f3e10ad70a151aee inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type, and neither iterator nor const_iterator is implicitly convertible from K. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#afd873b83ff14b355f3e10ad70a151aee">More...</a><br /></td></tr>
<tr class="separator:afd873b83ff14b355f3e10ad70a151aee inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413ccac6fd92ac9ededb9420495f5456 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a413ccac6fd92ac9ededb9420495f5456">erase</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:a413ccac6fd92ac9ededb9420495f5456 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="classseq_1_1flat__set.html#a413ccac6fd92ac9ededb9420495f5456">More...</a><br /></td></tr>
<tr class="separator:a413ccac6fd92ac9ededb9420495f5456 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcb0e7c7ad9bf0bdb5c548eda361306 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aabcb0e7c7ad9bf0bdb5c548eda361306">find</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:aabcb0e7c7ad9bf0bdb5c548eda361306 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#aabcb0e7c7ad9bf0bdb5c548eda361306">More...</a><br /></td></tr>
<tr class="separator:aabcb0e7c7ad9bf0bdb5c548eda361306 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f4598c86bb4ec62495ba4f06e52acf inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a17f4598c86bb4ec62495ba4f06e52acf">find</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a17f4598c86bb4ec62495ba4f06e52acf inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1flat__set.html#a17f4598c86bb4ec62495ba4f06e52acf">More...</a><br /></td></tr>
<tr class="separator:a17f4598c86bb4ec62495ba4f06e52acf inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1e9bc705afeb3974f71a2f33cbdeec inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2d1e9bc705afeb3974f71a2f33cbdeec">find</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a2d1e9bc705afeb3974f71a2f33cbdeec inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a2d1e9bc705afeb3974f71a2f33cbdeec">More...</a><br /></td></tr>
<tr class="separator:a2d1e9bc705afeb3974f71a2f33cbdeec inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2991f10f11b13559e9417893e5b1869 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac2991f10f11b13559e9417893e5b1869">find</a> (const Key &amp;x) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:ac2991f10f11b13559e9417893e5b1869 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1flat__set.html#ac2991f10f11b13559e9417893e5b1869">More...</a><br /></td></tr>
<tr class="separator:ac2991f10f11b13559e9417893e5b1869 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae195139b10f6f384b516eb0c6f9f0c41 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae195139b10f6f384b516eb0c6f9f0c41">find_pos</a> (const K &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:ae195139b10f6f384b516eb0c6f9f0c41 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#ae195139b10f6f384b516eb0c6f9f0c41">More...</a><br /></td></tr>
<tr class="separator:ae195139b10f6f384b516eb0c6f9f0c41 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd267246ae66f06e7280d4ac6b1871c inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a4cd267246ae66f06e7280d4ac6b1871c">find_pos</a> (const Key &amp;x) const -&gt; size_t</td></tr>
<tr class="memdesc:a4cd267246ae66f06e7280d4ac6b1871c inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1flat__set.html#a4cd267246ae66f06e7280d4ac6b1871c">More...</a><br /></td></tr>
<tr class="separator:a4cd267246ae66f06e7280d4ac6b1871c inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50bb3faf656740d6080aab6569990f9 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab50bb3faf656740d6080aab6569990f9">pos</a> (size_t i) const noexcept -&gt; const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;</td></tr>
<tr class="memdesc:ab50bb3faf656740d6080aab6569990f9 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value at given flat position.  <a href="classseq_1_1flat__set.html#ab50bb3faf656740d6080aab6569990f9">More...</a><br /></td></tr>
<tr class="separator:ab50bb3faf656740d6080aab6569990f9 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2173cac0b26bf9cdc6a11d7990ed8c50 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50">lower_bound</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a2173cac0b26bf9cdc6a11d7990ed8c50 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50">More...</a><br /></td></tr>
<tr class="separator:a2173cac0b26bf9cdc6a11d7990ed8c50 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b45c773ae10bc33f9e02489a6b96ae inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab1b45c773ae10bc33f9e02489a6b96ae">lower_bound</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:ab1b45c773ae10bc33f9e02489a6b96ae inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="classseq_1_1flat__set.html#ab1b45c773ae10bc33f9e02489a6b96ae">More...</a><br /></td></tr>
<tr class="separator:ab1b45c773ae10bc33f9e02489a6b96ae inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83375d6d39451636c0979c06d365b54c inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a83375d6d39451636c0979c06d365b54c">lower_bound</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a83375d6d39451636c0979c06d365b54c inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a83375d6d39451636c0979c06d365b54c">More...</a><br /></td></tr>
<tr class="separator:a83375d6d39451636c0979c06d365b54c inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7d2cfaa13474b1163ef8e687d3bf33 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aae7d2cfaa13474b1163ef8e687d3bf33">lower_bound</a> (const Key &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:aae7d2cfaa13474b1163ef8e687d3bf33 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="classseq_1_1flat__set.html#aae7d2cfaa13474b1163ef8e687d3bf33">More...</a><br /></td></tr>
<tr class="separator:aae7d2cfaa13474b1163ef8e687d3bf33 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec79ed0fd4cef7e0844deac4aa3aedd inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0ec79ed0fd4cef7e0844deac4aa3aedd">lower_bound_pos</a> (const K &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a0ec79ed0fd4cef7e0844deac4aa3aedd inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a0ec79ed0fd4cef7e0844deac4aa3aedd">More...</a><br /></td></tr>
<tr class="separator:a0ec79ed0fd4cef7e0844deac4aa3aedd inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f4b3ed5334be19de998d70e4a7ba39 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a22f4b3ed5334be19de998d70e4a7ba39">lower_bound_pos</a> (const Key &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a22f4b3ed5334be19de998d70e4a7ba39 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that is not less than (i.e. greater or equal to) key.  <a href="classseq_1_1flat__set.html#a22f4b3ed5334be19de998d70e4a7ba39">More...</a><br /></td></tr>
<tr class="separator:a22f4b3ed5334be19de998d70e4a7ba39 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0121f5a6e358530f708c4558fe5c4bc inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc">upper_bound</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:af0121f5a6e358530f708c4558fe5c4bc inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc">More...</a><br /></td></tr>
<tr class="separator:af0121f5a6e358530f708c4558fe5c4bc inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31aca82caf521823b1737444657fe3e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa31aca82caf521823b1737444657fe3e">upper_bound</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:aa31aca82caf521823b1737444657fe3e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classseq_1_1flat__set.html#aa31aca82caf521823b1737444657fe3e">More...</a><br /></td></tr>
<tr class="separator:aa31aca82caf521823b1737444657fe3e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe42865ce80bd40c8a5f90916d7a4367 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#afe42865ce80bd40c8a5f90916d7a4367">upper_bound</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:afe42865ce80bd40c8a5f90916d7a4367 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#afe42865ce80bd40c8a5f90916d7a4367">More...</a><br /></td></tr>
<tr class="separator:afe42865ce80bd40c8a5f90916d7a4367 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e42fb2055408052db9f10750994e69 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a98e42fb2055408052db9f10750994e69">upper_bound</a> (const Key &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a98e42fb2055408052db9f10750994e69 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classseq_1_1flat__set.html#a98e42fb2055408052db9f10750994e69">More...</a><br /></td></tr>
<tr class="separator:a98e42fb2055408052db9f10750994e69 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7187e79a36f33a8e356cbc19619c786e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a7187e79a36f33a8e356cbc19619c786e">upper_bound_pos</a> (const K &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a7187e79a36f33a8e356cbc19619c786e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a7187e79a36f33a8e356cbc19619c786e">More...</a><br /></td></tr>
<tr class="separator:a7187e79a36f33a8e356cbc19619c786e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d86c7d68a8ff523e82232be2b0eb404 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9d86c7d68a8ff523e82232be2b0eb404">upper_bound_pos</a> (const Key &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a9d86c7d68a8ff523e82232be2b0eb404 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that is greater than key.  <a href="classseq_1_1flat__set.html#a9d86c7d68a8ff523e82232be2b0eb404">More...</a><br /></td></tr>
<tr class="separator:a9d86c7d68a8ff523e82232be2b0eb404 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d31ec2fae3aa949ec3c0c811b4b2620 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a7d31ec2fae3aa949ec3c0c811b4b2620">contains</a> (const K &amp;key) const -&gt; bool</td></tr>
<tr class="memdesc:a7d31ec2fae3aa949ec3c0c811b4b2620 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a7d31ec2fae3aa949ec3c0c811b4b2620">More...</a><br /></td></tr>
<tr class="separator:a7d31ec2fae3aa949ec3c0c811b4b2620 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac7c825bddb1b5a97e2e65f657e33b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#abbac7c825bddb1b5a97e2e65f657e33b">contains</a> (const Key &amp;key) const -&gt; bool</td></tr>
<tr class="memdesc:abbac7c825bddb1b5a97e2e65f657e33b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key equivalent to key in the container.  <a href="classseq_1_1flat__set.html#abbac7c825bddb1b5a97e2e65f657e33b">More...</a><br /></td></tr>
<tr class="separator:abbac7c825bddb1b5a97e2e65f657e33b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0088631c9c3a478faa65decfdb456d11 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0088631c9c3a478faa65decfdb456d11">count</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:a0088631c9c3a478faa65decfdb456d11 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key key (either 1 or 0 for flat_set and flat_map). This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a0088631c9c3a478faa65decfdb456d11">More...</a><br /></td></tr>
<tr class="separator:a0088631c9c3a478faa65decfdb456d11 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714d052eb4568f2971c65c02d7c30ee9 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a714d052eb4568f2971c65c02d7c30ee9">count</a> (const Key &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:a714d052eb4568f2971c65c02d7c30ee9 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key key (either 1 or 0 for flat_set and flat_map).  <a href="classseq_1_1flat__set.html#a714d052eb4568f2971c65c02d7c30ee9">More...</a><br /></td></tr>
<tr class="separator:a714d052eb4568f2971c65c02d7c30ee9 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa267f0b23224b0ab83d1a9dc985536f2 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa267f0b23224b0ab83d1a9dc985536f2">equal_range</a> (const K &amp;key) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> &gt;</td></tr>
<tr class="memdesc:aa267f0b23224b0ab83d1a9dc985536f2 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#aa267f0b23224b0ab83d1a9dc985536f2">More...</a><br /></td></tr>
<tr class="separator:aa267f0b23224b0ab83d1a9dc985536f2 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cea0708e6c0aaa3d77e206fdf5a8db8 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9cea0708e6c0aaa3d77e206fdf5a8db8">equal_range</a> (const Key &amp;key) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> &gt;</td></tr>
<tr class="memdesc:a9cea0708e6c0aaa3d77e206fdf5a8db8 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#a9cea0708e6c0aaa3d77e206fdf5a8db8">More...</a><br /></td></tr>
<tr class="separator:a9cea0708e6c0aaa3d77e206fdf5a8db8 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab619b8f53013b24028517ae8b84ca543 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab619b8f53013b24028517ae8b84ca543">equal_range</a> (const K &amp;key) const -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:ab619b8f53013b24028517ae8b84ca543 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#ab619b8f53013b24028517ae8b84ca543">More...</a><br /></td></tr>
<tr class="separator:ab619b8f53013b24028517ae8b84ca543 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624895de6710b50cc37c4fbe8a66e905 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a624895de6710b50cc37c4fbe8a66e905">equal_range</a> (const Key &amp;key) const -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a624895de6710b50cc37c4fbe8a66e905 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#a624895de6710b50cc37c4fbe8a66e905">More...</a><br /></td></tr>
<tr class="separator:a624895de6710b50cc37c4fbe8a66e905 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108">equal_range_pos</a> (const K &amp;key) const -&gt; std::pair&lt; size_t, size_t &gt;</td></tr>
<tr class="memdesc:a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a0ec79ed0fd4cef7e0844deac4aa3aedd" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7187e79a36f33a8e356cbc19619c786e" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>.  <a href="classseq_1_1flat__set.html#a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108">More...</a><br /></td></tr>
<tr class="separator:a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2060d103ad5ed1e01f1eb17862bdd943 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2060d103ad5ed1e01f1eb17862bdd943">equal_range_pos</a> (const Key &amp;key) const -&gt; std::pair&lt; size_t, size_t &gt;</td></tr>
<tr class="memdesc:a2060d103ad5ed1e01f1eb17862bdd943 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a0ec79ed0fd4cef7e0844deac4aa3aedd" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7187e79a36f33a8e356cbc19619c786e" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>.  <a href="classseq_1_1flat__set.html#a2060d103ad5ed1e01f1eb17862bdd943">More...</a><br /></td></tr>
<tr class="separator:a2060d103ad5ed1e01f1eb17862bdd943 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9050125cbdb0a07737350da1feb32086 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9050125cbdb0a07737350da1feb32086">merge</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, C2, Allocator, layout2 &gt; &amp;source)</td></tr>
<tr class="memdesc:a9050125cbdb0a07737350da1feb32086 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract each element in source and insert it into this using the comparison object of this. If there is an element in this with key equivalent to the key of an element from source, then that element is not extracted from source. Note that elements from source are moved to this.  <a href="classseq_1_1flat__set.html#a9050125cbdb0a07737350da1feb32086">More...</a><br /></td></tr>
<tr class="separator:a9050125cbdb0a07737350da1feb32086 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59da319ca4e1f96f964e0d3a9aa0b5e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab59da319ca4e1f96f964e0d3a9aa0b5e">begin</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:ab59da319ca4e1f96f964e0d3a9aa0b5e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1flat__set.html#ab59da319ca4e1f96f964e0d3a9aa0b5e">More...</a><br /></td></tr>
<tr class="separator:ab59da319ca4e1f96f964e0d3a9aa0b5e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec4dac53a49bcb800c04484af32394b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adec4dac53a49bcb800c04484af32394b">begin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:adec4dac53a49bcb800c04484af32394b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1flat__set.html#adec4dac53a49bcb800c04484af32394b">More...</a><br /></td></tr>
<tr class="separator:adec4dac53a49bcb800c04484af32394b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce20d98d01cf4d0870f1d13a52d3742 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1ce20d98d01cf4d0870f1d13a52d3742">cbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a1ce20d98d01cf4d0870f1d13a52d3742 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1flat__set.html#a1ce20d98d01cf4d0870f1d13a52d3742">More...</a><br /></td></tr>
<tr class="separator:a1ce20d98d01cf4d0870f1d13a52d3742 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa94b63a25292f8a58cbfd2512c9860 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1fa94b63a25292f8a58cbfd2512c9860">end</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a1fa94b63a25292f8a58cbfd2512c9860 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1flat__set.html#a1fa94b63a25292f8a58cbfd2512c9860">More...</a><br /></td></tr>
<tr class="separator:a1fa94b63a25292f8a58cbfd2512c9860 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a9df66742e115f9689ce030d271ccf inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a49a9df66742e115f9689ce030d271ccf">end</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a49a9df66742e115f9689ce030d271ccf inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1flat__set.html#a49a9df66742e115f9689ce030d271ccf">More...</a><br /></td></tr>
<tr class="separator:a49a9df66742e115f9689ce030d271ccf inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0582e082a11301c87c027d53b5acc20 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af0582e082a11301c87c027d53b5acc20">cend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:af0582e082a11301c87c027d53b5acc20 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1flat__set.html#af0582e082a11301c87c027d53b5acc20">More...</a><br /></td></tr>
<tr class="separator:af0582e082a11301c87c027d53b5acc20 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb102fa22655897552043a5646f7a56f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#acb102fa22655897552043a5646f7a56f">rbegin</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">reverse_iterator</a></td></tr>
<tr class="memdesc:acb102fa22655897552043a5646f7a56f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1flat__set.html#acb102fa22655897552043a5646f7a56f">More...</a><br /></td></tr>
<tr class="separator:acb102fa22655897552043a5646f7a56f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddfd7f5e28cc93df7988ac58974c356 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6ddfd7f5e28cc93df7988ac58974c356">rbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a6ddfd7f5e28cc93df7988ac58974c356 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1flat__set.html#a6ddfd7f5e28cc93df7988ac58974c356">More...</a><br /></td></tr>
<tr class="separator:a6ddfd7f5e28cc93df7988ac58974c356 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee6637715350687953e694f5dc2ce34 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adee6637715350687953e694f5dc2ce34">crbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a></td></tr>
<tr class="memdesc:adee6637715350687953e694f5dc2ce34 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1flat__set.html#adee6637715350687953e694f5dc2ce34">More...</a><br /></td></tr>
<tr class="separator:adee6637715350687953e694f5dc2ce34 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd447617ab7d75b2ef5bab57b83989 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab0dd447617ab7d75b2ef5bab57b83989">rend</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">reverse_iterator</a></td></tr>
<tr class="memdesc:ab0dd447617ab7d75b2ef5bab57b83989 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1flat__set.html#ab0dd447617ab7d75b2ef5bab57b83989">More...</a><br /></td></tr>
<tr class="separator:ab0dd447617ab7d75b2ef5bab57b83989 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b22892f760277490febbbd0eeef3a8 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab5b22892f760277490febbbd0eeef3a8">rend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ab5b22892f760277490febbbd0eeef3a8 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1flat__set.html#ab5b22892f760277490febbbd0eeef3a8">More...</a><br /></td></tr>
<tr class="separator:ab5b22892f760277490febbbd0eeef3a8 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d1501d0598eddffcf7822d4f270aa8 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af1d1501d0598eddffcf7822d4f270aa8">crend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a></td></tr>
<tr class="memdesc:af1d1501d0598eddffcf7822d4f270aa8 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1flat__set.html#af1d1501d0598eddffcf7822d4f270aa8">More...</a><br /></td></tr>
<tr class="separator:af1d1501d0598eddffcf7822d4f270aa8 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39893991623c0876b65231b4ec7bd43c inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a39893991623c0876b65231b4ec7bd43c">key_comp</a> () const -&gt; <a class="el" href="classseq_1_1flat__set.html#afa6bb6b87f93185e1512bc25216b37df">key_compare</a></td></tr>
<tr class="memdesc:a39893991623c0876b65231b4ec7bd43c inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the comparison object.  <a href="classseq_1_1flat__set.html#a39893991623c0876b65231b4ec7bd43c">More...</a><br /></td></tr>
<tr class="separator:a39893991623c0876b65231b4ec7bd43c inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38209b2ae8d2ff7d4e84f4daf76983ff inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a38209b2ae8d2ff7d4e84f4daf76983ff">sort</a> ()</td></tr>
<tr class="memdesc:a38209b2ae8d2ff7d4e84f4daf76983ff inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container. This function sort again the container only if:  <a href="classseq_1_1flat__set.html#a38209b2ae8d2ff7d4e84f4daf76983ff">More...</a><br /></td></tr>
<tr class="separator:a38209b2ae8d2ff7d4e84f4daf76983ff inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false&gt;<br />
class seq::flat_multiset&lt; Key, Compare, Allocator, Stable &gt;</h3>

<p>flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>key type </td></tr>
    <tr><td class="paramname">Compare</td><td>comparison function </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator </td></tr>
    <tr><td class="paramname">Stable</td><td>insertion order stability</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1flat__multiset.html" title="flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values...">seq::flat_multiset</a> is a sorted associative container similar to <a href="https://www.boost.org/doc/libs/1_64_0/doc/html/boost/container/flat_multiset.html">boost::flat_multiset</a>, but relying on a <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> instead of a flat array. It supports multiple equal keys.</p>
<p><a class="el" href="classseq_1_1flat__multiset.html" title="flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values...">seq::flat_multiset</a> directly inherits <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> and behaves similarly, except for the support of multiple equal keys. Its interface is similar to std::multiset, except for the node based members.</p>
<p>All references and iterators are invalidated when inserting/removing keys. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2acb47d25447dc7113a4b382986ea1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acb47d25447dc7113a4b382986ea1a4">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a2acb47d25447dc7113a4b382986ea1a4">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5303e7efe773475176936142c7c2ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5303e7efe773475176936142c7c2ba4">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aa5303e7efe773475176936142c7c2ba4">const_iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">base_type::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6747e1b7b64fa370494285e0f27781ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6747e1b7b64fa370494285e0f27781ba">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a6747e1b7b64fa370494285e0f27781ba">const_pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#a6747e1b7b64fa370494285e0f27781ba">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec5d372c2e24008f11a9e4e498f448e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5d372c2e24008f11a9e4e498f448e6">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aec5d372c2e24008f11a9e4e498f448e6">const_reference</a> =  const Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a71fd411a04e07080ac35125651124a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a71fd411a04e07080ac35125651124a">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a3a71fd411a04e07080ac35125651124a">const_reverse_iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">base_type::const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfb7081c362c2d3f1991377f654470f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb7081c362c2d3f1991377f654470f2">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#adfb7081c362c2d3f1991377f654470f2">difference_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#adfb7081c362c2d3f1991377f654470f2">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63d1b7d9eb727886437213e308b20dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d1b7d9eb727886437213e308b20dfd">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a63d1b7d9eb727886437213e308b20dfd">iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">base_type::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0333bb2b0baf706d6b937649b6c21760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0333bb2b0baf706d6b937649b6c21760">&#9670;&nbsp;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a0333bb2b0baf706d6b937649b6c21760">key_compare</a> =  Compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee30ec0cf46cc5516db5f99e0b7f3c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee30ec0cf46cc5516db5f99e0b7f3c88">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aee30ec0cf46cc5516db5f99e0b7f3c88">key_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a119ed1b0468bc376f60924ff74c6d06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119ed1b0468bc376f60924ff74c6d06c">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a119ed1b0468bc376f60924ff74c6d06c">pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#a119ed1b0468bc376f60924ff74c6d06c">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae484a1332361478f03cd1d0558f734b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae484a1332361478f03cd1d0558f734b5">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#ae484a1332361478f03cd1d0558f734b5">reference</a> =  Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bbb24f35b3f76321b219693a506bbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbb24f35b3f76321b219693a506bbaf">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a3bbb24f35b3f76321b219693a506bbaf">reverse_iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">base_type::reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a169ff02024172d4b250908068fa372ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169ff02024172d4b250908068fa372ee">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a169ff02024172d4b250908068fa372ee">size_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#a169ff02024172d4b250908068fa372ee">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaefc3f06c69d7fc615cafe21447be1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefc3f06c69d7fc615cafe21447be1ac">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3acc0932e6511a48d3c2c70591347f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acc0932e6511a48d3c2c70591347f43">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="addd552d1886a2c9ecfa4f07e29338b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd552d1886a2c9ecfa4f07e29338b4e">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6de5f2bc676efa23d30b62c64332b115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5f2bc676efa23d30b62c64332b115">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ed85b43953afa88e43e02214ea55db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed85b43953afa88e43e02214ea55db8">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad964fe874ae8408f98eda4a5ed61beed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad964fe874ae8408f98eda4a5ed61beed">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3205866bd305392eb545123c467fb17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3205866bd305392eb545123c467fb17c">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af664227fe839419ad2ead43dca64550f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af664227fe839419ad2ead43dca64550f">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18f1571c3377d7c802d852167c271537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f1571c3377d7c802d852167c271537">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4ef0fd96156da1fdc35ea3bd6a19f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ef0fd96156da1fdc35ea3bd6a19f47">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4b0c5882ba3dc33935f622b31410913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b0c5882ba3dc33935f622b31410913">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab527548fe301516334d403dbc6a2e089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab527548fe301516334d403dbc6a2e089">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc75a9e8c008280d94fc186365db05fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc75a9e8c008280d94fc186365db05fa">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html#a63d1b7d9eb727886437213e308b20dfd">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65566f4fd4d826e7a4b0520a88157647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65566f4fd4d826e7a4b0520a88157647">&#9670;&nbsp;</a></span>emplace_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::emplace_pos </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15712d35d2870d9a558b3ff621671460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15712d35d2870d9a558b3ff621671460">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html#a63d1b7d9eb727886437213e308b20dfd">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c5793dc78a0a5767bf8be64a02eae91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5793dc78a0a5767bf8be64a02eae91">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html#a63d1b7d9eb727886437213e308b20dfd">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0aed3b1323da5963b3ba61fafac1806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aed3b1323da5963b3ba61fafac1806">&#9670;&nbsp;</a></span>insert_pos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea24f7c708d29f6240fbee777e7eb220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea24f7c708d29f6240fbee777e7eb220">&#9670;&nbsp;</a></span>insert_pos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ea7732c616a2584b5b7a080a60a6970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea7732c616a2584b5b7a080a60a6970">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3df8e3b44107daf11fe77aae2691395f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df8e3b44107daf11fe77aae2691395f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac25ca3f78a5b5fb66be90d8c58b8c1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25ca3f78a5b5fb66be90d8c58b8c1ac">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, Stable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aaefc3f06c69d7fc615cafe21447be1ac">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="flat__map_8hpp_source.html">flat_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
