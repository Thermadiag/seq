<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::flat_multiset&lt; Key, Compare, Allocator, layout, Stable &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classseq_1_1flat__multiset.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseq_1_1flat__multiset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::flat_multiset&lt; Key, Compare, Allocator, layout, Stable &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values  
 <a href="classseq_1_1flat__multiset.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="flat__map_8hpp_source.html">flat_map.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="classseq_1_1flat__set.html">seq::flat_set&lt; Key, std::less&lt; Key &gt;, std::allocator&lt; Key &gt;, OptimizeForMemory, false, false &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac8d0c0eca9a5079957fe5f7fda9f5967"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ac8d0c0eca9a5079957fe5f7fda9f5967">key_type</a> = Key</td></tr>
<tr class="separator:ac8d0c0eca9a5079957fe5f7fda9f5967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9f8264e3e53764cfae47bd03a18d8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> = Key</td></tr>
<tr class="separator:aac9f8264e3e53764cfae47bd03a18d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc8ba21e60beee2752e6a3c202602eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a6fc8ba21e60beee2752e6a3c202602eb">difference_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a6fc8ba21e60beee2752e6a3c202602eb">difference_type</a></td></tr>
<tr class="separator:a6fc8ba21e60beee2752e6a3c202602eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1151b2ccc5b0068c3a66ddb390691c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#af1151b2ccc5b0068c3a66ddb390691c7">size_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#af1151b2ccc5b0068c3a66ddb390691c7">size_type</a></td></tr>
<tr class="separator:af1151b2ccc5b0068c3a66ddb390691c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a1ac7d77c88e7bbd22ff3f8849e923"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ae1a1ac7d77c88e7bbd22ff3f8849e923">key_compare</a> = Compare</td></tr>
<tr class="separator:ae1a1ac7d77c88e7bbd22ff3f8849e923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd81cccf7490e9ead18b447ae4c473"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a9abd81cccf7490e9ead18b447ae4c473">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a9abd81cccf7490e9ead18b447ae4c473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb12309bb26912ed6f2216177e0de406"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#acb12309bb26912ed6f2216177e0de406">reference</a> = Key &amp;</td></tr>
<tr class="separator:acb12309bb26912ed6f2216177e0de406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f75594ce52484b1d41b7f94db41218"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a58f75594ce52484b1d41b7f94db41218">const_reference</a> = const Key &amp;</td></tr>
<tr class="separator:a58f75594ce52484b1d41b7f94db41218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e5b4fdbf23fb6a5544aaf4a3f481fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">pointer</a></td></tr>
<tr class="separator:aa5e5b4fdbf23fb6a5544aaf4a3f481fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2335cb7eff2b949c387aaca474b8046a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a2335cb7eff2b949c387aaca474b8046a">const_pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a2335cb7eff2b949c387aaca474b8046a">const_pointer</a></td></tr>
<tr class="separator:a2335cb7eff2b949c387aaca474b8046a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7abcd8c332f777c1ec9ad0b4c432f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">base_type::iterator</a></td></tr>
<tr class="separator:abf7abcd8c332f777c1ec9ad0b4c432f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec78ce95ab35003a8e76ca861f03859"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a2ec78ce95ab35003a8e76ca861f03859">const_iterator</a> = typename <a class="el" href="structseq_1_1flat__set_1_1const__iterator.html">base_type::const_iterator</a></td></tr>
<tr class="separator:a2ec78ce95ab35003a8e76ca861f03859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf04f204152e12fbb7bea08b639cca3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a9bf04f204152e12fbb7bea08b639cca3">reverse_iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">base_type::reverse_iterator</a></td></tr>
<tr class="separator:a9bf04f204152e12fbb7bea08b639cca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892d2e8da8ef3eb9dfbf63911fd73e5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a892d2e8da8ef3eb9dfbf63911fd73e5f">const_reverse_iterator</a> = typename <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">base_type::const_reverse_iterator</a></td></tr>
<tr class="separator:a892d2e8da8ef3eb9dfbf63911fd73e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classseq_1_1flat__set"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classseq_1_1flat__set')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classseq_1_1flat__set.html">seq::flat_set&lt; Key, std::less&lt; Key &gt;, std::allocator&lt; Key &gt;, OptimizeForMemory, false, false &gt;</a></td></tr>
<tr class="memitem:a1a99d74a2c1b1287883c1aa8f77b9d23 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1a99d74a2c1b1287883c1aa8f77b9d23">deque_type</a> = typename <a class="el" href="structseq_1_1detail_1_1flat__tree.html#a206db35a1c2d1065d811172700f3518d">flat_tree_type::deque_type</a></td></tr>
<tr class="separator:a1a99d74a2c1b1287883c1aa8f77b9d23 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b64c5f701a2ab7921e34ce3d5b5d1a6 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a> = const_iterator</td></tr>
<tr class="separator:a1b64c5f701a2ab7921e34ce3d5b5d1a6 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c948977310c47866584a268790a6f0 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a95c948977310c47866584a268790a6f0">key_type</a> = Key</td></tr>
<tr class="separator:a95c948977310c47866584a268790a6f0 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423dfd403dcf1078aa0400ceb34aca10 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> = Key</td></tr>
<tr class="separator:a423dfd403dcf1078aa0400ceb34aca10 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8481828c9f2f74c4e061acfdc1e02a inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9d8481828c9f2f74c4e061acfdc1e02a">difference_type</a> = typename std::allocator_traits&lt; std::allocator&lt; Key &gt; &gt;::<a class="el" href="classseq_1_1flat__set.html#a9d8481828c9f2f74c4e061acfdc1e02a">difference_type</a></td></tr>
<tr class="separator:a9d8481828c9f2f74c4e061acfdc1e02a inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2f707cf8f7944eda425023d33003e7 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a> = typename std::allocator_traits&lt; std::allocator&lt; Key &gt; &gt;::<a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a></td></tr>
<tr class="separator:a4c2f707cf8f7944eda425023d33003e7 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1d4b80fd721e98fd252d5f2dbc674d inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0a1d4b80fd721e98fd252d5f2dbc674d">key_compare</a> = std::less&lt; Key &gt;</td></tr>
<tr class="separator:a0a1d4b80fd721e98fd252d5f2dbc674d inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e750bb1eb6ece2521d164c022287d7 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a45e750bb1eb6ece2521d164c022287d7">allocator_type</a> = std::allocator&lt; Key &gt;</td></tr>
<tr class="separator:a45e750bb1eb6ece2521d164c022287d7 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dac755c1568229cf24798257217d0b3 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a3dac755c1568229cf24798257217d0b3">reference</a> = Key &amp;</td></tr>
<tr class="separator:a3dac755c1568229cf24798257217d0b3 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aa14284b49ee04935c41c6e8c01a55 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac3aa14284b49ee04935c41c6e8c01a55">const_reference</a> = const Key &amp;</td></tr>
<tr class="separator:ac3aa14284b49ee04935c41c6e8c01a55 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c4082dfe9ef37b2894e9a785830887 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a32c4082dfe9ef37b2894e9a785830887">pointer</a> = typename std::allocator_traits&lt; std::allocator&lt; Key &gt; &gt;::<a class="el" href="classseq_1_1flat__set.html#a32c4082dfe9ef37b2894e9a785830887">pointer</a></td></tr>
<tr class="separator:a32c4082dfe9ef37b2894e9a785830887 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56ed1e8f1b1fee2c4f8a26f16969210 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac56ed1e8f1b1fee2c4f8a26f16969210">const_pointer</a> = typename std::allocator_traits&lt; std::allocator&lt; Key &gt; &gt;::<a class="el" href="classseq_1_1flat__set.html#ac56ed1e8f1b1fee2c4f8a26f16969210">const_pointer</a></td></tr>
<tr class="separator:ac56ed1e8f1b1fee2c4f8a26f16969210 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa005e31dc3f4c6de57c78c08579c0350 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a> &gt;</td></tr>
<tr class="separator:aa005e31dc3f4c6de57c78c08579c0350 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f0b73c32e563991fa077115d501c69 inherit pub_types_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a> = std::reverse_iterator&lt; const_iterator &gt;</td></tr>
<tr class="separator:a59f0b73c32e563991fa077115d501c69 inherit pub_types_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a837ce53e1ed9c749770df9e1ec3541dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a837ce53e1ed9c749770df9e1ec3541dc">flat_multiset</a> ()</td></tr>
<tr class="separator:a837ce53e1ed9c749770df9e1ec3541dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231f0bcbfcb21972e4cdf089ddf5fb77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a231f0bcbfcb21972e4cdf089ddf5fb77">flat_multiset</a> (const Compare &amp;comp, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a231f0bcbfcb21972e4cdf089ddf5fb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995f51fc40e3429596a29f475ff106c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a995f51fc40e3429596a29f475ff106c0">flat_multiset</a> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:a995f51fc40e3429596a29f475ff106c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b2454113754b7bd8d3c922119ff41f"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ab6b2454113754b7bd8d3c922119ff41f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ab6b2454113754b7bd8d3c922119ff41f">flat_multiset</a> (InputIt first, InputIt last, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:ab6b2454113754b7bd8d3c922119ff41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3078805e2694e24a1107ecc9e3ace5"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a2c3078805e2694e24a1107ecc9e3ace5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a2c3078805e2694e24a1107ecc9e3ace5">flat_multiset</a> (InputIt first, InputIt last, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a2c3078805e2694e24a1107ecc9e3ace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8986285103b6b8b8ff113f5de551d3d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a8986285103b6b8b8ff113f5de551d3d3">flat_multiset</a> (const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;other)</td></tr>
<tr class="separator:a8986285103b6b8b8ff113f5de551d3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983e596648725c407017bd6561fca0bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a983e596648725c407017bd6561fca0bd">flat_multiset</a> (const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a983e596648725c407017bd6561fca0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cca6165cc057921692869414c37c55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a55cca6165cc057921692869414c37c55">flat_multiset</a> (<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a55cca6165cc057921692869414c37c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f16cb6d01d65d73acb6370e353b4e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a19f16cb6d01d65d73acb6370e353b4e5">flat_multiset</a> (<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&amp;other, const Allocator &amp;alloc) noexcept</td></tr>
<tr class="separator:a19f16cb6d01d65d73acb6370e353b4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2dcc536430281e13477a9a08915020"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a1a2dcc536430281e13477a9a08915020">flat_multiset</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; init, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a1a2dcc536430281e13477a9a08915020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44549f25eaaa5708d7328673e6ecebbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a44549f25eaaa5708d7328673e6ecebbe">flat_multiset</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; init, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a44549f25eaaa5708d7328673e6ecebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7462b5c7a65e4e65662e87f5d35776a6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a7462b5c7a65e4e65662e87f5d35776a6">operator=</a> (<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;</td></tr>
<tr class="separator:a7462b5c7a65e4e65662e87f5d35776a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6ced1312b3bcfe4b5467ba82c68c24"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a8b6ced1312b3bcfe4b5467ba82c68c24">operator=</a> (const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;other) -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;</td></tr>
<tr class="separator:a8b6ced1312b3bcfe4b5467ba82c68c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0424f77ef1ea305834e4789fb6e77acf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a0424f77ef1ea305834e4789fb6e77acf">operator=</a> (const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; &amp;init) -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> &amp;</td></tr>
<tr class="separator:a0424f77ef1ea305834e4789fb6e77acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d1ece82c6759cf9e8001e106a1e21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#aa5d1ece82c6759cf9e8001e106a1e21b">insert</a> (const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;value) -&gt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a></td></tr>
<tr class="separator:aa5d1ece82c6759cf9e8001e106a1e21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cb4a293aeffa890293828f3da3a0bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a90cb4a293aeffa890293828f3da3a0bf">insert</a> (<a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a></td></tr>
<tr class="separator:a90cb4a293aeffa890293828f3da3a0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b890a03c2f8d294d516263b880107f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a1b890a03c2f8d294d516263b880107f3">insert_pos</a> (const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;value) -&gt; size_t</td></tr>
<tr class="separator:a1b890a03c2f8d294d516263b880107f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa885291fc3c4e61572e98eb035434a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a4aa885291fc3c4e61572e98eb035434a">insert_pos</a> (<a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;value) -&gt; size_t</td></tr>
<tr class="separator:a4aa885291fc3c4e61572e98eb035434a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587774cefd2d54988d8469a59477f69d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a587774cefd2d54988d8469a59477f69d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a587774cefd2d54988d8469a59477f69d">emplace</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a></td></tr>
<tr class="separator:a587774cefd2d54988d8469a59477f69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37278b2eda6b919acfdd4d45592c5aab"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a37278b2eda6b919acfdd4d45592c5aab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a37278b2eda6b919acfdd4d45592c5aab">emplace_pos</a> (Args &amp;&amp;... args) -&gt; size_t</td></tr>
<tr class="separator:a37278b2eda6b919acfdd4d45592c5aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d303585e85156afba2c58aafab309a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a1d303585e85156afba2c58aafab309a4">insert</a> (const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a1d303585e85156afba2c58aafab309a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__multiset.html#a1d303585e85156afba2c58aafab309a4">More...</a><br /></td></tr>
<tr class="separator:a1d303585e85156afba2c58aafab309a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40f91951dc0cffa782856434f3d98e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ab40f91951dc0cffa782856434f3d98e3">insert</a> (<a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:ab40f91951dc0cffa782856434f3d98e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__multiset.html#ab40f91951dc0cffa782856434f3d98e3">More...</a><br /></td></tr>
<tr class="separator:ab40f91951dc0cffa782856434f3d98e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae026ff05db15ce89a04df42942a73505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ae026ff05db15ce89a04df42942a73505">insert</a> (<a class="el" href="classseq_1_1flat__multiset.html#a2ec78ce95ab35003a8e76ca861f03859">const_iterator</a> hint, const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;value) -&gt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a></td></tr>
<tr class="memdesc:ae026ff05db15ce89a04df42942a73505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__multiset.html#ae026ff05db15ce89a04df42942a73505">More...</a><br /></td></tr>
<tr class="separator:ae026ff05db15ce89a04df42942a73505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71768fa11e840ccf87e601102e4355ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a71768fa11e840ccf87e601102e4355ce">insert</a> (<a class="el" href="classseq_1_1flat__multiset.html#a2ec78ce95ab35003a8e76ca861f03859">const_iterator</a> hint, <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a></td></tr>
<tr class="memdesc:a71768fa11e840ccf87e601102e4355ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__multiset.html#a71768fa11e840ccf87e601102e4355ce">More...</a><br /></td></tr>
<tr class="separator:a71768fa11e840ccf87e601102e4355ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370336c5106645ee45fec8a2a26eadc4"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a370336c5106645ee45fec8a2a26eadc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#a370336c5106645ee45fec8a2a26eadc4">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a370336c5106645ee45fec8a2a26eadc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std_deque like container implemented as a tiered-vector.">tiered_vector</a>, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one.  <a href="classseq_1_1flat__multiset.html#a370336c5106645ee45fec8a2a26eadc4">More...</a><br /></td></tr>
<tr class="separator:a370336c5106645ee45fec8a2a26eadc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace98a525dfd46ea113f9f151c63f2411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__multiset.html#ace98a525dfd46ea113f9f151c63f2411">insert</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ace98a525dfd46ea113f9f151c63f2411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__multiset.html#ace98a525dfd46ea113f9f151c63f2411">More...</a><br /></td></tr>
<tr class="separator:ace98a525dfd46ea113f9f151c63f2411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classseq_1_1flat__set"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classseq_1_1flat__set')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classseq_1_1flat__set.html">seq::flat_set&lt; Key, std::less&lt; Key &gt;, std::allocator&lt; Key &gt;, OptimizeForMemory, false, false &gt;</a></td></tr>
<tr class="memitem:af28779bd30528cfb05dbdd6738a5e230 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af28779bd30528cfb05dbdd6738a5e230">flat_set</a> ()</td></tr>
<tr class="memdesc:af28779bd30528cfb05dbdd6738a5e230 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classseq_1_1flat__set.html#af28779bd30528cfb05dbdd6738a5e230">More...</a><br /></td></tr>
<tr class="separator:af28779bd30528cfb05dbdd6738a5e230 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43495f719ac2a6337b70580292767eab inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a43495f719ac2a6337b70580292767eab">flat_set</a> (const std::less&lt; Key &gt; &amp;comp, const std::allocator&lt; Key &gt; &amp;alloc=std::allocator&lt; Key &gt;())</td></tr>
<tr class="memdesc:a43495f719ac2a6337b70580292767eab inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from comparator function and optional allocator object.  <a href="classseq_1_1flat__set.html#a43495f719ac2a6337b70580292767eab">More...</a><br /></td></tr>
<tr class="separator:a43495f719ac2a6337b70580292767eab inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ca0e8e62ba5e2400f60678eb8e038f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a96ca0e8e62ba5e2400f60678eb8e038f">flat_set</a> (const std::allocator&lt; Key &gt; &amp;alloc)</td></tr>
<tr class="memdesc:a96ca0e8e62ba5e2400f60678eb8e038f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from allocator object.  <a href="classseq_1_1flat__set.html#a96ca0e8e62ba5e2400f60678eb8e038f">More...</a><br /></td></tr>
<tr class="separator:a96ca0e8e62ba5e2400f60678eb8e038f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e6b15d9f9e06b35f91e61f35f73862 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab3e6b15d9f9e06b35f91e61f35f73862">flat_set</a> (InputIt first, InputIt last, const std::less&lt; Key &gt; &amp;comp=std::less&lt; Key &gt;(), const std::allocator&lt; Key &gt; &amp;alloc=std::allocator&lt; Key &gt;())</td></tr>
<tr class="memdesc:ab3e6b15d9f9e06b35f91e61f35f73862 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#ab3e6b15d9f9e06b35f91e61f35f73862">More...</a><br /></td></tr>
<tr class="separator:ab3e6b15d9f9e06b35f91e61f35f73862 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37d39789987ad2558c9c44ed3d0785 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a5e37d39789987ad2558c9c44ed3d0785">flat_set</a> (InputIt first, InputIt last, const std::allocator&lt; Key &gt; &amp;alloc)</td></tr>
<tr class="memdesc:a5e37d39789987ad2558c9c44ed3d0785 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#a5e37d39789987ad2558c9c44ed3d0785">More...</a><br /></td></tr>
<tr class="separator:a5e37d39789987ad2558c9c44ed3d0785 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ba984f81b0db26a01612988d610318 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a55ba984f81b0db26a01612988d610318">flat_set</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other)</td></tr>
<tr class="memdesc:a55ba984f81b0db26a01612988d610318 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1flat__set.html#a55ba984f81b0db26a01612988d610318">More...</a><br /></td></tr>
<tr class="separator:a55ba984f81b0db26a01612988d610318 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebb1cbcd91fd9baf92dd692511796b0 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6ebb1cbcd91fd9baf92dd692511796b0">flat_set</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other, const std::allocator&lt; Key &gt; &amp;alloc)</td></tr>
<tr class="memdesc:a6ebb1cbcd91fd9baf92dd692511796b0 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1flat__set.html#a6ebb1cbcd91fd9baf92dd692511796b0">More...</a><br /></td></tr>
<tr class="separator:a6ebb1cbcd91fd9baf92dd692511796b0 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5ef5410087dbbfac294b6c3863838f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0a5ef5410087dbbfac294b6c3863838f">flat_set</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a0a5ef5410087dbbfac294b6c3863838f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="classseq_1_1flat__set.html#a0a5ef5410087dbbfac294b6c3863838f">More...</a><br /></td></tr>
<tr class="separator:a0a5ef5410087dbbfac294b6c3863838f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c9734ff27566340dd880f205c51a83 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a99c9734ff27566340dd880f205c51a83">flat_set</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other, const std::allocator&lt; Key &gt; &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a99c9734ff27566340dd880f205c51a83 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="classseq_1_1flat__set.html#a99c9734ff27566340dd880f205c51a83">More...</a><br /></td></tr>
<tr class="separator:a99c9734ff27566340dd880f205c51a83 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834fe917b40b91a984b0b6e6a873fb77 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a834fe917b40b91a984b0b6e6a873fb77">flat_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &gt; init, const std::less&lt; Key &gt; &amp;comp=std::less&lt; Key &gt;(), const std::allocator&lt; Key &gt; &amp;alloc=std::allocator&lt; Key &gt;())</td></tr>
<tr class="memdesc:a834fe917b40b91a984b0b6e6a873fb77 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#a834fe917b40b91a984b0b6e6a873fb77">More...</a><br /></td></tr>
<tr class="separator:a834fe917b40b91a984b0b6e6a873fb77 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad129f6187e0badecbcf74e653813b751 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ad129f6187e0badecbcf74e653813b751">flat_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &gt; init, const std::allocator&lt; Key &gt; &amp;alloc)</td></tr>
<tr class="memdesc:ad129f6187e0badecbcf74e653813b751 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#ad129f6187e0badecbcf74e653813b751">More...</a><br /></td></tr>
<tr class="separator:ad129f6187e0badecbcf74e653813b751 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38730475abb8a0a31dcc8674ec8712a3 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a38730475abb8a0a31dcc8674ec8712a3">operator=</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;</td></tr>
<tr class="memdesc:a38730475abb8a0a31dcc8674ec8712a3 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classseq_1_1flat__set.html#a38730475abb8a0a31dcc8674ec8712a3">More...</a><br /></td></tr>
<tr class="separator:a38730475abb8a0a31dcc8674ec8712a3 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c5d9440fe54481bdd8db47a0c4256a inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a85c5d9440fe54481bdd8db47a0c4256a">operator=</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other) -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;</td></tr>
<tr class="memdesc:a85c5d9440fe54481bdd8db47a0c4256a inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator.  <a href="classseq_1_1flat__set.html#a85c5d9440fe54481bdd8db47a0c4256a">More...</a><br /></td></tr>
<tr class="separator:a85c5d9440fe54481bdd8db47a0c4256a inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad22c9c9dad8a9720aa3c1f6dee76430 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aad22c9c9dad8a9720aa3c1f6dee76430">operator=</a> (const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &gt; &amp;init) -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;</td></tr>
<tr class="memdesc:aad22c9c9dad8a9720aa3c1f6dee76430 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign initializer-list.  <a href="classseq_1_1flat__set.html#aad22c9c9dad8a9720aa3c1f6dee76430">More...</a><br /></td></tr>
<tr class="separator:aad22c9c9dad8a9720aa3c1f6dee76430 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050ce6bc5285419473b22f7aade304ae inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a050ce6bc5285419473b22f7aade304ae">get_allocator</a> () const noexcept -&gt; std::allocator&lt; Key &gt;</td></tr>
<tr class="memdesc:a050ce6bc5285419473b22f7aade304ae inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns container's allocator.  <a href="classseq_1_1flat__set.html#a050ce6bc5285419473b22f7aade304ae">More...</a><br /></td></tr>
<tr class="separator:a050ce6bc5285419473b22f7aade304ae inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2096ed6a791d86016655b8ea6806405 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab2096ed6a791d86016655b8ea6806405">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:ab2096ed6a791d86016655b8ea6806405 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if container is empty, false otherwise.  <a href="classseq_1_1flat__set.html#ab2096ed6a791d86016655b8ea6806405">More...</a><br /></td></tr>
<tr class="separator:ab2096ed6a791d86016655b8ea6806405 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad47840009cc56187911e7f2a47193d inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adad47840009cc56187911e7f2a47193d">size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a></td></tr>
<tr class="memdesc:adad47840009cc56187911e7f2a47193d inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size.  <a href="classseq_1_1flat__set.html#adad47840009cc56187911e7f2a47193d">More...</a><br /></td></tr>
<tr class="separator:adad47840009cc56187911e7f2a47193d inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85b0206e6306dc533f30c34dd55a065 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa85b0206e6306dc533f30c34dd55a065">max_size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a></td></tr>
<tr class="memdesc:aa85b0206e6306dc533f30c34dd55a065 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size.  <a href="classseq_1_1flat__set.html#aa85b0206e6306dc533f30c34dd55a065">More...</a><br /></td></tr>
<tr class="separator:aa85b0206e6306dc533f30c34dd55a065 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48d76f5df8ae9b333e7d947e7132505 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af48d76f5df8ae9b333e7d947e7132505">clear</a> () noexcept</td></tr>
<tr class="memdesc:af48d76f5df8ae9b333e7d947e7132505 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container.  <a href="classseq_1_1flat__set.html#af48d76f5df8ae9b333e7d947e7132505">More...</a><br /></td></tr>
<tr class="separator:af48d76f5df8ae9b333e7d947e7132505 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a8c0071d070fc5f1f4ceb03bb595e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a145a8c0071d070fc5f1f4ceb03bb595e">swap</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a145a8c0071d070fc5f1f4ceb03bb595e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this container's content with another. Iterators to both containers remain valid, including end iterators.  <a href="classseq_1_1flat__set.html#a145a8c0071d070fc5f1f4ceb03bb595e">More...</a><br /></td></tr>
<tr class="separator:a145a8c0071d070fc5f1f4ceb03bb595e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f600b3a19bfeb5bb3515a915f184f7 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a62f600b3a19bfeb5bb3515a915f184f7">tvector</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a1a99d74a2c1b1287883c1aa8f77b9d23">deque_type</a> &amp;</td></tr>
<tr class="memdesc:a62f600b3a19bfeb5bb3515a915f184f7 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying tiered_vector. Calling this function will mark the container as dirty. Any further attempts to call members like <a class="el" href="classseq_1_1flat__set.html#ab57074210e38022bdea1e1d34eaea124" title="Finds an element with key that compares equivalent to the value key. This overload participates in ov...">find()</a>, lower_bound, upper_bound... will raise a std::logic_error. To mark the container as non dirty anymore, the user must call flat_set::sort().  <a href="classseq_1_1flat__set.html#a62f600b3a19bfeb5bb3515a915f184f7">More...</a><br /></td></tr>
<tr class="separator:a62f600b3a19bfeb5bb3515a915f184f7 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71e0e9ba96e3cb66048659fa6af5dd2 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af71e0e9ba96e3cb66048659fa6af5dd2">tvector</a> () const noexcept -&gt; const <a class="el" href="classseq_1_1flat__set.html#a1a99d74a2c1b1287883c1aa8f77b9d23">deque_type</a> &amp;</td></tr>
<tr class="memdesc:af71e0e9ba96e3cb66048659fa6af5dd2 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the underlying tiered_vector. The container will NOT be marked as dirty.  <a href="classseq_1_1flat__set.html#af71e0e9ba96e3cb66048659fa6af5dd2">More...</a><br /></td></tr>
<tr class="separator:af71e0e9ba96e3cb66048659fa6af5dd2 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e69f59aea54f2796b97e73d8c9a387e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9e69f59aea54f2796b97e73d8c9a387e">cdeque</a> () const noexcept -&gt; const <a class="el" href="classseq_1_1flat__set.html#a1a99d74a2c1b1287883c1aa8f77b9d23">deque_type</a> &amp;</td></tr>
<tr class="memdesc:a9e69f59aea54f2796b97e73d8c9a387e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the underlying tiered_vector. The container will NOT be marked as dirty.  <a href="classseq_1_1flat__set.html#a9e69f59aea54f2796b97e73d8c9a387e">More...</a><br /></td></tr>
<tr class="separator:a9e69f59aea54f2796b97e73d8c9a387e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d303585e85156afba2c58aafab309a4 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1d303585e85156afba2c58aafab309a4">insert</a> (const <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a1d303585e85156afba2c58aafab309a4 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__set.html#a1d303585e85156afba2c58aafab309a4">More...</a><br /></td></tr>
<tr class="separator:a1d303585e85156afba2c58aafab309a4 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40f91951dc0cffa782856434f3d98e3 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab40f91951dc0cffa782856434f3d98e3">insert</a> (<a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:ab40f91951dc0cffa782856434f3d98e3 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1flat__set.html#ab40f91951dc0cffa782856434f3d98e3">More...</a><br /></td></tr>
<tr class="separator:ab40f91951dc0cffa782856434f3d98e3 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae026ff05db15ce89a04df42942a73505 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae026ff05db15ce89a04df42942a73505">insert</a> (const_iterator hint, const <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;value) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:ae026ff05db15ce89a04df42942a73505 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__set.html#ae026ff05db15ce89a04df42942a73505">More...</a><br /></td></tr>
<tr class="separator:ae026ff05db15ce89a04df42942a73505 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71768fa11e840ccf87e601102e4355ce inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a71768fa11e840ccf87e601102e4355ce">insert</a> (const_iterator hint, <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a71768fa11e840ccf87e601102e4355ce inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1flat__set.html#a71768fa11e840ccf87e601102e4355ce">More...</a><br /></td></tr>
<tr class="separator:a71768fa11e840ccf87e601102e4355ce inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370336c5106645ee45fec8a2a26eadc4 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a370336c5106645ee45fec8a2a26eadc4">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a370336c5106645ee45fec8a2a26eadc4 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying tiered_vector, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one.  <a href="classseq_1_1flat__set.html#a370336c5106645ee45fec8a2a26eadc4">More...</a><br /></td></tr>
<tr class="separator:a370336c5106645ee45fec8a2a26eadc4 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace98a525dfd46ea113f9f151c63f2411 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ace98a525dfd46ea113f9f151c63f2411">insert</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ace98a525dfd46ea113f9f151c63f2411 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1flat__set.html#ace98a525dfd46ea113f9f151c63f2411">More...</a><br /></td></tr>
<tr class="separator:ace98a525dfd46ea113f9f151c63f2411 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb5126c808ca716db9fd0e3d4e306b7 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#abcb5126c808ca716db9fd0e3d4e306b7">insert_pos</a> (const <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;value) -&gt; std::pair&lt; size_t, bool &gt;</td></tr>
<tr class="memdesc:abcb5126c808ca716db9fd0e3d4e306b7 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a1d303585e85156afba2c58aafab309a4" title="See std::set::insert.">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#adad47840009cc56187911e7f2a47193d" title="Returns the container size.">size()</a> if no element was inserted).  <a href="classseq_1_1flat__set.html#abcb5126c808ca716db9fd0e3d4e306b7">More...</a><br /></td></tr>
<tr class="separator:abcb5126c808ca716db9fd0e3d4e306b7 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a413bfa23fb123841f4c0b7c3e045cd inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9a413bfa23fb123841f4c0b7c3e045cd">insert_pos</a> (<a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; size_t, bool &gt;</td></tr>
<tr class="memdesc:a9a413bfa23fb123841f4c0b7c3e045cd inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a1d303585e85156afba2c58aafab309a4" title="See std::set::insert.">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#adad47840009cc56187911e7f2a47193d" title="Returns the container size.">size()</a> if no element was inserted).  <a href="classseq_1_1flat__set.html#a9a413bfa23fb123841f4c0b7c3e045cd">More...</a><br /></td></tr>
<tr class="separator:a9a413bfa23fb123841f4c0b7c3e045cd inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7400d10c6be9c84e4302950a039a48 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a7e7400d10c6be9c84e4302950a039a48">emplace</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a7e7400d10c6be9c84e4302950a039a48 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::emplace().  <a href="classseq_1_1flat__set.html#a7e7400d10c6be9c84e4302950a039a48">More...</a><br /></td></tr>
<tr class="separator:a7e7400d10c6be9c84e4302950a039a48 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6758b8d25da755df20ab3f5cfa56bc30 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6758b8d25da755df20ab3f5cfa56bc30">emplace_pos</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; size_t, bool &gt;</td></tr>
<tr class="memdesc:a6758b8d25da755df20ab3f5cfa56bc30 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a7e7400d10c6be9c84e4302950a039a48" title="See std::set::emplace().">emplace()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#adad47840009cc56187911e7f2a47193d" title="Returns the container size.">size()</a> if no element was inserted).  <a href="classseq_1_1flat__set.html#a6758b8d25da755df20ab3f5cfa56bc30">More...</a><br /></td></tr>
<tr class="separator:a6758b8d25da755df20ab3f5cfa56bc30 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d3bc87ac76060a64df3cff86de25c1 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a58d3bc87ac76060a64df3cff86de25c1">emplace_hint</a> (const_iterator hint, Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a58d3bc87ac76060a64df3cff86de25c1 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::emplace_hint.  <a href="classseq_1_1flat__set.html#a58d3bc87ac76060a64df3cff86de25c1">More...</a><br /></td></tr>
<tr class="separator:a58d3bc87ac76060a64df3cff86de25c1 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51062a09feb26117423c5e2637cdd91 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae51062a09feb26117423c5e2637cdd91">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:ae51062a09feb26117423c5e2637cdd91 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the content of the range [first, last) to this container, discarding previous values.  <a href="classseq_1_1flat__set.html#ae51062a09feb26117423c5e2637cdd91">More...</a><br /></td></tr>
<tr class="separator:ae51062a09feb26117423c5e2637cdd91 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa211185e183f54d722afea2e38769f6b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa211185e183f54d722afea2e38769f6b">erase_pos</a> (<a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a> <a class="el" href="classseq_1_1flat__set.html#a0c36b1aaec8f9d12343152213a4789ad">pos</a>)</td></tr>
<tr class="memdesc:aa211185e183f54d722afea2e38769f6b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given position in the container. This is slightly faster than calling <a class="el" href="classseq_1_1flat__set.html#a5bb1e814df180dd44a0032b877e823df" title="Erase element at given location.">erase(iterator)</a>.  <a href="classseq_1_1flat__set.html#aa211185e183f54d722afea2e38769f6b">More...</a><br /></td></tr>
<tr class="separator:aa211185e183f54d722afea2e38769f6b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb1e814df180dd44a0032b877e823df inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a5bb1e814df180dd44a0032b877e823df">erase</a> (const_iterator <a class="el" href="classseq_1_1flat__set.html#a0c36b1aaec8f9d12343152213a4789ad">pos</a>) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a5bb1e814df180dd44a0032b877e823df inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given location.  <a href="classseq_1_1flat__set.html#a5bb1e814df180dd44a0032b877e823df">More...</a><br /></td></tr>
<tr class="separator:a5bb1e814df180dd44a0032b877e823df inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb8322374785d7c6dc51938a16e13ce inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9fb8322374785d7c6dc51938a16e13ce">erase</a> (const_iterator first, const_iterator last) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a9fb8322374785d7c6dc51938a16e13ce inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the range [first, last)  <a href="classseq_1_1flat__set.html#a9fb8322374785d7c6dc51938a16e13ce">More...</a><br /></td></tr>
<tr class="separator:a9fb8322374785d7c6dc51938a16e13ce inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5bf6cec1d8e7106f6c34a5cae2850e inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aaf5bf6cec1d8e7106f6c34a5cae2850e">erase</a> (size_t first, size_t last)</td></tr>
<tr class="memdesc:aaf5bf6cec1d8e7106f6c34a5cae2850e inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the range [first, last)  <a href="classseq_1_1flat__set.html#aaf5bf6cec1d8e7106f6c34a5cae2850e">More...</a><br /></td></tr>
<tr class="separator:aaf5bf6cec1d8e7106f6c34a5cae2850e inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b66ef1a67458556d4a8573cc2d7862 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a81b66ef1a67458556d4a8573cc2d7862">erase</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a></td></tr>
<tr class="memdesc:a81b66ef1a67458556d4a8573cc2d7862 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type, and neither iterator nor const_iterator is implicitly convertible from K. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a81b66ef1a67458556d4a8573cc2d7862">More...</a><br /></td></tr>
<tr class="separator:a81b66ef1a67458556d4a8573cc2d7862 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769ae39fe7a3aabb03bc9eba700081eb inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a769ae39fe7a3aabb03bc9eba700081eb">erase</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a></td></tr>
<tr class="memdesc:a769ae39fe7a3aabb03bc9eba700081eb inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="classseq_1_1flat__set.html#a769ae39fe7a3aabb03bc9eba700081eb">More...</a><br /></td></tr>
<tr class="separator:a769ae39fe7a3aabb03bc9eba700081eb inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57074210e38022bdea1e1d34eaea124 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab57074210e38022bdea1e1d34eaea124">find</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:ab57074210e38022bdea1e1d34eaea124 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#ab57074210e38022bdea1e1d34eaea124">More...</a><br /></td></tr>
<tr class="separator:ab57074210e38022bdea1e1d34eaea124 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edc18a9b502e44daf57d8343e249994 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9edc18a9b502e44daf57d8343e249994">find</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a9edc18a9b502e44daf57d8343e249994 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1flat__set.html#a9edc18a9b502e44daf57d8343e249994">More...</a><br /></td></tr>
<tr class="separator:a9edc18a9b502e44daf57d8343e249994 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c519766a4d8b7c1e16a91e9347fa6d6 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6c519766a4d8b7c1e16a91e9347fa6d6">find</a> (const K &amp;key) const -&gt; const_iterator</td></tr>
<tr class="memdesc:a6c519766a4d8b7c1e16a91e9347fa6d6 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a6c519766a4d8b7c1e16a91e9347fa6d6">More...</a><br /></td></tr>
<tr class="separator:a6c519766a4d8b7c1e16a91e9347fa6d6 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e1aeb2634304ff1c1bf26a0107d918 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae8e1aeb2634304ff1c1bf26a0107d918">find</a> (const Key &amp;x) const -&gt; const_iterator</td></tr>
<tr class="memdesc:ae8e1aeb2634304ff1c1bf26a0107d918 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1flat__set.html#ae8e1aeb2634304ff1c1bf26a0107d918">More...</a><br /></td></tr>
<tr class="separator:ae8e1aeb2634304ff1c1bf26a0107d918 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9949c1ca56b3124db9bffd2581bdbce inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab9949c1ca56b3124db9bffd2581bdbce">find_pos</a> (const K &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:ab9949c1ca56b3124db9bffd2581bdbce inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#ab9949c1ca56b3124db9bffd2581bdbce">More...</a><br /></td></tr>
<tr class="separator:ab9949c1ca56b3124db9bffd2581bdbce inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b92a2a8e8a39936d16846c2f12dcf8 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae3b92a2a8e8a39936d16846c2f12dcf8">find_pos</a> (const Key &amp;x) const -&gt; size_t</td></tr>
<tr class="memdesc:ae3b92a2a8e8a39936d16846c2f12dcf8 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1flat__set.html#ae3b92a2a8e8a39936d16846c2f12dcf8">More...</a><br /></td></tr>
<tr class="separator:ae3b92a2a8e8a39936d16846c2f12dcf8 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c36b1aaec8f9d12343152213a4789ad inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0c36b1aaec8f9d12343152213a4789ad">pos</a> (size_t i) const noexcept -&gt; const <a class="el" href="classseq_1_1flat__set.html#a423dfd403dcf1078aa0400ceb34aca10">value_type</a> &amp;</td></tr>
<tr class="memdesc:a0c36b1aaec8f9d12343152213a4789ad inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value at given flat position.  <a href="classseq_1_1flat__set.html#a0c36b1aaec8f9d12343152213a4789ad">More...</a><br /></td></tr>
<tr class="separator:a0c36b1aaec8f9d12343152213a4789ad inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a4bd7956b3d665fabb283c7ac92457 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a05a4bd7956b3d665fabb283c7ac92457">lower_bound</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a05a4bd7956b3d665fabb283c7ac92457 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a05a4bd7956b3d665fabb283c7ac92457">More...</a><br /></td></tr>
<tr class="separator:a05a4bd7956b3d665fabb283c7ac92457 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629a2e5125b9141860aed25f26ea9a53 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a629a2e5125b9141860aed25f26ea9a53">lower_bound</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a629a2e5125b9141860aed25f26ea9a53 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="classseq_1_1flat__set.html#a629a2e5125b9141860aed25f26ea9a53">More...</a><br /></td></tr>
<tr class="separator:a629a2e5125b9141860aed25f26ea9a53 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ac90f96ae7a84fba51fbe80fec29b8 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af8ac90f96ae7a84fba51fbe80fec29b8">lower_bound</a> (const K &amp;key) const -&gt; const_iterator</td></tr>
<tr class="memdesc:af8ac90f96ae7a84fba51fbe80fec29b8 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#af8ac90f96ae7a84fba51fbe80fec29b8">More...</a><br /></td></tr>
<tr class="separator:af8ac90f96ae7a84fba51fbe80fec29b8 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b604bc495608e02a17696fed13493d inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a23b604bc495608e02a17696fed13493d">lower_bound</a> (const Key &amp;key) const -&gt; const_iterator</td></tr>
<tr class="memdesc:a23b604bc495608e02a17696fed13493d inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="classseq_1_1flat__set.html#a23b604bc495608e02a17696fed13493d">More...</a><br /></td></tr>
<tr class="separator:a23b604bc495608e02a17696fed13493d inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaab3b186746f31c608223d263a337d3 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#abaab3b186746f31c608223d263a337d3">lower_bound_pos</a> (const K &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:abaab3b186746f31c608223d263a337d3 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#abaab3b186746f31c608223d263a337d3">More...</a><br /></td></tr>
<tr class="separator:abaab3b186746f31c608223d263a337d3 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6077925167e63133dccb4590e93d2df inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af6077925167e63133dccb4590e93d2df">lower_bound_pos</a> (const Key &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:af6077925167e63133dccb4590e93d2df inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that is not less than (i.e. greater or equal to) key.  <a href="classseq_1_1flat__set.html#af6077925167e63133dccb4590e93d2df">More...</a><br /></td></tr>
<tr class="separator:af6077925167e63133dccb4590e93d2df inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cedd5671e9b0111d8b443727401c6c3 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a7cedd5671e9b0111d8b443727401c6c3">upper_bound</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a7cedd5671e9b0111d8b443727401c6c3 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a7cedd5671e9b0111d8b443727401c6c3">More...</a><br /></td></tr>
<tr class="separator:a7cedd5671e9b0111d8b443727401c6c3 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bee27bd128f6aefc76bd804a083aa55 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2bee27bd128f6aefc76bd804a083aa55">upper_bound</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a2bee27bd128f6aefc76bd804a083aa55 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classseq_1_1flat__set.html#a2bee27bd128f6aefc76bd804a083aa55">More...</a><br /></td></tr>
<tr class="separator:a2bee27bd128f6aefc76bd804a083aa55 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41bad49d5d46802758f61ec0e1b74ae inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac41bad49d5d46802758f61ec0e1b74ae">upper_bound</a> (const K &amp;key) const -&gt; const_iterator</td></tr>
<tr class="memdesc:ac41bad49d5d46802758f61ec0e1b74ae inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#ac41bad49d5d46802758f61ec0e1b74ae">More...</a><br /></td></tr>
<tr class="separator:ac41bad49d5d46802758f61ec0e1b74ae inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a85ecad5fd863135883a958f5e02f52 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a8a85ecad5fd863135883a958f5e02f52">upper_bound</a> (const Key &amp;key) const -&gt; const_iterator</td></tr>
<tr class="memdesc:a8a85ecad5fd863135883a958f5e02f52 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classseq_1_1flat__set.html#a8a85ecad5fd863135883a958f5e02f52">More...</a><br /></td></tr>
<tr class="separator:a8a85ecad5fd863135883a958f5e02f52 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157af0b66ff9eb5a8892a052b5437039 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a157af0b66ff9eb5a8892a052b5437039">upper_bound_pos</a> (const K &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a157af0b66ff9eb5a8892a052b5437039 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a157af0b66ff9eb5a8892a052b5437039">More...</a><br /></td></tr>
<tr class="separator:a157af0b66ff9eb5a8892a052b5437039 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9032ec73505dff2edef68f48b8867e5c inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9032ec73505dff2edef68f48b8867e5c">upper_bound_pos</a> (const Key &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a9032ec73505dff2edef68f48b8867e5c inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that is greater than key.  <a href="classseq_1_1flat__set.html#a9032ec73505dff2edef68f48b8867e5c">More...</a><br /></td></tr>
<tr class="separator:a9032ec73505dff2edef68f48b8867e5c inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f918ac2c34f0fc4ad9bad3cd6ea8020 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9f918ac2c34f0fc4ad9bad3cd6ea8020">contains</a> (const K &amp;key) const -&gt; bool</td></tr>
<tr class="memdesc:a9f918ac2c34f0fc4ad9bad3cd6ea8020 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#a9f918ac2c34f0fc4ad9bad3cd6ea8020">More...</a><br /></td></tr>
<tr class="separator:a9f918ac2c34f0fc4ad9bad3cd6ea8020 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322fde5fca97a0c3da93f391d2809d11 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a322fde5fca97a0c3da93f391d2809d11">contains</a> (const Key &amp;key) const -&gt; bool</td></tr>
<tr class="memdesc:a322fde5fca97a0c3da93f391d2809d11 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key equivalent to key in the container.  <a href="classseq_1_1flat__set.html#a322fde5fca97a0c3da93f391d2809d11">More...</a><br /></td></tr>
<tr class="separator:a322fde5fca97a0c3da93f391d2809d11 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5760dc699ac86f0faf0900ab6d1cc1 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aed5760dc699ac86f0faf0900ab6d1cc1">count</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a></td></tr>
<tr class="memdesc:aed5760dc699ac86f0faf0900ab6d1cc1 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key key (either 1 or 0 for flat_set and flat_map). This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="classseq_1_1flat__set.html#aed5760dc699ac86f0faf0900ab6d1cc1">More...</a><br /></td></tr>
<tr class="separator:aed5760dc699ac86f0faf0900ab6d1cc1 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0108b61136b039802e0a5d630b528ba7 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0108b61136b039802e0a5d630b528ba7">count</a> (const Key &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a4c2f707cf8f7944eda425023d33003e7">size_type</a></td></tr>
<tr class="memdesc:a0108b61136b039802e0a5d630b528ba7 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key key (either 1 or 0 for flat_set and flat_map).  <a href="classseq_1_1flat__set.html#a0108b61136b039802e0a5d630b528ba7">More...</a><br /></td></tr>
<tr class="separator:a0108b61136b039802e0a5d630b528ba7 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335c56f73beb14db8a2533352f53ad9d inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a335c56f73beb14db8a2533352f53ad9d">equal_range</a> (const K &amp;key) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a> &gt;</td></tr>
<tr class="memdesc:a335c56f73beb14db8a2533352f53ad9d inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a05a4bd7956b3d665fabb283c7ac92457" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7cedd5671e9b0111d8b443727401c6c3" title="Returns an iterator pointing to the first element that compares greater to the value key....">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#a335c56f73beb14db8a2533352f53ad9d">More...</a><br /></td></tr>
<tr class="separator:a335c56f73beb14db8a2533352f53ad9d inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf33465b2705df1b6b8063bd89822610 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#abf33465b2705df1b6b8063bd89822610">equal_range</a> (const Key &amp;key) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a> &gt;</td></tr>
<tr class="memdesc:abf33465b2705df1b6b8063bd89822610 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a05a4bd7956b3d665fabb283c7ac92457" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7cedd5671e9b0111d8b443727401c6c3" title="Returns an iterator pointing to the first element that compares greater to the value key....">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#abf33465b2705df1b6b8063bd89822610">More...</a><br /></td></tr>
<tr class="separator:abf33465b2705df1b6b8063bd89822610 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e81e0e8b7082f46c5dd53a189ed6a04 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1e81e0e8b7082f46c5dd53a189ed6a04">equal_range</a> (const K &amp;key) const -&gt; std::pair&lt; const_iterator, const_iterator &gt;</td></tr>
<tr class="memdesc:a1e81e0e8b7082f46c5dd53a189ed6a04 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a05a4bd7956b3d665fabb283c7ac92457" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7cedd5671e9b0111d8b443727401c6c3" title="Returns an iterator pointing to the first element that compares greater to the value key....">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#a1e81e0e8b7082f46c5dd53a189ed6a04">More...</a><br /></td></tr>
<tr class="separator:a1e81e0e8b7082f46c5dd53a189ed6a04 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1873a004bfa957a6454704e2f8ab91cc inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1873a004bfa957a6454704e2f8ab91cc">equal_range</a> (const Key &amp;key) const -&gt; std::pair&lt; const_iterator, const_iterator &gt;</td></tr>
<tr class="memdesc:a1873a004bfa957a6454704e2f8ab91cc inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a05a4bd7956b3d665fabb283c7ac92457" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7cedd5671e9b0111d8b443727401c6c3" title="Returns an iterator pointing to the first element that compares greater to the value key....">upper_bound()</a>.  <a href="classseq_1_1flat__set.html#a1873a004bfa957a6454704e2f8ab91cc">More...</a><br /></td></tr>
<tr class="separator:a1873a004bfa957a6454704e2f8ab91cc inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a4cceb7d0c71e85df8f532ba8eaf6f inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a43a4cceb7d0c71e85df8f532ba8eaf6f">equal_range_pos</a> (const K &amp;key) const -&gt; std::pair&lt; size_t, size_t &gt;</td></tr>
<tr class="memdesc:a43a4cceb7d0c71e85df8f532ba8eaf6f inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#abaab3b186746f31c608223d263a337d3" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a157af0b66ff9eb5a8892a052b5437039" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>.  <a href="classseq_1_1flat__set.html#a43a4cceb7d0c71e85df8f532ba8eaf6f">More...</a><br /></td></tr>
<tr class="separator:a43a4cceb7d0c71e85df8f532ba8eaf6f inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc1702bfbf2b5fb80fde4a68c604564 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a3dc1702bfbf2b5fb80fde4a68c604564">equal_range_pos</a> (const Key &amp;key) const -&gt; std::pair&lt; size_t, size_t &gt;</td></tr>
<tr class="memdesc:a3dc1702bfbf2b5fb80fde4a68c604564 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#abaab3b186746f31c608223d263a337d3" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a157af0b66ff9eb5a8892a052b5437039" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>.  <a href="classseq_1_1flat__set.html#a3dc1702bfbf2b5fb80fde4a68c604564">More...</a><br /></td></tr>
<tr class="separator:a3dc1702bfbf2b5fb80fde4a68c604564 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53ba988a2774436198f857105de9969 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ad53ba988a2774436198f857105de9969">merge</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, C2, std::allocator&lt; Key &gt;, layout2 &gt; &amp;source)</td></tr>
<tr class="memdesc:ad53ba988a2774436198f857105de9969 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract each element in source and insert it into this using the comparison object of this. If there is an element in this with key equivalent to the key of an element from source, then that element is not extracted from source. Note that elements from source are moved to this.  <a href="classseq_1_1flat__set.html#ad53ba988a2774436198f857105de9969">More...</a><br /></td></tr>
<tr class="separator:ad53ba988a2774436198f857105de9969 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0ae68bbfdd65d872ced19448211dc6 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2e0ae68bbfdd65d872ced19448211dc6">begin</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a2e0ae68bbfdd65d872ced19448211dc6 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1flat__set.html#a2e0ae68bbfdd65d872ced19448211dc6">More...</a><br /></td></tr>
<tr class="separator:a2e0ae68bbfdd65d872ced19448211dc6 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fce030fb400220bed09cc61e5481660 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6fce030fb400220bed09cc61e5481660">begin</a> () const noexcept -&gt; const_iterator</td></tr>
<tr class="memdesc:a6fce030fb400220bed09cc61e5481660 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1flat__set.html#a6fce030fb400220bed09cc61e5481660">More...</a><br /></td></tr>
<tr class="separator:a6fce030fb400220bed09cc61e5481660 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31bc4f93192298eae80d450128f19fe inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa31bc4f93192298eae80d450128f19fe">cbegin</a> () const noexcept -&gt; const_iterator</td></tr>
<tr class="memdesc:aa31bc4f93192298eae80d450128f19fe inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1flat__set.html#aa31bc4f93192298eae80d450128f19fe">More...</a><br /></td></tr>
<tr class="separator:aa31bc4f93192298eae80d450128f19fe inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c05caf75cab36a9867f327b36a0e1a inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a24c05caf75cab36a9867f327b36a0e1a">end</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">iterator</a></td></tr>
<tr class="memdesc:a24c05caf75cab36a9867f327b36a0e1a inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1flat__set.html#a24c05caf75cab36a9867f327b36a0e1a">More...</a><br /></td></tr>
<tr class="separator:a24c05caf75cab36a9867f327b36a0e1a inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac3bfe3b3689202b76363abab0c2b22 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6ac3bfe3b3689202b76363abab0c2b22">end</a> () const noexcept -&gt; const_iterator</td></tr>
<tr class="memdesc:a6ac3bfe3b3689202b76363abab0c2b22 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1flat__set.html#a6ac3bfe3b3689202b76363abab0c2b22">More...</a><br /></td></tr>
<tr class="separator:a6ac3bfe3b3689202b76363abab0c2b22 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a2f7b8e1111e564d7a697fcc636ae4 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a45a2f7b8e1111e564d7a697fcc636ae4">cend</a> () const noexcept -&gt; const_iterator</td></tr>
<tr class="memdesc:a45a2f7b8e1111e564d7a697fcc636ae4 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1flat__set.html#a45a2f7b8e1111e564d7a697fcc636ae4">More...</a><br /></td></tr>
<tr class="separator:a45a2f7b8e1111e564d7a697fcc636ae4 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f8f14f5d3939b85d73bfd33ff18b6b inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a08f8f14f5d3939b85d73bfd33ff18b6b">rbegin</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">reverse_iterator</a></td></tr>
<tr class="memdesc:a08f8f14f5d3939b85d73bfd33ff18b6b inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1flat__set.html#a08f8f14f5d3939b85d73bfd33ff18b6b">More...</a><br /></td></tr>
<tr class="separator:a08f8f14f5d3939b85d73bfd33ff18b6b inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca9925da3e6ac9e5892a29dc9ac49b2 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6ca9925da3e6ac9e5892a29dc9ac49b2">rbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a6ca9925da3e6ac9e5892a29dc9ac49b2 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1flat__set.html#a6ca9925da3e6ac9e5892a29dc9ac49b2">More...</a><br /></td></tr>
<tr class="separator:a6ca9925da3e6ac9e5892a29dc9ac49b2 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888df9ed8978abe58fd4d244177caf91 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a888df9ed8978abe58fd4d244177caf91">crbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a888df9ed8978abe58fd4d244177caf91 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1flat__set.html#a888df9ed8978abe58fd4d244177caf91">More...</a><br /></td></tr>
<tr class="separator:a888df9ed8978abe58fd4d244177caf91 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05da8c9d8495c529c8487b3f4a8cc724 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a05da8c9d8495c529c8487b3f4a8cc724">rend</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">reverse_iterator</a></td></tr>
<tr class="memdesc:a05da8c9d8495c529c8487b3f4a8cc724 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1flat__set.html#a05da8c9d8495c529c8487b3f4a8cc724">More...</a><br /></td></tr>
<tr class="separator:a05da8c9d8495c529c8487b3f4a8cc724 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e186cc2c502d5dfd123e6ca38cdf6c5 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a3e186cc2c502d5dfd123e6ca38cdf6c5">rend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a3e186cc2c502d5dfd123e6ca38cdf6c5 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1flat__set.html#a3e186cc2c502d5dfd123e6ca38cdf6c5">More...</a><br /></td></tr>
<tr class="separator:a3e186cc2c502d5dfd123e6ca38cdf6c5 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9923cc9ecdcc5c25c96dd5508b72c7 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2a9923cc9ecdcc5c25c96dd5508b72c7">crend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a2a9923cc9ecdcc5c25c96dd5508b72c7 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1flat__set.html#a2a9923cc9ecdcc5c25c96dd5508b72c7">More...</a><br /></td></tr>
<tr class="separator:a2a9923cc9ecdcc5c25c96dd5508b72c7 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8c0e7201020733f0240a4d0036148a inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aab8c0e7201020733f0240a4d0036148a">key_comp</a> () const -&gt; <a class="el" href="classseq_1_1flat__set.html#a0a1d4b80fd721e98fd252d5f2dbc674d">key_compare</a></td></tr>
<tr class="memdesc:aab8c0e7201020733f0240a4d0036148a inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the comparison object.  <a href="classseq_1_1flat__set.html#aab8c0e7201020733f0240a4d0036148a">More...</a><br /></td></tr>
<tr class="separator:aab8c0e7201020733f0240a4d0036148a inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2aa28ae90743b550fd6543126d6138 inherit pub_methods_classseq_1_1flat__set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aed2aa28ae90743b550fd6543126d6138">sort</a> ()</td></tr>
<tr class="memdesc:aed2aa28ae90743b550fd6543126d6138 inherit pub_methods_classseq_1_1flat__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container. This function sort again the container only if:  <a href="classseq_1_1flat__set.html#aed2aa28ae90743b550fd6543126d6138">More...</a><br /></td></tr>
<tr class="separator:aed2aa28ae90743b550fd6543126d6138 inherit pub_methods_classseq_1_1flat__set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt;<br />
class seq::flat_multiset&lt; Key, Compare, Allocator, layout, Stable &gt;</h3>

<p>flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>key type </td></tr>
    <tr><td class="paramname">Compare</td><td>comparison function </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator </td></tr>
    <tr><td class="paramname">layout</td><td>memory layout of the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std_deque like container implemented as a tiered-vector.">seq::tiered_vector</a> </td></tr>
    <tr><td class="paramname">Stable</td><td>insertion order stability</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1flat__multiset.html" title="flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values">seq::flat_multiset</a> is a sorted associative container similar to <a href="https://www.boost.org/doc/libs/1_64_0/doc/html/boost/container/flat_multiset.html">boost::flat_multiset</a>, but relying on a <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std_deque like container implemented as a tiered-vector.">seq::tiered_vector</a> instead of a flat array. It supports multiple equal keys.</p>
<p><a class="el" href="classseq_1_1flat__multiset.html" title="flat sorted container similar to boost::flat_multiset with faster insertion/deletion of single values">seq::flat_multiset</a> directly inherits <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values">seq::flat_set</a> and behaves similarly, except for the support of multiple equal keys. Its interface is similar to std::multiset, except for the node based members.</p>
<p>All references and iterators are invalidated when inserting/removing keys. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9abd81cccf7490e9ead18b447ae4c473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abd81cccf7490e9ead18b447ae4c473">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a9abd81cccf7490e9ead18b447ae4c473">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ec78ce95ab35003a8e76ca861f03859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec78ce95ab35003a8e76ca861f03859">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a2ec78ce95ab35003a8e76ca861f03859">const_iterator</a> =  typename <a class="el" href="structseq_1_1flat__set_1_1const__iterator.html">base_type::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2335cb7eff2b949c387aaca474b8046a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2335cb7eff2b949c387aaca474b8046a">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a2335cb7eff2b949c387aaca474b8046a">const_pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#a2335cb7eff2b949c387aaca474b8046a">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58f75594ce52484b1d41b7f94db41218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f75594ce52484b1d41b7f94db41218">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a58f75594ce52484b1d41b7f94db41218">const_reference</a> =  const Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a892d2e8da8ef3eb9dfbf63911fd73e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892d2e8da8ef3eb9dfbf63911fd73e5f">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a892d2e8da8ef3eb9dfbf63911fd73e5f">const_reverse_iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#a59f0b73c32e563991fa077115d501c69">base_type::const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fc8ba21e60beee2752e6a3c202602eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc8ba21e60beee2752e6a3c202602eb">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a6fc8ba21e60beee2752e6a3c202602eb">difference_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#a6fc8ba21e60beee2752e6a3c202602eb">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf7abcd8c332f777c1ec9ad0b4c432f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7abcd8c332f777c1ec9ad0b4c432f6">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#a1b64c5f701a2ab7921e34ce3d5b5d1a6">base_type::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1a1ac7d77c88e7bbd22ff3f8849e923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a1ac7d77c88e7bbd22ff3f8849e923">&#9670;&nbsp;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#ae1a1ac7d77c88e7bbd22ff3f8849e923">key_compare</a> =  Compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8d0c0eca9a5079957fe5f7fda9f5967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d0c0eca9a5079957fe5f7fda9f5967">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#ac8d0c0eca9a5079957fe5f7fda9f5967">key_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5e5b4fdbf23fb6a5544aaf4a3f481fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#aa5e5b4fdbf23fb6a5544aaf4a3f481fc">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb12309bb26912ed6f2216177e0de406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb12309bb26912ed6f2216177e0de406">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#acb12309bb26912ed6f2216177e0de406">reference</a> =  Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bf04f204152e12fbb7bea08b639cca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf04f204152e12fbb7bea08b639cca3">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#a9bf04f204152e12fbb7bea08b639cca3">reverse_iterator</a> =  typename <a class="el" href="classseq_1_1flat__set.html#aa005e31dc3f4c6de57c78c08579c0350">base_type::reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1151b2ccc5b0068c3a66ddb390691c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1151b2ccc5b0068c3a66ddb390691c7">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#af1151b2ccc5b0068c3a66ddb390691c7">size_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__multiset.html#af1151b2ccc5b0068c3a66ddb390691c7">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac9f8264e3e53764cfae47bd03a18d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9f8264e3e53764cfae47bd03a18d8d">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a837ce53e1ed9c749770df9e1ec3541dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837ce53e1ed9c749770df9e1ec3541dc">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a231f0bcbfcb21972e4cdf089ddf5fb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231f0bcbfcb21972e4cdf089ddf5fb77">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a995f51fc40e3429596a29f475ff106c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995f51fc40e3429596a29f475ff106c0">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6b2454113754b7bd8d3c922119ff41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b2454113754b7bd8d3c922119ff41f">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c3078805e2694e24a1107ecc9e3ace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3078805e2694e24a1107ecc9e3ace5">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8986285103b6b8b8ff113f5de551d3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8986285103b6b8b8ff113f5de551d3d3">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a983e596648725c407017bd6561fca0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983e596648725c407017bd6561fca0bd">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55cca6165cc057921692869414c37c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cca6165cc057921692869414c37c55">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19f16cb6d01d65d73acb6370e353b4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f16cb6d01d65d73acb6370e353b4e5">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a2dcc536430281e13477a9a08915020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2dcc536430281e13477a9a08915020">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44549f25eaaa5708d7328673e6ecebbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44549f25eaaa5708d7328673e6ecebbe">&#9670;&nbsp;</a></span>flat_multiset() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::<a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a587774cefd2d54988d8469a59477f69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587774cefd2d54988d8469a59477f69d">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37278b2eda6b919acfdd4d45592c5aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37278b2eda6b919acfdd4d45592c5aab">&#9670;&nbsp;</a></span>emplace_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::emplace_pos </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5d1ece82c6759cf9e8001e106a1e21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d1ece82c6759cf9e8001e106a1e21b">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d303585e85156afba2c58aafab309a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d303585e85156afba2c58aafab309a4">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::insert. </p>

</div>
</div>
<a id="ae026ff05db15ce89a04df42942a73505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae026ff05db15ce89a04df42942a73505">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::insert() </p>

</div>
</div>
<a id="a71768fa11e840ccf87e601102e4355ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71768fa11e840ccf87e601102e4355ce">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::insert() </p>

</div>
</div>
<a id="a370336c5106645ee45fec8a2a26eadc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370336c5106645ee45fec8a2a26eadc4">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">class InputIt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std_deque like container implemented as a tiered-vector.">tiered_vector</a>, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one. </p>

</div>
</div>
<a id="ace98a525dfd46ea113f9f151c63f2411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace98a525dfd46ea113f9f151c63f2411">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>

</div>
</div>
<a id="a90cb4a293aeffa890293828f3da3a0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cb4a293aeffa890293828f3da3a0bf">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html#abf7abcd8c332f777c1ec9ad0b4c432f6">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab40f91951dc0cffa782856434f3d98e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40f91951dc0cffa782856434f3d98e3">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, layout, Stable, Unique &gt;::insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::insert. </p>

</div>
</div>
<a id="a1b890a03c2f8d294d516263b880107f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b890a03c2f8d294d516263b880107f3">&#9670;&nbsp;</a></span>insert_pos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4aa885291fc3c4e61572e98eb035434a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa885291fc3c4e61572e98eb035434a">&#9670;&nbsp;</a></span>insert_pos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b6ced1312b3bcfe4b5467ba82c68c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6ced1312b3bcfe4b5467ba82c68c24">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0424f77ef1ea305834e4789fb6e77acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0424f77ef1ea305834e4789fb6e77acf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__multiset.html#aac9f8264e3e53764cfae47bd03a18d8d">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&amp;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7462b5c7a65e4e65662e87f5d35776a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7462b5c7a65e4e65662e87f5d35776a6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement layout = OptimizeForMemory, bool Stable = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1flat__multiset.html">seq::flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&lt; Key, Compare, Allocator, layout, Stable &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="flat__map_8hpp_source.html">flat_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1flat__multiset.html">flat_multiset</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
