<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::flat_set&lt; Key, Compare, Allocator, Stable, Unique &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classseq_1_1flat__set.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseq_1_1flat__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::flat_set&lt; Key, Compare, Allocator, Stable, Unique &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>flat sorted container similar to boost::flat_set with faster insertion/deletion of single values  
 <a href="classseq_1_1flat__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="flat__map_8hpp_source.html">flat_map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a21b0bac611ecd8732e6282084f533b9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a> = typename <a class="el" href="structseq_1_1detail_1_1flat__tree.html#af41da69c0cf605bd81accf294e4a96d6">flat_tree_type::deque_type</a></td></tr>
<tr class="separator:a21b0bac611ecd8732e6282084f533b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77879fbd7d9f8f9e59c1ff8b4d2ea144"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> = typename deque_type::const_iterator</td></tr>
<tr class="separator:a77879fbd7d9f8f9e59c1ff8b4d2ea144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999dddbf15eb6553aa7e91be08ce6222"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> = typename deque_type::const_iterator</td></tr>
<tr class="separator:a999dddbf15eb6553aa7e91be08ce6222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ad7f5537b59b28ec7fd2a4ab32df07"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">reverse_iterator</a> = typename deque_type::const_reverse_iterator</td></tr>
<tr class="separator:a25ad7f5537b59b28ec7fd2a4ab32df07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1957a91d7d434300b953843676c2ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a> = typename deque_type::const_reverse_iterator</td></tr>
<tr class="separator:aeb1957a91d7d434300b953843676c2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6e0b374be4defba15ff71873ceee01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aac6e0b374be4defba15ff71873ceee01">key_type</a> = Key</td></tr>
<tr class="separator:aac6e0b374be4defba15ff71873ceee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacbd6819f205822a6c898e5257dad95"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> = Key</td></tr>
<tr class="separator:aeacbd6819f205822a6c898e5257dad95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4f850cd1b727e52d9e3b5c5291afb0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1b4f850cd1b727e52d9e3b5c5291afb0">difference_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__set.html#a1b4f850cd1b727e52d9e3b5c5291afb0">difference_type</a></td></tr>
<tr class="separator:a1b4f850cd1b727e52d9e3b5c5291afb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f202fe21ed7de6f559b38740fe0b5a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="separator:a30f202fe21ed7de6f559b38740fe0b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6bb6b87f93185e1512bc25216b37df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#afa6bb6b87f93185e1512bc25216b37df">key_compare</a> = Compare</td></tr>
<tr class="separator:afa6bb6b87f93185e1512bc25216b37df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dd536447c118abbfa74b8551d49061"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a79dd536447c118abbfa74b8551d49061">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a79dd536447c118abbfa74b8551d49061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b80e04ba844d8e26f452ca4d3ceece"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a25b80e04ba844d8e26f452ca4d3ceece">reference</a> = Key &amp;</td></tr>
<tr class="separator:a25b80e04ba844d8e26f452ca4d3ceece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16c86bbdc8b0bca507d35927b7bb985"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac16c86bbdc8b0bca507d35927b7bb985">const_reference</a> = const Key &amp;</td></tr>
<tr class="separator:ac16c86bbdc8b0bca507d35927b7bb985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370d857cf97fed3323fbb5cc6977eee4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a370d857cf97fed3323fbb5cc6977eee4">pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__set.html#a370d857cf97fed3323fbb5cc6977eee4">pointer</a></td></tr>
<tr class="separator:a370d857cf97fed3323fbb5cc6977eee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dbf894f94d85541c14db4ab6eb3a65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab1dbf894f94d85541c14db4ab6eb3a65">const_pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1flat__set.html#ab1dbf894f94d85541c14db4ab6eb3a65">const_pointer</a></td></tr>
<tr class="separator:ab1dbf894f94d85541c14db4ab6eb3a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae603afa34949ebea033565d2d1d89cce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae603afa34949ebea033565d2d1d89cce">flat_set</a> ()</td></tr>
<tr class="memdesc:ae603afa34949ebea033565d2d1d89cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ae603afa34949ebea033565d2d1d89cce">More...</a><br /></td></tr>
<tr class="separator:ae603afa34949ebea033565d2d1d89cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e9bb2e33267ee0d9ad81100eedd7dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a72e9bb2e33267ee0d9ad81100eedd7dc">flat_set</a> (const Compare &amp;comp, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a72e9bb2e33267ee0d9ad81100eedd7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from comparator function and optional allocator object.  <a href="#a72e9bb2e33267ee0d9ad81100eedd7dc">More...</a><br /></td></tr>
<tr class="separator:a72e9bb2e33267ee0d9ad81100eedd7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797ec01f149442f508e8f915373071b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a797ec01f149442f508e8f915373071b6">flat_set</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a797ec01f149442f508e8f915373071b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from allocator object.  <a href="#a797ec01f149442f508e8f915373071b6">More...</a><br /></td></tr>
<tr class="separator:a797ec01f149442f508e8f915373071b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20afaa6733d1f49cfbbf7ea33bce1485"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a20afaa6733d1f49cfbbf7ea33bce1485"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a20afaa6733d1f49cfbbf7ea33bce1485">flat_set</a> (InputIt first, InputIt last, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a20afaa6733d1f49cfbbf7ea33bce1485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="#a20afaa6733d1f49cfbbf7ea33bce1485">More...</a><br /></td></tr>
<tr class="separator:a20afaa6733d1f49cfbbf7ea33bce1485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac553b49836b4069726a1e609ec6a538f"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ac553b49836b4069726a1e609ec6a538f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac553b49836b4069726a1e609ec6a538f">flat_set</a> (InputIt first, InputIt last, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:ac553b49836b4069726a1e609ec6a538f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="#ac553b49836b4069726a1e609ec6a538f">More...</a><br /></td></tr>
<tr class="separator:ac553b49836b4069726a1e609ec6a538f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af129b4ab9563a1029550a02049b7f171"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af129b4ab9563a1029550a02049b7f171">flat_set</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other)</td></tr>
<tr class="memdesc:af129b4ab9563a1029550a02049b7f171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#af129b4ab9563a1029550a02049b7f171">More...</a><br /></td></tr>
<tr class="separator:af129b4ab9563a1029550a02049b7f171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2369e182eed80289a53705d80ee826"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aca2369e182eed80289a53705d80ee826">flat_set</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:aca2369e182eed80289a53705d80ee826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aca2369e182eed80289a53705d80ee826">More...</a><br /></td></tr>
<tr class="separator:aca2369e182eed80289a53705d80ee826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b89e289a324ea94e64c1f4f489d2912"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6b89e289a324ea94e64c1f4f489d2912">flat_set</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a6b89e289a324ea94e64c1f4f489d2912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="#a6b89e289a324ea94e64c1f4f489d2912">More...</a><br /></td></tr>
<tr class="separator:a6b89e289a324ea94e64c1f4f489d2912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44961e5e4a80765f854d6279793e9303"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a44961e5e4a80765f854d6279793e9303">flat_set</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a44961e5e4a80765f854d6279793e9303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="#a44961e5e4a80765f854d6279793e9303">More...</a><br /></td></tr>
<tr class="separator:a44961e5e4a80765f854d6279793e9303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae238a65551109cfd46d305e6d7792156"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae238a65551109cfd46d305e6d7792156">flat_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt; init, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:ae238a65551109cfd46d305e6d7792156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="#ae238a65551109cfd46d305e6d7792156">More...</a><br /></td></tr>
<tr class="separator:ae238a65551109cfd46d305e6d7792156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070e001a5cad36bf9a068a91c2693544"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a070e001a5cad36bf9a068a91c2693544">flat_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt; init, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a070e001a5cad36bf9a068a91c2693544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="#a070e001a5cad36bf9a068a91c2693544">More...</a><br /></td></tr>
<tr class="separator:a070e001a5cad36bf9a068a91c2693544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9cc850f1e573e675f3d3245db82485"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1b9cc850f1e573e675f3d3245db82485">operator=</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;</td></tr>
<tr class="memdesc:a1b9cc850f1e573e675f3d3245db82485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a1b9cc850f1e573e675f3d3245db82485">More...</a><br /></td></tr>
<tr class="separator:a1b9cc850f1e573e675f3d3245db82485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4b686521bb9cc5d0507e917627fe68"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a4f4b686521bb9cc5d0507e917627fe68">operator=</a> (const <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other) -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;</td></tr>
<tr class="memdesc:a4f4b686521bb9cc5d0507e917627fe68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator.  <a href="#a4f4b686521bb9cc5d0507e917627fe68">More...</a><br /></td></tr>
<tr class="separator:a4f4b686521bb9cc5d0507e917627fe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296d675a8e4951def139df9fe800529e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a296d675a8e4951def139df9fe800529e">operator=</a> (const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt; &amp;init) -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;</td></tr>
<tr class="memdesc:a296d675a8e4951def139df9fe800529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign initializer-list.  <a href="#a296d675a8e4951def139df9fe800529e">More...</a><br /></td></tr>
<tr class="separator:a296d675a8e4951def139df9fe800529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9288683c58c2cd6f6da6d813d5c93a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9f9288683c58c2cd6f6da6d813d5c93a">get_allocator</a> () const noexcept -&gt; const Allocator &amp;</td></tr>
<tr class="memdesc:a9f9288683c58c2cd6f6da6d813d5c93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns container's allocator.  <a href="#a9f9288683c58c2cd6f6da6d813d5c93a">More...</a><br /></td></tr>
<tr class="separator:a9f9288683c58c2cd6f6da6d813d5c93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacada284f479e651b636864157f5acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adacada284f479e651b636864157f5acf">get_allocator</a> () noexcept -&gt; Allocator &amp;</td></tr>
<tr class="separator:adacada284f479e651b636864157f5acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6652e65d040fe2f445f1addc37cf83b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab6652e65d040fe2f445f1addc37cf83b">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:ab6652e65d040fe2f445f1addc37cf83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if container is empty, false otherwise.  <a href="#ab6652e65d040fe2f445f1addc37cf83b">More...</a><br /></td></tr>
<tr class="separator:ab6652e65d040fe2f445f1addc37cf83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c8886d204becfa074d92ce15c1874d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d">size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:a23c8886d204becfa074d92ce15c1874d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size.  <a href="#a23c8886d204becfa074d92ce15c1874d">More...</a><br /></td></tr>
<tr class="separator:a23c8886d204becfa074d92ce15c1874d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93a8ed38a83b36d0a89ca600395aa22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae93a8ed38a83b36d0a89ca600395aa22">max_size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:ae93a8ed38a83b36d0a89ca600395aa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size.  <a href="#ae93a8ed38a83b36d0a89ca600395aa22">More...</a><br /></td></tr>
<tr class="separator:ae93a8ed38a83b36d0a89ca600395aa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692fd5619b00f4034158d580ffc06a2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a692fd5619b00f4034158d580ffc06a2a">clear</a> () noexcept</td></tr>
<tr class="memdesc:a692fd5619b00f4034158d580ffc06a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container.  <a href="#a692fd5619b00f4034158d580ffc06a2a">More...</a><br /></td></tr>
<tr class="separator:a692fd5619b00f4034158d580ffc06a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abfe0f7dd40f799cbe7aad1dfe95257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a5abfe0f7dd40f799cbe7aad1dfe95257">swap</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a5abfe0f7dd40f799cbe7aad1dfe95257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this container's content with another. Iterators to both containers remain valid, including end iterators.  <a href="#a5abfe0f7dd40f799cbe7aad1dfe95257">More...</a><br /></td></tr>
<tr class="separator:a5abfe0f7dd40f799cbe7aad1dfe95257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa7fbd752589e8564aa0c3ad67dbc7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9fa7fbd752589e8564aa0c3ad67dbc7e">tvector</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a> &amp;</td></tr>
<tr class="memdesc:a9fa7fbd752589e8564aa0c3ad67dbc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. Calling this function will mark the container as dirty. Any further attempts to call members like <a class="el" href="classseq_1_1flat__set.html#aabcb0e7c7ad9bf0bdb5c548eda361306" title="Finds an element with key that compares equivalent to the value key. This overload participates in ov...">find()</a>, lower_bound, upper_bound... will raise a std::logic_error. To mark the container as non dirty anymore, the user must call <a class="el" href="classseq_1_1flat__set.html#a38209b2ae8d2ff7d4e84f4daf76983ff" title="Sort the container. This function sort again the container only if: ">flat_set::sort()</a>.  <a href="#a9fa7fbd752589e8564aa0c3ad67dbc7e">More...</a><br /></td></tr>
<tr class="separator:a9fa7fbd752589e8564aa0c3ad67dbc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ecee637d5934dd496bb1516f0e85c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a64ecee637d5934dd496bb1516f0e85c8">tvector</a> () const noexcept -&gt; const <a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a> &amp;</td></tr>
<tr class="memdesc:a64ecee637d5934dd496bb1516f0e85c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. The container will NOT be marked as dirty.  <a href="#a64ecee637d5934dd496bb1516f0e85c8">More...</a><br /></td></tr>
<tr class="separator:a64ecee637d5934dd496bb1516f0e85c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ea61c3eff4beb05bb561a1488e02ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a89ea61c3eff4beb05bb561a1488e02ee">ctvector</a> () const noexcept -&gt; const <a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a> &amp;</td></tr>
<tr class="memdesc:a89ea61c3eff4beb05bb561a1488e02ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. The container will NOT be marked as dirty.  <a href="#a89ea61c3eff4beb05bb561a1488e02ee">More...</a><br /></td></tr>
<tr class="separator:a89ea61c3eff4beb05bb561a1488e02ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90998eda17f1d133efa03a852f73342"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa90998eda17f1d133efa03a852f73342"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa90998eda17f1d133efa03a852f73342">emplace</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:aa90998eda17f1d133efa03a852f73342"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::emplace().  <a href="#aa90998eda17f1d133efa03a852f73342">More...</a><br /></td></tr>
<tr class="separator:aa90998eda17f1d133efa03a852f73342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824394ff33504f5b923ea708d057451c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c">insert</a> (const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a824394ff33504f5b923ea708d057451c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="#a824394ff33504f5b923ea708d057451c">More...</a><br /></td></tr>
<tr class="separator:a824394ff33504f5b923ea708d057451c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c3798d946d17f1bdcc2eba6c2522c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae7c3798d946d17f1bdcc2eba6c2522c2">insert</a> (<a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:ae7c3798d946d17f1bdcc2eba6c2522c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="#ae7c3798d946d17f1bdcc2eba6c2522c2">More...</a><br /></td></tr>
<tr class="separator:ae7c3798d946d17f1bdcc2eba6c2522c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3995b3e1a3cfa248d7246992bbacac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa3995b3e1a3cfa248d7246992bbacac0">insert_pos</a> (const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;value) -&gt; std::pair&lt; size_t, bool &gt;</td></tr>
<tr class="memdesc:aa3995b3e1a3cfa248d7246992bbacac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c" title="See std::set::insert. ">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> if no element was inserted).  <a href="#aa3995b3e1a3cfa248d7246992bbacac0">More...</a><br /></td></tr>
<tr class="separator:aa3995b3e1a3cfa248d7246992bbacac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be4cbf48c48067da32a6ec329c62bf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a7be4cbf48c48067da32a6ec329c62bf2">insert_pos</a> (<a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; size_t, bool &gt;</td></tr>
<tr class="memdesc:a7be4cbf48c48067da32a6ec329c62bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c" title="See std::set::insert. ">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> if no element was inserted).  <a href="#a7be4cbf48c48067da32a6ec329c62bf2">More...</a><br /></td></tr>
<tr class="separator:a7be4cbf48c48067da32a6ec329c62bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc0b5c9d6064ece331587d3d54da760"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a0bc0b5c9d6064ece331587d3d54da760"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0bc0b5c9d6064ece331587d3d54da760">emplace_pos</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; size_t, bool &gt;</td></tr>
<tr class="memdesc:a0bc0b5c9d6064ece331587d3d54da760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classseq_1_1flat__set.html#aa90998eda17f1d133efa03a852f73342" title="See std::set::emplace(). ">emplace()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> if no element was inserted).  <a href="#a0bc0b5c9d6064ece331587d3d54da760">More...</a><br /></td></tr>
<tr class="separator:a0bc0b5c9d6064ece331587d3d54da760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d642b59b512aa4876c3507224cbe73"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa2d642b59b512aa4876c3507224cbe73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa2d642b59b512aa4876c3507224cbe73">emplace_hint</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> hint, Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:aa2d642b59b512aa4876c3507224cbe73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::emplace_hint.  <a href="#aa2d642b59b512aa4876c3507224cbe73">More...</a><br /></td></tr>
<tr class="separator:aa2d642b59b512aa4876c3507224cbe73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd49dfd48ccd3057e13ee4a7549094f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#affd49dfd48ccd3057e13ee4a7549094f">insert</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> hint, const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;value) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:affd49dfd48ccd3057e13ee4a7549094f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="#affd49dfd48ccd3057e13ee4a7549094f">More...</a><br /></td></tr>
<tr class="separator:affd49dfd48ccd3057e13ee4a7549094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b0f2b618c92c54c7a7b56aea0509bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a22b0f2b618c92c54c7a7b56aea0509bf">insert</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> hint, <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a22b0f2b618c92c54c7a7b56aea0509bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="#a22b0f2b618c92c54c7a7b56aea0509bf">More...</a><br /></td></tr>
<tr class="separator:a22b0f2b618c92c54c7a7b56aea0509bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ed9fadc8b03e3d3a03543dd114640e"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:af4ed9fadc8b03e3d3a03543dd114640e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af4ed9fadc8b03e3d3a03543dd114640e">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:af4ed9fadc8b03e3d3a03543dd114640e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one.  <a href="#af4ed9fadc8b03e3d3a03543dd114640e">More...</a><br /></td></tr>
<tr class="separator:af4ed9fadc8b03e3d3a03543dd114640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f41daa22558743458cbfdce680f720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab7f41daa22558743458cbfdce680f720">insert</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:ab7f41daa22558743458cbfdce680f720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="#ab7f41daa22558743458cbfdce680f720">More...</a><br /></td></tr>
<tr class="separator:ab7f41daa22558743458cbfdce680f720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3620f84e2d615134e8e4df04b20a53"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:afa3620f84e2d615134e8e4df04b20a53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#afa3620f84e2d615134e8e4df04b20a53">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:afa3620f84e2d615134e8e4df04b20a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the content of the range [first, last) to this container, discarding previous values.  <a href="#afa3620f84e2d615134e8e4df04b20a53">More...</a><br /></td></tr>
<tr class="separator:afa3620f84e2d615134e8e4df04b20a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bf6d75dba07b09fb05326d37bf2b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa7bf6d75dba07b09fb05326d37bf2b56">erase_pos</a> (<a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a> <a class="el" href="classseq_1_1flat__set.html#ab50bb3faf656740d6080aab6569990f9">pos</a>)</td></tr>
<tr class="memdesc:aa7bf6d75dba07b09fb05326d37bf2b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given position in the container. This is slightly faster than calling <a class="el" href="classseq_1_1flat__set.html#adc66a0e8125c797462812cc1fad29ae9" title="Erase element at given location. ">erase(iterator)</a>.  <a href="#aa7bf6d75dba07b09fb05326d37bf2b56">More...</a><br /></td></tr>
<tr class="separator:aa7bf6d75dba07b09fb05326d37bf2b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc66a0e8125c797462812cc1fad29ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adc66a0e8125c797462812cc1fad29ae9">erase</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> <a class="el" href="classseq_1_1flat__set.html#ab50bb3faf656740d6080aab6569990f9">pos</a>) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:adc66a0e8125c797462812cc1fad29ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given location.  <a href="#adc66a0e8125c797462812cc1fad29ae9">More...</a><br /></td></tr>
<tr class="separator:adc66a0e8125c797462812cc1fad29ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fabdfc9d2d46b9fd29e16154d6cc324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9fabdfc9d2d46b9fd29e16154d6cc324">erase</a> (<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> first, <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> last) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a9fabdfc9d2d46b9fd29e16154d6cc324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the range [first, last)  <a href="#a9fabdfc9d2d46b9fd29e16154d6cc324">More...</a><br /></td></tr>
<tr class="separator:a9fabdfc9d2d46b9fd29e16154d6cc324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88ff2047f7bb5426d5dce534db6caeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa88ff2047f7bb5426d5dce534db6caeb">erase</a> (size_t first, size_t last)</td></tr>
<tr class="memdesc:aa88ff2047f7bb5426d5dce534db6caeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the range [first, last)  <a href="#aa88ff2047f7bb5426d5dce534db6caeb">More...</a><br /></td></tr>
<tr class="separator:aa88ff2047f7bb5426d5dce534db6caeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd873b83ff14b355f3e10ad70a151aee"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afd873b83ff14b355f3e10ad70a151aee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#afd873b83ff14b355f3e10ad70a151aee">erase</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:afd873b83ff14b355f3e10ad70a151aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type, and neither iterator nor const_iterator is implicitly convertible from K. It allows calling this function without constructing an instance of Key.  <a href="#afd873b83ff14b355f3e10ad70a151aee">More...</a><br /></td></tr>
<tr class="separator:afd873b83ff14b355f3e10ad70a151aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413ccac6fd92ac9ededb9420495f5456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a413ccac6fd92ac9ededb9420495f5456">erase</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:a413ccac6fd92ac9ededb9420495f5456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="#a413ccac6fd92ac9ededb9420495f5456">More...</a><br /></td></tr>
<tr class="separator:a413ccac6fd92ac9ededb9420495f5456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcb0e7c7ad9bf0bdb5c548eda361306"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aabcb0e7c7ad9bf0bdb5c548eda361306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aabcb0e7c7ad9bf0bdb5c548eda361306">find</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:aabcb0e7c7ad9bf0bdb5c548eda361306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#aabcb0e7c7ad9bf0bdb5c548eda361306">More...</a><br /></td></tr>
<tr class="separator:aabcb0e7c7ad9bf0bdb5c548eda361306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f4598c86bb4ec62495ba4f06e52acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a17f4598c86bb4ec62495ba4f06e52acf">find</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a17f4598c86bb4ec62495ba4f06e52acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="#a17f4598c86bb4ec62495ba4f06e52acf">More...</a><br /></td></tr>
<tr class="separator:a17f4598c86bb4ec62495ba4f06e52acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1e9bc705afeb3974f71a2f33cbdeec"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2d1e9bc705afeb3974f71a2f33cbdeec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2d1e9bc705afeb3974f71a2f33cbdeec">find</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a2d1e9bc705afeb3974f71a2f33cbdeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#a2d1e9bc705afeb3974f71a2f33cbdeec">More...</a><br /></td></tr>
<tr class="separator:a2d1e9bc705afeb3974f71a2f33cbdeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2991f10f11b13559e9417893e5b1869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ac2991f10f11b13559e9417893e5b1869">find</a> (const Key &amp;x) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:ac2991f10f11b13559e9417893e5b1869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="#ac2991f10f11b13559e9417893e5b1869">More...</a><br /></td></tr>
<tr class="separator:ac2991f10f11b13559e9417893e5b1869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae195139b10f6f384b516eb0c6f9f0c41"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae195139b10f6f384b516eb0c6f9f0c41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ae195139b10f6f384b516eb0c6f9f0c41">find_pos</a> (const K &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:ae195139b10f6f384b516eb0c6f9f0c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#ae195139b10f6f384b516eb0c6f9f0c41">More...</a><br /></td></tr>
<tr class="separator:ae195139b10f6f384b516eb0c6f9f0c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd267246ae66f06e7280d4ac6b1871c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a4cd267246ae66f06e7280d4ac6b1871c">find_pos</a> (const Key &amp;x) const -&gt; size_t</td></tr>
<tr class="memdesc:a4cd267246ae66f06e7280d4ac6b1871c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="#a4cd267246ae66f06e7280d4ac6b1871c">More...</a><br /></td></tr>
<tr class="separator:a4cd267246ae66f06e7280d4ac6b1871c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50bb3faf656740d6080aab6569990f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab50bb3faf656740d6080aab6569990f9">pos</a> (size_t i) const noexcept -&gt; const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;</td></tr>
<tr class="memdesc:ab50bb3faf656740d6080aab6569990f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value at given flat position.  <a href="#ab50bb3faf656740d6080aab6569990f9">More...</a><br /></td></tr>
<tr class="separator:ab50bb3faf656740d6080aab6569990f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2173cac0b26bf9cdc6a11d7990ed8c50"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2173cac0b26bf9cdc6a11d7990ed8c50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50">lower_bound</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a2173cac0b26bf9cdc6a11d7990ed8c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#a2173cac0b26bf9cdc6a11d7990ed8c50">More...</a><br /></td></tr>
<tr class="separator:a2173cac0b26bf9cdc6a11d7990ed8c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b45c773ae10bc33f9e02489a6b96ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab1b45c773ae10bc33f9e02489a6b96ae">lower_bound</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:ab1b45c773ae10bc33f9e02489a6b96ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="#ab1b45c773ae10bc33f9e02489a6b96ae">More...</a><br /></td></tr>
<tr class="separator:ab1b45c773ae10bc33f9e02489a6b96ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83375d6d39451636c0979c06d365b54c"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a83375d6d39451636c0979c06d365b54c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a83375d6d39451636c0979c06d365b54c">lower_bound</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a83375d6d39451636c0979c06d365b54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#a83375d6d39451636c0979c06d365b54c">More...</a><br /></td></tr>
<tr class="separator:a83375d6d39451636c0979c06d365b54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7d2cfaa13474b1163ef8e687d3bf33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aae7d2cfaa13474b1163ef8e687d3bf33">lower_bound</a> (const Key &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:aae7d2cfaa13474b1163ef8e687d3bf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="#aae7d2cfaa13474b1163ef8e687d3bf33">More...</a><br /></td></tr>
<tr class="separator:aae7d2cfaa13474b1163ef8e687d3bf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec79ed0fd4cef7e0844deac4aa3aedd"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0ec79ed0fd4cef7e0844deac4aa3aedd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0ec79ed0fd4cef7e0844deac4aa3aedd">lower_bound_pos</a> (const K &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a0ec79ed0fd4cef7e0844deac4aa3aedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#a0ec79ed0fd4cef7e0844deac4aa3aedd">More...</a><br /></td></tr>
<tr class="separator:a0ec79ed0fd4cef7e0844deac4aa3aedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f4b3ed5334be19de998d70e4a7ba39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a22f4b3ed5334be19de998d70e4a7ba39">lower_bound_pos</a> (const Key &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a22f4b3ed5334be19de998d70e4a7ba39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that is not less than (i.e. greater or equal to) key.  <a href="#a22f4b3ed5334be19de998d70e4a7ba39">More...</a><br /></td></tr>
<tr class="separator:a22f4b3ed5334be19de998d70e4a7ba39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0121f5a6e358530f708c4558fe5c4bc"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af0121f5a6e358530f708c4558fe5c4bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc">upper_bound</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:af0121f5a6e358530f708c4558fe5c4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#af0121f5a6e358530f708c4558fe5c4bc">More...</a><br /></td></tr>
<tr class="separator:af0121f5a6e358530f708c4558fe5c4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31aca82caf521823b1737444657fe3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa31aca82caf521823b1737444657fe3e">upper_bound</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:aa31aca82caf521823b1737444657fe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="#aa31aca82caf521823b1737444657fe3e">More...</a><br /></td></tr>
<tr class="separator:aa31aca82caf521823b1737444657fe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe42865ce80bd40c8a5f90916d7a4367"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afe42865ce80bd40c8a5f90916d7a4367"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#afe42865ce80bd40c8a5f90916d7a4367">upper_bound</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:afe42865ce80bd40c8a5f90916d7a4367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#afe42865ce80bd40c8a5f90916d7a4367">More...</a><br /></td></tr>
<tr class="separator:afe42865ce80bd40c8a5f90916d7a4367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e42fb2055408052db9f10750994e69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a98e42fb2055408052db9f10750994e69">upper_bound</a> (const Key &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a98e42fb2055408052db9f10750994e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="#a98e42fb2055408052db9f10750994e69">More...</a><br /></td></tr>
<tr class="separator:a98e42fb2055408052db9f10750994e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7187e79a36f33a8e356cbc19619c786e"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7187e79a36f33a8e356cbc19619c786e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a7187e79a36f33a8e356cbc19619c786e">upper_bound_pos</a> (const K &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a7187e79a36f33a8e356cbc19619c786e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#a7187e79a36f33a8e356cbc19619c786e">More...</a><br /></td></tr>
<tr class="separator:a7187e79a36f33a8e356cbc19619c786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d86c7d68a8ff523e82232be2b0eb404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9d86c7d68a8ff523e82232be2b0eb404">upper_bound_pos</a> (const Key &amp;key) const -&gt; size_t</td></tr>
<tr class="memdesc:a9d86c7d68a8ff523e82232be2b0eb404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first element that is greater than key.  <a href="#a9d86c7d68a8ff523e82232be2b0eb404">More...</a><br /></td></tr>
<tr class="separator:a9d86c7d68a8ff523e82232be2b0eb404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d31ec2fae3aa949ec3c0c811b4b2620"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7d31ec2fae3aa949ec3c0c811b4b2620"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a7d31ec2fae3aa949ec3c0c811b4b2620">contains</a> (const K &amp;key) const -&gt; bool</td></tr>
<tr class="memdesc:a7d31ec2fae3aa949ec3c0c811b4b2620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#a7d31ec2fae3aa949ec3c0c811b4b2620">More...</a><br /></td></tr>
<tr class="separator:a7d31ec2fae3aa949ec3c0c811b4b2620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac7c825bddb1b5a97e2e65f657e33b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#abbac7c825bddb1b5a97e2e65f657e33b">contains</a> (const Key &amp;key) const -&gt; bool</td></tr>
<tr class="memdesc:abbac7c825bddb1b5a97e2e65f657e33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key equivalent to key in the container.  <a href="#abbac7c825bddb1b5a97e2e65f657e33b">More...</a><br /></td></tr>
<tr class="separator:abbac7c825bddb1b5a97e2e65f657e33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0088631c9c3a478faa65decfdb456d11"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0088631c9c3a478faa65decfdb456d11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a0088631c9c3a478faa65decfdb456d11">count</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:a0088631c9c3a478faa65decfdb456d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key key (either 1 or 0 for <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> and <a class="el" href="classseq_1_1flat__map.html" title="flat sorted associative container that contains key-value pairs with unique keys similar to boost::fl...">flat_map</a>). This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.  <a href="#a0088631c9c3a478faa65decfdb456d11">More...</a><br /></td></tr>
<tr class="separator:a0088631c9c3a478faa65decfdb456d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714d052eb4568f2971c65c02d7c30ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a714d052eb4568f2971c65c02d7c30ee9">count</a> (const Key &amp;key) const -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td></tr>
<tr class="memdesc:a714d052eb4568f2971c65c02d7c30ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key key (either 1 or 0 for <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> and <a class="el" href="classseq_1_1flat__map.html" title="flat sorted associative container that contains key-value pairs with unique keys similar to boost::fl...">flat_map</a>).  <a href="#a714d052eb4568f2971c65c02d7c30ee9">More...</a><br /></td></tr>
<tr class="separator:a714d052eb4568f2971c65c02d7c30ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa267f0b23224b0ab83d1a9dc985536f2"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa267f0b23224b0ab83d1a9dc985536f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#aa267f0b23224b0ab83d1a9dc985536f2">equal_range</a> (const K &amp;key) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> &gt;</td></tr>
<tr class="memdesc:aa267f0b23224b0ab83d1a9dc985536f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>.  <a href="#aa267f0b23224b0ab83d1a9dc985536f2">More...</a><br /></td></tr>
<tr class="separator:aa267f0b23224b0ab83d1a9dc985536f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cea0708e6c0aaa3d77e206fdf5a8db8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9cea0708e6c0aaa3d77e206fdf5a8db8">equal_range</a> (const Key &amp;key) -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> &gt;</td></tr>
<tr class="memdesc:a9cea0708e6c0aaa3d77e206fdf5a8db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>.  <a href="#a9cea0708e6c0aaa3d77e206fdf5a8db8">More...</a><br /></td></tr>
<tr class="separator:a9cea0708e6c0aaa3d77e206fdf5a8db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab619b8f53013b24028517ae8b84ca543"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab619b8f53013b24028517ae8b84ca543"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab619b8f53013b24028517ae8b84ca543">equal_range</a> (const K &amp;key) const -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:ab619b8f53013b24028517ae8b84ca543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>.  <a href="#ab619b8f53013b24028517ae8b84ca543">More...</a><br /></td></tr>
<tr class="separator:ab619b8f53013b24028517ae8b84ca543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624895de6710b50cc37c4fbe8a66e905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a624895de6710b50cc37c4fbe8a66e905">equal_range</a> (const Key &amp;key) const -&gt; std::pair&lt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a624895de6710b50cc37c4fbe8a66e905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>.  <a href="#a624895de6710b50cc37c4fbe8a66e905">More...</a><br /></td></tr>
<tr class="separator:a624895de6710b50cc37c4fbe8a66e905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108"><td class="memTemplParams" colspan="2">template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108">equal_range_pos</a> (const K &amp;key) const -&gt; std::pair&lt; size_t, size_t &gt;</td></tr>
<tr class="memdesc:a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a0ec79ed0fd4cef7e0844deac4aa3aedd" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7187e79a36f33a8e356cbc19619c786e" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>.  <a href="#a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108">More...</a><br /></td></tr>
<tr class="separator:a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2060d103ad5ed1e01f1eb17862bdd943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a2060d103ad5ed1e01f1eb17862bdd943">equal_range_pos</a> (const Key &amp;key) const -&gt; std::pair&lt; size_t, size_t &gt;</td></tr>
<tr class="memdesc:a2060d103ad5ed1e01f1eb17862bdd943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a0ec79ed0fd4cef7e0844deac4aa3aedd" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7187e79a36f33a8e356cbc19619c786e" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>.  <a href="#a2060d103ad5ed1e01f1eb17862bdd943">More...</a><br /></td></tr>
<tr class="separator:a2060d103ad5ed1e01f1eb17862bdd943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9050125cbdb0a07737350da1feb32086"><td class="memTemplParams" colspan="2">template&lt;class C2 , LayoutManagement layout2&gt; </td></tr>
<tr class="memitem:a9050125cbdb0a07737350da1feb32086"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a9050125cbdb0a07737350da1feb32086">merge</a> (<a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, C2, Allocator, layout2 &gt; &amp;source)</td></tr>
<tr class="memdesc:a9050125cbdb0a07737350da1feb32086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to extract each element in source and insert it into this using the comparison object of this. If there is an element in this with key equivalent to the key of an element from source, then that element is not extracted from source. Note that elements from source are moved to this.  <a href="#a9050125cbdb0a07737350da1feb32086">More...</a><br /></td></tr>
<tr class="separator:a9050125cbdb0a07737350da1feb32086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59da319ca4e1f96f964e0d3a9aa0b5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab59da319ca4e1f96f964e0d3a9aa0b5e">begin</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:ab59da319ca4e1f96f964e0d3a9aa0b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#ab59da319ca4e1f96f964e0d3a9aa0b5e">More...</a><br /></td></tr>
<tr class="separator:ab59da319ca4e1f96f964e0d3a9aa0b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec4dac53a49bcb800c04484af32394b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adec4dac53a49bcb800c04484af32394b">begin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:adec4dac53a49bcb800c04484af32394b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#adec4dac53a49bcb800c04484af32394b">More...</a><br /></td></tr>
<tr class="separator:adec4dac53a49bcb800c04484af32394b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce20d98d01cf4d0870f1d13a52d3742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1ce20d98d01cf4d0870f1d13a52d3742">cbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a1ce20d98d01cf4d0870f1d13a52d3742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a1ce20d98d01cf4d0870f1d13a52d3742">More...</a><br /></td></tr>
<tr class="separator:a1ce20d98d01cf4d0870f1d13a52d3742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa94b63a25292f8a58cbfd2512c9860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a1fa94b63a25292f8a58cbfd2512c9860">end</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td></tr>
<tr class="memdesc:a1fa94b63a25292f8a58cbfd2512c9860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#a1fa94b63a25292f8a58cbfd2512c9860">More...</a><br /></td></tr>
<tr class="separator:a1fa94b63a25292f8a58cbfd2512c9860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a9df66742e115f9689ce030d271ccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a49a9df66742e115f9689ce030d271ccf">end</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:a49a9df66742e115f9689ce030d271ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#a49a9df66742e115f9689ce030d271ccf">More...</a><br /></td></tr>
<tr class="separator:a49a9df66742e115f9689ce030d271ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0582e082a11301c87c027d53b5acc20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af0582e082a11301c87c027d53b5acc20">cend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a></td></tr>
<tr class="memdesc:af0582e082a11301c87c027d53b5acc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#af0582e082a11301c87c027d53b5acc20">More...</a><br /></td></tr>
<tr class="separator:af0582e082a11301c87c027d53b5acc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb102fa22655897552043a5646f7a56f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#acb102fa22655897552043a5646f7a56f">rbegin</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">reverse_iterator</a></td></tr>
<tr class="memdesc:acb102fa22655897552043a5646f7a56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="#acb102fa22655897552043a5646f7a56f">More...</a><br /></td></tr>
<tr class="separator:acb102fa22655897552043a5646f7a56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddfd7f5e28cc93df7988ac58974c356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a6ddfd7f5e28cc93df7988ac58974c356">rbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a6ddfd7f5e28cc93df7988ac58974c356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="#a6ddfd7f5e28cc93df7988ac58974c356">More...</a><br /></td></tr>
<tr class="separator:a6ddfd7f5e28cc93df7988ac58974c356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee6637715350687953e694f5dc2ce34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#adee6637715350687953e694f5dc2ce34">crbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a></td></tr>
<tr class="memdesc:adee6637715350687953e694f5dc2ce34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="#adee6637715350687953e694f5dc2ce34">More...</a><br /></td></tr>
<tr class="separator:adee6637715350687953e694f5dc2ce34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd447617ab7d75b2ef5bab57b83989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab0dd447617ab7d75b2ef5bab57b83989">rend</a> () noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">reverse_iterator</a></td></tr>
<tr class="memdesc:ab0dd447617ab7d75b2ef5bab57b83989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="#ab0dd447617ab7d75b2ef5bab57b83989">More...</a><br /></td></tr>
<tr class="separator:ab0dd447617ab7d75b2ef5bab57b83989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b22892f760277490febbbd0eeef3a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#ab5b22892f760277490febbbd0eeef3a8">rend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ab5b22892f760277490febbbd0eeef3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="#ab5b22892f760277490febbbd0eeef3a8">More...</a><br /></td></tr>
<tr class="separator:ab5b22892f760277490febbbd0eeef3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d1501d0598eddffcf7822d4f270aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#af1d1501d0598eddffcf7822d4f270aa8">crend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a></td></tr>
<tr class="memdesc:af1d1501d0598eddffcf7822d4f270aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="#af1d1501d0598eddffcf7822d4f270aa8">More...</a><br /></td></tr>
<tr class="separator:af1d1501d0598eddffcf7822d4f270aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39893991623c0876b65231b4ec7bd43c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a39893991623c0876b65231b4ec7bd43c">key_comp</a> () const -&gt; <a class="el" href="classseq_1_1flat__set.html#afa6bb6b87f93185e1512bc25216b37df">key_compare</a></td></tr>
<tr class="memdesc:a39893991623c0876b65231b4ec7bd43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the comparison object.  <a href="#a39893991623c0876b65231b4ec7bd43c">More...</a><br /></td></tr>
<tr class="separator:a39893991623c0876b65231b4ec7bd43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38209b2ae8d2ff7d4e84f4daf76983ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1flat__set.html#a38209b2ae8d2ff7d4e84f4daf76983ff">sort</a> ()</td></tr>
<tr class="memdesc:a38209b2ae8d2ff7d4e84f4daf76983ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container. This function sort again the container only if:  <a href="#a38209b2ae8d2ff7d4e84f4daf76983ff">More...</a><br /></td></tr>
<tr class="separator:a38209b2ae8d2ff7d4e84f4daf76983ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt;<br />
class seq::flat_set&lt; Key, Compare, Allocator, Stable, Unique &gt;</h3>

<p>flat sorted container similar to boost::flat_set with faster insertion/deletion of single values </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>key type </td></tr>
    <tr><td class="paramname">Compare</td><td>comparison function </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator </td></tr>
    <tr><td class="paramname">Stable</td><td>insertion order stability</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> is a sorted associative container similar to <a href="https://www.boost.org/doc/libs/1_64_0/doc/html/boost/container/flat_set.html">boost::flat_set</a>, but relying on a <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> instead of a flat array. Therefore, it inherits <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> properties: faster insertion and deletion of individual values (thanks to its tiered-vector based implementation), fast iteration, random access, invalidation of references/iterators on insertion and deletion.</p>
<p>All keys in a <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> are unique. All references and iterators are invalidated when inserting/removing keys.</p>
<p><a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> provides a similar interface to std::set (C++17) with the following differences:</p><ul>
<li>The node related functions are not implemented,</li>
<li>The member <a class="el" href="classseq_1_1flat__set.html#ab50bb3faf656740d6080aab6569990f9" title="Returns value at given flat position. ">flat_set::pos()</a> is used to access to a random location,</li>
<li>The members <a class="el" href="classseq_1_1flat__set.html#a9fa7fbd752589e8564aa0c3ad67dbc7e" title="Returns the underlying tiered_vector. Calling this function will mark the container as dirty...">flat_set::tvector()</a> returns a reference to the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> object,</li>
<li>Its iterator and const_iterator types are random access iterators.</li>
</ul>
<p>The underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> object stores plain non const Key objects. However, in order to avoid modifying the keys through iterators (and potentially invalidating the order), both iterator and const_iterator types can only return const references.</p>
<p>In addition to members returning (const_)iterator(s), the <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> provides the same members ending with the '_pos' prefix and returning positions within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> instead of iterators. These functions are slightly faster than the iterator based members.</p>
<p>Unlike most flat set implementations, it it possible to directly access and modify the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. This possibility must be used with great care, as modifying directly the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> might break the key ordering. When calling the non-const version of <a class="el" href="classseq_1_1flat__set.html#a9fa7fbd752589e8564aa0c3ad67dbc7e" title="Returns the underlying tiered_vector. Calling this function will mark the container as dirty...">flat_set::tvector()</a>, the <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> will be marked as dirty, and further attempts to call functions like <a class="el" href="classseq_1_1flat__set.html#aabcb0e7c7ad9bf0bdb5c548eda361306" title="Finds an element with key that compares equivalent to the value key. This overload participates in ov...">flat_set::find()</a> of <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">flat_set::lower_bound()</a> (functions based on key ordering) will throw a std::logic_error.</p>
<p>Therefore, after finishing modifying the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>, you must call <a class="el" href="classseq_1_1flat__set.html#a38209b2ae8d2ff7d4e84f4daf76983ff" title="Sort the container. This function sort again the container only if: ">flat_set::sort()</a> to sort again the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>, remove potential duplicates, and mark the <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> as non dirty anymore.</p>
<p>This way of modifying a <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> must be used carefully, but is way faster than multiple calls to <a class="el" href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c" title="See std::set::insert. ">flat_set::insert()</a> or <a class="el" href="classseq_1_1flat__set.html#adc66a0e8125c797462812cc1fad29ae9" title="Erase element at given location. ">flat_set::erase()</a>.</p>
<p>Inserting a range of values using flat_set::insert(first, last) is faster than inserting keys one by one, and should be favored if possible. Range insertion works the following way:</p><ul>
<li>New keys are first appended to the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a></li>
<li>These new keys are sorted directly within the <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a></li>
<li>Old keys and new keys are merged using std::inplace_merge</li>
<li>Duplicate values are removed if necessary using std::unique.</li>
</ul>
<p>Note that <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> used by default <a href="https://github.com/orlp/pdqsort">pdqsort</a> implementation from Orson Peters which is not stable. If you need to keep stability when inserting range of values, you must set the Stable template parameter to true. std::stable_sort will be used instead of pdqsort (std::inplace_merge and std::unique are already stable).</p>
<p>All <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> operations only provide <b>basic exception guarantee</b>, exactly like the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a>.</p>
<p>Performances of <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> has been measured and compared to std::set, std::unordered_set, <a href="https://www.boost.org/doc/libs/1_64_0/doc/html/boost/container/flat_set.html">boost::flat_set</a> and <a href="https://github.com/greg7mdp/parallel-hashmap">phmap::btree_set</a> (based on abseil btree_set). The following table show the results when compiled with gcc 10.1.0 (-O3) for msys2 on Windows 10, using Intel(R) Core(TM) i7-10850H at 2.70GHz. Measured operations are:</p><ul>
<li>Insert successfully a range of 1M unique double randomly shuffled using set_class::insert(first,last)</li>
<li>Insert successfully 1M unique double randomly shuffled one by one using set_class::insert(const Key&amp;)</li>
<li>Insert 1M double randomly shuffled one by one and already present in the set (failed insertion)</li>
<li>Successfully search for 1M double in the set using set_class::find(const Key&amp;), or flat_set::find_pos(const Key&amp;)</li>
<li>Search for 1M double not present in the set (failed lookup)</li>
<li>Walk through the full set (1M double) using iterators</li>
<li>Successfull find and erase all 1M double one by one using set_class::erase(iterator)</li>
</ul>
<p>Note the the given memory is NOT the memory footprint of the container, but the one of the full program. It should be used relatively to compare memory usage difference between each container.</p>
<table class="doxtable">
<tr>
<th>Set name </th><th>Insert(range) </th><th>Insert </th><th>Insert(failed) </th><th>Find (success) </th><th>Find (failed) </th><th>Iterate </th><th>Erase  </th></tr>
<tr>
<td><a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> </td><td>46 ms/15 MO </td><td>408 ms/16 MO </td><td>128 ms </td><td>130 ms </td><td>122 ms </td><td>1 ms </td><td>413 ms </td></tr>
<tr>
<td>phmap::btree_set </td><td>135 ms/18 MO </td><td>118 ms/18 MO </td><td>118 ms </td><td>119 ms </td><td>120 ms </td><td>3 ms </td><td>131 ms </td></tr>
<tr>
<td>boost::flat_set&lt;T&gt; </td><td>57 ms/15 MO </td><td>49344 ms/17 MO </td><td>133 ms </td><td>132 ms </td><td>127 ms </td><td>1 ms </td><td>131460 ms </td></tr>
<tr>
<td>std::set </td><td>457 ms/54 MO </td><td>457 ms/54 MO </td><td>449 ms </td><td>505 ms </td><td>502 ms </td><td>92 ms </td><td>739 ms </td></tr>
<tr>
<td>std::unordered_set </td><td>187 ms/46 MO </td><td>279 ms/50 MO </td><td>100 ms </td><td>116 ms </td><td>155 ms </td><td>29 ms </td><td>312 ms </td></tr>
</table>
<p>Below is the same benchmark using random <a class="el" href="namespaceseq.html#aebe7cbd216aa93afb6c62a1bc4d39ba5" title="Base string typedef, similar to std::string. Equivalent to tiny_string&lt;0, std::allocator&lt;char&gt;&gt;. ">seq::tstring</a> of length 14 (using Small String Optimization):</p>
<table class="doxtable">
<tr>
<th>Set name </th><th>Insert(range) </th><th>Insert </th><th>Insert(failed) </th><th>Find (success) </th><th>Find (failed) </th><th>Iterate </th><th>Erase  </th></tr>
<tr>
<td><a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> </td><td>127 ms/30 MO </td><td>891 ms/31 MO </td><td>252 ms </td><td>245 ms </td><td>240 ms </td><td>1 ms </td><td>904 ms </td></tr>
<tr>
<td>phmap::btree_set </td><td>280 ms/37 MO </td><td>278 ms/37 MO </td><td>266 ms </td><td>292 ms </td><td>279 ms </td><td>10 ms </td><td>292 ms </td></tr>
<tr>
<td>boost::flat_set&lt;T&gt; </td><td>107 ms/30 MO </td><td>585263 ms/32 MO </td><td>228 ms </td><td>232 ms </td><td>232 ms </td><td>0 ms </td><td>601541 ms </td></tr>
<tr>
<td>std::set </td><td>646 ms/77 MO </td><td>640 ms/77 MO </td><td>611 ms </td><td>672 ms </td><td>710 ms </td><td>87 ms </td><td>798 ms </td></tr>
<tr>
<td>std::unordered_set </td><td>205 ms/54 MO </td><td>319 ms/57 MO </td><td>157 ms </td><td>192 ms </td><td>220 ms </td><td>34 ms </td><td>380 ms </td></tr>
</table>
<p>These benchmarks are available in file 'seq/benchs/bench_map.hpp'. <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> behaves quite well compared to phmap::btree_set or boost::flat_set, and is even faster for single insertion/deletion than std::set for double type.</p>
<p><a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> insertion/deletion performs in O(sqrt(N)) on average, as compared to std::set that performs in O(log(N)). <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a> is therfore slower for inserting and deleting elements than std::set when dealing with several millions of elements. Lookup functions (find, lower_bound, upper_bound...) still perform in O(log(N)) and remain faster that std::set couterparts because of the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> cache friendliness. <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> will almost always be slower for element lookup than boost::flat_set wich uses a single dense array, except for very small keys (like in above benchmark).</p>
<p>Several factors will impact the performances of <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">seq::flat_set</a>:</p><ul>
<li>Relocatable types (where <a class="el" href="structseq_1_1is__relocatable.html#a9bc3104d310961a601c2185957f846ad">seq::is_relocatable&lt;T&gt;::value</a> is true) are faster than other types for insertion/deletion, as <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a> will use memmove to move around objects. Therefore, a <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> of <a class="el" href="namespaceseq.html#aebe7cbd216aa93afb6c62a1bc4d39ba5" title="Base string typedef, similar to std::string. Equivalent to tiny_string&lt;0, std::allocator&lt;char&gt;&gt;. ">seq::tstring</a> will always be faster than std::string.</li>
<li>Performances of insertion/deletion decrease as sizeof(value_type) increases. This is especially true for insertion/deletion, much less for lookup functions which remain (more or less) as fast as boost::flat_set.</li>
<li>All members using the '_pos' prefix are usually slightly faster than their iterator based counterparts. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a79dd536447c118abbfa74b8551d49061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79dd536447c118abbfa74b8551d49061">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#a79dd536447c118abbfa74b8551d49061">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a999dddbf15eb6553aa7e91be08ce6222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999dddbf15eb6553aa7e91be08ce6222">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> =  typename deque_type::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1dbf894f94d85541c14db4ab6eb3a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dbf894f94d85541c14db4ab6eb3a65">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#ab1dbf894f94d85541c14db4ab6eb3a65">const_pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__set.html#ab1dbf894f94d85541c14db4ab6eb3a65">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac16c86bbdc8b0bca507d35927b7bb985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16c86bbdc8b0bca507d35927b7bb985">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#ac16c86bbdc8b0bca507d35927b7bb985">const_reference</a> =  const Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb1957a91d7d434300b953843676c2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1957a91d7d434300b953843676c2ed">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a> =  typename deque_type::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21b0bac611ecd8732e6282084f533b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b0bac611ecd8732e6282084f533b9c">&#9670;&nbsp;</a></span>deque_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a> =  typename <a class="el" href="structseq_1_1detail_1_1flat__tree.html#af41da69c0cf605bd81accf294e4a96d6">flat_tree_type::deque_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b4f850cd1b727e52d9e3b5c5291afb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4f850cd1b727e52d9e3b5c5291afb0">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#a1b4f850cd1b727e52d9e3b5c5291afb0">difference_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__set.html#a1b4f850cd1b727e52d9e3b5c5291afb0">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77879fbd7d9f8f9e59c1ff8b4d2ea144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77879fbd7d9f8f9e59c1ff8b4d2ea144">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> =  typename deque_type::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa6bb6b87f93185e1512bc25216b37df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6bb6b87f93185e1512bc25216b37df">&#9670;&nbsp;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#afa6bb6b87f93185e1512bc25216b37df">key_compare</a> =  Compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac6e0b374be4defba15ff71873ceee01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6e0b374be4defba15ff71873ceee01">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#aac6e0b374be4defba15ff71873ceee01">key_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a370d857cf97fed3323fbb5cc6977eee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370d857cf97fed3323fbb5cc6977eee4">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#a370d857cf97fed3323fbb5cc6977eee4">pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__set.html#a370d857cf97fed3323fbb5cc6977eee4">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25b80e04ba844d8e26f452ca4d3ceece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b80e04ba844d8e26f452ca4d3ceece">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#a25b80e04ba844d8e26f452ca4d3ceece">reference</a> =  Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25ad7f5537b59b28ec7fd2a4ab32df07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ad7f5537b59b28ec7fd2a4ab32df07">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">reverse_iterator</a> =  typename deque_type::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30f202fe21ed7de6f559b38740fe0b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f202fe21ed7de6f559b38740fe0b5a">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeacbd6819f205822a6c898e5257dad95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacbd6819f205822a6c898e5257dad95">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae603afa34949ebea033565d2d1d89cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae603afa34949ebea033565d2d1d89cce">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a72e9bb2e33267ee0d9ad81100eedd7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e9bb2e33267ee0d9ad81100eedd7dc">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from comparator function and optional allocator object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>comparison function object to use for all comparisons of keys </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a797ec01f149442f508e8f915373071b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797ec01f149442f508e8f915373071b6">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from allocator object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20afaa6733d1f49cfbbf7ea33bce1485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20afaa6733d1f49cfbbf7ea33bce1485">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">comp</td><td>comparison function object to use for all comparisons of keys </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac553b49836b4069726a1e609ec6a538f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac553b49836b4069726a1e609ec6a538f">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af129b4ab9563a1029550a02049b7f171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af129b4ab9563a1029550a02049b7f171">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca2369e182eed80289a53705d80ee826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2369e182eed80289a53705d80ee826">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b89e289a324ea94e64c1f4f489d2912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b89e289a324ea94e64c1f4f489d2912">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44961e5e4a80765f854d6279793e9303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44961e5e4a80765f854d6279793e9303">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae238a65551109cfd46d305e6d7792156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae238a65551109cfd46d305e6d7792156">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">comp</td><td>comparison function object to use for all comparisons of keys </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a070e001a5cad36bf9a068a91c2693544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070e001a5cad36bf9a068a91c2693544">&#9670;&nbsp;</a></span>flat_set() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::<a class="el" href="classseq_1_1flat__set.html">flat_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afa3620f84e2d615134e8e4df04b20a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3620f84e2d615134e8e4df04b20a53">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the content of the range [first, last) to this container, discarding previous values. </p>

</div>
</div>
<a id="ab59da319ca4e1f96f964e0d3a9aa0b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59da319ca4e1f96f964e0d3a9aa0b5e">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="adec4dac53a49bcb800c04484af32394b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec4dac53a49bcb800c04484af32394b">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="a1ce20d98d01cf4d0870f1d13a52d3742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce20d98d01cf4d0870f1d13a52d3742">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="af0582e082a11301c87c027d53b5acc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0582e082a11301c87c027d53b5acc20">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="a692fd5619b00f4034158d580ffc06a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692fd5619b00f4034158d580ffc06a2a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the container. </p>

</div>
</div>
<a id="a7d31ec2fae3aa949ec3c0c811b4b2620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d31ec2fae3aa949ec3c0c811b4b2620">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; bool  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="abbac7c825bddb1b5a97e2e65f657e33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac7c825bddb1b5a97e2e65f657e33b">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; bool  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key equivalent to key in the container. </p>

</div>
</div>
<a id="a0088631c9c3a478faa65decfdb456d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0088631c9c3a478faa65decfdb456d11">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key key (either 1 or 0 for <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> and <a class="el" href="classseq_1_1flat__map.html" title="flat sorted associative container that contains key-value pairs with unique keys similar to boost::fl...">flat_map</a>). This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="a714d052eb4568f2971c65c02d7c30ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714d052eb4568f2971c65c02d7c30ee9">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key key (either 1 or 0 for <a class="el" href="classseq_1_1flat__set.html" title="flat sorted container similar to boost::flat_set with faster insertion/deletion of single values ...">flat_set</a> and <a class="el" href="classseq_1_1flat__map.html" title="flat sorted associative container that contains key-value pairs with unique keys similar to boost::fl...">flat_map</a>). </p>

</div>
</div>
<a id="adee6637715350687953e694f5dc2ce34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee6637715350687953e694f5dc2ce34">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="af1d1501d0598eddffcf7822d4f270aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d1501d0598eddffcf7822d4f270aa8">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a89ea61c3eff4beb05bb561a1488e02ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ea61c3eff4beb05bb561a1488e02ee">&#9670;&nbsp;</a></span>ctvector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::ctvector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const <a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. The container will NOT be marked as dirty. </p>

</div>
</div>
<a id="aa90998eda17f1d133efa03a852f73342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90998eda17f1d133efa03a852f73342">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::emplace(). </p>

</div>
</div>
<a id="aa2d642b59b512aa4876c3507224cbe73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d642b59b512aa4876c3507224cbe73">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::emplace_hint. </p>

</div>
</div>
<a id="a0bc0b5c9d6064ece331587d3d54da760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc0b5c9d6064ece331587d3d54da760">&#9670;&nbsp;</a></span>emplace_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::emplace_pos </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; std::pair&lt;size_t, bool&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classseq_1_1flat__set.html#aa90998eda17f1d133efa03a852f73342" title="See std::set::emplace(). ">emplace()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> if no element was inserted). </p>

</div>
</div>
<a id="ab6652e65d040fe2f445f1addc37cf83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6652e65d040fe2f445f1addc37cf83b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if container is empty, false otherwise. </p>

</div>
</div>
<a id="a1fa94b63a25292f8a58cbfd2512c9860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa94b63a25292f8a58cbfd2512c9860">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="a49a9df66742e115f9689ce030d271ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a9df66742e115f9689ce030d271ccf">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="aa267f0b23224b0ab83d1a9dc985536f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa267f0b23224b0ab83d1a9dc985536f2">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>&gt;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>. </p>
<p>This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="a9cea0708e6c0aaa3d77e206fdf5a8db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cea0708e6c0aaa3d77e206fdf5a8db8">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>&gt;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>. </p>

</div>
</div>
<a id="ab619b8f53013b24028517ae8b84ca543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab619b8f53013b24028517ae8b84ca543">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; std::pair&lt;<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>&gt;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>. </p>
<p>This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="a624895de6710b50cc37c4fbe8a66e905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624895de6710b50cc37c4fbe8a66e905">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; std::pair&lt;<a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>, <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>&gt;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a2173cac0b26bf9cdc6a11d7990ed8c50" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#af0121f5a6e358530f708c4558fe5c4bc" title="Returns an iterator pointing to the first element that compares greater to the value key...">upper_bound()</a>. </p>

</div>
</div>
<a id="a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d7ea4cb8cd9e2cf1ba3ecc6f6c1108">&#9670;&nbsp;</a></span>equal_range_pos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::equal_range_pos </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; std::pair&lt;size_t, size_t&gt;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a0ec79ed0fd4cef7e0844deac4aa3aedd" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7187e79a36f33a8e356cbc19619c786e" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>. </p>
<p>This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="a2060d103ad5ed1e01f1eb17862bdd943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2060d103ad5ed1e01f1eb17862bdd943">&#9670;&nbsp;</a></span>equal_range_pos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::equal_range_pos </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; std::pair&lt;size_t, size_t&gt;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two position, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1flat__set.html#a0ec79ed0fd4cef7e0844deac4aa3aedd" title="Returns the position of the first element that compares not less (i.e. greater or equal) to the value...">lower_bound_pos()</a>, and the second with <a class="el" href="classseq_1_1flat__set.html#a7187e79a36f33a8e356cbc19619c786e" title="Returns the position of the first element that compares greater to the value key. This overload parti...">upper_bound_pos()</a>. </p>

</div>
</div>
<a id="adc66a0e8125c797462812cc1fad29ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc66a0e8125c797462812cc1fad29ae9">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element at given location. </p>

</div>
</div>
<a id="a9fabdfc9d2d46b9fd29e16154d6cc324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fabdfc9d2d46b9fd29e16154d6cc324">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements in the range [first, last) </p>

</div>
</div>
<a id="aa88ff2047f7bb5426d5dce534db6caeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88ff2047f7bb5426d5dce534db6caeb">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements in the range [first, last) </p>

</div>
</div>
<a id="afd873b83ff14b355f3e10ad70a151aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd873b83ff14b355f3e10ad70a151aee">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type, and neither iterator nor const_iterator is implicitly convertible from K. It allows calling this function without constructing an instance of Key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value of the elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>

</div>
</div>
<a id="a413ccac6fd92ac9ededb9420495f5456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413ccac6fd92ac9ededb9420495f5456">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value of the elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>

</div>
</div>
<a id="aa7bf6d75dba07b09fb05326d37bf2b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bf6d75dba07b09fb05326d37bf2b56">&#9670;&nbsp;</a></span>erase_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element at given position in the container. This is slightly faster than calling <a class="el" href="classseq_1_1flat__set.html#adc66a0e8125c797462812cc1fad29ae9" title="Erase element at given location. ">erase(iterator)</a>. </p>

</div>
</div>
<a id="aabcb0e7c7ad9bf0bdb5c548eda361306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcb0e7c7ad9bf0bdb5c548eda361306">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found element, or end iterator </dd></dl>

</div>
</div>
<a id="a17f4598c86bb4ec62495ba4f06e52acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f4598c86bb4ec62495ba4f06e52acf">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found element, or end iterator </dd></dl>

</div>
</div>
<a id="a2d1e9bc705afeb3974f71a2f33cbdeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1e9bc705afeb3974f71a2f33cbdeec">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found element, or end iterator </dd></dl>

</div>
</div>
<a id="ac2991f10f11b13559e9417893e5b1869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2991f10f11b13559e9417893e5b1869">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found element, or end iterator </dd></dl>

</div>
</div>
<a id="ae195139b10f6f384b516eb0c6f9f0c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae195139b10f6f384b516eb0c6f9f0c41">&#9670;&nbsp;</a></span>find_pos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::find_pos </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of found value, or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> </dd></dl>

</div>
</div>
<a id="a4cd267246ae66f06e7280d4ac6b1871c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd267246ae66f06e7280d4ac6b1871c">&#9670;&nbsp;</a></span>find_pos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::find_pos </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const -&gt; size_t  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of found value, or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> </dd></dl>

</div>
</div>
<a id="a9f9288683c58c2cd6f6da6d813d5c93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9288683c58c2cd6f6da6d813d5c93a">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const Allocator &amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns container's allocator. </p>

</div>
</div>
<a id="adacada284f479e651b636864157f5acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacada284f479e651b636864157f5acf">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; Allocator&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a824394ff33504f5b923ea708d057451c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824394ff33504f5b923ea708d057451c">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, bool&gt; 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::insert. </p>

</div>
</div>
<a id="ae7c3798d946d17f1bdcc2eba6c2522c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c3798d946d17f1bdcc2eba6c2522c2">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>, bool&gt; 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::insert. </p>

</div>
</div>
<a id="affd49dfd48ccd3057e13ee4a7549094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd49dfd48ccd3057e13ee4a7549094f">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::insert() </p>

</div>
</div>
<a id="a22b0f2b618c92c54c7a7b56aea0509bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b0f2b618c92c54c7a7b56aea0509bf">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a> 
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::insert() </p>

</div>
</div>
<a id="af4ed9fadc8b03e3d3a03543dd114640e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ed9fadc8b03e3d3a03543dd114640e">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one. </p>

</div>
</div>
<a id="ab7f41daa22558743458cbfdce680f720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f41daa22558743458cbfdce680f720">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>

</div>
</div>
<a id="aa3995b3e1a3cfa248d7246992bbacac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3995b3e1a3cfa248d7246992bbacac0">&#9670;&nbsp;</a></span>insert_pos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;size_t, bool&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c" title="See std::set::insert. ">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> if no element was inserted). </p>

</div>
</div>
<a id="a7be4cbf48c48067da32a6ec329c62bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be4cbf48c48067da32a6ec329c62bf2">&#9670;&nbsp;</a></span>insert_pos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;size_t, bool&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classseq_1_1flat__set.html#a824394ff33504f5b923ea708d057451c" title="See std::set::insert. ">insert()</a>, but returns the inserted object position instead of iterator (or <a class="el" href="classseq_1_1flat__set.html#a23c8886d204becfa074d92ce15c1874d" title="Returns the container size. ">size()</a> if no element was inserted). </p>

</div>
</div>
<a id="a39893991623c0876b65231b4ec7bd43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39893991623c0876b65231b4ec7bd43c">&#9670;&nbsp;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#afa6bb6b87f93185e1512bc25216b37df">key_compare</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the comparison object. </p>

</div>
</div>
<a id="a2173cac0b26bf9cdc6a11d7990ed8c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2173cac0b26bf9cdc6a11d7990ed8c50">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="ab1b45c773ae10bc33f9e02489a6b96ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b45c773ae10bc33f9e02489a6b96ae">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="a83375d6d39451636c0979c06d365b54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83375d6d39451636c0979c06d365b54c">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="aae7d2cfaa13474b1163ef8e687d3bf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7d2cfaa13474b1163ef8e687d3bf33">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="a0ec79ed0fd4cef7e0844deac4aa3aedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec79ed0fd4cef7e0844deac4aa3aedd">&#9670;&nbsp;</a></span>lower_bound_pos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::lower_bound_pos </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; size_t  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the first element that compares not less (i.e. greater or equal) to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="a22f4b3ed5334be19de998d70e4a7ba39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f4b3ed5334be19de998d70e4a7ba39">&#9670;&nbsp;</a></span>lower_bound_pos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::lower_bound_pos </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; size_t  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="ae93a8ed38a83b36d0a89ca600395aa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93a8ed38a83b36d0a89ca600395aa22">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container maximum size. </p>

</div>
</div>
<a id="a9050125cbdb0a07737350da1feb32086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9050125cbdb0a07737350da1feb32086">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class C2 , LayoutManagement layout2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, C2, Allocator, layout2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to extract each element in source and insert it into this using the comparison object of this. If there is an element in this with key equivalent to the key of an element from source, then that element is not extracted from source. Note that elements from source are moved to this. </p>

</div>
</div>
<a id="a1b9cc850f1e573e675f3d3245db82485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9cc850f1e573e675f3d3245db82485">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this container </dd></dl>

</div>
</div>
<a id="a4f4b686521bb9cc5d0507e917627fe68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4b686521bb9cc5d0507e917627fe68">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this container </dd></dl>

</div>
</div>
<a id="a296d675a8e4951def139df9fe800529e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296d675a8e4951def139df9fe800529e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html">flat_set</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign initializer-list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this container </dd></dl>

</div>
</div>
<a id="ab50bb3faf656740d6080aab6569990f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50bb3faf656740d6080aab6569990f9">&#9670;&nbsp;</a></span>pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::pos </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const -&gt; const <a class="el" href="classseq_1_1flat__set.html#aeacbd6819f205822a6c898e5257dad95">value_type</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value at given flat position. </p>

</div>
</div>
<a id="acb102fa22655897552043a5646f7a56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb102fa22655897552043a5646f7a56f">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a6ddfd7f5e28cc93df7988ac58974c356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddfd7f5e28cc93df7988ac58974c356">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="ab0dd447617ab7d75b2ef5bab57b83989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dd447617ab7d75b2ef5bab57b83989">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a25ad7f5537b59b28ec7fd2a4ab32df07">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="ab5b22892f760277490febbbd0eeef3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b22892f760277490febbbd0eeef3a8">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#aeb1957a91d7d434300b953843676c2ed">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a23c8886d204becfa074d92ce15c1874d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c8886d204becfa074d92ce15c1874d">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a30f202fe21ed7de6f559b38740fe0b5a">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size. </p>

</div>
</div>
<a id="a38209b2ae8d2ff7d4e84f4daf76983ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38209b2ae8d2ff7d4e84f4daf76983ff">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the container. This function sort again the container only if: </p>
<ul>
<li>The container is dirty (because of <a class="el" href="classseq_1_1flat__set.html#a9fa7fbd752589e8564aa0c3ad67dbc7e" title="Returns the underlying tiered_vector. Calling this function will mark the container as dirty...">flat_set::tvector()</a> calls) and</li>
<li>the container is not already sorted. This function also remove duplicates if necessary. </li>
</ul>

</div>
</div>
<a id="a5abfe0f7dd40f799cbe7aad1dfe95257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abfe0f7dd40f799cbe7aad1dfe95257">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1flat__set.html">flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap this container's content with another. Iterators to both containers remain valid, including end iterators. </p>

</div>
</div>
<a id="a9fa7fbd752589e8564aa0c3ad67dbc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa7fbd752589e8564aa0c3ad67dbc7e">&#9670;&nbsp;</a></span>tvector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::tvector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. Calling this function will mark the container as dirty. Any further attempts to call members like <a class="el" href="classseq_1_1flat__set.html#aabcb0e7c7ad9bf0bdb5c548eda361306" title="Finds an element with key that compares equivalent to the value key. This overload participates in ov...">find()</a>, lower_bound, upper_bound... will raise a std::logic_error. To mark the container as non dirty anymore, the user must call <a class="el" href="classseq_1_1flat__set.html#a38209b2ae8d2ff7d4e84f4daf76983ff" title="Sort the container. This function sort again the container only if: ">flat_set::sort()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">seq::tiered_vector</a> object </dd></dl>

</div>
</div>
<a id="a64ecee637d5934dd496bb1516f0e85c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ecee637d5934dd496bb1516f0e85c8">&#9670;&nbsp;</a></span>tvector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::tvector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const <a class="el" href="classseq_1_1flat__set.html#a21b0bac611ecd8732e6282084f533b9c">deque_type</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector. ...">tiered_vector</a>. The container will NOT be marked as dirty. </p>

</div>
</div>
<a id="af0121f5a6e358530f708c4558fe5c4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0121f5a6e358530f708c4558fe5c4bc">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="aa31aca82caf521823b1737444657fe3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31aca82caf521823b1737444657fe3e">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1flat__set.html#a77879fbd7d9f8f9e59c1ff8b4d2ea144">iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="afe42865ce80bd40c8a5f90916d7a4367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe42865ce80bd40c8a5f90916d7a4367">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="a98e42fb2055408052db9f10750994e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e42fb2055408052db9f10750994e69">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1flat__set.html#a999dddbf15eb6553aa7e91be08ce6222">const_iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="a7187e79a36f33a8e356cbc19619c786e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7187e79a36f33a8e356cbc19619c786e">&#9670;&nbsp;</a></span>upper_bound_pos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<div class="memtemplate">
template&lt;class K , class LE  = Compare, typename std::enable_if&lt; has_is_transparent&lt; LE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::upper_bound_pos </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; size_t  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the first element that compares greater to the value key. This overload participates in overload resolution only if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key. </p>

</div>
</div>
<a id="a9d86c7d68a8ff523e82232be2b0eb404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d86c7d68a8ff523e82232be2b0eb404">&#9670;&nbsp;</a></span>upper_bound_pos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, bool Stable = false, bool Unique = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1flat__set.html">seq::flat_set</a>&lt; Key, Compare, Allocator, Stable, Unique &gt;::upper_bound_pos </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; size_t  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the first element that is greater than key. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="flat__map_8hpp_source.html">flat_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1flat__set.html">flat_set</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
