<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::ordered_set&lt; Key, Hash, KeyEqual, Allocator, Layout &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classseq_1_1ordered__set.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseq_1_1ordered__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::ordered_set&lt; Key, Hash, KeyEqual, Allocator, Layout &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.  
 <a href="classseq_1_1ordered__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ordered__map_8hpp_source.html">ordered_map.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html">seq::detail::SparseFlatNodeHashTable&lt; Key, Key, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, std::allocator&lt; Key &gt;, OptimizeForSpeed &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af9cd9e0271ca9e938e1d128522da7b41"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#af9cd9e0271ca9e938e1d128522da7b41">sequence_type</a> = typename <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a98d750db6b916e5c8c9d287a31c79f6c">base_type::sequence_type</a></td></tr>
<tr class="separator:af9cd9e0271ca9e938e1d128522da7b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac624ed3f3e8da177bf1cc5d8d5933a77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a> = <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="separator:ac624ed3f3e8da177bf1cc5d8d5933a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df3f900aa837aab6177961dd338c1b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a8df3f900aa837aab6177961dd338c1b6">key_type</a> = Key</td></tr>
<tr class="separator:a8df3f900aa837aab6177961dd338c1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f3080d8f641e7a405a0c6cfb3f953d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> = Key</td></tr>
<tr class="separator:a09f3080d8f641e7a405a0c6cfb3f953d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fdf0cb0cfbd9e15e6c9d72c2dde6fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a73fdf0cb0cfbd9e15e6c9d72c2dde6fd">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a73fdf0cb0cfbd9e15e6c9d72c2dde6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db22b9060c55bae803daa77fb21a6f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a> = size_t</td></tr>
<tr class="separator:a14db22b9060c55bae803daa77fb21a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5395a6fe5848dd040ffb3e59d3f6c3c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#aa5395a6fe5848dd040ffb3e59d3f6c3c">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="separator:aa5395a6fe5848dd040ffb3e59d3f6c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878f53e048251a95c495145448f628f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a878f53e048251a95c495145448f628f5">hasher</a> = Hash</td></tr>
<tr class="separator:a878f53e048251a95c495145448f628f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233a269648da39723d38745330132eed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a> = KeyEqual</td></tr>
<tr class="separator:a233a269648da39723d38745330132eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8006e5f056b3fb50a17d0bf3df9ac2ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a8006e5f056b3fb50a17d0bf3df9ac2ad">reference</a> = <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;</td></tr>
<tr class="separator:a8006e5f056b3fb50a17d0bf3df9ac2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87adb9393e20f2c19129bf916f512dbc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a87adb9393e20f2c19129bf916f512dbc">const_reference</a> = const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;</td></tr>
<tr class="separator:a87adb9393e20f2c19129bf916f512dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad784defbe06bd89595059b376df90062"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ad784defbe06bd89595059b376df90062">pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1ordered__set.html#ad784defbe06bd89595059b376df90062">pointer</a></td></tr>
<tr class="separator:ad784defbe06bd89595059b376df90062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f08d42969711a69c876b66cbc87b500"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a4f08d42969711a69c876b66cbc87b500">const_pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1ordered__set.html#a4f08d42969711a69c876b66cbc87b500">const_pointer</a></td></tr>
<tr class="separator:a4f08d42969711a69c876b66cbc87b500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432ef60eab5f87e4ed9293dc2c893cbc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a432ef60eab5f87e4ed9293dc2c893cbc">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a> &gt;</td></tr>
<tr class="separator:a432ef60eab5f87e4ed9293dc2c893cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aa2c4d6b23b4782bd5f84f9edec62f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a77aa2c4d6b23b4782bd5f84f9edec62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a96ea410f4493eee72013cfc7b6305b77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a96ea410f4493eee72013cfc7b6305b77">ordered_set</a> (const Hash &amp;<a class="el" href="structseq_1_1detail_1_1_hash_equal.html#a7783d856c913420c1ee4b2a921b48b2f">hash</a>=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator()) noexcept</td></tr>
<tr class="memdesc:a96ea410f4493eee72013cfc7b6305b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty container. Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6.  <a href="classseq_1_1ordered__set.html#a96ea410f4493eee72013cfc7b6305b77">More...</a><br /></td></tr>
<tr class="separator:a96ea410f4493eee72013cfc7b6305b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9179dfd353fd9781409d2cc92006fb24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a9179dfd353fd9781409d2cc92006fb24">ordered_set</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a9179dfd353fd9781409d2cc92006fb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty container. Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6.  <a href="classseq_1_1ordered__set.html#a9179dfd353fd9781409d2cc92006fb24">More...</a><br /></td></tr>
<tr class="separator:a9179dfd353fd9781409d2cc92006fb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6bcc81b7efdb3553fe0ff3b36af990"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a6f6bcc81b7efdb3553fe0ff3b36af990"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a6f6bcc81b7efdb3553fe0ff3b36af990">ordered_set</a> (InputIt first, InputIt last, const Hash &amp;<a class="el" href="structseq_1_1detail_1_1_hash_equal.html#a7783d856c913420c1ee4b2a921b48b2f">hash</a>=Hash(), const <a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a> &amp;equal=<a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a>(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a6f6bcc81b7efdb3553fe0ff3b36af990"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs the container with the contents of the range [first, last). Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved.  <a href="classseq_1_1ordered__set.html#a6f6bcc81b7efdb3553fe0ff3b36af990">More...</a><br /></td></tr>
<tr class="separator:a6f6bcc81b7efdb3553fe0ff3b36af990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f84ee00fc14d4117d6f1b94ed93e0a"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ac7f84ee00fc14d4117d6f1b94ed93e0a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ac7f84ee00fc14d4117d6f1b94ed93e0a">ordered_set</a> (InputIt first, InputIt last, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:ac7f84ee00fc14d4117d6f1b94ed93e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs the container with the contents of the range [first, last). Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved.  <a href="classseq_1_1ordered__set.html#ac7f84ee00fc14d4117d6f1b94ed93e0a">More...</a><br /></td></tr>
<tr class="separator:ac7f84ee00fc14d4117d6f1b94ed93e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae695e84589fc08e4c9f9bbc32ef9bc15"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ae695e84589fc08e4c9f9bbc32ef9bc15"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ae695e84589fc08e4c9f9bbc32ef9bc15">ordered_set</a> (InputIt first, InputIt last, const Hash &amp;<a class="el" href="structseq_1_1detail_1_1_hash_equal.html#a7783d856c913420c1ee4b2a921b48b2f">hash</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:ae695e84589fc08e4c9f9bbc32ef9bc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs the container with the contents of the range [first, last). Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved.  <a href="classseq_1_1ordered__set.html#ae695e84589fc08e4c9f9bbc32ef9bc15">More...</a><br /></td></tr>
<tr class="separator:ae695e84589fc08e4c9f9bbc32ef9bc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19292e709db9f5932a5fb15d4241924a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a19292e709db9f5932a5fb15d4241924a">ordered_set</a> (const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a19292e709db9f5932a5fb15d4241924a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1ordered__set.html#a19292e709db9f5932a5fb15d4241924a">More...</a><br /></td></tr>
<tr class="separator:a19292e709db9f5932a5fb15d4241924a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a9e6f92a609ee74b285938413e0850"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a98a9e6f92a609ee74b285938413e0850">ordered_set</a> (const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> &amp;other)</td></tr>
<tr class="memdesc:a98a9e6f92a609ee74b285938413e0850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1ordered__set.html#a98a9e6f92a609ee74b285938413e0850">More...</a><br /></td></tr>
<tr class="separator:a98a9e6f92a609ee74b285938413e0850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e87480d5c9721a44724f350abcbd2bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a1e87480d5c9721a44724f350abcbd2bb">ordered_set</a> (<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a1e87480d5c9721a44724f350abcbd2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classseq_1_1ordered__set.html#a1e87480d5c9721a44724f350abcbd2bb">More...</a><br /></td></tr>
<tr class="separator:a1e87480d5c9721a44724f350abcbd2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdb40f76a9f82431b70484dc786c25f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a2bdb40f76a9f82431b70484dc786c25f">ordered_set</a> (<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a2bdb40f76a9f82431b70484dc786c25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classseq_1_1ordered__set.html#a2bdb40f76a9f82431b70484dc786c25f">More...</a><br /></td></tr>
<tr class="separator:a2bdb40f76a9f82431b70484dc786c25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011127b90b2248894df0fe2456bf7a7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a011127b90b2248894df0fe2456bf7a7a">ordered_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &gt; init, const Hash &amp;<a class="el" href="structseq_1_1detail_1_1_hash_equal.html#a7783d856c913420c1ee4b2a921b48b2f">hash</a>=Hash(), const <a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a> &amp;equal=<a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a>(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a011127b90b2248894df0fe2456bf7a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec56dda7502a497016d12d495ae2ade"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a5ec56dda7502a497016d12d495ae2ade">ordered_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &gt; init, const Hash &amp;<a class="el" href="structseq_1_1detail_1_1_hash_equal.html#a7783d856c913420c1ee4b2a921b48b2f">hash</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a5ec56dda7502a497016d12d495ae2ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs the container with the contents of the initializer list init, same as <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a>(init.begin(), init.end())  <a href="classseq_1_1ordered__set.html#a5ec56dda7502a497016d12d495ae2ade">More...</a><br /></td></tr>
<tr class="separator:a5ec56dda7502a497016d12d495ae2ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af783eef5a121f45a78b9aa1bd64a4e1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#af783eef5a121f45a78b9aa1bd64a4e1f">ordered_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &gt; init, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:af783eef5a121f45a78b9aa1bd64a4e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs the container with the contents of the initializer list init, same as <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a>(init.begin(), init.end())  <a href="classseq_1_1ordered__set.html#af783eef5a121f45a78b9aa1bd64a4e1f">More...</a><br /></td></tr>
<tr class="separator:af783eef5a121f45a78b9aa1bd64a4e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be5fbe03ed3b3f03b71348550985d09"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a6be5fbe03ed3b3f03b71348550985d09">operator=</a> (const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> &amp;other) -&gt; <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> &amp;</td></tr>
<tr class="memdesc:a6be5fbe03ed3b3f03b71348550985d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classseq_1_1ordered__set.html#a6be5fbe03ed3b3f03b71348550985d09">More...</a><br /></td></tr>
<tr class="separator:a6be5fbe03ed3b3f03b71348550985d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2575a6950a9e2a41ea7f0b073fde1134"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a2575a6950a9e2a41ea7f0b073fde1134">operator=</a> (<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> &amp;</td></tr>
<tr class="memdesc:a2575a6950a9e2a41ea7f0b073fde1134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classseq_1_1ordered__set.html#a2575a6950a9e2a41ea7f0b073fde1134">More...</a><br /></td></tr>
<tr class="separator:a2575a6950a9e2a41ea7f0b073fde1134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ebe2df7d623875a764a0d83e8cc067"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a12ebe2df7d623875a764a0d83e8cc067">size</a> () const noexcept -&gt; size_t</td></tr>
<tr class="memdesc:a12ebe2df7d623875a764a0d83e8cc067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size.  <a href="classseq_1_1ordered__set.html#a12ebe2df7d623875a764a0d83e8cc067">More...</a><br /></td></tr>
<tr class="separator:a12ebe2df7d623875a764a0d83e8cc067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0e2d5eea7bd8904e5859584dc1e6cf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a0e0e2d5eea7bd8904e5859584dc1e6cf">max_size</a> () const noexcept -&gt; size_t</td></tr>
<tr class="memdesc:a0e0e2d5eea7bd8904e5859584dc1e6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size.  <a href="classseq_1_1ordered__set.html#a0e0e2d5eea7bd8904e5859584dc1e6cf">More...</a><br /></td></tr>
<tr class="separator:a0e0e2d5eea7bd8904e5859584dc1e6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bfb5bafad2839efbc66abdc1fd831c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ae6bfb5bafad2839efbc66abdc1fd831c">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:ae6bfb5bafad2839efbc66abdc1fd831c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the container is empty, false otherwise.  <a href="classseq_1_1ordered__set.html#ae6bfb5bafad2839efbc66abdc1fd831c">More...</a><br /></td></tr>
<tr class="separator:ae6bfb5bafad2839efbc66abdc1fd831c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfdbedce5753271a2a3e5ff2fcb6ffd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a0cfdbedce5753271a2a3e5ff2fcb6ffd">max_probe_distance</a> () const noexcept -&gt; int</td></tr>
<tr class="memdesc:a0cfdbedce5753271a2a3e5ff2fcb6ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current maximum possible probe distance.  <a href="classseq_1_1ordered__set.html#a0cfdbedce5753271a2a3e5ff2fcb6ffd">More...</a><br /></td></tr>
<tr class="separator:a0cfdbedce5753271a2a3e5ff2fcb6ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bc92e7739a3fc48b904dd1539766a3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ac6bc92e7739a3fc48b904dd1539766a3">load_factor</a> () const noexcept -&gt; float</td></tr>
<tr class="memdesc:ac6bc92e7739a3fc48b904dd1539766a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current load factor.  <a href="classseq_1_1ordered__set.html#ac6bc92e7739a3fc48b904dd1539766a3">More...</a><br /></td></tr>
<tr class="separator:ac6bc92e7739a3fc48b904dd1539766a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fb96b6026596a42b0a186260086f91"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ac7fb96b6026596a42b0a186260086f91">max_load_factor</a> () const noexcept -&gt; float</td></tr>
<tr class="memdesc:ac7fb96b6026596a42b0a186260086f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current maximum load factor.  <a href="classseq_1_1ordered__set.html#ac7fb96b6026596a42b0a186260086f91">More...</a><br /></td></tr>
<tr class="separator:ac7fb96b6026596a42b0a186260086f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403cd189fba893ab4f06b6cb28247288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a403cd189fba893ab4f06b6cb28247288">max_load_factor</a> (float f) noexcept</td></tr>
<tr class="memdesc:a403cd189fba893ab4f06b6cb28247288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum load factor.  <a href="classseq_1_1ordered__set.html#a403cd189fba893ab4f06b6cb28247288">More...</a><br /></td></tr>
<tr class="separator:a403cd189fba893ab4f06b6cb28247288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5e2b5a3370aac53a5271774edb1c3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a2bd5e2b5a3370aac53a5271774edb1c3">get_allocator</a> () noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#a73fdf0cb0cfbd9e15e6c9d72c2dde6fd">allocator_type</a> &amp;</td></tr>
<tr class="memdesc:a2bd5e2b5a3370aac53a5271774edb1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container allocator object.  <a href="classseq_1_1ordered__set.html#a2bd5e2b5a3370aac53a5271774edb1c3">More...</a><br /></td></tr>
<tr class="separator:a2bd5e2b5a3370aac53a5271774edb1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b0f4e76ebb8ecd31bb850a904ae76d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a19b0f4e76ebb8ecd31bb850a904ae76d">get_allocator</a> () const noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#a73fdf0cb0cfbd9e15e6c9d72c2dde6fd">allocator_type</a></td></tr>
<tr class="memdesc:a19b0f4e76ebb8ecd31bb850a904ae76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container allocator object.  <a href="classseq_1_1ordered__set.html#a19b0f4e76ebb8ecd31bb850a904ae76d">More...</a><br /></td></tr>
<tr class="separator:a19b0f4e76ebb8ecd31bb850a904ae76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff53fface88ca6650d8a45c49db24798"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#aff53fface88ca6650d8a45c49db24798">hash_function</a> () const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a878f53e048251a95c495145448f628f5">hasher</a></td></tr>
<tr class="memdesc:aff53fface88ca6650d8a45c49db24798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash function.  <a href="classseq_1_1ordered__set.html#aff53fface88ca6650d8a45c49db24798">More...</a><br /></td></tr>
<tr class="separator:aff53fface88ca6650d8a45c49db24798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add28814de268def7f2a41f5cac43e3dd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#add28814de268def7f2a41f5cac43e3dd">key_eq</a> () const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a></td></tr>
<tr class="memdesc:add28814de268def7f2a41f5cac43e3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the equality comparison function.  <a href="classseq_1_1ordered__set.html#add28814de268def7f2a41f5cac43e3dd">More...</a><br /></td></tr>
<tr class="separator:add28814de268def7f2a41f5cac43e3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b1dd7454c03a4b6a4d8e5f08dc7adb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#af1b1dd7454c03a4b6a4d8e5f08dc7adb">sequence</a> () noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#af9cd9e0271ca9e938e1d128522da7b41">sequence_type</a> &amp;</td></tr>
<tr class="memdesc:af1b1dd7454c03a4b6a4d8e5f08dc7adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying sequence object. Calling this function will mark the container as dirty. Any further attempts to call members like <a class="el" href="classseq_1_1ordered__set.html#ac7b344d232a85339ae3633c6aaefd1e3" title="Finds an element with key equivalent to key.">find()</a> or <a class="el" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c" title="Inserts element into the container, if the container doesn&#39;t already contain an element with an equiv...">insert()</a> (relying on the hash function) will raise a std::logic_error. To mark the container as non dirty anymore, the user must call <a class="el" href="classseq_1_1ordered__set.html#a2bb1f28b32c0c6c0422540b7986a49b0" title="Rehash the container. This function triggers a full rehash if:">ordered_set::rehash()</a>.  <a href="classseq_1_1ordered__set.html#af1b1dd7454c03a4b6a4d8e5f08dc7adb">More...</a><br /></td></tr>
<tr class="separator:af1b1dd7454c03a4b6a4d8e5f08dc7adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f4ce86306098d218e2c1154a910870"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a56f4ce86306098d218e2c1154a910870">sequence</a> () const noexcept -&gt; const <a class="el" href="classseq_1_1ordered__set.html#af9cd9e0271ca9e938e1d128522da7b41">sequence_type</a> &amp;</td></tr>
<tr class="memdesc:a56f4ce86306098d218e2c1154a910870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying sequence object. Do NOT mark the container as dirty.  <a href="classseq_1_1ordered__set.html#a56f4ce86306098d218e2c1154a910870">More...</a><br /></td></tr>
<tr class="separator:a56f4ce86306098d218e2c1154a910870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f5605cb65e30201fcf7eed2355ece5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a94f5605cb65e30201fcf7eed2355ece5">csequence</a> () const noexcept -&gt; const <a class="el" href="classseq_1_1ordered__set.html#af9cd9e0271ca9e938e1d128522da7b41">sequence_type</a> &amp;</td></tr>
<tr class="memdesc:a94f5605cb65e30201fcf7eed2355ece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying sequence object. Do NOT mark the container as dirty.  <a href="classseq_1_1ordered__set.html#a94f5605cb65e30201fcf7eed2355ece5">More...</a><br /></td></tr>
<tr class="separator:a94f5605cb65e30201fcf7eed2355ece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefb4c70eac4ca5123ade8a3af80a6c1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#acefb4c70eac4ca5123ade8a3af80a6c1">end</a> () noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a></td></tr>
<tr class="memdesc:acefb4c70eac4ca5123ade8a3af80a6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1ordered__set.html#acefb4c70eac4ca5123ade8a3af80a6c1">More...</a><br /></td></tr>
<tr class="separator:acefb4c70eac4ca5123ade8a3af80a6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97417c28fec1bdc54feec7cf2800b0a4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a97417c28fec1bdc54feec7cf2800b0a4">end</a> () const noexcept -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:a97417c28fec1bdc54feec7cf2800b0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1ordered__set.html#a97417c28fec1bdc54feec7cf2800b0a4">More...</a><br /></td></tr>
<tr class="separator:a97417c28fec1bdc54feec7cf2800b0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07117fffb2a77323fb69e5b198f4d43"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ad07117fffb2a77323fb69e5b198f4d43">cend</a> () const noexcept -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:ad07117fffb2a77323fb69e5b198f4d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1ordered__set.html#ad07117fffb2a77323fb69e5b198f4d43">More...</a><br /></td></tr>
<tr class="separator:ad07117fffb2a77323fb69e5b198f4d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca04d7c527900e08c38203940889b8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a21ca04d7c527900e08c38203940889b8">begin</a> () noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a></td></tr>
<tr class="memdesc:a21ca04d7c527900e08c38203940889b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1ordered__set.html#a21ca04d7c527900e08c38203940889b8">More...</a><br /></td></tr>
<tr class="separator:a21ca04d7c527900e08c38203940889b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbeab9873ae41f1a96212ce273c5e8f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a4dbeab9873ae41f1a96212ce273c5e8f">begin</a> () const noexcept -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:a4dbeab9873ae41f1a96212ce273c5e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1ordered__set.html#a4dbeab9873ae41f1a96212ce273c5e8f">More...</a><br /></td></tr>
<tr class="separator:a4dbeab9873ae41f1a96212ce273c5e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b0670ce78d994a309bc14a912f4c44"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#aa8b0670ce78d994a309bc14a912f4c44">cbegin</a> () const noexcept -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:aa8b0670ce78d994a309bc14a912f4c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1ordered__set.html#aa8b0670ce78d994a309bc14a912f4c44">More...</a><br /></td></tr>
<tr class="separator:aa8b0670ce78d994a309bc14a912f4c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aba4efa615411f6d42d2a0ea32537b5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a4aba4efa615411f6d42d2a0ea32537b5">rbegin</a> () noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#a432ef60eab5f87e4ed9293dc2c893cbc">reverse_iterator</a></td></tr>
<tr class="memdesc:a4aba4efa615411f6d42d2a0ea32537b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1ordered__set.html#a4aba4efa615411f6d42d2a0ea32537b5">More...</a><br /></td></tr>
<tr class="separator:a4aba4efa615411f6d42d2a0ea32537b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b4bd0e5dd6e4fa694833edf2a2141d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a46b4bd0e5dd6e4fa694833edf2a2141d">rbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a46b4bd0e5dd6e4fa694833edf2a2141d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1ordered__set.html#a46b4bd0e5dd6e4fa694833edf2a2141d">More...</a><br /></td></tr>
<tr class="separator:a46b4bd0e5dd6e4fa694833edf2a2141d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe18df0c4c2845f5037ec4c9fb3d311"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a3fe18df0c4c2845f5037ec4c9fb3d311">crbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a3fe18df0c4c2845f5037ec4c9fb3d311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1ordered__set.html#a3fe18df0c4c2845f5037ec4c9fb3d311">More...</a><br /></td></tr>
<tr class="separator:a3fe18df0c4c2845f5037ec4c9fb3d311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4ec861f743e02c59e959933bd5e8cf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ade4ec861f743e02c59e959933bd5e8cf">rend</a> () noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#a432ef60eab5f87e4ed9293dc2c893cbc">reverse_iterator</a></td></tr>
<tr class="memdesc:ade4ec861f743e02c59e959933bd5e8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1ordered__set.html#ade4ec861f743e02c59e959933bd5e8cf">More...</a><br /></td></tr>
<tr class="separator:ade4ec861f743e02c59e959933bd5e8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ea6f4b63cae7476f3f0193d3a1e3ae"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a41ea6f4b63cae7476f3f0193d3a1e3ae">rend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a41ea6f4b63cae7476f3f0193d3a1e3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1ordered__set.html#a41ea6f4b63cae7476f3f0193d3a1e3ae">More...</a><br /></td></tr>
<tr class="separator:a41ea6f4b63cae7476f3f0193d3a1e3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c2710fbe35338d53ada9cd05ddbe60"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a68c2710fbe35338d53ada9cd05ddbe60">crend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a68c2710fbe35338d53ada9cd05ddbe60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1ordered__set.html#a68c2710fbe35338d53ada9cd05ddbe60">More...</a><br /></td></tr>
<tr class="separator:a68c2710fbe35338d53ada9cd05ddbe60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e9b089e85777a7b1e0eb27ec05a51a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a26e9b089e85777a7b1e0eb27ec05a51a">clear</a> ()</td></tr>
<tr class="memdesc:a26e9b089e85777a7b1e0eb27ec05a51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the container.  <a href="classseq_1_1ordered__set.html#a26e9b089e85777a7b1e0eb27ec05a51a">More...</a><br /></td></tr>
<tr class="separator:a26e9b089e85777a7b1e0eb27ec05a51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb1f28b32c0c6c0422540b7986a49b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a2bb1f28b32c0c6c0422540b7986a49b0">rehash</a> ()</td></tr>
<tr class="memdesc:a2bb1f28b32c0c6c0422540b7986a49b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehash the container. This function triggers a full rehash if:  <a href="classseq_1_1ordered__set.html#a2bb1f28b32c0c6c0422540b7986a49b0">More...</a><br /></td></tr>
<tr class="separator:a2bb1f28b32c0c6c0422540b7986a49b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc52f5ac410c23469f67314d85fc96f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a4fc52f5ac410c23469f67314d85fc96f">reserve</a> (size_t <a class="el" href="classseq_1_1ordered__set.html#ad714ae153e4ab88f4473fb16f118f1d4">count</a>)</td></tr>
<tr class="memdesc:a4fc52f5ac410c23469f67314d85fc96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of nodes to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container.  <a href="classseq_1_1ordered__set.html#a4fc52f5ac410c23469f67314d85fc96f">More...</a><br /></td></tr>
<tr class="separator:a4fc52f5ac410c23469f67314d85fc96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c0514644286c8155f35d87dab0e3e9"><td class="memTemplParams" colspan="2">template&lt;class Less &gt; </td></tr>
<tr class="memitem:ad8c0514644286c8155f35d87dab0e3e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ad8c0514644286c8155f35d87dab0e3e9">sort</a> (Less le)</td></tr>
<tr class="memdesc:ad8c0514644286c8155f35d87dab0e3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container based on given comparator. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only.  <a href="classseq_1_1ordered__set.html#ad8c0514644286c8155f35d87dab0e3e9">More...</a><br /></td></tr>
<tr class="separator:ad8c0514644286c8155f35d87dab0e3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a66b34dafa44d2f963a201272b2d24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a36a66b34dafa44d2f963a201272b2d24">sort</a> ()</td></tr>
<tr class="memdesc:a36a66b34dafa44d2f963a201272b2d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container using std::less&lt;Key&gt;. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only.  <a href="classseq_1_1ordered__set.html#a36a66b34dafa44d2f963a201272b2d24">More...</a><br /></td></tr>
<tr class="separator:a36a66b34dafa44d2f963a201272b2d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23ceeda63ee924eae70f4f2a40e6b7d"><td class="memTemplParams" colspan="2">template&lt;class Less &gt; </td></tr>
<tr class="memitem:aa23ceeda63ee924eae70f4f2a40e6b7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#aa23ceeda63ee924eae70f4f2a40e6b7d">stable_sort</a> (Less le)</td></tr>
<tr class="memdesc:aa23ceeda63ee924eae70f4f2a40e6b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container based on given comparator and using std::stable_sort. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only.  <a href="classseq_1_1ordered__set.html#aa23ceeda63ee924eae70f4f2a40e6b7d">More...</a><br /></td></tr>
<tr class="separator:aa23ceeda63ee924eae70f4f2a40e6b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64707af69a6b261413d1325c8f35d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ae64707af69a6b261413d1325c8f35d30">stable_sort</a> ()</td></tr>
<tr class="memdesc:ae64707af69a6b261413d1325c8f35d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the container based on std::less&lt;Key&gt; and using std::stable_sort. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only.  <a href="classseq_1_1ordered__set.html#ae64707af69a6b261413d1325c8f35d30">More...</a><br /></td></tr>
<tr class="separator:ae64707af69a6b261413d1325c8f35d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ba901e3b3b3be36be8a12156f4614e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a13ba901e3b3b3be36be8a12156f4614e">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a13ba901e3b3b3be36be8a12156f4614e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classseq_1_1sequence.html#a1bf494125859119c2748a7a5e59588fa" title="Pack the sequence to remove empty slots and release unused memory. All empty slots created by calls t...">seq::sequence::shrink_to_fit()</a>. Remove potential holes in the sequence object due to calls to <a class="el" href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0" title="Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs...">ordered_set::erase()</a>. Does not allocate memory, except for the hash table itself. Invalidate all references and iterators. Basic exception guarantee only.  <a href="classseq_1_1ordered__set.html#a13ba901e3b3b3be36be8a12156f4614e">More...</a><br /></td></tr>
<tr class="separator:a13ba901e3b3b3be36be8a12156f4614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768027febcc0b8e7df4465815510715d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a768027febcc0b8e7df4465815510715d">swap</a> (<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> &amp;other)</td></tr>
<tr class="memdesc:a768027febcc0b8e7df4465815510715d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this container with other.  <a href="classseq_1_1ordered__set.html#a768027febcc0b8e7df4465815510715d">More...</a><br /></td></tr>
<tr class="separator:a768027febcc0b8e7df4465815510715d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44832bcf734eb3797689cb299683954"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa44832bcf734eb3797689cb299683954"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#aa44832bcf734eb3797689cb299683954">emplace</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:aa44832bcf734eb3797689cb299683954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace, forwarded via std::forward&lt;Args&gt;(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#aa44832bcf734eb3797689cb299683954">More...</a><br /></td></tr>
<tr class="separator:aa44832bcf734eb3797689cb299683954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158e3ea89502cafe19dd6c86ea0d262c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a158e3ea89502cafe19dd6c86ea0d262c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a158e3ea89502cafe19dd6c86ea0d262c">emplace_hint</a> (<a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> hint, Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a></td></tr>
<tr class="memdesc:a158e3ea89502cafe19dd6c86ea0d262c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. Same as <a class="el" href="classseq_1_1ordered__set.html#aa44832bcf734eb3797689cb299683954" title="Inserts a new element into the container constructed in-place with the given args if there is no elem...">ordered_set::emplace()</a>.  <a href="classseq_1_1ordered__set.html#a158e3ea89502cafe19dd6c86ea0d262c">More...</a><br /></td></tr>
<tr class="separator:a158e3ea89502cafe19dd6c86ea0d262c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc6c320f13dbfe438907cac9a787f6c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c">insert</a> (const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:afbc6c320f13dbfe438907cac9a787f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). This function calls <a class="el" href="classseq_1_1sequence.html#a7dcbce0b90160f9479bfcb7a09f3277e" title="Insert the given element into the sequence.">seq::sequence::insert()</a> which insert the new element anywhere in the sequence, trying to fill holes left by calls to <a class="el" href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0" title="Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs...">ordered_set::erase()</a>. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c">More...</a><br /></td></tr>
<tr class="separator:afbc6c320f13dbfe438907cac9a787f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b8b075669194ee26bb1a19189b19b7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ab2b8b075669194ee26bb1a19189b19b7">insert</a> (<a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:ab2b8b075669194ee26bb1a19189b19b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container using move semantic, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). This function calls <a class="el" href="classseq_1_1sequence.html#a7dcbce0b90160f9479bfcb7a09f3277e" title="Insert the given element into the sequence.">seq::sequence::insert()</a> which insert the new element anywhere in the sequence, trying to fill holes left by calls to <a class="el" href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0" title="Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs...">ordered_set::erase()</a>. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#ab2b8b075669194ee26bb1a19189b19b7">More...</a><br /></td></tr>
<tr class="separator:ab2b8b075669194ee26bb1a19189b19b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae503b7aebc8f8b339fbcfb97147a49fb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ae503b7aebc8f8b339fbcfb97147a49fb">insert</a> (<a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> hint, const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;value) -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a></td></tr>
<tr class="memdesc:ae503b7aebc8f8b339fbcfb97147a49fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container, if the container doesn't already contain an element with an equivalent key. Same as <a class="el" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c" title="Inserts element into the container, if the container doesn&#39;t already contain an element with an equiv...">ordered_set::insert()</a>.  <a href="classseq_1_1ordered__set.html#ae503b7aebc8f8b339fbcfb97147a49fb">More...</a><br /></td></tr>
<tr class="separator:ae503b7aebc8f8b339fbcfb97147a49fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae688ce8e525fbc2c246a5ffa82598eff"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ae688ce8e525fbc2c246a5ffa82598eff">insert</a> (<a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> hint, <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a></td></tr>
<tr class="memdesc:ae688ce8e525fbc2c246a5ffa82598eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container using move semantic, if the container doesn't already contain an element with an equivalent key. Same as <a class="el" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c" title="Inserts element into the container, if the container doesn&#39;t already contain an element with an equiv...">ordered_set::insert()</a>.  <a href="classseq_1_1ordered__set.html#ae688ce8e525fbc2c246a5ffa82598eff">More...</a><br /></td></tr>
<tr class="separator:ae688ce8e525fbc2c246a5ffa82598eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97d9655ac3a0a3f954c1bfae0ddc8c3"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ad97d9655ac3a0a3f954c1bfae0ddc8c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ad97d9655ac3a0a3f954c1bfae0ddc8c3">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:ad97d9655ac3a0a3f954c1bfae0ddc8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Elements are inserted in any order. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#ad97d9655ac3a0a3f954c1bfae0ddc8c3">More...</a><br /></td></tr>
<tr class="separator:ad97d9655ac3a0a3f954c1bfae0ddc8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af008845549da85d2b5ec77e10020361f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#af008845549da85d2b5ec77e10020361f">insert</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:af008845549da85d2b5ec77e10020361f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [init.begin(), init.end()). If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Elements are inserted in any order. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#af008845549da85d2b5ec77e10020361f">More...</a><br /></td></tr>
<tr class="separator:af008845549da85d2b5ec77e10020361f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2165161b38251e5310e11b896d9cb478"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a2165161b38251e5310e11b896d9cb478"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a2165161b38251e5310e11b896d9cb478">emplace_back</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a2165161b38251e5310e11b896d9cb478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at the back of the container, constructed in-place with the given args if there is no element with the key in the container. Careful use of emplace_back allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace_back, forwarded via std::forward&lt;Args&gt;(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#a2165161b38251e5310e11b896d9cb478">More...</a><br /></td></tr>
<tr class="separator:a2165161b38251e5310e11b896d9cb478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fa8bb634a540e73eb812b233bb8eda"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a15fa8bb634a540e73eb812b233bb8eda">push_back</a> (const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a15fa8bb634a540e73eb812b233bb8eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element at the back of the container, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#a15fa8bb634a540e73eb812b233bb8eda">More...</a><br /></td></tr>
<tr class="separator:a15fa8bb634a540e73eb812b233bb8eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbe4f0a179714cf107b6d095dfd3c3b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#afbbe4f0a179714cf107b6d095dfd3c3b">push_back</a> (<a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:afbbe4f0a179714cf107b6d095dfd3c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element at the back of the container use move semantic, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#afbbe4f0a179714cf107b6d095dfd3c3b">More...</a><br /></td></tr>
<tr class="separator:afbbe4f0a179714cf107b6d095dfd3c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7b49336fa2c03a76903be72a3dc2c4"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a0b7b49336fa2c03a76903be72a3dc2c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a0b7b49336fa2c03a76903be72a3dc2c4">emplace_front</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a0b7b49336fa2c03a76903be72a3dc2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at the front of the container, constructed in-place with the given args if there is no element with the key in the container. Careful use of emplace_front allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace_front, forwarded via std::forward&lt;Args&gt;(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#a0b7b49336fa2c03a76903be72a3dc2c4">More...</a><br /></td></tr>
<tr class="separator:a0b7b49336fa2c03a76903be72a3dc2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d49aa11cdcc711db02d265b7bc606f8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a9d49aa11cdcc711db02d265b7bc606f8">push_front</a> (const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a9d49aa11cdcc711db02d265b7bc606f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element at the front of the container, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#a9d49aa11cdcc711db02d265b7bc606f8">More...</a><br /></td></tr>
<tr class="separator:a9d49aa11cdcc711db02d265b7bc606f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933f2e5e3bb45e5f1aad5d3cd28b2d05"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a933f2e5e3bb45e5f1aad5d3cd28b2d05">push_front</a> (<a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a933f2e5e3bb45e5f1aad5d3cd28b2d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element at the front of the container using move semantic, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size().  <a href="classseq_1_1ordered__set.html#a933f2e5e3bb45e5f1aad5d3cd28b2d05">More...</a><br /></td></tr>
<tr class="separator:a933f2e5e3bb45e5f1aad5d3cd28b2d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc879b0ce162396bbc1ab16c372d9d0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0">erase</a> (<a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a></td></tr>
<tr class="memdesc:a6fc879b0ce162396bbc1ab16c372d9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs.  <a href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0">More...</a><br /></td></tr>
<tr class="separator:a6fc879b0ce162396bbc1ab16c372d9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae12f5fe1790baf6d96857df2683197"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a2ae12f5fe1790baf6d96857df2683197">erase</a> (const Key &amp;key) -&gt; <a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a></td></tr>
<tr class="memdesc:a2ae12f5fe1790baf6d96857df2683197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element comparing equal to given key (if any). Iterators and references are not invalidated. Rehashing never occurs.  <a href="classseq_1_1ordered__set.html#a2ae12f5fe1790baf6d96857df2683197">More...</a><br /></td></tr>
<tr class="separator:a2ae12f5fe1790baf6d96857df2683197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee0f41eed18d8a036ec89bf460af603"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a8ee0f41eed18d8a036ec89bf460af603"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a8ee0f41eed18d8a036ec89bf460af603">erase</a> (const K &amp;x) -&gt; <a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a></td></tr>
<tr class="memdesc:a8ee0f41eed18d8a036ec89bf460af603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element comparing equal to given key (if any). Removes the element (if one exists) with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash::is_transparent and KeyEqual::is_transparent are valid and each denotes a type, and neither iterator nor <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> is implicitly convertible from K. This assumes that such Hash is callable with both K and Key type, and that the KeyEqual is transparent, which, together, allows calling this function without constructing an instance of Key.  <a href="classseq_1_1ordered__set.html#a8ee0f41eed18d8a036ec89bf460af603">More...</a><br /></td></tr>
<tr class="separator:a8ee0f41eed18d8a036ec89bf460af603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0188d696f3263e84ad3f0fa11c8e52"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a7e0188d696f3263e84ad3f0fa11c8e52">erase</a> (<a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> last) -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a></td></tr>
<tr class="memdesc:a7e0188d696f3263e84ad3f0fa11c8e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first; last), which must be a valid range in *this.  <a href="classseq_1_1ordered__set.html#a7e0188d696f3263e84ad3f0fa11c8e52">More...</a><br /></td></tr>
<tr class="separator:a7e0188d696f3263e84ad3f0fa11c8e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b344d232a85339ae3633c6aaefd1e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ac7b344d232a85339ae3633c6aaefd1e3">find</a> (const Key &amp;key) const -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:ac7b344d232a85339ae3633c6aaefd1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1ordered__set.html#ac7b344d232a85339ae3633c6aaefd1e3">More...</a><br /></td></tr>
<tr class="separator:ac7b344d232a85339ae3633c6aaefd1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e4da578f2eac9d941f150a361930a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a21e4da578f2eac9d941f150a361930a8">find</a> (const Key &amp;value) -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a></td></tr>
<tr class="memdesc:a21e4da578f2eac9d941f150a361930a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classseq_1_1ordered__set.html#a21e4da578f2eac9d941f150a361930a8">More...</a><br /></td></tr>
<tr class="separator:a21e4da578f2eac9d941f150a361930a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935fb52f076a64c43eec787022593a10"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a935fb52f076a64c43eec787022593a10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a935fb52f076a64c43eec787022593a10">find</a> (const K &amp;x) const -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:a935fb52f076a64c43eec787022593a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key. Finds an element with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash::is_transparent and KeyEqual::is_transparent are valid and each denotes a type. This assumes that such Hash is callable with both K and Key type, and that the KeyEqual is transparent, which, together, allows calling this function without constructing an instance of Key.  <a href="classseq_1_1ordered__set.html#a935fb52f076a64c43eec787022593a10">More...</a><br /></td></tr>
<tr class="separator:a935fb52f076a64c43eec787022593a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbcfa453584119f10ab4a63eb4e0e68"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0dbcfa453584119f10ab4a63eb4e0e68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a0dbcfa453584119f10ab4a63eb4e0e68">find</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a></td></tr>
<tr class="memdesc:a0dbcfa453584119f10ab4a63eb4e0e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key. Finds an element with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash::is_transparent and KeyEqual::is_transparent are valid and each denotes a type. This assumes that such Hash is callable with both K and Key type, and that the KeyEqual is transparent, which, together, allows calling this function without constructing an instance of Key.  <a href="classseq_1_1ordered__set.html#a0dbcfa453584119f10ab4a63eb4e0e68">More...</a><br /></td></tr>
<tr class="separator:a0dbcfa453584119f10ab4a63eb4e0e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad714ae153e4ab88f4473fb16f118f1d4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ad714ae153e4ab88f4473fb16f118f1d4">count</a> (const Key &amp;key) const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a></td></tr>
<tr class="memdesc:ad714ae153e4ab88f4473fb16f118f1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 of key exists, 0 otherwise.  <a href="classseq_1_1ordered__set.html#ad714ae153e4ab88f4473fb16f118f1d4">More...</a><br /></td></tr>
<tr class="separator:ad714ae153e4ab88f4473fb16f118f1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c4c8bde3697efa05e017e5d46a3dbd"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad9c4c8bde3697efa05e017e5d46a3dbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#ad9c4c8bde3697efa05e017e5d46a3dbd">count</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a></td></tr>
<tr class="memdesc:ad9c4c8bde3697efa05e017e5d46a3dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 of key exists, 0 otherwise.  <a href="classseq_1_1ordered__set.html#ad9c4c8bde3697efa05e017e5d46a3dbd">More...</a><br /></td></tr>
<tr class="separator:ad9c4c8bde3697efa05e017e5d46a3dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3437ee0e1dc0e479949b622df8671a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#add3437ee0e1dc0e479949b622df8671a">contains</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:add3437ee0e1dc0e479949b622df8671a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of key exists, false otherwise.  <a href="classseq_1_1ordered__set.html#add3437ee0e1dc0e479949b622df8671a">More...</a><br /></td></tr>
<tr class="separator:add3437ee0e1dc0e479949b622df8671a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784bc98a40616dd5676c80b3ac4430c8"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a784bc98a40616dd5676c80b3ac4430c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1ordered__set.html#a784bc98a40616dd5676c80b3ac4430c8">contains</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a784bc98a40616dd5676c80b3ac4430c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of key exists, false otherwise.  <a href="classseq_1_1ordered__set.html#a784bc98a40616dd5676c80b3ac4430c8">More...</a><br /></td></tr>
<tr class="separator:a784bc98a40616dd5676c80b3ac4430c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt;<br />
class seq::ordered_set&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;</h3>

<p>Associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Key type </td></tr>
    <tr><td class="paramname">Hash</td><td>Hash function </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>Equality comparison function </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator object </td></tr>
    <tr><td class="paramname">Layout</td><td>memory layout used by the underlying sequence object</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> is a open addressing hash table using robin hood hashing and backward shift deletion. Its main properties are:</p><ul>
<li>Keys are ordered by insertion order. Therefore, <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> provides the additional members <a class="el" href="classseq_1_1ordered__set.html#a15fa8bb634a540e73eb812b233bb8eda" title="Inserts element at the back of the container, if the container doesn&#39;t already contain an element wit...">push_back()</a>, <a class="el" href="classseq_1_1ordered__set.html#a9d49aa11cdcc711db02d265b7bc606f8" title="Inserts element at the front of the container, if the container doesn&#39;t already contain an element wi...">push_front()</a>, <a class="el" href="classseq_1_1ordered__set.html#a2165161b38251e5310e11b896d9cb478" title="Inserts a new element at the back of the container, constructed in-place with the given args if there...">emplace_back()</a> and <a class="el" href="classseq_1_1ordered__set.html#a0b7b49336fa2c03a76903be72a3dc2c4" title="Inserts a new element at the front of the container, constructed in-place with the given args if ther...">emplace_front()</a> to constrol key ordering.</li>
<li>Since the container is ordered, it is also sortable. <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> provides the additional members <a class="el" href="classseq_1_1ordered__set.html#a36a66b34dafa44d2f963a201272b2d24" title="Sort the container using std::less&lt;Key&gt;. The full container is rehashed afterward....">sort()</a> and <a class="el" href="classseq_1_1ordered__set.html#ae64707af69a6b261413d1325c8f35d30" title="Sort the container based on std::less&lt;Key&gt; and using std::stable_sort. The full container is rehashed...">stable_sort()</a> for this purpose.</li>
<li>The hash table itself basically stores iterators to a <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant removal ...">seq::sequence</a> object storing the actual values. Therefore, <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> provides <b>stable references and iterators, even on rehash</b> (unlike std::unordered_set that invalidates iterators on rehash).</li>
<li>No memory peak on rehash.</li>
<li><a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> uses robin hood probing with backard shift deletion. It does not rely on tombstones and supports high load factors.</li>
<li>It is fast and memory efficient compared to other node based hash tables (see section <b>Performances</b>), but still slower than most open addressing hash tables due to the additional indirection.</li>
</ul>
<h2><a class="anchor" id="autotoc_md32"></a>
Interface</h2>
<p><a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> provides a similar interface to std::unordered_set with the following differences:</p><ul>
<li>The bucket related functions are not implemented,</li>
<li>The default load factor is set to 0.6,</li>
<li>Additional members <a class="el" href="classseq_1_1ordered__set.html#a15fa8bb634a540e73eb812b233bb8eda" title="Inserts element at the back of the container, if the container doesn&#39;t already contain an element wit...">push_back()</a>, <a class="el" href="classseq_1_1ordered__set.html#a9d49aa11cdcc711db02d265b7bc606f8" title="Inserts element at the front of the container, if the container doesn&#39;t already contain an element wi...">push_front()</a>, <a class="el" href="classseq_1_1ordered__set.html#a2165161b38251e5310e11b896d9cb478" title="Inserts a new element at the back of the container, constructed in-place with the given args if there...">emplace_back()</a> and <a class="el" href="classseq_1_1ordered__set.html#a0b7b49336fa2c03a76903be72a3dc2c4" title="Inserts a new element at the front of the container, constructed in-place with the given args if ther...">emplace_front()</a> let you control the key ordering,</li>
<li>Additional members <a class="el" href="classseq_1_1ordered__set.html#a36a66b34dafa44d2f963a201272b2d24" title="Sort the container using std::less&lt;Key&gt;. The full container is rehashed afterward....">sort()</a> and <a class="el" href="classseq_1_1ordered__set.html#ae64707af69a6b261413d1325c8f35d30" title="Sort the container based on std::less&lt;Key&gt; and using std::stable_sort. The full container is rehashed...">stable_sort()</a> let you sort the container,</li>
<li>The member <a class="el" href="classseq_1_1ordered__set.html#af1b1dd7454c03a4b6a4d8e5f08dc7adb" title="Returns the underlying sequence object. Calling this function will mark the container as dirty....">ordered_set::sequence()</a> returns a reference to the underlying <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant removal ...">seq::sequence</a> object,</li>
<li>Its iterator and <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> types are bidirectional iterators.</li>
</ul>
<p>The underlying sequence object stores plain non const Key objects. However, in order to avoid modifying the keys through iterators (and potentially invalidating the order), both iterator and <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> types can only return const references.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Direct access to sequence</h2>
<p>Unlike most hash table implementations, it it possible to access and modify the underlying value storage directly (a <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant removal ...">seq::sequence</a> object). This possibility musy be used with great care, as modifying directly the sequence might break the hashing. When calling the non-const version of <a class="el" href="classseq_1_1ordered__set.html#af1b1dd7454c03a4b6a4d8e5f08dc7adb" title="Returns the underlying sequence object. Calling this function will mark the container as dirty....">ordered_set::sequence()</a>, the <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> will be marked as dirty, and further attempts to call functions like <a class="el" href="classseq_1_1ordered__set.html#ac7b344d232a85339ae3633c6aaefd1e3" title="Finds an element with key equivalent to key.">ordered_set::find()</a> of <a class="el" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c" title="Inserts element into the container, if the container doesn&#39;t already contain an element with an equiv...">ordered_set::insert()</a> (functions based on hash value) will throw a std::logic_error.</p>
<p>Therefore, after finishing modifying the sequence, you must call <a class="el" href="classseq_1_1ordered__set.html#a2bb1f28b32c0c6c0422540b7986a49b0" title="Rehash the container. This function triggers a full rehash if:">ordered_set::rehash()</a> to rehash the sequence, remove potential duplicates, and mark the <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> as non dirty anymore.</p>
<p>This way of modifying a <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> must be used carefully, but is way faster than multiple calls to <a class="el" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c" title="Inserts element into the container, if the container doesn&#39;t already contain an element with an equiv...">ordered_set::insert()</a> of <a class="el" href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0" title="Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs...">ordered_set::erase()</a>. For instance, it is usually faster to insert values this way than reserving the hash table ahead, except when inserting lots of duplicate keys. Example:</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; keys = ...</div>
<div class="line"> </div>
<div class="line">seq::ordered_set&lt;<span class="keywordtype">double</span>&gt; set;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i &lt; keys.size(); ++i)</div>
<div class="line">    set.sequence().insert(keys[i]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// rehash the set and remove potential duplicate values in a stable way</span></div>
<div class="line">set.rehash();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
Exception guarantee</h2>
<p>Most members of <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> provide <b>strong exception guarantee</b>, except if specified otherwise (mentionned in function documentation).</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Growth policy and load factor</h2>
<p><a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> uses a growth factor of 2 to use the fast modulo. The hash table size is multiplied by 2 each time the table load factor exceeds the given <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>. The default maximum load factor is set to 0.6 and can by set up to 0.95, which is well supported thanks to the robin hood hashing.</p>
<p>In some cases, the actual load factor can exceed the provided maximum load factor. This holds when the keys are very well distributed, and the maximum distance of a key to its computed location is low (below 8). This strategy avoids some unnecessary rehash for very strong hash function (or well distributed keys). Note however that the load factor will never exceed 0.95.</p>
<p>On rehash, the old table is deallocated before allocating the new (twice as big) one. This is possible thanks to the double storage strategy (values are stored in an independant sequence object) and avoid memory peaks.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Handling of bad hash function</h2>
<p>Like most robin hood based hash tables (ska::flat_hash_set, tsl::robin_set...), <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> uses 8 bits to store the node distance to its computed location. For a bad hash function leading to strong clustering, this 8 bits distance quickly overflows. The usual strategy in this case is to rehash the table based on the growth strategy, hopping for a better key distribution.</p>
<p>For very bad hash function (or in case of DOS attack), hash tables like ska::flat_hash_set and tsl::robin_set will keep rehashing its values and reallocating the table, until a fatal std::bad_alloc is thrown. <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> uses a different strategy to cope with such situation:</p><ul>
<li>When the distance value overflows, it is discarded and the table relies on pure linear hashing.</li>
<li>In this case, deleting an entry will create a tombstone instead of the standard backward shift deletion.</li>
<li>The linear probing behavior is kept until a call to <a class="el" href="classseq_1_1ordered__set.html#a2bb1f28b32c0c6c0422540b7986a49b0" title="Rehash the container. This function triggers a full rehash if:">ordered_set::rehash()</a> that might switch back the behavior to robin hood hashing.</li>
</ul>
<p>Therefore, a (very) bad hash function will only make the table slower but will never explode with a std::bad_alloc exception</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Deleting entries</h2>
<p><a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> uses backward shift deletion to avoid introducing tombstone, except for bad hash functions (see section above). The key lookup remains fast when deleting lots of entries, and mixed scenarios involving lots of interleaved insertion/deletion are well supported.</p>
<p>Note however that removing a key will never trigger a rehash. The user is free to rehash the <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> at any point using <a class="el" href="classseq_1_1ordered__set.html#a2bb1f28b32c0c6c0422540b7986a49b0" title="Rehash the container. This function triggers a full rehash if:">ordered_set::rehash()</a> member.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Sorting</h2>
<p>Since the <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a> is ordered by key insertion order, it makes sense to provide a function to sort it. The members <a class="el" href="classseq_1_1ordered__set.html#a36a66b34dafa44d2f963a201272b2d24" title="Sort the container using std::less&lt;Key&gt;. The full container is rehashed afterward....">ordered_set::sort()</a> and <a class="el" href="classseq_1_1ordered__set.html#ae64707af69a6b261413d1325c8f35d30" title="Sort the container based on std::less&lt;Key&gt; and using std::stable_sort. The full container is rehashed...">ordered_set::stable_sort()</a> are provided and call respectively <a class="el" href="classseq_1_1sequence.html#a0c2005c28e8537de74b4c1e588180463" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">seq::sequence::sort()</a> and <a class="el" href="classseq_1_1sequence.html#a5aaca3cd0a83c4637c28599ac55d70a0" title="Sort the sequence. The sequence is sorted using the std::less&lt;value_type&gt; comparator....">seq::sequence::stable_sort()</a>. These functions rehash the full table after sorting.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Performances</h2>
<p>Performances of <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> has been measured and compared to other node based hash tables: std::unordered_set, <a href="https://github.com/skarupke/flat_hash_map/blob/master/unordered_map.hpp">ska::unordered_set</a>, <a href="https://github.com/martinus/robin-hood-hashing">robin_hood::unordered_node_set</a> and <a href="https://github.com/greg7mdp/parallel-hashmap">phmap::node_hash_set</a> (based on abseil hash table). The following table show the results when compiled with gcc 10.1.0 (-O3) for msys2 on Windows 10, using Intel(R) Core(TM) i7-10850H at 2.70GHz. Measured operations are:</p><ul>
<li>Insert successfully 5M unique double randomly shuffled in an empty table using hash_table::insert()</li>
<li>Insert successfully 5M unique double randomly shuffled in an empty table using hash_table::insert() after reserving enough space</li>
<li>Successfully search for 5M double in random order using hash_table::find(const Key&amp;)</li>
<li>Search for 5M double not present in the table (failed lookup)</li>
<li>Walk through the full table (5M double) using iterators</li>
<li>Erase half the table in random order using hash_table::erase(iterator)</li>
<li>Perform mixed failed/successfull lookups on the remaining 2.5M keys.</li>
</ul>
<p>For each tested hash table, the maximum load factor is left to its default value, and std::hash&lt;double&gt; is used. For insert and erase operations, the program memory consumption is given. Note that the memory consumption is not the exact memory usage of the hash table, and should only bu used to measure the difference between implementations.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Hash table name </th><th class="markdownTableHeadNone">Insert </th><th class="markdownTableHeadNone">Insert (reserve) </th><th class="markdownTableHeadNone">Find (success) </th><th class="markdownTableHeadNone">Find (failed) </th><th class="markdownTableHeadNone">Iterate </th><th class="markdownTableHeadNone">Erase </th><th class="markdownTableHeadNone">Find again  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> </td><td class="markdownTableBodyNone">477 ms/145 MO </td><td class="markdownTableBodyNone">302 ms/145 MO </td><td class="markdownTableBodyNone">282 ms </td><td class="markdownTableBodyNone">188 ms </td><td class="markdownTableBodyNone">6 ms </td><td class="markdownTableBodyNone">269 ms/210 MO </td><td class="markdownTableBodyNone">166 ms  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">phmap::node_hash_set </td><td class="markdownTableBodyNone">926 ms/187 MO </td><td class="markdownTableBodyNone">492 ms/188 MO </td><td class="markdownTableBodyNone">370 ms </td><td class="markdownTableBodyNone">130 ms </td><td class="markdownTableBodyNone">96 ms </td><td class="markdownTableBodyNone">501 ms/232 MO </td><td class="markdownTableBodyNone">193 ms  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">robin_hood::unordered_node_set </td><td class="markdownTableBodyNone">598 ms/182 MO </td><td class="markdownTableBodyNone">448 ms/182 MO </td><td class="markdownTableBodyNone">394 ms </td><td class="markdownTableBodyNone">134 ms </td><td class="markdownTableBodyNone">87 ms </td><td class="markdownTableBodyNone">407 ms/259 MO </td><td class="markdownTableBodyNone">212 ms  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ska::unordered_set </td><td class="markdownTableBodyNone">1540 ms/256 MO </td><td class="markdownTableBodyNone">728 ms/256 MO </td><td class="markdownTableBodyNone">300 ms </td><td class="markdownTableBodyNone">261 ms </td><td class="markdownTableBodyNone">141 ms </td><td class="markdownTableBodyNone">513 ms/268 MO </td><td class="markdownTableBodyNone">204 ms  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::unordered_set </td><td class="markdownTableBodyNone">1844 ms/238 MO </td><td class="markdownTableBodyNone">1148 ms/231 MO </td><td class="markdownTableBodyNone">751 ms </td><td class="markdownTableBodyNone">941 ms </td><td class="markdownTableBodyNone">205 ms </td><td class="markdownTableBodyNone">868 ms/245 MO </td><td class="markdownTableBodyNone">509 ms  </td></tr>
</table>
<p><a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> is significantly faster than the other hash tables except for failed lookup, and has a lower memory overhead. Note that this benchmark does not represent all possible workloads, and additional tests must be fullfilled for specific scenarios.</p>
<p><a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">seq::ordered_set</a> uses internally and if possible compressed pointers to reduce its memory footprint. In such case, the last 16 bits of a pointer are used to store metadata. Situations where this is not possible are detected at compile time, but it is possible to manually disable this optimization by defining SEQ_NO_COMPRESSED_PTR. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a73fdf0cb0cfbd9e15e6c9d72c2dde6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fdf0cb0cfbd9e15e6c9d72c2dde6fd">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a73fdf0cb0cfbd9e15e6c9d72c2dde6fd">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f08d42969711a69c876b66cbc87b500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f08d42969711a69c876b66cbc87b500">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a4f08d42969711a69c876b66cbc87b500">const_pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1ordered__set.html#a4f08d42969711a69c876b66cbc87b500">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87adb9393e20f2c19129bf916f512dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87adb9393e20f2c19129bf916f512dbc">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a87adb9393e20f2c19129bf916f512dbc">const_reference</a> =  const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77aa2c4d6b23b4782bd5f84f9edec62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77aa2c4d6b23b4782bd5f84f9edec62f">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5395a6fe5848dd040ffb3e59d3f6c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5395a6fe5848dd040ffb3e59d3f6c3c">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#aa5395a6fe5848dd040ffb3e59d3f6c3c">difference_type</a> =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a878f53e048251a95c495145448f628f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878f53e048251a95c495145448f628f5">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a878f53e048251a95c495145448f628f5">hasher</a> =  Hash</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac624ed3f3e8da177bf1cc5d8d5933a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac624ed3f3e8da177bf1cc5d8d5933a77">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a> =  <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a233a269648da39723d38745330132eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233a269648da39723d38745330132eed">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a> =  KeyEqual</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8df3f900aa837aab6177961dd338c1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df3f900aa837aab6177961dd338c1b6">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a8df3f900aa837aab6177961dd338c1b6">key_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad784defbe06bd89595059b376df90062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad784defbe06bd89595059b376df90062">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#ad784defbe06bd89595059b376df90062">pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1ordered__set.html#ad784defbe06bd89595059b376df90062">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8006e5f056b3fb50a17d0bf3df9ac2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8006e5f056b3fb50a17d0bf3df9ac2ad">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a8006e5f056b3fb50a17d0bf3df9ac2ad">reference</a> =  <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a432ef60eab5f87e4ed9293dc2c893cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432ef60eab5f87e4ed9293dc2c893cbc">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a432ef60eab5f87e4ed9293dc2c893cbc">reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9cd9e0271ca9e938e1d128522da7b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cd9e0271ca9e938e1d128522da7b41">&#9670;&nbsp;</a></span>sequence_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#af9cd9e0271ca9e938e1d128522da7b41">sequence_type</a> =  typename <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a98d750db6b916e5c8c9d287a31c79f6c">base_type::sequence_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14db22b9060c55bae803daa77fb21a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db22b9060c55bae803daa77fb21a6f">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a> =  size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09f3080d8f641e7a405a0c6cfb3f953d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f3080d8f641e7a405a0c6cfb3f953d">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a96ea410f4493eee72013cfc7b6305b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ea410f4493eee72013cfc7b6305b77">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty container. Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>hash function to use </td></tr>
    <tr><td class="paramname">equal</td><td>comparison function to use for all key comparisons of this container </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9179dfd353fd9781409d2cc92006fb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9179dfd353fd9781409d2cc92006fb24">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty container. Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f6bcc81b7efdb3553fe0ff3b36af990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6bcc81b7efdb3553fe0ff3b36af990">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs the container with the contents of the range [first, last). Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">hash</td><td>hash function to use </td></tr>
    <tr><td class="paramname">equal</td><td>comparison function to use for all key comparisons of this container </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7f84ee00fc14d4117d6f1b94ed93e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f84ee00fc14d4117d6f1b94ed93e0a">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs the container with the contents of the range [first, last). Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae695e84589fc08e4c9f9bbc32ef9bc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae695e84589fc08e4c9f9bbc32ef9bc15">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs the container with the contents of the range [first, last). Sets <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a> to 0.6. If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Input iteration order is preserved. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">hash</td><td>hash function to use </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19292e709db9f5932a5fb15d4241924a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19292e709db9f5932a5fb15d4241924a">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98a9e6f92a609ee74b285938413e0850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a9e6f92a609ee74b285938413e0850">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e87480d5c9721a44724f350abcbd2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e87480d5c9721a44724f350abcbd2bb">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bdb40f76a9f82431b70484dc786c25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdb40f76a9f82431b70484dc786c25f">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a011127b90b2248894df0fe2456bf7a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011127b90b2248894df0fe2456bf7a7a">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ec56dda7502a497016d12d495ae2ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec56dda7502a497016d12d495ae2ade">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs the container with the contents of the initializer list init, same as <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a>(init.begin(), init.end()) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">hash</td><td>hash function to use </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af783eef5a121f45a78b9aa1bd64a4e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af783eef5a121f45a78b9aa1bd64a4e1f">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs the container with the contents of the initializer list init, same as <a class="el" href="classseq_1_1ordered__set.html" title="Associative container that contains a set of unique objects of type Key. Search, insertion,...">ordered_set</a>(init.begin(), init.end()) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4dbeab9873ae41f1a96212ce273c5e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbeab9873ae41f1a96212ce273c5e8f">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="a21ca04d7c527900e08c38203940889b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ca04d7c527900e08c38203940889b8">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="aa8b0670ce78d994a309bc14a912f4c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b0670ce78d994a309bc14a912f4c44">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="ad07117fffb2a77323fb69e5b198f4d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07117fffb2a77323fb69e5b198f4d43">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="a26e9b089e85777a7b1e0eb27ec05a51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e9b089e85777a7b1e0eb27ec05a51a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the container. </p>

</div>
</div>
<a id="a784bc98a40616dd5676c80b3ac4430c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784bc98a40616dd5676c80b3ac4430c8">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true of key exists, false otherwise. </p>

</div>
</div>
<a id="add3437ee0e1dc0e479949b622df8671a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3437ee0e1dc0e479949b622df8671a">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true of key exists, false otherwise. </p>

</div>
</div>
<a id="ad9c4c8bde3697efa05e017e5d46a3dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c4c8bde3697efa05e017e5d46a3dbd">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 of key exists, 0 otherwise. </p>

</div>
</div>
<a id="ad714ae153e4ab88f4473fb16f118f1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad714ae153e4ab88f4473fb16f118f1d4">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 of key exists, 0 otherwise. </p>

</div>
</div>
<a id="a3fe18df0c4c2845f5037ec4c9fb3d311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe18df0c4c2845f5037ec4c9fb3d311">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a68c2710fbe35338d53ada9cd05ddbe60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c2710fbe35338d53ada9cd05ddbe60">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a94f5605cb65e30201fcf7eed2355ece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f5605cb65e30201fcf7eed2355ece5">&#9670;&nbsp;</a></span>csequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::csequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const <a class="el" href="classseq_1_1ordered__set.html#af9cd9e0271ca9e938e1d128522da7b41">sequence_type</a> &amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying sequence object. Do NOT mark the container as dirty. </p>

</div>
</div>
<a id="aa44832bcf734eb3797689cb299683954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44832bcf734eb3797689cb299683954">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace, forwarded via std::forward&lt;Args&gt;(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<p>This function calls <a class="el" href="classseq_1_1sequence.html#a7dcbce0b90160f9479bfcb7a09f3277e" title="Insert the given element into the sequence.">seq::sequence::insert()</a> which insert the new element anywhere in the sequence, trying to fill holes left by calls to <a class="el" href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0" title="Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs...">ordered_set::erase()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). </dd></dl>

</div>
</div>
<a id="a2165161b38251e5310e11b896d9cb478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2165161b38251e5310e11b896d9cb478">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element at the back of the container, constructed in-place with the given args if there is no element with the key in the container. Careful use of emplace_back allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace_back, forwarded via std::forward&lt;Args&gt;(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="section return"><dt>Returns</dt><dd>pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). </dd></dl>

</div>
</div>
<a id="a0b7b49336fa2c03a76903be72a3dc2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7b49336fa2c03a76903be72a3dc2c4">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element at the front of the container, constructed in-place with the given args if there is no element with the key in the container. Careful use of emplace_front allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace_front, forwarded via std::forward&lt;Args&gt;(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="section return"><dt>Returns</dt><dd>pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). </dd></dl>

</div>
</div>
<a id="a158e3ea89502cafe19dd6c86ea0d262c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158e3ea89502cafe19dd6c86ea0d262c">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. Same as <a class="el" href="classseq_1_1ordered__set.html#aa44832bcf734eb3797689cb299683954" title="Inserts a new element into the container constructed in-place with the given args if there is no elem...">ordered_set::emplace()</a>. </p>

</div>
</div>
<a id="ae6bfb5bafad2839efbc66abdc1fd831c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bfb5bafad2839efbc66abdc1fd831c">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the container is empty, false otherwise. </p>

</div>
</div>
<a id="a97417c28fec1bdc54feec7cf2800b0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97417c28fec1bdc54feec7cf2800b0a4">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="acefb4c70eac4ca5123ade8a3af80a6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefb4c70eac4ca5123ade8a3af80a6c1">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="a8ee0f41eed18d8a036ec89bf460af603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee0f41eed18d8a036ec89bf460af603">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element comparing equal to given key (if any). Removes the element (if one exists) with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash::is_transparent and KeyEqual::is_transparent are valid and each denotes a type, and neither iterator nor <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a> is implicitly convertible from K. This assumes that such Hash is callable with both K and Key type, and that the KeyEqual is transparent, which, together, allows calling this function without constructing an instance of Key. </p>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements (0 or 1) </dd></dl>

</div>
</div>
<a id="a2ae12f5fe1790baf6d96857df2683197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae12f5fe1790baf6d96857df2683197">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#a14db22b9060c55bae803daa77fb21a6f">size_type</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element comparing equal to given key (if any). Iterators and references are not invalidated. Rehashing never occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to be erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements (0 or 1) </dd></dl>

</div>
</div>
<a id="a7e0188d696f3263e84ad3f0fa11c8e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0188d696f3263e84ad3f0fa11c8e52">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first; last), which must be a valid range in *this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>range of elements to remove </td></tr>
    <tr><td class="paramname">last</td><td>range of elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element </dd></dl>

</div>
</div>
<a id="a6fc879b0ce162396bbc1ab16c372d9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc879b0ce162396bbc1ab16c372d9d0">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element </dd></dl>

</div>
</div>
<a id="a0dbcfa453584119f10ab4a63eb4e0e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbcfa453584119f10ab4a63eb4e0e68">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. Finds an element with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash::is_transparent and KeyEqual::is_transparent are valid and each denotes a type. This assumes that such Hash is callable with both K and Key type, and that the KeyEqual is transparent, which, together, allows calling this function without constructing an instance of Key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>key value to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found key on success, end iterator on failure. </dd></dl>

</div>
</div>
<a id="a935fb52f076a64c43eec787022593a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935fb52f076a64c43eec787022593a10">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class H  = Hash, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &amp;&amp;has_is_transparent&lt; H &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. Finds an element with key that compares equivalent to the value x. This overload participates in overload resolution only if Hash::is_transparent and KeyEqual::is_transparent are valid and each denotes a type. This assumes that such Hash is callable with both K and Key type, and that the KeyEqual is transparent, which, together, allows calling this function without constructing an instance of Key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>key value to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found key on success, end iterator on failure. </dd></dl>

</div>
</div>
<a id="ac7b344d232a85339ae3633c6aaefd1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b344d232a85339ae3633c6aaefd1e3">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>key value to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found key on success, end iterator on failure. </dd></dl>

</div>
</div>
<a id="a21e4da578f2eac9d941f150a361930a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e4da578f2eac9d941f150a361930a8">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>key value to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found key on success, end iterator on failure. </dd></dl>

</div>
</div>
<a id="a19b0f4e76ebb8ecd31bb850a904ae76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b0f4e76ebb8ecd31bb850a904ae76d">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a73fdf0cb0cfbd9e15e6c9d72c2dde6fd">allocator_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container allocator object. </p>

</div>
</div>
<a id="a2bd5e2b5a3370aac53a5271774edb1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd5e2b5a3370aac53a5271774edb1c3">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#a73fdf0cb0cfbd9e15e6c9d72c2dde6fd">allocator_type</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container allocator object. </p>

</div>
</div>
<a id="aff53fface88ca6650d8a45c49db24798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff53fface88ca6650d8a45c49db24798">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a878f53e048251a95c495145448f628f5">hasher</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash function. </p>

</div>
</div>
<a id="afbc6c320f13dbfe438907cac9a787f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc6c320f13dbfe438907cac9a787f6c">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element into the container, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). This function calls <a class="el" href="classseq_1_1sequence.html#a7dcbce0b90160f9479bfcb7a09f3277e" title="Insert the given element into the sequence.">seq::sequence::insert()</a> which insert the new element anywhere in the sequence, trying to fill holes left by calls to <a class="el" href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0" title="Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs...">ordered_set::erase()</a>. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). </dd></dl>

</div>
</div>
<a id="ae503b7aebc8f8b339fbcfb97147a49fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae503b7aebc8f8b339fbcfb97147a49fb">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element into the container, if the container doesn't already contain an element with an equivalent key. Same as <a class="el" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c" title="Inserts element into the container, if the container doesn&#39;t already contain an element with an equiv...">ordered_set::insert()</a>. </p>

</div>
</div>
<a id="ae688ce8e525fbc2c246a5ffa82598eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae688ce8e525fbc2c246a5ffa82598eff">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1ordered__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element into the container using move semantic, if the container doesn't already contain an element with an equivalent key. Same as <a class="el" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c" title="Inserts element into the container, if the container doesn&#39;t already contain an element with an equiv...">ordered_set::insert()</a>. </p>

</div>
</div>
<a id="ad97d9655ac3a0a3f954c1bfae0ddc8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97d9655ac3a0a3f954c1bfae0ddc8c3">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Elements are inserted in any order. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>range of elements to insert </td></tr>
    <tr><td class="paramname">last</td><td>range of elements to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af008845549da85d2b5ec77e10020361f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af008845549da85d2b5ec77e10020361f">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [init.begin(), init.end()). If multiple elements in the range have keys that compare equivalent, only the first occurence is inserted. Elements are inserted in any order. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>range of elements to insert </td></tr>
    <tr><td class="paramname">last</td><td>range of elements to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2b8b075669194ee26bb1a19189b19b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b8b075669194ee26bb1a19189b19b7">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element into the container using move semantic, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). This function calls <a class="el" href="classseq_1_1sequence.html#a7dcbce0b90160f9479bfcb7a09f3277e" title="Insert the given element into the sequence.">seq::sequence::insert()</a> which insert the new element anywhere in the sequence, trying to fill holes left by calls to <a class="el" href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0" title="Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs...">ordered_set::erase()</a>. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). </dd></dl>

</div>
</div>
<a id="add28814de268def7f2a41f5cac43e3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add28814de268def7f2a41f5cac43e3dd">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a233a269648da39723d38745330132eed">key_equal</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the equality comparison function. </p>

</div>
</div>
<a id="ac6bc92e7739a3fc48b904dd1539766a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bc92e7739a3fc48b904dd1539766a3">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current load factor. </p>

</div>
</div>
<a id="ac7fb96b6026596a42b0a186260086f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fb96b6026596a42b0a186260086f91">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current maximum load factor. </p>

</div>
</div>
<a id="a403cd189fba893ab4f06b6cb28247288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403cd189fba893ab4f06b6cb28247288">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum load factor. </p>

</div>
</div>
<a id="a0cfdbedce5753271a2a3e5ff2fcb6ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfdbedce5753271a2a3e5ff2fcb6ffd">&#9670;&nbsp;</a></span>max_probe_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::max_probe_distance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current maximum possible probe distance. </p>

</div>
</div>
<a id="a0e0e2d5eea7bd8904e5859584dc1e6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0e2d5eea7bd8904e5859584dc1e6cf">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container maximum size. </p>

</div>
</div>
<a id="a6be5fbe03ed3b3f03b71348550985d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be5fbe03ed3b3f03b71348550985d09">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="a2575a6950a9e2a41ea7f0b073fde1134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2575a6950a9e2a41ea7f0b073fde1134">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&amp;
  		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="a15fa8bb634a540e73eb812b233bb8eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fa8bb634a540e73eb812b233bb8eda">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element at the back of the container, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). </dd></dl>

</div>
</div>
<a id="afbbe4f0a179714cf107b6d095dfd3c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbe4f0a179714cf107b6d095dfd3c3b">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element at the back of the container use move semantic, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). </dd></dl>

</div>
</div>
<a id="a9d49aa11cdcc711db02d265b7bc606f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d49aa11cdcc711db02d265b7bc606f8">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element at the front of the container, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). </dd></dl>

</div>
</div>
<a id="a933f2e5e3bb45e5f1aad5d3cd28b2d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933f2e5e3bb45e5f1aad5d3cd28b2d05">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html#a09f3080d8f641e7a405a0c6cfb3f953d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1ordered__set.html#ac624ed3f3e8da177bf1cc5d8d5933a77">iterator</a>, bool&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element at the front of the container using move semantic, if the container doesn't already contain an element with an equivalent key. Iterators and references are not invalidated. Rehashing occurs only if the new number of elements is greater than <a class="el" href="structseq_1_1detail_1_1_sparse_flat_node_hash_table.html#a61d12e6f0f066d5f3eebeb61be0a55df">max_load_factor()</a>*size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place (true if insertion happened, false if it did not). </dd></dl>

</div>
</div>
<a id="a46b4bd0e5dd6e4fa694833edf2a2141d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b4bd0e5dd6e4fa694833edf2a2141d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a4aba4efa615411f6d42d2a0ea32537b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aba4efa615411f6d42d2a0ea32537b5">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#a432ef60eab5f87e4ed9293dc2c893cbc">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a2bb1f28b32c0c6c0422540b7986a49b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb1f28b32c0c6c0422540b7986a49b0">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::rehash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rehash the container. This function triggers a full rehash if: </p>
<pre class="fragment">-   the container is dirty (through a call to ordered_set::sequence()
-   the hash table size is too big or too small considering the max load factor (for instance after several calls to ordered_set::erase())
-   the hash table is in linear hashing state (because of bad hash function). In this case, the hash table size is doubled.
</pre><p>Otherwise, this function does nothing. </p>

</div>
</div>
<a id="a41ea6f4b63cae7476f3f0193d3a1e3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ea6f4b63cae7476f3f0193d3a1e3ae">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1ordered__set.html#a77aa2c4d6b23b4782bd5f84f9edec62f">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="ade4ec861f743e02c59e959933bd5e8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4ec861f743e02c59e959933bd5e8cf">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#a432ef60eab5f87e4ed9293dc2c893cbc">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a4fc52f5ac410c23469f67314d85fc96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc52f5ac410c23469f67314d85fc96f">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of nodes to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>new capacity of the container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56f4ce86306098d218e2c1154a910870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f4ce86306098d218e2c1154a910870">&#9670;&nbsp;</a></span>sequence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const <a class="el" href="classseq_1_1ordered__set.html#af9cd9e0271ca9e938e1d128522da7b41">sequence_type</a> &amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying sequence object. Do NOT mark the container as dirty. </p>

</div>
</div>
<a id="af1b1dd7454c03a4b6a4d8e5f08dc7adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b1dd7454c03a4b6a4d8e5f08dc7adb">&#9670;&nbsp;</a></span>sequence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::<a class="el" href="classseq_1_1sequence.html">sequence</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1ordered__set.html#af9cd9e0271ca9e938e1d128522da7b41">sequence_type</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying sequence object. Calling this function will mark the container as dirty. Any further attempts to call members like <a class="el" href="classseq_1_1ordered__set.html#ac7b344d232a85339ae3633c6aaefd1e3" title="Finds an element with key equivalent to key.">find()</a> or <a class="el" href="classseq_1_1ordered__set.html#afbc6c320f13dbfe438907cac9a787f6c" title="Inserts element into the container, if the container doesn&#39;t already contain an element with an equiv...">insert()</a> (relying on the hash function) will raise a std::logic_error. To mark the container as non dirty anymore, the user must call <a class="el" href="classseq_1_1ordered__set.html#a2bb1f28b32c0c6c0422540b7986a49b0" title="Rehash the container. This function triggers a full rehash if:">ordered_set::rehash()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the underlying <a class="el" href="classseq_1_1sequence.html" title="sequence is an ordered container supporting constant time insertion at both end and constant removal ...">seq::sequence</a> object </dd></dl>

</div>
</div>
<a id="a13ba901e3b3b3be36be8a12156f4614e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ba901e3b3b3be36be8a12156f4614e">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classseq_1_1sequence.html#a1bf494125859119c2748a7a5e59588fa" title="Pack the sequence to remove empty slots and release unused memory. All empty slots created by calls t...">seq::sequence::shrink_to_fit()</a>. Remove potential holes in the sequence object due to calls to <a class="el" href="classseq_1_1ordered__set.html#a6fc879b0ce162396bbc1ab16c372d9d0" title="Erase element at given location. Iterators and references are not invalidated. Rehashing never occurs...">ordered_set::erase()</a>. Does not allocate memory, except for the hash table itself. Invalidate all references and iterators. Basic exception guarantee only. </p>

</div>
</div>
<a id="a12ebe2df7d623875a764a0d83e8cc067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ebe2df7d623875a764a0d83e8cc067">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size. </p>

</div>
</div>
<a id="a36a66b34dafa44d2f963a201272b2d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a66b34dafa44d2f963a201272b2d24">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the container using std::less&lt;Key&gt;. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. </p>

</div>
</div>
<a id="ad8c0514644286c8155f35d87dab0e3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c0514644286c8155f35d87dab0e3e9">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>le</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the container based on given comparator. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">le</td><td>comparison function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae64707af69a6b261413d1325c8f35d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64707af69a6b261413d1325c8f35d30">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::stable_sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the container based on std::less&lt;Key&gt; and using std::stable_sort. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. </p>

</div>
</div>
<a id="aa23ceeda63ee924eae70f4f2a40e6b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23ceeda63ee924eae70f4f2a40e6b7d">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<div class="memtemplate">
template&lt;class Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::stable_sort </td>
          <td>(</td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>le</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the container based on given comparator and using std::stable_sort. The full container is rehashed afterward. Invalidate all references and iterators. Basic exception guarantee only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">le</td><td>comparison function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a768027febcc0b8e7df4465815510715d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768027febcc0b8e7df4465815510715d">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, LayoutManagement Layout = OptimizeForSpeed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1ordered__set.html">seq::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap this container with other. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="ordered__map_8hpp_source.html">ordered_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1ordered__set.html">ordered_set</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
