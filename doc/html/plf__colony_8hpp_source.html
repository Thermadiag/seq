<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: plf_colony.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('plf__colony_8hpp_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">plf_colony.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">// Copyright (c) 2021, Matthew Bentley (mattreecebentley@gmail.com) www.plflib.org</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// zLib license (https://www.zlib.net/zlib_license.html):</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// This software is provided &#39;as-is&#39;, without any express or implied</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// warranty. In no event will the authors be held liable for any damages</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">// arising from the use of this software.</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Permission is granted to anyone to use this software for any purpose,</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// including commercial applications, and to alter it and redistribute it</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">// freely, subject to the following restrictions:</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">// 1. The origin of this software must not be misrepresented; you must not</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">//  claim that you wrote the original software. If you use this software</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">//  in a product, an acknowledgement in the product documentation would be</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">//  appreciated but is not required.</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">// 2. Altered source versions must be plainly marked as such, and must not be</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">//  misrepresented as being the original software.</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">// 3. This notice may not be removed or altered from any source distribution.</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#ifndef PLF_COLONY_H</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#define PLF_COLONY_H</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">// Compiler-specific defines:</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160; </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; !defined(__clang__) &amp;&amp; !defined(__GNUC__)</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="preprocessor">#define PLF_FORCE_INLINE __forceinline</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; </div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#if _MSC_VER &gt;= 1600</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#define PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) static_assert(check, message)</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) assert(check)</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="preprocessor">#if _MSC_VER &gt;= 1700</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#define PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="preprocessor">#define PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="preprocessor">#if _MSC_VER &gt;= 1800</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#define PLF_VARIADICS_SUPPORT // Variadics, in this context, means both variadic templates and variadic macros are supported</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="preprocessor">#define PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="preprocessor">#if _MSC_VER &gt;= 1900</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#define PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT noexcept</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="preprocessor">#define PLF_IS_ALWAYS_EQUAL_SUPPORT</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT throw()</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160; </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="preprocessor">#if defined(_MSVC_LANG) &amp;&amp; (_MSVC_LANG &gt;= 201703L)</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="preprocessor">#define PLF_CONSTEXPR constexpr</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="preprocessor">#define PLF_CONSTEXPR</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="preprocessor">#if defined(_MSVC_LANG) &amp;&amp; (_MSVC_LANG &gt; 201703L) &amp;&amp; _MSC_VER &gt;= 1923</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="preprocessor">#define PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="preprocessor">#elif defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L // C++11 support, at least</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="preprocessor">#define PLF_FORCE_INLINE // note: GCC and clang create faster code without forcing inline</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160; </div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="preprocessor">#if defined(__GNUC__) &amp;&amp; defined(__GNUC_MINOR__) &amp;&amp; !defined(__clang__) // If compiler is GCC/G++</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="preprocessor">#if (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 3) || __GNUC__ &gt; 4 // 4.2 and below do not support variadic templates</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="preprocessor">#define PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="preprocessor">#define PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) static_assert(check, message)</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) assert(check)</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="preprocessor">#if (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 4) || __GNUC__ &gt; 4 // 4.3 and below do not support initializer lists</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="preprocessor">#define PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="preprocessor">#if (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 6) || __GNUC__ &gt; 4</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT noexcept</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT throw()</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="preprocessor">#if (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 7) || __GNUC__ &gt; 4</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="preprocessor">#define PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="preprocessor">#if (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 8) || __GNUC__ &gt; 4</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="preprocessor">#define PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="preprocessor">#if __GNUC__ &gt;= 5 // GCC v4.9 and below do not support std::is_trivially_copyable</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="preprocessor">#define PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="preprocessor">#if __GNUC__ &gt; 6</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="preprocessor">#define PLF_IS_ALWAYS_EQUAL_SUPPORT</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="preprocessor">#elif defined(__clang__) &amp;&amp; !defined(__GLIBCXX__) &amp;&amp; !defined(_LIBCPP_CXX03_LANG)</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="preprocessor">#if __clang_major__ &gt;= 3 // clang versions &lt; 3 don&#39;t support __has_feature() or traits</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="preprocessor">#define PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="preprocessor">#define PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160; </div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="preprocessor">#if __has_feature(cxx_alignas) &amp;&amp; __has_feature(cxx_alignof)</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="preprocessor">#define PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="preprocessor">#if __has_feature(cxx_noexcept)</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT noexcept</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="preprocessor">#define PLF_IS_ALWAYS_EQUAL_SUPPORT</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT throw()</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="preprocessor">#if __has_feature(cxx_rvalue_references) &amp;&amp; !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="preprocessor">#define PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="preprocessor">#if __has_feature(cxx_static_assert)</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) static_assert(check, message)</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) assert(check)</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="preprocessor">#if __has_feature(cxx_variadic_templates) &amp;&amp; !defined(_LIBCPP_HAS_NO_VARIADICS)</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="preprocessor">#define PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="preprocessor">#if (__clang_major__ == 3 &amp;&amp; __clang_minor__ &gt;= 1) || __clang_major__ &gt; 3</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="preprocessor">#define PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="preprocessor">#elif defined(__GLIBCXX__) // Using another compiler type with libstdc++ - we are assuming full c++11 compliance for compiler - which may not be true</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="preprocessor">#if __GLIBCXX__ &gt;= 20080606</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="preprocessor">#define PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="preprocessor">#define PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) static_assert(check, message)</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) assert(check)</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="preprocessor">#if __GLIBCXX__ &gt;= 20090421</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="preprocessor">#define PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="preprocessor">#if __GLIBCXX__ &gt;= 20120322</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="preprocessor">#define PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT noexcept</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT throw()</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="preprocessor">#if __GLIBCXX__ &gt;= 20130322</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="preprocessor">#define PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="preprocessor">#if __GLIBCXX__ &gt;= 20150422 // libstdc++ v4.9 and below do not support std::is_trivially_copyable</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="preprocessor">#define PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="preprocessor">#if __GLIBCXX__ &gt;= 20160111</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="preprocessor">#define PLF_IS_ALWAYS_EQUAL_SUPPORT</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="preprocessor">#elif defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) // Special case for checking C++11 support with libCPP</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) assert(check)</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT throw()</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="preprocessor">#if !defined(_LIBCPP_HAS_NO_VARIADICS)</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="preprocessor">#define PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="preprocessor">#else // Assume type traits and initializer support for other compilers and standard library implementations</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="preprocessor">#define PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) static_assert(check, message)</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="preprocessor">#define PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="preprocessor">#define PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="preprocessor">#define PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="preprocessor">#define PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="preprocessor">#define PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT noexcept</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="preprocessor">#define PLF_IS_ALWAYS_EQUAL_SUPPORT</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160; </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="preprocessor">#if __cplusplus &gt;= 201703L &amp;&amp; ((defined(__clang__) &amp;&amp; ((__clang_major__ == 3 &amp;&amp; __clang_minor__ == 9) || __clang_major__ &gt; 3)) || (defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 7) || (!defined(__clang__) &amp;&amp; !defined(__GNUC__))) // assume correct C++17 implementation for non-gcc/clang compilers</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="preprocessor">#define PLF_CONSTEXPR constexpr</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="preprocessor">#define PLF_CONSTEXPR</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160; </div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="preprocessor">#if __cplusplus &gt; 201703L &amp;&amp; ((defined(__clang__) &amp;&amp; (__clang_major__ &gt;= 13)) || (defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 10) || (!defined(__clang__) &amp;&amp; !defined(__GNUC__)))</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="preprocessor">#define PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="preprocessor">#define PLF_FORCE_INLINE</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="preprocessor">#define PLF_STATIC_ASSERT(check, message) assert(check)</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT throw()</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="preprocessor">#define PLF_CONSTEXPR</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160; </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="preprocessor">#if defined(PLF_IS_ALWAYS_EQUAL_SUPPORT) &amp;&amp; defined(PLF_MOVE_SEMANTICS_SUPPORT) &amp;&amp; defined(PLF_ALLOCATOR_TRAITS_SUPPORT) &amp;&amp; (__cplusplus &gt;= 201703L || (defined(_MSVC_LANG) &amp;&amp; (_MSVC_LANG &gt;= 201703L)))</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT_MOVE_ASSIGN(the_allocator) noexcept(std::allocator_traits&lt;the_allocator&gt;::propagate_on_container_move_assignment::value || std::allocator_traits&lt;the_allocator&gt;::is_always_equal::value)</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT_SWAP(the_allocator) noexcept(std::allocator_traits&lt;the_allocator&gt;::propagate_on_container_swap::value || std::allocator_traits&lt;the_allocator&gt;::is_always_equal::value)</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT_MOVE_ASSIGN(the_allocator)</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="preprocessor">#define PLF_NOEXCEPT_SWAP(the_allocator)</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160; </div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="preprocessor">#undef PLF_IS_ALWAYS_EQUAL_SUPPORT</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160; </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160; </div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="preprocessor">#ifdef PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="preprocessor">#ifdef PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="preprocessor">#define PLF_CONSTRUCT(the_allocator, allocator_instance, location, ...) std::allocator_traits&lt;the_allocator&gt;::construct(allocator_instance, location, __VA_ARGS__)</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="preprocessor">#define PLF_CONSTRUCT(the_allocator, allocator_instance, location, data)    std::allocator_traits&lt;the_allocator&gt;::construct(allocator_instance, location, data)</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160; </div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="preprocessor">#define PLF_DESTROY(the_allocator, allocator_instance, location)                std::allocator_traits&lt;the_allocator&gt;::destroy(allocator_instance, location)</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="preprocessor">#define PLF_ALLOCATE(the_allocator, allocator_instance, size, hint)         std::allocator_traits&lt;the_allocator&gt;::allocate(allocator_instance, size, hint)</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="preprocessor">#define PLF_DEALLOCATE(the_allocator, allocator_instance, location, size)   std::allocator_traits&lt;the_allocator&gt;::deallocate(allocator_instance, location, size)</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="preprocessor">#ifdef PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="preprocessor">#define PLF_CONSTRUCT(the_allocator, allocator_instance, location, ...)     (allocator_instance).construct(location, __VA_ARGS__)</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="preprocessor">#define PLF_CONSTRUCT(the_allocator, allocator_instance, location, data)    (allocator_instance).construct(location, data)</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160; </div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="preprocessor">#define PLF_DESTROY(the_allocator, allocator_instance, location)                (allocator_instance).destroy(location)</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="preprocessor">#define PLF_ALLOCATE(the_allocator, allocator_instance, size, hint)         (allocator_instance).allocate(size, hint)</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="preprocessor">#define PLF_DEALLOCATE(the_allocator, allocator_instance, location, size)   (allocator_instance).deallocate(location, size)</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160; </div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160; </div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160; </div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// std::fill_n, std::sort</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="preprocessor">#include &lt;cassert&gt;</span>  <span class="comment">// assert</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="preprocessor">#include &lt;cstring&gt;</span>  <span class="comment">// memset, memcpy, size_t</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="preprocessor">#include &lt;limits&gt;</span>  <span class="comment">// std::numeric_limits</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="preprocessor">#include &lt;memory&gt;</span> <span class="comment">// std::allocator</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="preprocessor">#include &lt;iterator&gt;</span> <span class="comment">// std::bidirectional_iterator_tag, iterator_traits, make_move_iterator, std::distance for range insert</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="preprocessor">#include &lt;stdexcept&gt;</span> <span class="comment">// std::length_error</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160; </div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160; </div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="preprocessor">#include &lt;cstddef&gt;</span> <span class="comment">// offsetof, used in blank()</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="preprocessor">#include &lt;type_traits&gt;</span> <span class="comment">// std::is_trivially_destructible, etc</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160; </div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// std::move</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160; </div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="preprocessor">#ifdef PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="preprocessor">#include &lt;initializer_list&gt;</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160; </div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="preprocessor">#ifdef PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="preprocessor">#include &lt;concepts&gt;</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160; </div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160; </div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="keyword">namespace </span>plf</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;{</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160; </div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160; </div>
<div class="line"><a name="l00248"></a><span class="lineno"><a class="line" href="structplf_1_1colony__limits.html">  248</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structplf_1_1colony__limits.html">colony_limits</a> <span class="comment">// for use in block_capacity setting/getting functions and constructors</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        <span class="keywordtype">size_t</span> min, max;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <a class="code" href="structplf_1_1colony__limits.html">colony_limits</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> minimum, <span class="keyword">const</span> <span class="keywordtype">size_t</span> maximum) PLF_NOEXCEPT : min(minimum), max(maximum) {}</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    };</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160; </div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160; </div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keyword">enum</span> colony_priority { performance, memory_use };</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160; </div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160; </div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno"><a class="line" href="classplf_1_1colony.html">  259</a></span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> element_type, <span class="keyword">class</span> allocator_type = std::allocator&lt;element_type&gt;, plf::colony_priority priority = plf::performance&gt; <span class="keyword">class </span><a class="code" href="classplf_1_1colony.html">colony</a> : <span class="keyword">private</span> allocator_type <span class="comment">// Empty base class optimisation (EBCO) - inheriting allocator functions</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    {</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="comment">// Type-switching pattern:</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> flag, <span class="keyword">class</span> is_true, <span class="keyword">class</span> is_false&gt; <span class="keyword">struct </span>choose;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160; </div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> is_true, <span class="keyword">class</span> is_false&gt; <span class="keyword">struct </span>choose&lt;true, is_true, is_false&gt;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        {</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <span class="keyword">typedef</span> is_true type;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        };</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160; </div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> is_true, <span class="keyword">class</span> is_false&gt; <span class="keyword">struct </span>choose&lt;false, is_true, is_false&gt;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        {</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="keyword">typedef</span> is_false type;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        };</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160; </div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> choose&lt;priority == plf::performance, unsigned short, unsigned char&gt;::type      skipfield_type; <span class="comment">// Note: unsigned short is equivalent to uint_least16_t ie. Using 16-bit unsigned integer in best-case scenario, greater-than-16-bit unsigned integer where platform doesn&#39;t support 16-bit types. unsigned char is always == 1 byte, as opposed to uint_8, which may not be</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160; </div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        <span class="comment">// Standard container typedefs:</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="keyword">typedef</span> element_type value_type;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160; </div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="preprocessor">#ifdef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::aligned_storage&lt;<span class="keyword">sizeof</span>(element_type), (<span class="keyword">sizeof</span>(element_type) &gt;= (<span class="keyword">sizeof</span>(skipfield_type) * 2) || <span class="keyword">alignof</span>(element_type) &gt;= (<span class="keyword">sizeof</span>(skipfield_type) * 2)) ? <span class="keyword">alignof</span>(element_type) : (<span class="keyword">sizeof</span>(skipfield_type) * 2)&gt;::type aligned_element_type;</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="keyword">typedef</span> element_type aligned_element_type;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160; </div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="preprocessor">#ifdef PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::size_type           size_type;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::difference_type     difference_type;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keyword">typedef</span> element_type&amp; reference;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">const</span> element_type&amp; const_reference;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::pointer             pointer;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::const_pointer       const_pointer;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::size_type          size_type;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::difference_type    difference_type;</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::reference          reference;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::const_reference    const_reference;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::pointer                pointer;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::const_pointer      const_pointer;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160; </div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160; </div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="comment">// Iterator declarations:</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const&gt; <span class="keyword">class          </span><a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keyword">typedef</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;false&gt;</a>          <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">iterator</a>;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <span class="keyword">typedef</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;true&gt;</a>       <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">const_iterator</a>;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&lt;false&gt;; <span class="comment">// Using above typedef name here is illegal under C++03</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&lt;true&gt;;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160; </div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> r_is_const&gt; <span class="keyword">class    </span><a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        <span class="keyword">typedef</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;false&gt;</a> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">reverse_iterator</a>;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keyword">typedef</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;true&gt;</a>   <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">const_reverse_iterator</a>;</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&lt;false&gt;;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&lt;true&gt;;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160; </div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160; </div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160; </div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160; </div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="preprocessor">#ifdef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        <span class="keyword">struct </span><span class="keyword">alignas</span>(alignof(aligned_element_type)) aligned_allocation_struct</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        {</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            <span class="keywordtype">char</span> data[<span class="keyword">alignof</span>(aligned_element_type)]; <span class="comment">// Using char as sizeof is always guaranteed to be 1 byte regardless of the number of bits in a byte on given computer, whereas for example, uint8_t would fail on machines where there are more than 8 bits in a byte eg. Texas Instruments C54x DSPs.</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        };</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160; </div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="preprocessor">#define PLF_GROUP_ALIGNED_BLOCK_SIZE(elements_per_group) ((((elements_per_group * (((sizeof(aligned_element_type) &gt;= alignof(aligned_element_type)) ? sizeof(aligned_element_type) : alignof(aligned_element_type)) + sizeof(skipfield_type))) + sizeof(skipfield_type)) + sizeof(aligned_allocation_struct) - 1) / sizeof(aligned_allocation_struct)) // The size of a groups&#39; memory block when expressed in multiples of the value_type&#39;s alignment. We also check to see if alignment is larger than sizeof value_type and use alignment size if so.</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <span class="keyword">struct </span>aligned_allocation_struct</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        {</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;            <span class="keywordtype">char</span> data;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        };</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160; </div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="preprocessor">#define PLF_GROUP_ALIGNED_BLOCK_SIZE(elements_per_group) ((elements_per_group * (sizeof(aligned_element_type) + sizeof(skipfield_type))) + sizeof(skipfield_type)) // The size of a groups&#39; memory block when expressed in bytes, since no alignment available</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160; </div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160; </div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="comment">// forward declarations for typedefs below</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="keyword">struct </span>group;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="keyword">struct </span>item_index_tuple; <span class="comment">// for use in sort()</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160; </div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160; </div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="preprocessor">#ifdef PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::template rebind_alloc&lt;aligned_element_type&gt;     aligned_element_allocator_type;</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::template rebind_alloc&lt;group&gt;                            group_allocator_type;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::template rebind_alloc&lt;skipfield_type&gt;               skipfield_allocator_type;</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::template rebind_alloc&lt;aligned_allocation_struct&gt; aligned_struct_allocator_type;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::template rebind_alloc&lt;item_index_tuple&gt;             tuple_allocator_type;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;allocator_type&gt;::template rebind_alloc&lt;unsigned char&gt;                uchar_allocator_type;</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160; </div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;aligned_element_allocator_type&gt;::pointer aligned_pointer_type; <span class="comment">// pointer to the overaligned element type, not the original element type</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;group_allocator_type&gt;::pointer               group_pointer_type;</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;skipfield_allocator_type&gt;::pointer           skipfield_pointer_type;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;aligned_struct_allocator_type&gt;::pointer  aligned_struct_pointer_type;</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::allocator_traits&lt;tuple_allocator_type&gt;::pointer               tuple_pointer_type;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::template rebind&lt;aligned_element_type&gt;::other   aligned_element_allocator_type; <span class="comment">// In case compiler supports alignment but not allocator_traits</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::template rebind&lt;group&gt;::other                      group_allocator_type;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::template rebind&lt;skipfield_type&gt;::other             skipfield_allocator_type;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::template rebind&lt;char&gt;::other                           aligned_struct_allocator_type;</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::template rebind&lt;item_index_tuple&gt;::other           tuple_allocator_type;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::template rebind&lt;unsigned char&gt;::other              uchar_allocator_type;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160; </div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> aligned_element_allocator_type::pointer aligned_pointer_type;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> group_allocator_type::pointer              group_pointer_type;</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> skipfield_allocator_type::pointer      skipfield_pointer_type;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> aligned_struct_allocator_type::pointer aligned_struct_pointer_type;</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> tuple_allocator_type::pointer              tuple_pointer_type;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160; </div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160; </div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160; </div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="comment">// Colony groups:</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        <span class="keyword">struct </span>group : <span class="keyword">private</span> aligned_struct_allocator_type    <span class="comment">// ebco - inherit allocator functions</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        {</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            aligned_pointer_type                last_endpoint;          <span class="comment">// The address that is one past the highest cell number that&#39;s been used so far in this group - does not change with erase command but may change with insert (if no previously-erased locations are available) - is necessary because an iterator cannot access the colony&#39;s end_iterator. Most-used variable in colony use (operator ++, --) so first in struct. If the colony has been completely filled at some point, it will be == reinterpret_cast&lt;aligned_pointer_type&gt;(skipfield)</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;            group_pointer_type                  next_group;                 <span class="comment">// Next group in the intrusive list of all groups. NULL if no next group</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;            <span class="keyword">const</span> aligned_pointer_type      elements;                   <span class="comment">// Element storage</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            <span class="keyword">const</span> skipfield_pointer_type        skipfield;                  <span class="comment">// Skipfield storage. The element and skipfield arrays are allocated contiguously in this implementation, hence the skipfield pointer also functions as a &#39;one-past-end&#39; pointer for the elements array. There will always be one additional skipfield node allocated compared to the number of elements. This is to ensure a faster ++ iterator operation (fewer checks are required when this is present). The extra node is unused and always zero, but checked, and not having it will result in out-of-bounds memory errors.</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            group_pointer_type                  previous_group;         <span class="comment">// previous group in the linked list of all groups. NULL if no preceding group</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            skipfield_type                      free_list_head;         <span class="comment">// The index of the last erased element in the group. The last erased element will, in turn, contain the number of the index of the next erased element, and so on. If this is == maximum skipfield_type value then free_list is empty ie. no erasures have occurred in the group (or if they have, the erased locations have subsequently been reused via insert()).</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;            <span class="keyword">const</span> skipfield_type                capacity;                   <span class="comment">// The element capacity of this particular group - can also be calculated from reinterpret_cast&lt;aligned_pointer_type&gt;(group-&gt;skipfield) - group-&gt;elements, however this space is effectively free due to struct padding and the default sizeof skipfield_type, and calculating it once is cheaper</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            skipfield_type                      size;                       <span class="comment">// indicates total number of active elements in group - changes with insert and erase commands - used to check for empty group in erase function, as an indication to remove the group</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            group_pointer_type                  erasures_list_next_group; <span class="comment">// The next group in the singly-linked list of groups with erasures ie. with active erased-element free lists</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;            size_type                               group_number;               <span class="comment">// Used for comparison (&gt; &lt; &gt;= &lt;= &lt;=&gt;) iterator operators (used by distance function and user)</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160; </div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160; </div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="preprocessor">#ifdef PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            group(<span class="keyword">const</span> skipfield_type elements_per_group, group_pointer_type <span class="keyword">const</span> previous) :</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                last_endpoint(<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(PLF_ALLOCATE(aligned_struct_allocator_type, *<span class="keyword">this</span>, PLF_GROUP_ALIGNED_BLOCK_SIZE(elements_per_group), (previous == NULL) ? 0 : previous-&gt;elements))),</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;                next_group(NULL),</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                elements(last_endpoint++),</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                skipfield(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(elements + elements_per_group)),</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                previous_group(previous),</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                free_list_head(std::numeric_limits&lt;skipfield_type&gt;::max()),</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                capacity(elements_per_group),</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                size(1),</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                erasures_list_next_group(NULL),</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                group_number((previous == NULL) ? 0 : previous-&gt;group_number + 1u)</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;            {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                <span class="comment">// Static casts to unsigned int from short not necessary as C++ automatically promotes lesser types for arithmetic purposes.</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                std::memset(&amp;*skipfield, 0, <span class="keyword">sizeof</span>(skipfield_type) * (<span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(elements_per_group) + 1u)); <span class="comment">// &amp;* to avoid problems with non-trivial pointers</span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;            }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160; </div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="comment">// This is a hack around the fact that allocator_type::construct only supports copy construction in C++03 and copy elision does not occur on the vast majority of compilers in this circumstance. So to avoid running out of memory (and losing performance) from allocating the same block twice, we&#39;re allocating in the &#39;copy&#39; constructor.</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;            group(<span class="keyword">const</span> skipfield_type elements_per_group, group_pointer_type <span class="keyword">const</span> previous) PLF_NOEXCEPT:</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;            elements(NULL),</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                skipfield(NULL),</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                previous_group(previous),</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                capacity(elements_per_group)</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;            {}</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160; </div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160; </div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; </div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;            <span class="comment">// Not a real copy constructor ie. actually a constructor. Only used for allocator.construct in C++03 for reasons stated above:</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;            group(<span class="keyword">const</span> group&amp; source) :</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                aligned_struct_allocator_type(source),</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                last_endpoint(<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(PLF_ALLOCATE(aligned_struct_allocator_type, *<span class="keyword">this</span>, PLF_GROUP_ALIGNED_BLOCK_SIZE(source.capacity), (source.previous_group == NULL) ? 0 : source.previous_group-&gt;elements))),</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                next_group(NULL),</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                elements(last_endpoint++),</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                skipfield(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(elements + source.capacity)),</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                previous_group(source.previous_group),</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                free_list_head(std::numeric_limits&lt;skipfield_type&gt;::max()),</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                capacity(source.capacity),</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                size(1),</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                erasures_list_next_group(NULL),</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                group_number((source.previous_group == NULL) ? 0 : source.previous_group-&gt;group_number + 1u)</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            {</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;                std::memset(&amp;*skipfield, 0, <span class="keyword">sizeof</span>(skipfield_type) * (<span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(capacity) + 1u));</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            }</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160; </div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160; </div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160; </div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            <span class="keywordtype">void</span> reset(<span class="keyword">const</span> skipfield_type increment, <span class="keyword">const</span> group_pointer_type next, <span class="keyword">const</span> group_pointer_type previous, <span class="keyword">const</span> size_type group_num) PLF_NOEXCEPT</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            {</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                last_endpoint = elements + increment;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                next_group = next;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                free_list_head = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                previous_group = previous;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                size = increment;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;                erasures_list_next_group = NULL;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                group_number = group_num;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160; </div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                std::memset(&amp;*skipfield, 0, <span class="keyword">sizeof</span>(skipfield_type) * <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(capacity)); <span class="comment">// capacity + 1 is not necessary here as the end skipfield is never written to after initialization</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;            }</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160; </div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160; </div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160; </div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            ~group() PLF_NOEXCEPT</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;            {</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                <span class="comment">// Null check not necessary (for copied group as above) as delete will also perform a null check.</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                PLF_DEALLOCATE(aligned_struct_allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>aligned_struct_pointer_type<span class="keyword">&gt;</span>(elements), PLF_GROUP_ALIGNED_BLOCK_SIZE(capacity));</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;            }</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        };</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160; </div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160; </div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160; </div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160; </div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160; </div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        <span class="comment">// Iterators:</span></div>
<div class="line"><a name="l00463"></a><span class="lineno"><a class="line" href="classplf_1_1colony_1_1colony__iterator.html">  463</a></span>&#160;        <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const&gt; <span class="keyword">class </span><a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        {</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        <span class="keyword">private</span>:</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;            group_pointer_type      group_pointer;</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            aligned_pointer_type    element_pointer;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;            skipfield_pointer_type  skipfield_pointer;</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160; </div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        <span class="keyword">public</span>:</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;            <span class="keyword">typedef</span> std::bidirectional_iterator_tag iterator_category;</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;            <span class="keyword">typedef</span> <span class="keyword">typename</span> colony::value_type         value_type;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;            <span class="keyword">typedef</span> <span class="keyword">typename</span> colony::difference_type    difference_type;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;            <span class="keyword">typedef</span> <span class="keyword">typename</span> choose&lt;is_const, typename colony::const_pointer, typename colony::pointer&gt;::type       pointer;</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;            <span class="keyword">typedef</span> <span class="keyword">typename</span> choose&lt;is_const, typename colony::const_reference, typename colony::reference&gt;::type reference;</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160; </div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classplf_1_1colony.html">colony</a>;</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&lt;false&gt;;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&lt;true&gt;;</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160; </div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160; </div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160; </div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; source) PLF_NOEXCEPT</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;            {</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                group_pointer = source.group_pointer;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;                element_pointer = source.element_pointer;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                skipfield_pointer = source.skipfield_pointer;</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;            }</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160; </div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160; </div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160; </div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;!is_const&gt;</a>&amp; source) PLF_NOEXCEPT</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            {</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                group_pointer = source.group_pointer;</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                element_pointer = source.element_pointer;</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                skipfield_pointer = source.skipfield_pointer;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            }</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160; </div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160; </div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160; </div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;            <span class="comment">// Move assignment - only really necessary if the allocator uses non-standard ie. &quot;smart&quot; pointers</span></div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; operator = (<a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp;&amp; source) PLF_NOEXCEPT</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            {</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                assert(&amp;source != <span class="keyword">this</span>);</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                group_pointer = std::move(source.group_pointer);</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                element_pointer = std::move(source.element_pointer);</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                skipfield_pointer = std::move(source.skipfield_pointer);</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;            }</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160; </div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160; </div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160; </div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; operator = (<a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;!is_const&gt;</a>&amp;&amp; source) PLF_NOEXCEPT</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;            {</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                group_pointer = std::move(source.group_pointer);</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                element_pointer = std::move(source.element_pointer);</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                skipfield_pointer = std::move(source.skipfield_pointer);</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            }</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160; </div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160; </div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160; </div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            {</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                <span class="keywordflow">return</span> (element_pointer == rh.element_pointer);</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            }</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160; </div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160; </div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160; </div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;!is_const&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;            {</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                <span class="keywordflow">return</span> (element_pointer == rh.element_pointer);</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            }</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160; </div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160; </div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160; </div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;            {</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                <span class="keywordflow">return</span> (element_pointer != rh.element_pointer);</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;            }</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160; </div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160; </div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160; </div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;!is_const&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;            {</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                <span class="keywordflow">return</span> (element_pointer != rh.element_pointer);</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;            }</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160; </div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160; </div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160; </div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE reference operator * () <span class="keyword">const</span> <span class="comment">// may cause exception with uninitialized iterator</span></div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;            {</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                <span class="keywordflow">return</span> *(<span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(element_pointer));</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;            }</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160; </div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160; </div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160; </div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE pointer operator -&gt; () <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            {</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(element_pointer);</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            }</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160; </div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160; </div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160; </div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; !defined(__clang__) &amp;&amp; !defined(__GNUC__) &amp;&amp; _MSC_VER &lt;= 1600 // MSVC 2010 needs a bit of a helping hand when it comes to optimizing</span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; operator ++ ()</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; operator ++ ()</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;            {</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                assert(group_pointer != NULL); <span class="comment">// covers uninitialised colony_iterator</span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                skipfield_type skip = *(++skipfield_pointer);</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160; </div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                <span class="keywordflow">if</span> ((element_pointer += <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(skip) + 1u) == group_pointer-&gt;last_endpoint &amp;&amp; group_pointer-&gt;next_group != NULL) <span class="comment">// ie. beyond end of current memory block. Second condition allows iterator to reach end(), which may be 1 past end of block, if block has been fully used and another block is not allocated</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                {</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                    group_pointer = group_pointer-&gt;next_group;</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                    <span class="keyword">const</span> aligned_pointer_type elements = group_pointer-&gt;elements;</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                    <span class="keyword">const</span> skipfield_pointer_type skipfield = group_pointer-&gt;skipfield;</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                    skip = *skipfield;</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                    element_pointer = elements + skip;</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                    skipfield_pointer = skipfield;</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                }</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160; </div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                skipfield_pointer += skip;</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;            }</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160; </div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160; </div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160; </div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a> operator ++(<span class="keywordtype">int</span>)</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;            {</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;                <span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a> copy(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;                ++* <span class="keyword">this</span>;</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                <span class="keywordflow">return</span> copy;</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;            }</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160; </div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160; </div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160; </div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <span class="keyword">public</span>:</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160; </div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; operator -- ()</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;            {</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                assert(group_pointer != NULL);</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160; </div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                <span class="keywordflow">if</span> (element_pointer != group_pointer-&gt;elements) <span class="comment">// ie. not already at beginning of group</span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                {</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                    <span class="keyword">const</span> skipfield_type skip = *(--skipfield_pointer);</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                    skipfield_pointer -= skip;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160; </div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                    <span class="keywordflow">if</span> ((element_pointer -= <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(skip) + 1u) != group_pointer-&gt;elements - 1) <span class="comment">// ie. iterator was not already at beginning of colony (with some previous consecutive deleted elements), and skipfield does not takes us into the previous group)</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                    {</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                    }</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                }</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160; </div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                group_pointer = group_pointer-&gt;previous_group;</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                <span class="keyword">const</span> skipfield_pointer_type skipfield = group_pointer-&gt;skipfield + group_pointer-&gt;capacity - 1;</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;                <span class="keyword">const</span> skipfield_type skip = *skipfield;</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                element_pointer = (<span class="keyword">reinterpret_cast&lt;</span>colony::aligned_pointer_type<span class="keyword">&gt;</span>(group_pointer-&gt;skipfield) - 1) - skip;</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                skipfield_pointer = skipfield - skip;</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;            }</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160; </div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160; </div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160; </div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a> operator -- (<span class="keywordtype">int</span>)</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;            {</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                <span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a> copy(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;                --* <span class="keyword">this</span>;</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;                <span class="keywordflow">return</span> copy;</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;            }</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160; </div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160; </div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160; </div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt; (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            {</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                <span class="keywordflow">return</span> ((group_pointer == rh.group_pointer) &amp; (element_pointer &gt; rh.element_pointer)) || (group_pointer != rh.group_pointer &amp;&amp; group_pointer-&gt;group_number &gt; rh.group_pointer-&gt;group_number);</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            }</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160; </div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160; </div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160; </div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;            {</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                <span class="keywordflow">return</span> rh &gt; *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;            }</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160; </div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160; </div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160; </div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;= (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;            {</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                <span class="keywordflow">return</span> !(rh &gt; *<span class="keyword">this</span>);</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;            }</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160; </div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160; </div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160; </div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt;= (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;            {</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                <span class="keywordflow">return</span> !(*<span class="keyword">this</span> &gt; rh);</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;            }</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160; </div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160; </div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160; </div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="preprocessor">#ifdef PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">int</span> operator &lt;=&gt; (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;            {</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                <span class="keywordflow">return</span> (element_pointer == rh.element_pointer) ? 0 : ((*<span class="keyword">this</span> &gt; rh) ? 1 : -1);</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;            }</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160; </div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160; </div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160; </div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>() PLF_NOEXCEPT: group_pointer(NULL), element_pointer(NULL), skipfield_pointer(NULL) {}</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160; </div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160; </div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160; </div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        <span class="keyword">private</span>:</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;            <span class="comment">// Used by cend(), erase() etc:</span></div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>(<span class="keyword">const</span> group_pointer_type group_p, <span class="keyword">const</span> aligned_pointer_type element_p, <span class="keyword">const</span> skipfield_pointer_type skipfield_p) PLF_NOEXCEPT : group_pointer(group_p), element_pointer(element_p), skipfield_pointer(skipfield_p) {}</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160; </div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160; </div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;        <span class="keyword">public</span>:</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160; </div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;            <span class="comment">// Friend functions:</span></div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160; </div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">class</span> distance_type&gt;</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;            <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> advance(<a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; it, distance_type distance)</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;            {</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                it.advance(<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(distance));</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;            }</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160; </div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160; </div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160; </div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;            <span class="keyword">friend</span> <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a> next(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; it, <span class="keyword">const</span> difference_type distance)</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;            {</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;                <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a> return_iterator(it);</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;                return_iterator.advance(<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(distance));</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;                <span class="keywordflow">return</span> return_iterator;</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;            }</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160; </div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160; </div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160; </div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;            <span class="keyword">friend</span> <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a> prev(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; it, <span class="keyword">const</span> difference_type distance)</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;            {</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;                <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a> return_iterator(it);</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;                return_iterator.advance(-(<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(distance)));</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;                <span class="keywordflow">return</span> return_iterator;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;            }</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160; </div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160; </div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160; </div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;            <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">typename</span> colony_iterator::difference_type distance(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; first, <span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; last)</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;            {</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;                <span class="keywordflow">return</span> first.distance(last);</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;            }</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160; </div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160; </div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160; </div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;        <span class="keyword">private</span>:</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160; </div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;            <span class="comment">// Advance implementation:</span></div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160; </div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;            <span class="keywordtype">void</span> advance(difference_type distance) <span class="comment">// Cannot be noexcept due to the possibility of an uninitialized iterator</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;            {</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;                assert(group_pointer != NULL); <span class="comment">// covers uninitialized colony_iterator &amp;&amp; empty group</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160; </div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;                <span class="comment">// Now, run code based on the nature of the distance type - negative, positive or zero:</span></div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;                <span class="keywordflow">if</span> (distance &gt; 0) <span class="comment">// ie. +=</span></div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;                {</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;                    <span class="comment">// Code explanation:</span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;                    <span class="comment">// For the initial state of the iterator, we don&#39;t know how what elements have been erased before that element in that group.</span></div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;                    <span class="comment">// So for the first group, we follow the following logic:</span></div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;                    <span class="comment">// 1. If no elements have been erased in the group, we do simple addition to progress either to within the group (if the distance is small enough) or the end of the group and subtract from distance accordingly.</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;                    <span class="comment">// 2. If any of the first group elements have been erased, we manually iterate, as we don&#39;t know whether the erased elements occur before or after the initial iterator position, and we subtract 1 from the distance amount each time. Iteration continues until either distance becomes zero, or we reach the end of the group.</span></div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160; </div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;                    <span class="comment">// For all subsequent groups, we follow this logic:</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;                    <span class="comment">// 1. If distance is larger than the total number of non-erased elements in a group, we skip that group and subtract the number of elements in that group from distance</span></div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;                    <span class="comment">// 2. If distance is smaller than the total number of non-erased elements in a group, then:</span></div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;                    <span class="comment">//   a. if there&#39;re no erased elements in the group we simply add distance to group-&gt;elements to find the new location for the iterator</span></div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                    <span class="comment">//   b. if there are erased elements in the group, we manually iterate and subtract 1 from distance on each iteration, until the new iterator location is found ie. distance = 0</span></div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160; </div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                    <span class="comment">// Note: incrementing element_pointer is avoided until necessary to avoid needless calculations</span></div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160; </div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;                    assert(!(element_pointer == group_pointer-&gt;last_endpoint &amp;&amp; group_pointer-&gt;next_group == NULL)); <span class="comment">// Check that we&#39;re not already at end()</span></div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160; </div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;                    <span class="comment">// Special case for initial element pointer and initial group (we don&#39;t know how far into the group the element pointer is)</span></div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;                    <span class="keywordflow">if</span> (element_pointer != group_pointer-&gt;elements + *(group_pointer-&gt;skipfield)) <span class="comment">// ie. != first non-erased element in group</span></div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;                    {</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                        <span class="keyword">const</span> difference_type distance_from_end = <span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(group_pointer-&gt;last_endpoint - element_pointer);</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160; </div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                        <span class="keywordflow">if</span> (group_pointer-&gt;size == <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(distance_from_end)) <span class="comment">// ie. if there are no erasures in the group (using endpoint - elements_start to determine number of elements in group just in case this is the last group of the colony, in which case group-&gt;last_endpoint != group-&gt;elements + group-&gt;capacity)</span></div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                        {</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;                            <span class="keywordflow">if</span> (distance &lt; distance_from_end)</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;                            {</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                                element_pointer += distance;</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                                skipfield_pointer += distance;</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                            }</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group_pointer-&gt;next_group == NULL) <span class="comment">// either we&#39;ve reached end() or gone beyond it, so bound to end()</span></div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                            {</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;                                element_pointer = group_pointer-&gt;last_endpoint;</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                                skipfield_pointer += distance_from_end;</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                            }</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                            {</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;                                distance -= distance_from_end;</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                            }</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;                        }</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;                        {</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;                            <span class="keyword">const</span> skipfield_pointer_type endpoint = skipfield_pointer + distance_from_end;</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160; </div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;                            <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;                            {</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;                                ++skipfield_pointer;</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;                                skipfield_pointer += *skipfield_pointer;</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;                                --distance;</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160; </div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;                                <span class="keywordflow">if</span> (skipfield_pointer == endpoint)</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;                                {</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;                                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;                                }</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;                                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (distance == 0)</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                                {</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;                                    element_pointer = group_pointer-&gt;elements + (skipfield_pointer - group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;                                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;                                }</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;                            }</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160; </div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;                            <span class="keywordflow">if</span> (group_pointer-&gt;next_group == NULL) <span class="comment">// either we&#39;ve reached end() or gone beyond it, so bound to end()</span></div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;                            {</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                                element_pointer = group_pointer-&gt;last_endpoint;</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;                            }</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;                        }</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160; </div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                        group_pointer = group_pointer-&gt;next_group;</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160; </div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;                        <span class="keywordflow">if</span> (distance == 0)</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                        {</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;                            element_pointer = group_pointer-&gt;elements + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                        }</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;                    }</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160; </div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160; </div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;                    <span class="comment">// Intermediary groups - at the start of this code block and the subsequent block, the position of the iterator is assumed to be the first non-erased element in the current group:</span></div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;                    <span class="keywordflow">while</span> (<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(group_pointer-&gt;size) &lt;= distance)</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;                    {</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                        <span class="keywordflow">if</span> (group_pointer-&gt;next_group == NULL) <span class="comment">// either we&#39;ve reached end() or gone beyond it, so bound to end()</span></div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;                        {</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                            element_pointer = group_pointer-&gt;last_endpoint;</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield + (group_pointer-&gt;last_endpoint - group_pointer-&gt;elements);</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;                        }</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((distance -= group_pointer-&gt;size) == 0)</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;                        {</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;                            group_pointer = group_pointer-&gt;next_group;</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;                            element_pointer = group_pointer-&gt;elements + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;                        }</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;                        {</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;                            group_pointer = group_pointer-&gt;next_group;</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;                        }</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;                    }</div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160; </div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160; </div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;                    <span class="comment">// Final group (if not already reached):</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;                    <span class="keywordflow">if</span> (group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// No erasures in this group, use straight pointer addition</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;                    {</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;                        element_pointer = group_pointer-&gt;elements + distance;</div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;                        skipfield_pointer = group_pointer-&gt;skipfield + distance;</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;                    }</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;                    <span class="keywordflow">else</span>     <span class="comment">// ie. size &gt; distance - safe to ignore endpoint check condition while incrementing:</span></div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                    {</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                        skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160; </div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;                        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                        {</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                            ++skipfield_pointer;</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;                            skipfield_pointer += *skipfield_pointer;</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;                        } <span class="keywordflow">while</span> (--distance != 0);</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160; </div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;                        element_pointer = group_pointer-&gt;elements + (skipfield_pointer - group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;                    }</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160; </div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;                }</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (distance &lt; 0) <span class="comment">// for negative change</span></div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                {</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;                    <span class="comment">// Code logic is very similar to += above</span></div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;                    assert(!((element_pointer == group_pointer-&gt;elements + *(group_pointer-&gt;skipfield)) &amp;&amp; group_pointer-&gt;previous_group == NULL)); <span class="comment">// check that we&#39;re not already at begin()</span></div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;                    distance = -distance;</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160; </div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;                    <span class="comment">// Special case for initial element pointer and initial group (we don&#39;t know how far into the group the element pointer is)</span></div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                    <span class="keywordflow">if</span> (element_pointer != group_pointer-&gt;last_endpoint) <span class="comment">// ie. != end()</span></div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                    {</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;                        <span class="keywordflow">if</span> (group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. no prior erasures have occurred in this group</span></div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;                        {</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;                            <span class="keyword">const</span> difference_type distance_from_beginning = <span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(element_pointer - group_pointer-&gt;elements);</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160; </div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;                            <span class="keywordflow">if</span> (distance &lt;= distance_from_beginning)</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;                            {</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;                                element_pointer -= distance;</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;                                skipfield_pointer -= distance;</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;                            }</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;                            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group_pointer-&gt;previous_group == NULL) <span class="comment">// ie. we&#39;ve gone before begin(), so bound to begin()</span></div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;                            {</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;                                element_pointer = group_pointer-&gt;elements;</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;                                skipfield_pointer = group_pointer-&gt;skipfield;</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;                            }</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;                            {</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;                                distance -= distance_from_beginning;</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;                            }</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;                        }</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;                        {</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;                            <span class="keyword">const</span> skipfield_pointer_type beginning_point = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160; </div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;                            <span class="keywordflow">while</span> (skipfield_pointer != beginning_point)</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;                            {</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                                --skipfield_pointer;</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;                                skipfield_pointer -= *skipfield_pointer;</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160; </div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;                                <span class="keywordflow">if</span> (--distance == 0)</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;                                {</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;                                    element_pointer = group_pointer-&gt;elements + (skipfield_pointer - group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;                                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;                                }</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;                            }</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160; </div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;                            <span class="keywordflow">if</span> (group_pointer-&gt;previous_group == NULL)</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;                            {</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;                                element_pointer = group_pointer-&gt;elements + *(group_pointer-&gt;skipfield); <span class="comment">// This is first group, so bound to begin() (just in case final decrement took us before begin())</span></div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;                                skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;                            }</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;                        }</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160; </div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;                        group_pointer = group_pointer-&gt;previous_group;</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;                    }</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160; </div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160; </div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;                    <span class="comment">// Intermediary groups - at the start of this code block and the subsequent block, the position of the iterator is assumed to be either the first non-erased element in the next group over, or end():</span></div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;                    <span class="keywordflow">while</span> (<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(group_pointer-&gt;size) &lt; distance)</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;                    {</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                        <span class="keywordflow">if</span> (group_pointer-&gt;previous_group == NULL) <span class="comment">// we&#39;ve gone beyond begin(), so bound to it</span></div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;                        {</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;                            element_pointer = group_pointer-&gt;elements + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;                        }</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160; </div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;                        distance -= group_pointer-&gt;size;</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                        group_pointer = group_pointer-&gt;previous_group;</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;                    }</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160; </div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160; </div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;                    <span class="comment">// Final group (if not already reached):</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;                    <span class="keywordflow">if</span> (<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(group_pointer-&gt;size) == distance)</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;                    {</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;                        element_pointer = group_pointer-&gt;elements + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;                        skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;                    }</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. no erased elements in this group</span></div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;                    {</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;                        element_pointer = <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(group_pointer-&gt;skipfield) - distance;</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;                        skipfield_pointer = (group_pointer-&gt;skipfield + group_pointer-&gt;capacity) - distance;</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;                    }</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;                    <span class="keywordflow">else</span> <span class="comment">// ie. no more groups to traverse but there are erased elements in this group</span></div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;                    {</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;                        skipfield_pointer = group_pointer-&gt;skipfield + group_pointer-&gt;capacity;</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160; </div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;                        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;                        {</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;                            --skipfield_pointer;</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;                            skipfield_pointer -= *skipfield_pointer;</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                        } <span class="keywordflow">while</span> (--distance != 0);</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160; </div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;                        element_pointer = group_pointer-&gt;elements + (skipfield_pointer - group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                    }</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                }</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160; </div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                <span class="comment">// Only distance == 0 reaches here</span></div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;            }</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160; </div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160; </div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160; </div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;            <span class="comment">// distance implementation:</span></div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160; </div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;            difference_type distance(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; last)<span class="keyword"> const</span></div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;<span class="keyword">            </span>{</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;                <span class="comment">// Code logic:</span></div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;                <span class="comment">// If iterators are the same, return 0</span></div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;                <span class="comment">// Otherwise, find which iterator is later in colony, copy that to iterator2. Copy the lower to iterator1.</span></div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;                <span class="comment">// If they are not pointing to elements in the same group, process the intermediate groups and add distances,</span></div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;                <span class="comment">// skipping manual incrementation in all but the initial and final groups.</span></div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;                <span class="comment">// In the initial and final groups, manual incrementation must be used to calculate distance, if there have been no prior erasures in those groups.</span></div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;                <span class="comment">// If there are no prior erasures in either of those groups, we can use pointer arithmetic to calculate the distances for those groups.</span></div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160; </div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;                assert(!(group_pointer == NULL) &amp;&amp; !(last.group_pointer == NULL));  <span class="comment">// Check that they are initialized</span></div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160; </div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;                <span class="keywordflow">if</span> (last.element_pointer == element_pointer)</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;                {</div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;                    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;                }</div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160; </div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;                difference_type distance = 0;</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;                <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a> iterator1 = *<span class="keyword">this</span>, iterator2 = last;</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> swap = iterator1 &gt; iterator2;</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160; </div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;                <span class="keywordflow">if</span> (swap) <span class="comment">// Less common case</span></div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;                {</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;                    iterator1 = last;</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;                    iterator2 = *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;                }</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160; </div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;                <span class="keywordflow">if</span> (iterator1.group_pointer != iterator2.group_pointer) <span class="comment">// if not in same group, process intermediate groups</span></div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;                {</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;                    <span class="comment">// Process initial group:</span></div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                    <span class="keywordflow">if</span> (iterator1.group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// If no prior erasures have occured in this group we can do simple addition</span></div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;                    {</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                        distance += <span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(iterator1.group_pointer-&gt;last_endpoint - iterator1.element_pointer);</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;                    }</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iterator1.element_pointer == iterator1.group_pointer-&gt;elements + *(iterator1.group_pointer-&gt;skipfield)) <span class="comment">// ie. element is at start of group - rare case</span></div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;                    {</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;                        distance += <span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(iterator1.group_pointer-&gt;size);</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;                    }</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;                    <span class="keywordflow">else</span> <span class="comment">// Manually iterate to find distance to end of group:</span></div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;                    {</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;                        <span class="keyword">const</span> skipfield_pointer_type endpoint = iterator1.skipfield_pointer + (iterator1.group_pointer-&gt;last_endpoint - iterator1.element_pointer);</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160; </div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;                        <span class="keywordflow">while</span> (iterator1.skipfield_pointer != endpoint)</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;                        {</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;                            ++iterator1.skipfield_pointer;</div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;                            iterator1.skipfield_pointer += *iterator1.skipfield_pointer;</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;                            ++distance;</div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;                        }</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;                    }</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160; </div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;                    <span class="comment">// Process all other intermediate groups:</span></div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;                    iterator1.group_pointer = iterator1.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160; </div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;                    <span class="keywordflow">while</span> (iterator1.group_pointer != iterator2.group_pointer)</div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;                    {</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;                        distance += <span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(iterator1.group_pointer-&gt;size);</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;                        iterator1.group_pointer = iterator1.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;                    }</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160; </div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;                    iterator1.skipfield_pointer = iterator1.group_pointer-&gt;skipfield;</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;                }</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160; </div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160; </div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;                <span class="keywordflow">if</span> (iterator2.group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. no erasures in this group, direct subtraction is possible</span></div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;                {</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;                    distance += iterator2.skipfield_pointer - iterator1.skipfield_pointer;</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                }</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iterator2.group_pointer-&gt;last_endpoint - 1 &gt;= iterator2.element_pointer || iterator2.element_pointer + *(iterator2.skipfield_pointer + 1) == iterator2.group_pointer-&gt;last_endpoint) <span class="comment">// ie. if iterator2 is .end() or the last element in the block</span></div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;                {</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;                    distance += <span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(iterator2.group_pointer-&gt;size) - (iterator2.group_pointer-&gt;last_endpoint - iterator2.element_pointer);</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;                }</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;                {</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;                    <span class="keywordflow">while</span> (iterator1.skipfield_pointer != iterator2.skipfield_pointer)</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;                    {</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;                        ++iterator1.skipfield_pointer;</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;                        iterator1.skipfield_pointer += *iterator1.skipfield_pointer;</div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;                        ++distance;</div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;                    }</div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;                }</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160; </div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160; </div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;                <span class="keywordflow">if</span> (swap)</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;                {</div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;                    distance = -distance;</div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;                }</div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160; </div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;                <span class="keywordflow">return</span> distance;</div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;            }</div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160; </div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160; </div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;        <span class="keyword">public</span>:</div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160; </div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp; source) PLF_NOEXCEPT :</div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;                group_pointer(source.group_pointer),</div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;                element_pointer(source.element_pointer),</div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;                skipfield_pointer(source.skipfield_pointer)</div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;            {}</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160; </div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160; </div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;!is_const&gt;</a>&amp; source) PLF_NOEXCEPT:</div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;            group_pointer(source.group_pointer),</div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;                element_pointer(source.element_pointer),</div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;                skipfield_pointer(source.skipfield_pointer)</div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;            {}</div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160; </div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160; </div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160; </div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;            <span class="comment">// move constructors</span></div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>(<a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>&amp;&amp; source) PLF_NOEXCEPT:</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;            group_pointer(std::move(source.group_pointer)),</div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;                element_pointer(std::move(source.element_pointer)),</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;                skipfield_pointer(std::move(source.skipfield_pointer))</div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;            {}</div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160; </div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160; </div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator</a>(<a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;!is_const&gt;</a>&amp;&amp; source) PLF_NOEXCEPT:</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;            group_pointer(std::move(source.group_pointer)),</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;                element_pointer(std::move(source.element_pointer)),</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;                skipfield_pointer(std::move(source.skipfield_pointer))</div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;            {}</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160; </div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;        }; <span class="comment">// colony_iterator</span></div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160; </div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160; </div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160; </div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160; </div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160; </div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;        <span class="comment">// Reverse iterators:</span></div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160; </div>
<div class="line"><a name="l01103"></a><span class="lineno"><a class="line" href="classplf_1_1colony_1_1colony__reverse__iterator.html"> 1103</a></span>&#160;        <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> r_is_const&gt; <span class="keyword">class </span><a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a></div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;        {</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;        <span class="keyword">private</span>:</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">iterator</a> it;</div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160; </div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;        <span class="keyword">public</span>:</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;            <span class="keyword">typedef</span> std::bidirectional_iterator_tag iterator_category;</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;            <span class="keyword">typedef</span> <span class="keyword">typename</span> colony::value_type         value_type;</div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;            <span class="keyword">typedef</span> <span class="keyword">typename</span> colony::difference_type    difference_type;</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;            <span class="keyword">typedef</span> <span class="keyword">typename</span> choose&lt;r_is_const, typename colony::const_pointer, typename colony::pointer&gt;::type     pointer;</div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;            <span class="keyword">typedef</span> <span class="keyword">typename</span> choose&lt;r_is_const, typename colony::const_reference, typename colony::reference&gt;::type reference;</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160; </div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;            <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classplf_1_1colony.html">colony</a>;</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160; </div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160; </div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; source) PLF_NOEXCEPT</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;            {</div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;                it = source.it;</div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;            }</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160; </div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160; </div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160; </div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;!r_is_const&gt;</a>&amp; source) PLF_NOEXCEPT</div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;            {</div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;                it = source.it;</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;            }</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160; </div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160; </div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160; </div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;is_const_it&gt;</a>&amp; source) PLF_NOEXCEPT</div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;            {</div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;                it = source;</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;            }</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160; </div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160; </div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160; </div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;            <span class="comment">// move assignment</span></div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; operator = (<a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp;&amp; source) PLF_NOEXCEPT</div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;            {</div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;                assert(&amp;source != <span class="keyword">this</span>);</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;                it = std::move(source.it);</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;            }</div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160; </div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160; </div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; operator = (<a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;!r_is_const&gt;</a>&amp;&amp; source) PLF_NOEXCEPT</div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;            {</div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;                it = std::move(source.it);</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;            }</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160; </div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160; </div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160; </div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;            {</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;                <span class="keywordflow">return</span> (it == rh.it);</div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;            }</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160; </div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160; </div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160; </div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;!r_is_const&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;            {</div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;                <span class="keywordflow">return</span> (it == rh.it);</div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;            }</div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160; </div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160; </div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160; </div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;            {</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;                <span class="keywordflow">return</span> (it != rh.it);</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;            }</div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160; </div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160; </div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160; </div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;!r_is_const&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;            {</div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;                <span class="keywordflow">return</span> (it != rh.it);</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;            }</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160; </div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160; </div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160; </div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE reference operator * () <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;            {</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;                <span class="keywordflow">return</span> *(<span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(it.element_pointer));</div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;            }</div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160; </div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160; </div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160; </div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE pointer* operator -&gt; () <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;            {</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(it.element_pointer);</div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;            }</div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160; </div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160; </div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160; </div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;            <span class="comment">// In this case we have to redefine the algorithm, rather than using the internal iterator&#39;s -- operator, in order for the reverse_iterator to be allowed to reach rend() ie. begin_iterator - 1</span></div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; operator ++ ()</div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;            {</div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;                colony::group_pointer_type&amp; group_pointer = it.group_pointer;</div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;                colony::aligned_pointer_type&amp; element_pointer = it.element_pointer;</div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;                colony::skipfield_pointer_type&amp; skipfield_pointer = it.skipfield_pointer;</div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160; </div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;                assert(group_pointer != NULL);</div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160; </div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;                <span class="keywordflow">if</span> (element_pointer != group_pointer-&gt;elements) <span class="comment">// ie. not already at beginning of group</span></div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;                {</div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;                    element_pointer -= <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(*(--skipfield_pointer)) + 1u;</div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;                    skipfield_pointer -= *skipfield_pointer;</div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160; </div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;                    <span class="keywordflow">if</span> (!(element_pointer == group_pointer-&gt;elements - 1 &amp;&amp; group_pointer-&gt;previous_group == NULL)) <span class="comment">// ie. iterator is not == rend()</span></div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;                    {</div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;                        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;                    }</div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;                }</div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160; </div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;                <span class="keywordflow">if</span> (group_pointer-&gt;previous_group != NULL) <span class="comment">// ie. not first group in colony</span></div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;                {</div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;                    group_pointer = group_pointer-&gt;previous_group;</div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;                    skipfield_pointer = group_pointer-&gt;skipfield + group_pointer-&gt;capacity - 1;</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;                    element_pointer = (<span class="keyword">reinterpret_cast&lt;</span>colony::aligned_pointer_type<span class="keyword">&gt;</span>(group_pointer-&gt;skipfield) - 1) - *skipfield_pointer;</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;                    skipfield_pointer -= *skipfield_pointer;</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;                }</div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;                <span class="keywordflow">else</span> <span class="comment">// necessary so that reverse_iterator can end up == rend(), if we were already at first element in colony</span></div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;                {</div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;                    --element_pointer;</div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;                    --skipfield_pointer;</div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;                }</div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160; </div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;            }</div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160; </div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160; </div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160; </div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a> operator ++ (<span class="keywordtype">int</span>)</div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;            {</div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;                <span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a> copy(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;                ++* <span class="keyword">this</span>;</div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;                <span class="keywordflow">return</span> copy;</div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;            }</div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160; </div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160; </div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160; </div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;            <span class="keyword">inline</span> PLF_FORCE_INLINE <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; operator -- ()</div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;            {</div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;                ++it;</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;            }</div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160; </div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160; </div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160; </div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;            <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a> operator -- (<span class="keywordtype">int</span>)</div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;            {</div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;                <span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a> copy(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;                --* <span class="keyword">this</span>;</div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;                <span class="keywordflow">return</span> copy;</div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;            }</div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160; </div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160; </div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160; </div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;            <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony::iterator</a> base()<span class="keyword"> const</span></div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;<span class="keyword">            </span>{</div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;                <span class="keywordflow">return</span> ++(<span class="keyword">typename</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony::iterator</a>(it));</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;            }</div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160; </div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160; </div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160; </div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt; (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;            {</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;                <span class="keywordflow">return</span> (rh.it &gt; it);</div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;            }</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160; </div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160; </div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160; </div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;            {</div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;                <span class="keywordflow">return</span> (it &gt; rh.it);</div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;            }</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160; </div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160; </div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160; </div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;= (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;            {</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;                <span class="keywordflow">return</span> !(it &gt; rh.it);</div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;            }</div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160; </div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160; </div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160; </div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt;= (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;            {</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;                <span class="keywordflow">return</span> !(rh.it &gt; it);</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;            }</div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160; </div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160; </div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160; </div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;<span class="preprocessor">#ifdef PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;            <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const_it&gt;</div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">int</span> operator &lt;=&gt; (<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;is_const_it&gt;</a>&amp; rh) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;            {</div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;                <span class="keywordflow">return</span> (rh.it &lt;=&gt; it);</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;            }</div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160; </div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160; </div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160; </div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>() PLF_NOEXCEPT</div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;            {}</div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160; </div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160; </div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160; </div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; source) PLF_NOEXCEPT:</div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;            it(source.it)</div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;            {}</div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160; </div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160; </div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160; </div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;!r_is_const&gt;</a>&amp; source) PLF_NOEXCEPT:</div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;            it(source.it)</div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;            {}</div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160; </div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160; </div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160; </div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;            <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> is_const&gt;</div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;            <span class="keyword">explicit</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__iterator.html">colony_iterator&lt;is_const&gt;</a>&amp; source) PLF_NOEXCEPT:</div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;            it(source)</div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;            {}</div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160; </div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160; </div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160; </div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160; </div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;        <span class="keyword">private</span>:</div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;            <span class="comment">// Used by rend(), etc:</span></div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>(<span class="keyword">const</span> group_pointer_type group_p, <span class="keyword">const</span> aligned_pointer_type element_p, <span class="keyword">const</span> skipfield_pointer_type skipfield_p) PLF_NOEXCEPT : it(group_p, element_p, skipfield_p) {}</div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160; </div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160; </div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160; </div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;        <span class="keyword">public</span>:</div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;            <span class="comment">// Friend functions:</span></div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160; </div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">class</span> distance_type&gt;</div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;            <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> advance(<a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; it, distance_type distance)</div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;            {</div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;                it.advance(<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(distance));</div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;            }</div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160; </div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160; </div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160; </div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;            <span class="keyword">friend</span> <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a> next(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; it, <span class="keyword">const</span> difference_type distance)</div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;            {</div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;                <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a> return_iterator(it);</div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;                return_iterator.advance(<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(distance));</div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;                <span class="keywordflow">return</span> return_iterator;</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;            }</div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160; </div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160; </div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160; </div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">class</span> distance_type&gt;</div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;            <span class="keyword">friend</span> <span class="keyword">inline</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a> prev(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; it, <span class="keyword">const</span> difference_type distance)</div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;            {</div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;                <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a> return_iterator(it);</div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;                return_iterator.advance(-(<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(distance)));</div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;                <span class="keywordflow">return</span> return_iterator;</div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;            }</div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160; </div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160; </div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160; </div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;            <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">typename</span> colony_reverse_iterator::difference_type distance(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; first, <span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; last)</div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;            {</div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;                <span class="keywordflow">return</span> first.distance(last);</div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;            }</div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160; </div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160; </div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160; </div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;            <span class="comment">// distance implementation:</span></div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160; </div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;            <span class="keyword">inline</span> difference_type distance(<span class="keyword">const</span> <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp; last)<span class="keyword"> const</span></div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="keyword">            </span>{</div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;                <span class="keywordflow">return</span> last.it.distance(it);</div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;            }</div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160; </div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160; </div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160; </div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;        <span class="keyword">private</span>:</div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160; </div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;            <span class="comment">// Advance for reverse_iterator and const_reverse_iterator - this needs to be implemented slightly differently to forward-iterator&#39;s advance, as it needs to be able to reach rend() (ie. begin() - 1) and to be bounded by rbegin():</span></div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;            <span class="keywordtype">void</span> advance(difference_type distance) <span class="comment">// could cause exception if iterator is uninitialized</span></div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;            {</div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;                group_pointer_type&amp; group_pointer = it.group_pointer;</div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;                aligned_pointer_type&amp; element_pointer = it.element_pointer;</div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;                skipfield_pointer_type&amp; skipfield_pointer = it.skipfield_pointer;</div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160; </div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;                assert(element_pointer != NULL);</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160; </div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;                <span class="keywordflow">if</span> (distance &gt; 0)</div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;                {</div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;                    assert(!(element_pointer == group_pointer-&gt;elements - 1 &amp;&amp; group_pointer-&gt;previous_group == NULL)); <span class="comment">// Check that we&#39;re not already at rend()</span></div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;                    <span class="comment">// Special case for initial element pointer and initial group (we don&#39;t know how far into the group the element pointer is)</span></div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;                    <span class="comment">// Since a reverse_iterator cannot == last_endpoint (ie. before rbegin()) we don&#39;t need to check for that like with iterator</span></div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;                    <span class="keywordflow">if</span> (group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;                    {</div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;                        <span class="keyword">const</span> difference_type distance_from_beginning = element_pointer - group_pointer-&gt;elements;</div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160; </div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;                        <span class="keywordflow">if</span> (distance &lt;= distance_from_beginning)</div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;                        {</div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;                            element_pointer -= distance;</div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;                            skipfield_pointer -= distance;</div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;                        }</div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group_pointer-&gt;previous_group == NULL) <span class="comment">// Either we&#39;ve reached rend() or gone beyond it, so bound to rend()</span></div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;                        {</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;                            element_pointer = group_pointer-&gt;elements - 1;</div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield - 1;</div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;                        }</div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;                        {</div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;                            distance -= distance_from_beginning;</div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;                        }</div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;                    }</div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;                    {</div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;                        <span class="keyword">const</span> skipfield_pointer_type beginning_point = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160; </div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;                        <span class="keywordflow">while</span> (skipfield_pointer != beginning_point)</div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;                        {</div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;                            --skipfield_pointer;</div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;                            skipfield_pointer -= *skipfield_pointer;</div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160; </div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;                            <span class="keywordflow">if</span> (--distance == 0)</div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;                            {</div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;                                element_pointer = group_pointer-&gt;elements + (skipfield_pointer - group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;                            }</div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;                        }</div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160; </div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;                        <span class="keywordflow">if</span> (group_pointer-&gt;previous_group == NULL)</div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;                        {</div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;                            element_pointer = group_pointer-&gt;elements - 1; <span class="comment">// If we&#39;ve reached rend(), bound to that</span></div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield - 1;</div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;                        }</div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;                    }</div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160; </div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;                    group_pointer = group_pointer-&gt;previous_group;</div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160; </div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160; </div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;                    <span class="comment">// Intermediary groups - at the start of this code block and the subsequent block, the position of the iterator is assumed to be the first non-erased element in the next group:</span></div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;                    <span class="keywordflow">while</span> (<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(group_pointer-&gt;size) &lt; distance)</div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;                    {</div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;                        <span class="keywordflow">if</span> (group_pointer-&gt;previous_group == NULL) <span class="comment">// bound to rend()</span></div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;                        {</div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;                            element_pointer = group_pointer-&gt;elements - 1;</div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield - 1;</div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;                        }</div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160; </div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;                        distance -= <span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(group_pointer-&gt;size);</div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;                        group_pointer = group_pointer-&gt;previous_group;</div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;                    }</div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160; </div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160; </div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;                    <span class="comment">// Final group (if not already reached)</span></div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;                    <span class="keywordflow">if</span> (<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(group_pointer-&gt;size) == distance)</div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;                    {</div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;                        element_pointer = group_pointer-&gt;elements + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;                        skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;                    }</div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;                    {</div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;                        element_pointer = <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(group_pointer-&gt;skipfield) - distance;</div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;                        skipfield_pointer = (group_pointer-&gt;skipfield + group_pointer-&gt;capacity) - distance;</div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;                    }</div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;                    {</div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;                        skipfield_pointer = group_pointer-&gt;skipfield + group_pointer-&gt;capacity;</div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160; </div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;                        <span class="keywordflow">do</span></div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;                        {</div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;                            --skipfield_pointer;</div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;                            skipfield_pointer -= *skipfield_pointer;</div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;                        } <span class="keywordflow">while</span> (--distance != 0);</div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160; </div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;                        element_pointer = group_pointer-&gt;elements + (skipfield_pointer - group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;                    }</div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;                }</div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (distance &lt; 0)</div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;                {</div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;                    assert(!((element_pointer == (group_pointer-&gt;last_endpoint - 1) - *(group_pointer-&gt;skipfield + (group_pointer-&gt;last_endpoint - group_pointer-&gt;elements) - 1)) &amp;&amp; group_pointer-&gt;next_group == NULL)); <span class="comment">// Check that we&#39;re not already at rbegin()</span></div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160; </div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;                    <span class="keywordflow">if</span> (element_pointer != group_pointer-&gt;elements + *(group_pointer-&gt;skipfield)) <span class="comment">// ie. != first non-erased element in group</span></div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;                    {</div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;                        <span class="keywordflow">if</span> (group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. if there are no erasures in the group</span></div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;                        {</div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;                            <span class="keyword">const</span> difference_type distance_from_end = group_pointer-&gt;last_endpoint - element_pointer;</div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160; </div>
<div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;                            <span class="keywordflow">if</span> (distance &lt; distance_from_end)</div>
<div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;                            {</div>
<div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;                                element_pointer += distance;</div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;                                skipfield_pointer += distance;</div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;                            }</div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;                            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group_pointer-&gt;next_group == NULL) <span class="comment">// bound to rbegin()</span></div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;                            {</div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;                                element_pointer = group_pointer-&gt;last_endpoint - 1; <span class="comment">// no erasures so we don&#39;t have to subtract skipfield value as we do below</span></div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;                                skipfield_pointer += distance_from_end - 1;</div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;                            }</div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;                            {</div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;                                distance -= distance_from_end;</div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;                            }</div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;                        }</div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;                        {</div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;                            <span class="keyword">const</span> skipfield_pointer_type endpoint = skipfield_pointer + (group_pointer-&gt;last_endpoint - element_pointer);</div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160; </div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;                            <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;                            {</div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;                                ++skipfield_pointer;</div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;                                skipfield_pointer += *skipfield_pointer;</div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;                                --distance;</div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160; </div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;                                <span class="keywordflow">if</span> (skipfield_pointer == endpoint)</div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;                                {</div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;                                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;                                }</div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;                                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (distance == 0)</div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;                                {</div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;                                    element_pointer = group_pointer-&gt;elements + (skipfield_pointer - group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;                                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;                                }</div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;                            }</div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160; </div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;                            <span class="keywordflow">if</span> (group_pointer-&gt;next_group == NULL) <span class="comment">// bound to rbegin()</span></div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;                            {</div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;                                --skipfield_pointer;</div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;                                element_pointer = (group_pointer-&gt;last_endpoint - 1) - *skipfield_pointer;</div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;                                skipfield_pointer -= *skipfield_pointer;</div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;                            }</div>
<div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;                        }</div>
<div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160; </div>
<div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;                        group_pointer = group_pointer-&gt;next_group;</div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160; </div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;                        <span class="keywordflow">if</span> (distance == 0)</div>
<div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;                        {</div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;                            element_pointer = group_pointer-&gt;elements + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;                        }</div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;                    }</div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160; </div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160; </div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;                    <span class="comment">// Intermediary groups - at the start of this code block and the subsequent block, the position of the iterator is assumed to be the first non-erased element in the current group, as a result of the previous code blocks:</span></div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;                    <span class="keywordflow">while</span> (<span class="keyword">static_cast&lt;</span>difference_type<span class="keyword">&gt;</span>(group_pointer-&gt;size) &lt;= distance)</div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;                    {</div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;                        <span class="keywordflow">if</span> (group_pointer-&gt;next_group == NULL) <span class="comment">// bound to rbegin()</span></div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;                        {</div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield + (group_pointer-&gt;last_endpoint - group_pointer-&gt;elements) - 1;</div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;                            element_pointer = (group_pointer-&gt;last_endpoint - 1) - *skipfield_pointer;</div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;                            skipfield_pointer -= *skipfield_pointer;</div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;                        }</div>
<div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((distance -= group_pointer-&gt;size) == 0)</div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;                        {</div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;                            group_pointer = group_pointer-&gt;next_group;</div>
<div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;                            element_pointer = group_pointer-&gt;elements + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;                            skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;                            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;                        }</div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;                        {</div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;                            group_pointer = group_pointer-&gt;next_group;</div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;                        }</div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;                    }</div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160; </div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160; </div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;                    <span class="comment">// Final group (if not already reached):</span></div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;                    <span class="keywordflow">if</span> (group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// No erasures in this group, use straight pointer addition</span></div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;                    {</div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;                        element_pointer = group_pointer-&gt;elements + distance;</div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;                        skipfield_pointer = group_pointer-&gt;skipfield + distance;</div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;                    }</div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;                    <span class="keywordflow">else</span> <span class="comment">// ie. size &gt; distance - safe to ignore endpoint check condition while incrementing:</span></div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;                    {</div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;                        skipfield_pointer = group_pointer-&gt;skipfield + *(group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160; </div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;                        <span class="keywordflow">do</span></div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;                        {</div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;                            ++skipfield_pointer;</div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;                            skipfield_pointer += *skipfield_pointer;</div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;                        } <span class="keywordflow">while</span> (--distance != 0);</div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160; </div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;                        element_pointer = group_pointer-&gt;elements + (skipfield_pointer - group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;                    }</div>
<div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160; </div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;                }</div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;            }</div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160; </div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160; </div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160; </div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;        <span class="keyword">public</span>:</div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160; </div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;            <span class="comment">// move constructors</span></div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>(<a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>&amp;&amp; source) PLF_NOEXCEPT :</div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;                it(std::move(source.it))</div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;            {}</div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160; </div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;            <a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator</a>(<a class="code" href="classplf_1_1colony_1_1colony__reverse__iterator.html">colony_reverse_iterator&lt;!r_is_const&gt;</a>&amp;&amp; source) PLF_NOEXCEPT :</div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;                it(std::move(source.it))</div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;            {}</div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160; </div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;        }; <span class="comment">// colony_reverse_iterator</span></div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160; </div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160; </div>
<div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160; </div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160; </div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160; </div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;        <span class="comment">// Used to prevent fill-insert/constructor calls being mistakenly resolved to range-insert/constructor calls</span></div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160; </div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;        <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> condition, <span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;        <span class="keyword">struct </span>plf_enable_if_c</div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;        {</div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;            <span class="keyword">typedef</span> T type;</div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;        };</div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160; </div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;        <span class="keyword">struct </span>plf_enable_if_c&lt;false, T&gt;</div>
<div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;        {};</div>
<div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160; </div>
<div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160; </div>
<div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160; </div>
<div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;        <span class="comment">// Colony Member variables:</span></div>
<div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160; </div>
<div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;        iterator                end_iterator, begin_iterator;</div>
<div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;        group_pointer_type  groups_with_erasures_list_head, <span class="comment">// Head of the singly-linked list of groups which have erased-element memory locations available for re-use</span></div>
<div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;            unused_groups_head;                 <span class="comment">// Head of singly-linked list of groups retained by erase() or created by reserve()</span></div>
<div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;        size_type               total_size, total_capacity;</div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160; </div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;        <span class="keyword">struct </span>ebco_pair2 : tuple_allocator_type <span class="comment">// Packaging the element pointer allocator with a lesser-used member variable, for empty-base-class optimisation</span></div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;        {</div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;            skipfield_type min_group_capacity;</div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;            <span class="keyword">explicit</span> ebco_pair2(<span class="keyword">const</span> skipfield_type min_elements) PLF_NOEXCEPT: min_group_capacity(min_elements) {}</div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;        }                           tuple_allocator_pair;</div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160; </div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;        <span class="keyword">struct </span>ebco_pair : group_allocator_type</div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;        {</div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;            skipfield_type max_group_capacity;</div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;            <span class="keyword">explicit</span> ebco_pair(<span class="keyword">const</span> skipfield_type max_elements) PLF_NOEXCEPT: max_group_capacity(max_elements) {}</div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;        }                           group_allocator_pair;</div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160; </div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160; </div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160; </div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;        <span class="comment">// An adaptive minimum based around sizeof(element_type), sizeof(group) and sizeof(colony):</span></div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;<span class="preprocessor">#define PLF_MIN_BLOCK_CAPACITY (sizeof(aligned_element_type) * 8 &gt; (sizeof(plf::colony&lt;element_type&gt;) + sizeof(group)) * 2) ? 8 : (((sizeof(plf::colony&lt;element_type&gt;) + sizeof(group)) * 2) / sizeof(aligned_element_type))</span></div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160; </div>
<div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160; </div>
<div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160; </div>
<div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> check_capacities_conformance(<a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> capacities)<span class="keyword"> const</span></div>
<div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;<span class="keyword">        </span>{</div>
<div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;            <span class="keywordflow">if</span> (capacities.min &lt; 2 || capacities.min &gt; capacities.max || capacities.max &gt; std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;            {</div>
<div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;                <span class="keywordflow">throw</span> std::length_error(<span class="stringliteral">&quot;Supplied memory block capacities outside of allowable ranges&quot;</span>);</div>
<div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;            }</div>
<div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;        }</div>
<div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160; </div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160; </div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> check_skipfield_conformance() const PLF_NOEXCEPT</div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;        {</div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;            PLF_STATIC_ASSERT(<span class="keyword">sizeof</span>(element_type) &gt;= <span class="keyword">sizeof</span>(skipfield_type) * 2, <span class="stringliteral">&quot;Element type is not large enough to accomodate colony requirements under C++98/03. Change to C++11 or above, or use a larger type.&quot;</span>); <span class="comment">// eg. under C++98/03, aligned_storage is not available, so sizeof(skipfield type) * 2 must be larger or equal to sizeof(element_type), otherwise the doubly-linked free lists of erased element indexes will not work correctly. So if you&#39;re storing chars, for example, and the skipfield type is unsigned short (currently default for this implementation), the compiler will flag you with this assert. Which means you cannot store char or unsigned char in colony under C++03, and if storing short or unsigned short you must use the priority::memory_use parameter in your template instantiation. Or just use C++11 and above.</span></div>
<div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;        }</div>
<div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160; </div>
<div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160; </div>
<div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160; </div>
<div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160; </div>
<div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;        <span class="comment">// Default constructor:</span></div>
<div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160; </div>
<div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;        colony() :</div>
<div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;            allocator_type(allocator_type()),</div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;            tuple_allocator_pair(PLF_MIN_BLOCK_CAPACITY),</div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;            group_allocator_pair(std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;        {</div>
<div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;            check_skipfield_conformance();</div>
<div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;        }</div>
<div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160; </div>
<div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160; </div>
<div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160; </div>
<div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;        <span class="keyword">explicit</span> colony(<span class="keyword">const</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> capacities) :</div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;            allocator_type(allocator_type()),</div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;            tuple_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.min)),</div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;            group_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.max))</div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;        {</div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;            check_skipfield_conformance();</div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;            check_capacities_conformance(capacities);</div>
<div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;        }</div>
<div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160; </div>
<div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160; </div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160; </div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;        <span class="comment">// Default constructor (allocator-extended):</span></div>
<div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160; </div>
<div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;        <span class="keyword">explicit</span> colony(<span class="keyword">const</span> allocator_type&amp; alloc) :</div>
<div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;            allocator_type(alloc),</div>
<div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;            tuple_allocator_pair(PLF_MIN_BLOCK_CAPACITY),</div>
<div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;            group_allocator_pair(std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;        {</div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;            check_skipfield_conformance();</div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;        }</div>
<div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160; </div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160; </div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160; </div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;        <span class="keyword">explicit</span> colony(<span class="keyword">const</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> capacities, <span class="keyword">const</span> allocator_type&amp; alloc) :</div>
<div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;            allocator_type(alloc),</div>
<div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;            tuple_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.min)),</div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;            group_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.max))</div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;        {</div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;            check_skipfield_conformance();</div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;            check_capacities_conformance(capacities);</div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;        }</div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160; </div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160; </div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160; </div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;        <span class="comment">// Copy constructor:</span></div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160; </div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;        colony(<span class="keyword">const</span> colony&amp; source) :</div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;            allocator_type(source),</div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;            tuple_allocator_pair(static_cast&lt;skipfield_type&gt;((source.tuple_allocator_pair.min_group_capacity &gt; source.total_size) ? source.tuple_allocator_pair.min_group_capacity : ((source.total_size &gt; source.group_allocator_pair.max_group_capacity) ? source.group_allocator_pair.max_group_capacity : source.total_size))), <span class="comment">// min group size is set to value closest to total number of elements in source colony in order to not create unnecessary small groups in the range-insert below, then reverts to the original min group size afterwards. This effectively saves a call to reserve.</span></div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;            group_allocator_pair(source.group_allocator_pair.max_group_capacity)</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;        { <span class="comment">// can skip checking for skipfield conformance here as the skipfields must be equal between the destination and source, and source will have already had theirs checked. Same applies for other copy and move constructors below</span></div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;            range_assign(source.begin_iterator, source.total_size);</div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;            tuple_allocator_pair.min_group_capacity = source.tuple_allocator_pair.min_group_capacity; <span class="comment">// reset to correct value for future clear() or erasures</span></div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;        }</div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160; </div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160; </div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160; </div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;        <span class="comment">// Copy constructor (allocator-extended):</span></div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160; </div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;        colony(<span class="keyword">const</span> colony&amp; source, <span class="keyword">const</span> allocator_type&amp; alloc) :</div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;            allocator_type(alloc),</div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;            tuple_allocator_pair(static_cast&lt;skipfield_type&gt;((source.tuple_allocator_pair.min_group_capacity &gt; source.total_size) ? source.tuple_allocator_pair.min_group_capacity : ((source.total_size &gt; source.group_allocator_pair.max_group_capacity) ? source.group_allocator_pair.max_group_capacity : source.total_size))),</div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;            group_allocator_pair(source.group_allocator_pair.max_group_capacity)</div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;        {</div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;            range_assign(source.begin_iterator, source.total_size);</div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;            tuple_allocator_pair.min_group_capacity = source.tuple_allocator_pair.min_group_capacity;</div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;        }</div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160; </div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160; </div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160; </div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160; </div>
<div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> blank() PLF_NOEXCEPT</div>
<div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;        {</div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_trivial&lt;group_pointer_type&gt;::value &amp;&amp; std::is_trivial&lt;aligned_pointer_type&gt;::value &amp;&amp; std::is_trivial&lt;skipfield_pointer_type&gt;::value)  <span class="comment">// if all pointer types are trivial, we can just nuke it from orbit with memset (NULL is always 0 in C++):</span></div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;            {</div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;                std::memset(<span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>), 0, offsetof(colony, tuple_allocator_pair));</div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;            }</div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;            {</div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;                end_iterator.group_pointer = NULL;</div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;                end_iterator.element_pointer = NULL;</div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;                end_iterator.skipfield_pointer = NULL;</div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;                begin_iterator.group_pointer = NULL;</div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;                begin_iterator.element_pointer = NULL;</div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;                begin_iterator.skipfield_pointer = NULL;</div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;                groups_with_erasures_list_head = NULL;</div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;                unused_groups_head = NULL;</div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;                total_size = 0;</div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;                total_capacity = 0;</div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;            }</div>
<div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;        }</div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160; </div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160; </div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160; </div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160; </div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;        <span class="comment">// Move constructor:</span></div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160; </div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;        colony(colony&amp;&amp; source) PLF_NOEXCEPT:</div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;        allocator_type(source),</div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;            end_iterator(std::move(source.end_iterator)),</div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;            begin_iterator(std::move(source.begin_iterator)),</div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;            groups_with_erasures_list_head(std::move(source.groups_with_erasures_list_head)),</div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;            unused_groups_head(std::move(source.unused_groups_head)),</div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;            total_size(source.total_size),</div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;            total_capacity(source.total_capacity),</div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;            tuple_allocator_pair(source.tuple_allocator_pair.min_group_capacity),</div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;            group_allocator_pair(source.group_allocator_pair.max_group_capacity)</div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;        {</div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;            assert(&amp;source != <span class="keyword">this</span>);</div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;            source.blank();</div>
<div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;        }</div>
<div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160; </div>
<div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160; </div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160; </div>
<div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;        <span class="comment">// Move constructor (allocator-extended):</span></div>
<div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160; </div>
<div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;        colony(colony&amp;&amp; source, <span class="keyword">const</span> allocator_type&amp; alloc) :</div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;            allocator_type(alloc),</div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;            end_iterator(std::move(source.end_iterator)),</div>
<div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;            begin_iterator(std::move(source.begin_iterator)),</div>
<div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;            groups_with_erasures_list_head(std::move(source.groups_with_erasures_list_head)),</div>
<div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;            unused_groups_head(std::move(source.unused_groups_head)),</div>
<div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;            total_size(source.total_size),</div>
<div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;            total_capacity(source.total_capacity),</div>
<div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;            tuple_allocator_pair(source.tuple_allocator_pair.min_group_capacity),</div>
<div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;            group_allocator_pair(source.group_allocator_pair.max_group_capacity)</div>
<div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;        {</div>
<div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;            assert(&amp;source != <span class="keyword">this</span>);</div>
<div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;            source.blank();</div>
<div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;        }</div>
<div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160; </div>
<div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160; </div>
<div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160; </div>
<div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;        <span class="comment">// Fill constructor:</span></div>
<div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160; </div>
<div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;        colony(<span class="keyword">const</span> size_type fill_number, <span class="keyword">const</span> element_type&amp; element, <span class="keyword">const</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> capacities = <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a>(PLF_MIN_BLOCK_CAPACITY, std::numeric_limits&lt;skipfield_type&gt;::max()), <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type()) :</div>
<div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;            allocator_type(alloc),</div>
<div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;            tuple_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.min)),</div>
<div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;            group_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.max))</div>
<div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;        {</div>
<div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;            check_skipfield_conformance();</div>
<div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;            check_capacities_conformance(capacities);</div>
<div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;            assign(fill_number, element);</div>
<div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;        }</div>
<div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160; </div>
<div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160; </div>
<div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160; </div>
<div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;        <span class="comment">// Default-value fill constructor:</span></div>
<div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160; </div>
<div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;        <span class="keyword">explicit</span> colony(<span class="keyword">const</span> size_type fill_number, <span class="keyword">const</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> capacities = <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a>(PLF_MIN_BLOCK_CAPACITY, std::numeric_limits&lt;skipfield_type&gt;::max()), <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type()) :</div>
<div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;            allocator_type(alloc),</div>
<div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;            tuple_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.min)),</div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;            group_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.max))</div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;        {</div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;            check_skipfield_conformance();</div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;            check_capacities_conformance(capacities);</div>
<div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;            assign(fill_number, element_type());</div>
<div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;        }</div>
<div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160; </div>
<div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160; </div>
<div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160; </div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;        <span class="comment">// Range constructor:</span></div>
<div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160; </div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type&gt;</div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;        colony(<span class="keyword">const</span> <span class="keyword">typename</span> plf_enable_if_c&lt;!std::numeric_limits&lt;iterator_type&gt;::is_integer, iterator_type&gt;::type&amp; first, <span class="keyword">const</span> iterator_type&amp; last, <span class="keyword">const</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> capacities = <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a>(PLF_MIN_BLOCK_CAPACITY, std::numeric_limits&lt;skipfield_type&gt;::max()), <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type()) :</div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;            allocator_type(alloc),</div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;            tuple_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.min)),</div>
<div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;            group_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.max))</div>
<div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;        {</div>
<div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;            check_skipfield_conformance();</div>
<div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;            check_capacities_conformance(capacities);</div>
<div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;            assign&lt;iterator_type&gt;(first, last);</div>
<div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;        }</div>
<div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160; </div>
<div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160; </div>
<div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160; </div>
<div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;        <span class="comment">// Range constructor - differing iterators:</span></div>
<div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160; </div>
<div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;<span class="preprocessor">#ifdef PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type1, <span class="keyword">class</span> iterator_type2&gt;</div>
<div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;        requires (!std::same_as&lt;iterator_type1, iterator_type2&gt;&amp;&amp; std::equality_comparable_with&lt;iterator_type1, iterator_type2&gt; &amp;&amp; !std::integral&lt;iterator_type1&gt; &amp;&amp; !std::integral&lt;iterator_type2&gt;)</div>
<div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;            colony(<span class="keyword">const</span> iterator_type1&amp; first, <span class="keyword">const</span> iterator_type2&amp; last, <span class="keyword">const</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> capacities = <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a>(PLF_MIN_BLOCK_CAPACITY, std::numeric_limits&lt;skipfield_type&gt;::max()), <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type()) :</div>
<div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;            allocator_type(alloc),</div>
<div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;            tuple_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.min)),</div>
<div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;            group_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.max))</div>
<div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;        {</div>
<div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;            check_skipfield_conformance();</div>
<div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;            check_capacities_conformance(capacities);</div>
<div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;            assign&lt;iterator_type1, iterator_type2&gt;(first, last);</div>
<div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;        }</div>
<div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160; </div>
<div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160; </div>
<div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160; </div>
<div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;        <span class="comment">// Initializer-list constructor:</span></div>
<div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160; </div>
<div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;<span class="preprocessor">#ifdef PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;        colony(<span class="keyword">const</span> std::initializer_list&lt;element_type&gt;&amp; element_list, <span class="keyword">const</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> capacities = <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a>(PLF_MIN_BLOCK_CAPACITY, std::numeric_limits&lt;skipfield_type&gt;::max()), <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type()) :</div>
<div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;            allocator_type(alloc),</div>
<div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;            groups_with_erasures_list_head(NULL),</div>
<div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;            unused_groups_head(NULL),</div>
<div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;            total_size(0),</div>
<div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;            total_capacity(0),</div>
<div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;            tuple_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.min)),</div>
<div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;            group_allocator_pair(static_cast&lt;skipfield_type&gt;(capacities.max))</div>
<div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;        {</div>
<div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;<span class="preprocessor">#ifndef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;            check_skipfield_conformance();</div>
<div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;            check_capacities_conformance(capacities);</div>
<div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;            range_assign(element_list.begin(), <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(element_list.size()));</div>
<div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;        }</div>
<div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160; </div>
<div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160; </div>
<div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160; </div>
<div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160; </div>
<div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE iterator begin() PLF_NOEXCEPT</div>
<div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;        {</div>
<div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;            <span class="keywordflow">return</span> begin_iterator;</div>
<div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;        }</div>
<div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160; </div>
<div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160; </div>
<div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160; </div>
<div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE const_iterator begin() const PLF_NOEXCEPT</div>
<div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;        {</div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;            <span class="keywordflow">return</span> begin_iterator;</div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;        }</div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160; </div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160; </div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160; </div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE iterator end() PLF_NOEXCEPT</div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;        {</div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;            <span class="keywordflow">return</span> end_iterator;</div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;        }</div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160; </div>
<div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160; </div>
<div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160; </div>
<div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE const_iterator end() const PLF_NOEXCEPT</div>
<div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;        {</div>
<div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;            <span class="keywordflow">return</span> end_iterator;</div>
<div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;        }</div>
<div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160; </div>
<div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160; </div>
<div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160; </div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE const_iterator cbegin() const PLF_NOEXCEPT</div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;        {</div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;            <span class="keywordflow">return</span> begin_iterator;</div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;        }</div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160; </div>
<div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160; </div>
<div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160; </div>
<div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE const_iterator cend() const PLF_NOEXCEPT</div>
<div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;        {</div>
<div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;            <span class="keywordflow">return</span> end_iterator;</div>
<div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;        }</div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160; </div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160; </div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160; </div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;        <span class="keyword">inline</span> reverse_iterator rbegin() PLF_NOEXCEPT</div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;        {</div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;            <span class="keywordflow">return</span> (end_iterator.group_pointer != NULL) ? ++reverse_iterator(end_iterator) : reverse_iterator(begin_iterator.group_pointer, begin_iterator.element_pointer - 1, begin_iterator.skipfield_pointer - 1);</div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;        }</div>
<div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160; </div>
<div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160; </div>
<div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160; </div>
<div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;        <span class="keyword">inline</span> reverse_iterator rend() PLF_NOEXCEPT</div>
<div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;        {</div>
<div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;            <span class="keywordflow">return</span> reverse_iterator(begin_iterator.group_pointer, begin_iterator.element_pointer - 1, begin_iterator.skipfield_pointer - 1);</div>
<div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;        }</div>
<div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160; </div>
<div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160; </div>
<div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160; </div>
<div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;        <span class="keyword">inline</span> const_reverse_iterator crbegin() const PLF_NOEXCEPT</div>
<div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;        {</div>
<div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;            <span class="keywordflow">return</span> (end_iterator.group_pointer != NULL) ? ++const_reverse_iterator(end_iterator) : const_reverse_iterator(begin_iterator.group_pointer, begin_iterator.element_pointer - 1, begin_iterator.skipfield_pointer - 1);</div>
<div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;        }</div>
<div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160; </div>
<div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160; </div>
<div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160; </div>
<div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;        <span class="keyword">inline</span> const_reverse_iterator crend() const PLF_NOEXCEPT</div>
<div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;        {</div>
<div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;            <span class="keywordflow">return</span> const_reverse_iterator(begin_iterator.group_pointer, begin_iterator.element_pointer - 1, begin_iterator.skipfield_pointer - 1);</div>
<div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;        }</div>
<div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160; </div>
<div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160; </div>
<div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160; </div>
<div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;        ~colony() PLF_NOEXCEPT</div>
<div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;        {</div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;            destroy_all_data();</div>
<div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;        }</div>
<div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160; </div>
<div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160; </div>
<div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160; </div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160; </div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160; </div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;        group_pointer_type allocate_new_group(<span class="keyword">const</span> skipfield_type elements_per_group, group_pointer_type <span class="keyword">const</span> previous = NULL)</div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;        {</div>
<div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;            group_pointer_type <span class="keyword">const</span> new_group = PLF_ALLOCATE(group_allocator_type, group_allocator_pair, 1, 0);</div>
<div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160; </div>
<div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;            <span class="keywordflow">try</span></div>
<div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;            {</div>
<div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;<span class="preprocessor">#ifdef PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;                PLF_CONSTRUCT(group_allocator_type, group_allocator_pair, new_group, elements_per_group, previous);</div>
<div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;                PLF_CONSTRUCT(group_allocator_type, group_allocator_pair, new_group, group(elements_per_group, previous));</div>
<div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;            }</div>
<div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;            <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;            {</div>
<div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;                PLF_DEALLOCATE(group_allocator_type, group_allocator_pair, new_group, 1);</div>
<div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;                <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;            }</div>
<div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160; </div>
<div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;            <span class="keywordflow">return</span> new_group;</div>
<div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;        }</div>
<div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160; </div>
<div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160; </div>
<div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160; </div>
<div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> deallocate_group(group_pointer_type <span class="keyword">const</span> the_group) PLF_NOEXCEPT</div>
<div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;        {</div>
<div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;            PLF_DESTROY(group_allocator_type, group_allocator_pair, the_group);</div>
<div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;            PLF_DEALLOCATE(group_allocator_type, group_allocator_pair, the_group, 1);</div>
<div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;        }</div>
<div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160; </div>
<div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160; </div>
<div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160; </div>
<div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;        <span class="keywordtype">void</span> destroy_all_data() PLF_NOEXCEPT</div>
<div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;        {</div>
<div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;            <span class="keywordflow">if</span> (begin_iterator.group_pointer != NULL)</div>
<div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;            {</div>
<div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;                end_iterator.group_pointer-&gt;next_group = unused_groups_head;</div>
<div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160; </div>
<div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;                <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_trivially_destructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;<span class="preprocessor">#endif // If compiler doesn&#39;t support traits, iterate regardless - trivial destructors will not be called, hopefully compiler will optimise the &#39;destruct&#39; loop out for POD types</span></div>
<div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;                {</div>
<div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;                    <span class="keywordflow">if</span> (total_size != 0)</div>
<div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;                    {</div>
<div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;                        <span class="keywordflow">while</span> (<span class="keyword">true</span>) <span class="comment">// Erase elements without bothering to update skipfield - much faster:</span></div>
<div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;                        {</div>
<div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;                            <span class="keyword">const</span> aligned_pointer_type end_pointer = begin_iterator.group_pointer-&gt;last_endpoint;</div>
<div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160; </div>
<div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;                            <span class="keywordflow">do</span></div>
<div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;                            {</div>
<div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;                                PLF_DESTROY(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(begin_iterator.element_pointer));</div>
<div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;                                begin_iterator.element_pointer += <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(*++begin_iterator.skipfield_pointer) + 1u;</div>
<div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;                                begin_iterator.skipfield_pointer += *begin_iterator.skipfield_pointer;</div>
<div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;                            } <span class="keywordflow">while</span> (begin_iterator.element_pointer != end_pointer); <span class="comment">// ie. beyond end of available data</span></div>
<div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160; </div>
<div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;                            <span class="keyword">const</span> group_pointer_type next_group = begin_iterator.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;                            deallocate_group(begin_iterator.group_pointer);</div>
<div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;                            begin_iterator.group_pointer = next_group;</div>
<div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160; </div>
<div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;                            <span class="keywordflow">if</span> (next_group == unused_groups_head)</div>
<div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;                            {</div>
<div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;                                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;                            }</div>
<div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160; </div>
<div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;                            begin_iterator.element_pointer = next_group-&gt;elements + *(next_group-&gt;skipfield);</div>
<div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;                            begin_iterator.skipfield_pointer = next_group-&gt;skipfield + *(next_group-&gt;skipfield);</div>
<div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;                        }</div>
<div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;                    }</div>
<div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;                }</div>
<div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160; </div>
<div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;                <span class="keywordflow">while</span> (begin_iterator.group_pointer != NULL)</div>
<div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;                {</div>
<div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;                    <span class="keyword">const</span> group_pointer_type next_group = begin_iterator.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;                    deallocate_group(begin_iterator.group_pointer);</div>
<div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;                    begin_iterator.group_pointer = next_group;</div>
<div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;                }</div>
<div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;            }</div>
<div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;        }</div>
<div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160; </div>
<div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160; </div>
<div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160; </div>
<div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;        <span class="keywordtype">void</span> initialize(<span class="keyword">const</span> skipfield_type first_group_size)</div>
<div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;        {</div>
<div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;            end_iterator.group_pointer = begin_iterator.group_pointer = allocate_new_group(first_group_size);</div>
<div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;            end_iterator.element_pointer = begin_iterator.element_pointer = begin_iterator.group_pointer-&gt;elements;</div>
<div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;            end_iterator.skipfield_pointer = begin_iterator.skipfield_pointer = begin_iterator.group_pointer-&gt;skipfield;</div>
<div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;            total_capacity = first_group_size;</div>
<div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;        }</div>
<div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160; </div>
<div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160; </div>
<div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160; </div>
<div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;        <span class="keywordtype">void</span> update_skipblock(<span class="keyword">const</span> iterator&amp; new_location, <span class="keyword">const</span> skipfield_type prev_free_list_index) PLF_NOEXCEPT</div>
<div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;        {</div>
<div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;            <span class="keyword">const</span> skipfield_type new_value = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(*(new_location.skipfield_pointer) - 1);</div>
<div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160; </div>
<div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;            <span class="keywordflow">if</span> (new_value != 0) <span class="comment">// ie. skipfield was not 1, ie. a single-node skipblock, with no additional nodes to update</span></div>
<div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;            {</div>
<div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;                <span class="comment">// set (new) start and (original) end of skipblock to new value:</span></div>
<div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;                *(new_location.skipfield_pointer + new_value) = *(new_location.skipfield_pointer + 1) = new_value;</div>
<div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160; </div>
<div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;                <span class="comment">// transfer free list node to new start node:</span></div>
<div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;                ++(groups_with_erasures_list_head-&gt;free_list_head);</div>
<div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160; </div>
<div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;                <span class="keywordflow">if</span> (prev_free_list_index != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. not the tail free list node</span></div>
<div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;                {</div>
<div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(new_location.group_pointer-&gt;elements + prev_free_list_index) + 1) = groups_with_erasures_list_head-&gt;free_list_head;</div>
<div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;                }</div>
<div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160; </div>
<div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;                *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(new_location.element_pointer + 1)) = prev_free_list_index;</div>
<div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;                *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(new_location.element_pointer + 1) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;            }</div>
<div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;            {</div>
<div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;                groups_with_erasures_list_head-&gt;free_list_head = prev_free_list_index;</div>
<div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160; </div>
<div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;                <span class="keywordflow">if</span> (prev_free_list_index != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. not the last free list node</span></div>
<div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;                {</div>
<div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(new_location.group_pointer-&gt;elements + prev_free_list_index) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;                }</div>
<div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;                <span class="keywordflow">else</span> <span class="comment">// remove this group from the list of groups with erasures</span></div>
<div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;                {</div>
<div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;                    groups_with_erasures_list_head = groups_with_erasures_list_head-&gt;erasures_list_next_group;</div>
<div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;                }</div>
<div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;            }</div>
<div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160; </div>
<div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;            *(new_location.skipfield_pointer) = 0;</div>
<div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;            ++(new_location.group_pointer-&gt;size);</div>
<div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160; </div>
<div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;            <span class="keywordflow">if</span> (new_location.group_pointer == begin_iterator.group_pointer &amp;&amp; new_location.element_pointer &lt; begin_iterator.element_pointer)</div>
<div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;            { <span class="comment">/* ie. begin_iterator was moved forwards as the result of an erasure at some point, this erased element is before the current begin, hence, set current begin iterator to this element */</span></div>
<div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;                begin_iterator = new_location;</div>
<div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;            }</div>
<div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160; </div>
<div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;            ++total_size;</div>
<div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;        }</div>
<div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160; </div>
<div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160; </div>
<div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160; </div>
<div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160; </div>
<div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160; </div>
<div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;        iterator insert(<span class="keyword">const</span> element_type&amp; element)</div>
<div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;        {</div>
<div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;            <span class="keywordflow">if</span> (end_iterator.element_pointer != NULL)</div>
<div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;            {</div>
<div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;                <span class="keywordflow">if</span> (groups_with_erasures_list_head == NULL) <span class="comment">// ie. there are no erased elements and end_iterator is not at end of current final group</span></div>
<div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;                {</div>
<div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;                    <span class="keywordflow">if</span> (end_iterator.element_pointer != <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield))</div>
<div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;                    {</div>
<div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;                        <span class="keyword">const</span> iterator return_iterator = end_iterator; <span class="comment">/* Make copy for return before modifying end_iterator */</span></div>
<div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160; </div>
<div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;                        <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;                        { <span class="comment">// For no good reason this compiles to ridiculously faster code under GCC 5-9 in raw small struct tests with large N:</span></div>
<div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;                            PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer++), element);</div>
<div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;                            end_iterator.group_pointer-&gt;last_endpoint = end_iterator.element_pointer;</div>
<div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;                        }</div>
<div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;                        {</div>
<div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;                            PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer), element);</div>
<div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;                            end_iterator.group_pointer-&gt;last_endpoint = ++end_iterator.element_pointer; <span class="comment">// Shift the addition to the second operation, avoiding a try-catch block if an exception is thrown during construction</span></div>
<div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;                        }</div>
<div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160; </div>
<div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;                        ++(end_iterator.group_pointer-&gt;size);</div>
<div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;                        ++end_iterator.skipfield_pointer;</div>
<div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;                        ++total_size;</div>
<div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160; </div>
<div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;                        <span class="keywordflow">return</span> return_iterator; <span class="comment">// return value before incrementation</span></div>
<div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;                    }</div>
<div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160; </div>
<div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;                    group_pointer_type next_group;</div>
<div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160; </div>
<div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;                    <span class="keywordflow">if</span> (unused_groups_head == NULL)</div>
<div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;                    {</div>
<div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;                        <span class="keyword">const</span> skipfield_type new_group_size = (total_size &lt; static_cast&lt;size_type&gt;(group_allocator_pair.max_group_capacity)) ? <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(total_size) : group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;                        next_group = allocate_new_group(new_group_size, end_iterator.group_pointer);</div>
<div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160; </div>
<div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;                        <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;                        {</div>
<div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;                            PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(next_group-&gt;elements), element);</div>
<div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;                        }</div>
<div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;                        {</div>
<div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;                            <span class="keywordflow">try</span></div>
<div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;                            {</div>
<div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;                                PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(next_group-&gt;elements), element);</div>
<div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;                            }</div>
<div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;                            <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;                            {</div>
<div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;                                deallocate_group(next_group);</div>
<div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;                                <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;                            }</div>
<div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;                        }</div>
<div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160; </div>
<div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;                        total_capacity += new_group_size;</div>
<div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;                    }</div>
<div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;                    {</div>
<div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;                        next_group = unused_groups_head;</div>
<div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(next_group-&gt;elements), element);</div>
<div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;                        unused_groups_head = next_group-&gt;next_group;</div>
<div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;                        next_group-&gt;reset(1, NULL, end_iterator.group_pointer, end_iterator.group_pointer-&gt;group_number + 1u);</div>
<div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;                    }</div>
<div class="line"><a name="l02265"></a><span class="lineno"> 2265</span>&#160; </div>
<div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;                    end_iterator.group_pointer-&gt;next_group = next_group;</div>
<div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;                    end_iterator.group_pointer = next_group;</div>
<div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;                    end_iterator.element_pointer = next_group-&gt;last_endpoint;</div>
<div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;                    end_iterator.skipfield_pointer = next_group-&gt;skipfield + 1;</div>
<div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;                    ++total_size;</div>
<div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160; </div>
<div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;                    <span class="keywordflow">return</span> iterator(next_group, next_group-&gt;elements, next_group-&gt;skipfield); <span class="comment">/* returns value before incrementation */</span></div>
<div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;                }</div>
<div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;                <span class="keywordflow">else</span> <span class="comment">// ie. there are erased elements, reuse previous-erased element locations</span></div>
<div class="line"><a name="l02275"></a><span class="lineno"> 2275</span>&#160;                {</div>
<div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;                    iterator new_location(groups_with_erasures_list_head, groups_with_erasures_list_head-&gt;elements + groups_with_erasures_list_head-&gt;free_list_head, groups_with_erasures_list_head-&gt;skipfield + groups_with_erasures_list_head-&gt;free_list_head);</div>
<div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160; </div>
<div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;                    <span class="comment">// We always reuse the element at the start of the skipblock, this is also where the free-list information for that skipblock is stored. Get the previous free-list node&#39;s index from this memory space, before we write to our element to it. &#39;Next&#39; index is always the free_list_head (as represented by the maximum value of the skipfield type) here so we don&#39;t need to get it:</span></div>
<div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;                    <span class="keyword">const</span> skipfield_type prev_free_list_index = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(new_location.element_pointer));</div>
<div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;                    PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(new_location.element_pointer), element);</div>
<div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;                    update_skipblock(new_location, prev_free_list_index);</div>
<div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160; </div>
<div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;                    <span class="keywordflow">return</span> new_location;</div>
<div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;                }</div>
<div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;            }</div>
<div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;            <span class="keywordflow">else</span> <span class="comment">// ie. newly-constructed colony, no insertions yet and no groups</span></div>
<div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;            {</div>
<div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;                initialize(tuple_allocator_pair.min_group_capacity);</div>
<div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160; </div>
<div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;                <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;                {</div>
<div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;                    PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer++), element);</div>
<div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;                }</div>
<div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;                {</div>
<div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;                    <span class="keywordflow">try</span></div>
<div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;                    {</div>
<div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer++), element);</div>
<div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;                    }</div>
<div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;                    <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;                    {</div>
<div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;                        clear();</div>
<div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;                        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;                    }</div>
<div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;                }</div>
<div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160; </div>
<div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;                ++end_iterator.skipfield_pointer;</div>
<div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;                total_size = 1;</div>
<div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;                <span class="keywordflow">return</span> begin_iterator;</div>
<div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;            }</div>
<div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;        }</div>
<div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160; </div>
<div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160; </div>
<div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160; </div>
<div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;        iterator insert(element_type&amp;&amp; element) <span class="comment">// The move-insert function is near-identical to the regular insert function, with the exception of the element construction method and is_nothrow tests.</span></div>
<div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;        {</div>
<div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160;            <span class="keywordflow">if</span> (end_iterator.element_pointer != NULL)</div>
<div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;            {</div>
<div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;                <span class="keywordflow">if</span> (groups_with_erasures_list_head == NULL)</div>
<div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;                {</div>
<div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;                    <span class="keywordflow">if</span> (end_iterator.element_pointer != <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield))</div>
<div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;                    {</div>
<div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;                        <span class="keyword">const</span> iterator return_iterator = end_iterator;</div>
<div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160; </div>
<div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;                        <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_move_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;                        {</div>
<div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;                            PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer++), std::move(element));</div>
<div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;                            end_iterator.group_pointer-&gt;last_endpoint = end_iterator.element_pointer;</div>
<div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;                        }</div>
<div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;                        {</div>
<div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;                            PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer), std::move(element));</div>
<div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;                            end_iterator.group_pointer-&gt;last_endpoint = ++end_iterator.element_pointer;</div>
<div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;                        }</div>
<div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160; </div>
<div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;                        ++(end_iterator.group_pointer-&gt;size);</div>
<div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;                        ++end_iterator.skipfield_pointer;</div>
<div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;                        ++total_size;</div>
<div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160; </div>
<div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;                        <span class="keywordflow">return</span> return_iterator;</div>
<div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;                    }</div>
<div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160; </div>
<div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;                    group_pointer_type next_group;</div>
<div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160; </div>
<div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;                    <span class="keywordflow">if</span> (unused_groups_head == NULL)</div>
<div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;                    {</div>
<div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;                        <span class="keyword">const</span> skipfield_type new_group_size = (total_size &lt; static_cast&lt;size_type&gt;(group_allocator_pair.max_group_capacity)) ? <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(total_size) : group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;                        next_group = allocate_new_group(new_group_size, end_iterator.group_pointer);</div>
<div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160; </div>
<div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;                        <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_move_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;                        {</div>
<div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;                            PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(next_group-&gt;elements), std::move(element));</div>
<div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;                        }</div>
<div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;                        {</div>
<div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;                            <span class="keywordflow">try</span></div>
<div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;                            {</div>
<div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;                                PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(next_group-&gt;elements), std::move(element));</div>
<div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;                            }</div>
<div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;                            <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;                            {</div>
<div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;                                deallocate_group(next_group);</div>
<div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;                                <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;                            }</div>
<div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;                        }</div>
<div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160; </div>
<div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;                        total_capacity += new_group_size;</div>
<div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;                    }</div>
<div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;                    {</div>
<div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;                        next_group = unused_groups_head;</div>
<div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(next_group-&gt;elements), std::move(element));</div>
<div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;                        unused_groups_head = next_group-&gt;next_group;</div>
<div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;                        next_group-&gt;reset(1, NULL, end_iterator.group_pointer, end_iterator.group_pointer-&gt;group_number + 1u);</div>
<div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;                    }</div>
<div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160; </div>
<div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;                    end_iterator.group_pointer-&gt;next_group = next_group;</div>
<div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;                    end_iterator.group_pointer = next_group;</div>
<div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;                    end_iterator.element_pointer = next_group-&gt;last_endpoint;</div>
<div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;                    end_iterator.skipfield_pointer = next_group-&gt;skipfield + 1;</div>
<div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;                    ++total_size;</div>
<div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160; </div>
<div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;                    <span class="keywordflow">return</span> iterator(next_group, next_group-&gt;elements, next_group-&gt;skipfield); <span class="comment">/* returns value before incrementation */</span></div>
<div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;                }</div>
<div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;                {</div>
<div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;                    iterator new_location(groups_with_erasures_list_head, groups_with_erasures_list_head-&gt;elements + groups_with_erasures_list_head-&gt;free_list_head, groups_with_erasures_list_head-&gt;skipfield + groups_with_erasures_list_head-&gt;free_list_head);</div>
<div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160; </div>
<div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;                    <span class="keyword">const</span> skipfield_type prev_free_list_index = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(new_location.element_pointer));</div>
<div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;                    PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(new_location.element_pointer), std::move(element));</div>
<div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;                    update_skipblock(new_location, prev_free_list_index);</div>
<div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160; </div>
<div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;                    <span class="keywordflow">return</span> new_location;</div>
<div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;                }</div>
<div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;            }</div>
<div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;            {</div>
<div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;                initialize(tuple_allocator_pair.min_group_capacity);</div>
<div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160; </div>
<div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;                <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_move_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;                {</div>
<div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;                    PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer++), std::move(element));</div>
<div class="line"><a name="l02411"></a><span class="lineno"> 2411</span>&#160;                }</div>
<div class="line"><a name="l02412"></a><span class="lineno"> 2412</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l02413"></a><span class="lineno"> 2413</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02414"></a><span class="lineno"> 2414</span>&#160;                {</div>
<div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;                    <span class="keywordflow">try</span></div>
<div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;                    {</div>
<div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer++), std::move(element));</div>
<div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;                    }</div>
<div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;                    <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;                    {</div>
<div class="line"><a name="l02421"></a><span class="lineno"> 2421</span>&#160;                        clear();</div>
<div class="line"><a name="l02422"></a><span class="lineno"> 2422</span>&#160;                        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;                    }</div>
<div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;                }</div>
<div class="line"><a name="l02425"></a><span class="lineno"> 2425</span>&#160; </div>
<div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;                ++end_iterator.skipfield_pointer;</div>
<div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;                total_size = 1;</div>
<div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;                <span class="keywordflow">return</span> begin_iterator;</div>
<div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;            }</div>
<div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;        }</div>
<div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02432"></a><span class="lineno"> 2432</span>&#160; </div>
<div class="line"><a name="l02433"></a><span class="lineno"> 2433</span>&#160; </div>
<div class="line"><a name="l02434"></a><span class="lineno"> 2434</span>&#160; </div>
<div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;<span class="preprocessor">#ifdef PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l02436"></a><span class="lineno"> 2436</span>&#160;        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... arguments&gt;</div>
<div class="line"><a name="l02437"></a><span class="lineno"> 2437</span>&#160;        iterator emplace(arguments &amp;&amp;... parameters) <span class="comment">// The emplace function is near-identical to the regular insert function, with the exception of the element construction method, and change to is_nothrow tests.</span></div>
<div class="line"><a name="l02438"></a><span class="lineno"> 2438</span>&#160;        {</div>
<div class="line"><a name="l02439"></a><span class="lineno"> 2439</span>&#160;            <span class="keywordflow">if</span> (end_iterator.element_pointer != NULL)</div>
<div class="line"><a name="l02440"></a><span class="lineno"> 2440</span>&#160;            {</div>
<div class="line"><a name="l02441"></a><span class="lineno"> 2441</span>&#160;                <span class="keywordflow">if</span> (groups_with_erasures_list_head == NULL)</div>
<div class="line"><a name="l02442"></a><span class="lineno"> 2442</span>&#160;                {</div>
<div class="line"><a name="l02443"></a><span class="lineno"> 2443</span>&#160;                    <span class="keywordflow">if</span> (end_iterator.element_pointer != <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield))</div>
<div class="line"><a name="l02444"></a><span class="lineno"> 2444</span>&#160;                    {</div>
<div class="line"><a name="l02445"></a><span class="lineno"> 2445</span>&#160;                        <span class="keyword">const</span> iterator return_iterator = end_iterator;</div>
<div class="line"><a name="l02446"></a><span class="lineno"> 2446</span>&#160; </div>
<div class="line"><a name="l02447"></a><span class="lineno"> 2447</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;                        <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;                        {</div>
<div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;                            PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer++), std::forward&lt;arguments&gt;(parameters) ...);</div>
<div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;                            end_iterator.group_pointer-&gt;last_endpoint = end_iterator.element_pointer;</div>
<div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;                        }</div>
<div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;                        {</div>
<div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;                            PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer), std::forward&lt;arguments&gt;(parameters) ...);</div>
<div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;                            end_iterator.group_pointer-&gt;last_endpoint = ++end_iterator.element_pointer;</div>
<div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;                        }</div>
<div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160; </div>
<div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;                        ++(end_iterator.group_pointer-&gt;size);</div>
<div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;                        ++end_iterator.skipfield_pointer;</div>
<div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;                        ++total_size;</div>
<div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160; </div>
<div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;                        <span class="keywordflow">return</span> return_iterator;</div>
<div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;                    }</div>
<div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160; </div>
<div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;                    group_pointer_type next_group;</div>
<div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160; </div>
<div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;                    <span class="keywordflow">if</span> (unused_groups_head == NULL)</div>
<div class="line"><a name="l02470"></a><span class="lineno"> 2470</span>&#160;                    {</div>
<div class="line"><a name="l02471"></a><span class="lineno"> 2471</span>&#160;                        <span class="keyword">const</span> skipfield_type new_group_size = (total_size &lt; static_cast&lt;size_type&gt;(group_allocator_pair.max_group_capacity)) ? <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(total_size) : group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l02472"></a><span class="lineno"> 2472</span>&#160;                        next_group = allocate_new_group(new_group_size, end_iterator.group_pointer);</div>
<div class="line"><a name="l02473"></a><span class="lineno"> 2473</span>&#160; </div>
<div class="line"><a name="l02474"></a><span class="lineno"> 2474</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02475"></a><span class="lineno"> 2475</span>&#160;                        <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02476"></a><span class="lineno"> 2476</span>&#160;                        {</div>
<div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160;                            PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(next_group-&gt;elements), std::forward&lt;arguments&gt;(parameters) ...);</div>
<div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;                        }</div>
<div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160;                        {</div>
<div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;                            <span class="keywordflow">try</span></div>
<div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;                            {</div>
<div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;                                PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(next_group-&gt;elements), std::forward&lt;arguments&gt;(parameters) ...);</div>
<div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;                            }</div>
<div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;                            <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;                            {</div>
<div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160;                                deallocate_group(next_group);</div>
<div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;                                <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;                            }</div>
<div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;                        }</div>
<div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160; </div>
<div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;                        total_capacity += new_group_size;</div>
<div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;                    }</div>
<div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;                    {</div>
<div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;                        next_group = unused_groups_head;</div>
<div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(next_group-&gt;elements), std::forward&lt;arguments&gt;(parameters) ...);</div>
<div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;                        unused_groups_head = next_group-&gt;next_group;</div>
<div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160;                        next_group-&gt;reset(1, NULL, end_iterator.group_pointer, end_iterator.group_pointer-&gt;group_number + 1u);</div>
<div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;                    }</div>
<div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160; </div>
<div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;                    end_iterator.group_pointer-&gt;next_group = next_group;</div>
<div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;                    end_iterator.group_pointer = next_group;</div>
<div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;                    end_iterator.element_pointer = next_group-&gt;last_endpoint;</div>
<div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;                    end_iterator.skipfield_pointer = next_group-&gt;skipfield + 1;</div>
<div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;                    ++total_size;</div>
<div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160; </div>
<div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;                    <span class="keywordflow">return</span> iterator(next_group, next_group-&gt;elements, next_group-&gt;skipfield); <span class="comment">/* returns value before incrementation */</span></div>
<div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;                }</div>
<div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;                {</div>
<div class="line"><a name="l02513"></a><span class="lineno"> 2513</span>&#160;                    iterator new_location(groups_with_erasures_list_head, groups_with_erasures_list_head-&gt;elements + groups_with_erasures_list_head-&gt;free_list_head, groups_with_erasures_list_head-&gt;skipfield + groups_with_erasures_list_head-&gt;free_list_head);</div>
<div class="line"><a name="l02514"></a><span class="lineno"> 2514</span>&#160; </div>
<div class="line"><a name="l02515"></a><span class="lineno"> 2515</span>&#160;                    <span class="keyword">const</span> skipfield_type prev_free_list_index = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(new_location.element_pointer));</div>
<div class="line"><a name="l02516"></a><span class="lineno"> 2516</span>&#160;                    PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(new_location.element_pointer), std::forward&lt;arguments&gt;(parameters) ...);</div>
<div class="line"><a name="l02517"></a><span class="lineno"> 2517</span>&#160;                    update_skipblock(new_location, prev_free_list_index);</div>
<div class="line"><a name="l02518"></a><span class="lineno"> 2518</span>&#160; </div>
<div class="line"><a name="l02519"></a><span class="lineno"> 2519</span>&#160;                    <span class="keywordflow">return</span> new_location;</div>
<div class="line"><a name="l02520"></a><span class="lineno"> 2520</span>&#160;                }</div>
<div class="line"><a name="l02521"></a><span class="lineno"> 2521</span>&#160;            }</div>
<div class="line"><a name="l02522"></a><span class="lineno"> 2522</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l02523"></a><span class="lineno"> 2523</span>&#160;            {</div>
<div class="line"><a name="l02524"></a><span class="lineno"> 2524</span>&#160;                initialize(tuple_allocator_pair.min_group_capacity);</div>
<div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160; </div>
<div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;                <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_constructible&lt;element_type, arguments ...&gt;::value)</div>
<div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;                {</div>
<div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;                    PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer++), std::forward&lt;arguments&gt;(parameters) ...);</div>
<div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;                }</div>
<div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;                {</div>
<div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;                    <span class="keywordflow">try</span></div>
<div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;                    {</div>
<div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer++), std::forward&lt;arguments&gt;(parameters) ...);</div>
<div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;                    }</div>
<div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;                    <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;                    {</div>
<div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;                        clear();</div>
<div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;                        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;                    }</div>
<div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;                }</div>
<div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160; </div>
<div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;                ++end_iterator.skipfield_pointer;</div>
<div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;                total_size = 1;</div>
<div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;                <span class="keywordflow">return</span> begin_iterator;</div>
<div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;            }</div>
<div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;        }</div>
<div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160; </div>
<div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160; </div>
<div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160; </div>
<div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160; </div>
<div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160; </div>
<div class="line"><a name="l02557"></a><span class="lineno"> 2557</span>&#160;        <span class="comment">// For catch blocks in fill() and range_fill()</span></div>
<div class="line"><a name="l02558"></a><span class="lineno"> 2558</span>&#160;        <span class="keywordtype">void</span> recover_from_partial_fill()</div>
<div class="line"><a name="l02559"></a><span class="lineno"> 2559</span>&#160;        {</div>
<div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT // try to ensure this code will not be generated if this function is not called in fill() or range_fill()</span></div>
<div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_nothrow_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02563"></a><span class="lineno"> 2563</span>&#160;            {</div>
<div class="line"><a name="l02564"></a><span class="lineno"> 2564</span>&#160;                end_iterator.group_pointer-&gt;last_endpoint = end_iterator.element_pointer;</div>
<div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;                <span class="keyword">const</span> skipfield_type elements_constructed_before_exception = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(end_iterator.element_pointer - end_iterator.group_pointer-&gt;elements);</div>
<div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;                end_iterator.group_pointer-&gt;size = elements_constructed_before_exception;</div>
<div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;                end_iterator.skipfield_pointer = end_iterator.group_pointer-&gt;skipfield + elements_constructed_before_exception;</div>
<div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;                total_size += elements_constructed_before_exception;</div>
<div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;                unused_groups_head = end_iterator.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;                end_iterator.group_pointer-&gt;next_group = NULL;</div>
<div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;            }</div>
<div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;        }</div>
<div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160; </div>
<div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160; </div>
<div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160; </div>
<div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160;        <span class="keywordtype">void</span> fill(<span class="keyword">const</span> element_type&amp; element, <span class="keyword">const</span> skipfield_type size)</div>
<div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;        {</div>
<div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;            {</div>
<div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;                <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_trivially_copyable&lt;element_type&gt;::value &amp;&amp; std::is_trivially_copy_constructible&lt;element_type&gt;::value) <span class="comment">// ie. we can get away with using the cheaper fill_n here if there is no chance of an exception being thrown:</span></div>
<div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;                {</div>
<div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;<span class="preprocessor">#ifdef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;                    <span class="keywordflow">if</span> PLF_CONSTEXPR(<span class="keyword">sizeof</span>(aligned_element_type) != <span class="keyword">sizeof</span>(element_type))</div>
<div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;                    {</div>
<div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;                        <span class="keyword">alignas</span> (<span class="keyword">alignof</span>(aligned_element_type)) element_type aligned_copy = element; <span class="comment">// to avoid potentially violating memory boundaries in line below, create an initial copy object of same (but aligned) type</span></div>
<div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;                        std::fill_n(end_iterator.element_pointer, size, *(<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(&amp;aligned_copy)));</div>
<div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160;                    }</div>
<div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02590"></a><span class="lineno"> 2590</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02591"></a><span class="lineno"> 2591</span>&#160;                    {</div>
<div class="line"><a name="l02592"></a><span class="lineno"> 2592</span>&#160;                        std::fill_n(<span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer), size, element);</div>
<div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;                    }</div>
<div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160; </div>
<div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;                    end_iterator.element_pointer += size;</div>
<div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;                }</div>
<div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160;                <span class="keywordflow">else</span> <span class="comment">// If at least nothrow_constructible, can remove the large block of &#39;catch&#39; code below</span></div>
<div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;                {</div>
<div class="line"><a name="l02599"></a><span class="lineno"> 2599</span>&#160;                    <span class="keyword">const</span> aligned_pointer_type fill_end = end_iterator.element_pointer + size;</div>
<div class="line"><a name="l02600"></a><span class="lineno"> 2600</span>&#160; </div>
<div class="line"><a name="l02601"></a><span class="lineno"> 2601</span>&#160;                    <span class="keywordflow">do</span></div>
<div class="line"><a name="l02602"></a><span class="lineno"> 2602</span>&#160;                    {</div>
<div class="line"><a name="l02603"></a><span class="lineno"> 2603</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer), element);</div>
<div class="line"><a name="l02604"></a><span class="lineno"> 2604</span>&#160;                    } <span class="keywordflow">while</span> (++end_iterator.element_pointer != fill_end);</div>
<div class="line"><a name="l02605"></a><span class="lineno"> 2605</span>&#160;                }</div>
<div class="line"><a name="l02606"></a><span class="lineno"> 2606</span>&#160;            }</div>
<div class="line"><a name="l02607"></a><span class="lineno"> 2607</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;            {</div>
<div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;                <span class="keyword">const</span> aligned_pointer_type fill_end = end_iterator.element_pointer + size;</div>
<div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160; </div>
<div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;                <span class="keywordflow">do</span></div>
<div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;                {</div>
<div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;                    <span class="keywordflow">try</span></div>
<div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;                    {</div>
<div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer), element);</div>
<div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;                    }</div>
<div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;                    <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;                    {</div>
<div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;                        recover_from_partial_fill();</div>
<div class="line"><a name="l02621"></a><span class="lineno"> 2621</span>&#160;                        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02622"></a><span class="lineno"> 2622</span>&#160;                    }</div>
<div class="line"><a name="l02623"></a><span class="lineno"> 2623</span>&#160;                } <span class="keywordflow">while</span> (++end_iterator.element_pointer != fill_end);</div>
<div class="line"><a name="l02624"></a><span class="lineno"> 2624</span>&#160;            }</div>
<div class="line"><a name="l02625"></a><span class="lineno"> 2625</span>&#160; </div>
<div class="line"><a name="l02626"></a><span class="lineno"> 2626</span>&#160;            total_size += size;</div>
<div class="line"><a name="l02627"></a><span class="lineno"> 2627</span>&#160;        }</div>
<div class="line"><a name="l02628"></a><span class="lineno"> 2628</span>&#160; </div>
<div class="line"><a name="l02629"></a><span class="lineno"> 2629</span>&#160; </div>
<div class="line"><a name="l02630"></a><span class="lineno"> 2630</span>&#160; </div>
<div class="line"><a name="l02631"></a><span class="lineno"> 2631</span>&#160;        <span class="comment">// For catch blocks in range_fill_skipblock and fill_skipblock</span></div>
<div class="line"><a name="l02632"></a><span class="lineno"> 2632</span>&#160;        <span class="keywordtype">void</span> recover_from_partial_skipblock_fill(aligned_pointer_type <span class="keyword">const</span> location, <span class="keyword">const</span> aligned_pointer_type current_location, skipfield_pointer_type <span class="keyword">const</span> skipfield_pointer, <span class="keyword">const</span> skipfield_type prev_free_list_node)</div>
<div class="line"><a name="l02633"></a><span class="lineno"> 2633</span>&#160;        {</div>
<div class="line"><a name="l02634"></a><span class="lineno"> 2634</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT // try to ensure this code will not be generated if this function is not called in fill_skipblock or range_fill_skipblock</span></div>
<div class="line"><a name="l02635"></a><span class="lineno"> 2635</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_nothrow_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02636"></a><span class="lineno"> 2636</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02637"></a><span class="lineno"> 2637</span>&#160;            {</div>
<div class="line"><a name="l02638"></a><span class="lineno"> 2638</span>&#160;                <span class="comment">// Reconstruct existing skipblock and free-list indexes to reflect partially-reused skipblock:</span></div>
<div class="line"><a name="l02639"></a><span class="lineno"> 2639</span>&#160;                <span class="keyword">const</span> skipfield_type elements_constructed_before_exception = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>((current_location - 1) - location);</div>
<div class="line"><a name="l02640"></a><span class="lineno"> 2640</span>&#160;                groups_with_erasures_list_head-&gt;size = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;size + elements_constructed_before_exception);</div>
<div class="line"><a name="l02641"></a><span class="lineno"> 2641</span>&#160;                total_size += elements_constructed_before_exception;</div>
<div class="line"><a name="l02642"></a><span class="lineno"> 2642</span>&#160; </div>
<div class="line"><a name="l02643"></a><span class="lineno"> 2643</span>&#160;                std::memset(skipfield_pointer, 0, elements_constructed_before_exception * <span class="keyword">sizeof</span>(skipfield_type));</div>
<div class="line"><a name="l02644"></a><span class="lineno"> 2644</span>&#160; </div>
<div class="line"><a name="l02645"></a><span class="lineno"> 2645</span>&#160;                *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(location + elements_constructed_before_exception)) = prev_free_list_node;</div>
<div class="line"><a name="l02646"></a><span class="lineno"> 2646</span>&#160;                *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(location + elements_constructed_before_exception) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l02647"></a><span class="lineno"> 2647</span>&#160; </div>
<div class="line"><a name="l02648"></a><span class="lineno"> 2648</span>&#160;                <span class="keyword">const</span> skipfield_type new_skipblock_head_index = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>((location - groups_with_erasures_list_head-&gt;elements) + elements_constructed_before_exception);</div>
<div class="line"><a name="l02649"></a><span class="lineno"> 2649</span>&#160;                groups_with_erasures_list_head-&gt;free_list_head = new_skipblock_head_index;</div>
<div class="line"><a name="l02650"></a><span class="lineno"> 2650</span>&#160; </div>
<div class="line"><a name="l02651"></a><span class="lineno"> 2651</span>&#160;                <span class="keywordflow">if</span> (prev_free_list_node != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l02652"></a><span class="lineno"> 2652</span>&#160;                {</div>
<div class="line"><a name="l02653"></a><span class="lineno"> 2653</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;elements + prev_free_list_node) + 1) = new_skipblock_head_index;</div>
<div class="line"><a name="l02654"></a><span class="lineno"> 2654</span>&#160;                }</div>
<div class="line"><a name="l02655"></a><span class="lineno"> 2655</span>&#160;            }</div>
<div class="line"><a name="l02656"></a><span class="lineno"> 2656</span>&#160;        }</div>
<div class="line"><a name="l02657"></a><span class="lineno"> 2657</span>&#160; </div>
<div class="line"><a name="l02658"></a><span class="lineno"> 2658</span>&#160; </div>
<div class="line"><a name="l02659"></a><span class="lineno"> 2659</span>&#160; </div>
<div class="line"><a name="l02660"></a><span class="lineno"> 2660</span>&#160;        <span class="keywordtype">void</span> fill_skipblock(<span class="keyword">const</span> element_type&amp; element, aligned_pointer_type <span class="keyword">const</span> location, skipfield_pointer_type <span class="keyword">const</span> skipfield_pointer, <span class="keyword">const</span> skipfield_type size)</div>
<div class="line"><a name="l02661"></a><span class="lineno"> 2661</span>&#160;        {</div>
<div class="line"><a name="l02662"></a><span class="lineno"> 2662</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02663"></a><span class="lineno"> 2663</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02664"></a><span class="lineno"> 2664</span>&#160;            {</div>
<div class="line"><a name="l02665"></a><span class="lineno"> 2665</span>&#160;                <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_trivially_copyable&lt;element_type&gt;::value &amp;&amp; std::is_trivially_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02666"></a><span class="lineno"> 2666</span>&#160;                {</div>
<div class="line"><a name="l02667"></a><span class="lineno"> 2667</span>&#160;<span class="preprocessor">#ifdef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l02668"></a><span class="lineno"> 2668</span>&#160;                    <span class="keywordflow">if</span> PLF_CONSTEXPR(<span class="keyword">sizeof</span>(aligned_element_type) != <span class="keyword">sizeof</span>(element_type))</div>
<div class="line"><a name="l02669"></a><span class="lineno"> 2669</span>&#160;                    {</div>
<div class="line"><a name="l02670"></a><span class="lineno"> 2670</span>&#160;                        <span class="keyword">alignas</span> (<span class="keyword">alignof</span>(aligned_element_type)) element_type aligned_copy = element;</div>
<div class="line"><a name="l02671"></a><span class="lineno"> 2671</span>&#160;                        std::fill_n(location, size, *(<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(&amp;aligned_copy)));</div>
<div class="line"><a name="l02672"></a><span class="lineno"> 2672</span>&#160;                    }</div>
<div class="line"><a name="l02673"></a><span class="lineno"> 2673</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02674"></a><span class="lineno"> 2674</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02675"></a><span class="lineno"> 2675</span>&#160;                    {</div>
<div class="line"><a name="l02676"></a><span class="lineno"> 2676</span>&#160;                        std::fill_n(<span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(location), size, element);</div>
<div class="line"><a name="l02677"></a><span class="lineno"> 2677</span>&#160;                    }</div>
<div class="line"><a name="l02678"></a><span class="lineno"> 2678</span>&#160;                }</div>
<div class="line"><a name="l02679"></a><span class="lineno"> 2679</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l02680"></a><span class="lineno"> 2680</span>&#160;                {</div>
<div class="line"><a name="l02681"></a><span class="lineno"> 2681</span>&#160;                    <span class="keyword">const</span> aligned_pointer_type fill_end = location + size;</div>
<div class="line"><a name="l02682"></a><span class="lineno"> 2682</span>&#160; </div>
<div class="line"><a name="l02683"></a><span class="lineno"> 2683</span>&#160;                    <span class="keywordflow">for</span> (aligned_pointer_type current_location = location; current_location != fill_end; ++current_location)</div>
<div class="line"><a name="l02684"></a><span class="lineno"> 2684</span>&#160;                    {</div>
<div class="line"><a name="l02685"></a><span class="lineno"> 2685</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current_location), element);</div>
<div class="line"><a name="l02686"></a><span class="lineno"> 2686</span>&#160;                    }</div>
<div class="line"><a name="l02687"></a><span class="lineno"> 2687</span>&#160;                }</div>
<div class="line"><a name="l02688"></a><span class="lineno"> 2688</span>&#160;            }</div>
<div class="line"><a name="l02689"></a><span class="lineno"> 2689</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l02690"></a><span class="lineno"> 2690</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02691"></a><span class="lineno"> 2691</span>&#160;            {</div>
<div class="line"><a name="l02692"></a><span class="lineno"> 2692</span>&#160;                <span class="keyword">const</span> aligned_pointer_type fill_end = location + size;</div>
<div class="line"><a name="l02693"></a><span class="lineno"> 2693</span>&#160;                <span class="keyword">const</span> skipfield_type prev_free_list_node = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(location)); <span class="comment">// in case of exception, grabbing indexes before free_list node is reused</span></div>
<div class="line"><a name="l02694"></a><span class="lineno"> 2694</span>&#160; </div>
<div class="line"><a name="l02695"></a><span class="lineno"> 2695</span>&#160;                <span class="keywordflow">for</span> (aligned_pointer_type current_location = location; current_location != fill_end; ++current_location)</div>
<div class="line"><a name="l02696"></a><span class="lineno"> 2696</span>&#160;                {</div>
<div class="line"><a name="l02697"></a><span class="lineno"> 2697</span>&#160;                    <span class="keywordflow">try</span></div>
<div class="line"><a name="l02698"></a><span class="lineno"> 2698</span>&#160;                    {</div>
<div class="line"><a name="l02699"></a><span class="lineno"> 2699</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current_location), element);</div>
<div class="line"><a name="l02700"></a><span class="lineno"> 2700</span>&#160;                    }</div>
<div class="line"><a name="l02701"></a><span class="lineno"> 2701</span>&#160;                    <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02702"></a><span class="lineno"> 2702</span>&#160;                    {</div>
<div class="line"><a name="l02703"></a><span class="lineno"> 2703</span>&#160;                        recover_from_partial_skipblock_fill(location, current_location, skipfield_pointer, prev_free_list_node);</div>
<div class="line"><a name="l02704"></a><span class="lineno"> 2704</span>&#160;                        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02705"></a><span class="lineno"> 2705</span>&#160;                    }</div>
<div class="line"><a name="l02706"></a><span class="lineno"> 2706</span>&#160;                }</div>
<div class="line"><a name="l02707"></a><span class="lineno"> 2707</span>&#160;            }</div>
<div class="line"><a name="l02708"></a><span class="lineno"> 2708</span>&#160; </div>
<div class="line"><a name="l02709"></a><span class="lineno"> 2709</span>&#160;            std::memset(skipfield_pointer, 0, size * <span class="keyword">sizeof</span>(skipfield_type)); <span class="comment">// reset skipfield nodes within skipblock to 0</span></div>
<div class="line"><a name="l02710"></a><span class="lineno"> 2710</span>&#160;            groups_with_erasures_list_head-&gt;size = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;size + size);</div>
<div class="line"><a name="l02711"></a><span class="lineno"> 2711</span>&#160;            total_size += size;</div>
<div class="line"><a name="l02712"></a><span class="lineno"> 2712</span>&#160;        }</div>
<div class="line"><a name="l02713"></a><span class="lineno"> 2713</span>&#160; </div>
<div class="line"><a name="l02714"></a><span class="lineno"> 2714</span>&#160; </div>
<div class="line"><a name="l02715"></a><span class="lineno"> 2715</span>&#160; </div>
<div class="line"><a name="l02716"></a><span class="lineno"> 2716</span>&#160;        <span class="keywordtype">void</span> fill_unused_groups(size_type size, <span class="keyword">const</span> element_type&amp; element, size_type group_number, group_pointer_type previous_group, <span class="keyword">const</span> group_pointer_type current_group)</div>
<div class="line"><a name="l02717"></a><span class="lineno"> 2717</span>&#160;        {</div>
<div class="line"><a name="l02718"></a><span class="lineno"> 2718</span>&#160;            end_iterator.group_pointer = current_group;</div>
<div class="line"><a name="l02719"></a><span class="lineno"> 2719</span>&#160; </div>
<div class="line"><a name="l02720"></a><span class="lineno"> 2720</span>&#160;            <span class="keywordflow">for</span> (; end_iterator.group_pointer-&gt;capacity &lt; size; end_iterator.group_pointer = end_iterator.group_pointer-&gt;next_group)</div>
<div class="line"><a name="l02721"></a><span class="lineno"> 2721</span>&#160;            {</div>
<div class="line"><a name="l02722"></a><span class="lineno"> 2722</span>&#160;                <span class="keyword">const</span> skipfield_type capacity = end_iterator.group_pointer-&gt;capacity;</div>
<div class="line"><a name="l02723"></a><span class="lineno"> 2723</span>&#160;                end_iterator.group_pointer-&gt;reset(capacity, end_iterator.group_pointer-&gt;next_group, previous_group, group_number++);</div>
<div class="line"><a name="l02724"></a><span class="lineno"> 2724</span>&#160;                previous_group = end_iterator.group_pointer;</div>
<div class="line"><a name="l02725"></a><span class="lineno"> 2725</span>&#160;                size -= <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(capacity);</div>
<div class="line"><a name="l02726"></a><span class="lineno"> 2726</span>&#160;                end_iterator.element_pointer = end_iterator.group_pointer-&gt;elements;</div>
<div class="line"><a name="l02727"></a><span class="lineno"> 2727</span>&#160;                fill(element, capacity);</div>
<div class="line"><a name="l02728"></a><span class="lineno"> 2728</span>&#160;            }</div>
<div class="line"><a name="l02729"></a><span class="lineno"> 2729</span>&#160; </div>
<div class="line"><a name="l02730"></a><span class="lineno"> 2730</span>&#160;            <span class="comment">// Deal with final group (partial fill)</span></div>
<div class="line"><a name="l02731"></a><span class="lineno"> 2731</span>&#160;            unused_groups_head = end_iterator.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l02732"></a><span class="lineno"> 2732</span>&#160;            end_iterator.group_pointer-&gt;reset(<span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(size), NULL, previous_group, group_number);</div>
<div class="line"><a name="l02733"></a><span class="lineno"> 2733</span>&#160;            end_iterator.element_pointer = end_iterator.group_pointer-&gt;elements;</div>
<div class="line"><a name="l02734"></a><span class="lineno"> 2734</span>&#160;            end_iterator.skipfield_pointer = end_iterator.group_pointer-&gt;skipfield + size;</div>
<div class="line"><a name="l02735"></a><span class="lineno"> 2735</span>&#160;            fill(element, <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(size));</div>
<div class="line"><a name="l02736"></a><span class="lineno"> 2736</span>&#160;        }</div>
<div class="line"><a name="l02737"></a><span class="lineno"> 2737</span>&#160; </div>
<div class="line"><a name="l02738"></a><span class="lineno"> 2738</span>&#160; </div>
<div class="line"><a name="l02739"></a><span class="lineno"> 2739</span>&#160; </div>
<div class="line"><a name="l02740"></a><span class="lineno"> 2740</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l02741"></a><span class="lineno"> 2741</span>&#160; </div>
<div class="line"><a name="l02742"></a><span class="lineno"> 2742</span>&#160;        <span class="comment">// Fill insert</span></div>
<div class="line"><a name="l02743"></a><span class="lineno"> 2743</span>&#160; </div>
<div class="line"><a name="l02744"></a><span class="lineno"> 2744</span>&#160;        <span class="keywordtype">void</span> insert(size_type size, <span class="keyword">const</span> element_type&amp; element)</div>
<div class="line"><a name="l02745"></a><span class="lineno"> 2745</span>&#160;        {</div>
<div class="line"><a name="l02746"></a><span class="lineno"> 2746</span>&#160;            <span class="keywordflow">if</span> (size == 0)</div>
<div class="line"><a name="l02747"></a><span class="lineno"> 2747</span>&#160;            {</div>
<div class="line"><a name="l02748"></a><span class="lineno"> 2748</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02749"></a><span class="lineno"> 2749</span>&#160;            }</div>
<div class="line"><a name="l02750"></a><span class="lineno"> 2750</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (size == 1)</div>
<div class="line"><a name="l02751"></a><span class="lineno"> 2751</span>&#160;            {</div>
<div class="line"><a name="l02752"></a><span class="lineno"> 2752</span>&#160;                insert(element);</div>
<div class="line"><a name="l02753"></a><span class="lineno"> 2753</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02754"></a><span class="lineno"> 2754</span>&#160;            }</div>
<div class="line"><a name="l02755"></a><span class="lineno"> 2755</span>&#160; </div>
<div class="line"><a name="l02756"></a><span class="lineno"> 2756</span>&#160;            <span class="keywordflow">if</span> (total_size == 0)</div>
<div class="line"><a name="l02757"></a><span class="lineno"> 2757</span>&#160;            {</div>
<div class="line"><a name="l02758"></a><span class="lineno"> 2758</span>&#160;                assign(size, element);</div>
<div class="line"><a name="l02759"></a><span class="lineno"> 2759</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02760"></a><span class="lineno"> 2760</span>&#160;            }</div>
<div class="line"><a name="l02761"></a><span class="lineno"> 2761</span>&#160; </div>
<div class="line"><a name="l02762"></a><span class="lineno"> 2762</span>&#160;            reserve(total_size + size);</div>
<div class="line"><a name="l02763"></a><span class="lineno"> 2763</span>&#160; </div>
<div class="line"><a name="l02764"></a><span class="lineno"> 2764</span>&#160;            <span class="comment">// Use up erased locations if available:</span></div>
<div class="line"><a name="l02765"></a><span class="lineno"> 2765</span>&#160;            <span class="keywordflow">while</span> (groups_with_erasures_list_head != NULL) <span class="comment">// skipblock loop: breaks when colony is exhausted of reusable skipblocks, or returns if size == 0</span></div>
<div class="line"><a name="l02766"></a><span class="lineno"> 2766</span>&#160;            {</div>
<div class="line"><a name="l02767"></a><span class="lineno"> 2767</span>&#160;                aligned_pointer_type <span class="keyword">const</span> element_pointer = groups_with_erasures_list_head-&gt;elements + groups_with_erasures_list_head-&gt;free_list_head;</div>
<div class="line"><a name="l02768"></a><span class="lineno"> 2768</span>&#160;                skipfield_pointer_type <span class="keyword">const</span> skipfield_pointer = groups_with_erasures_list_head-&gt;skipfield + groups_with_erasures_list_head-&gt;free_list_head;</div>
<div class="line"><a name="l02769"></a><span class="lineno"> 2769</span>&#160;                <span class="keyword">const</span> skipfield_type skipblock_size = *skipfield_pointer;</div>
<div class="line"><a name="l02770"></a><span class="lineno"> 2770</span>&#160; </div>
<div class="line"><a name="l02771"></a><span class="lineno"> 2771</span>&#160;                <span class="keywordflow">if</span> (groups_with_erasures_list_head == begin_iterator.group_pointer &amp;&amp; element_pointer &lt; begin_iterator.element_pointer)</div>
<div class="line"><a name="l02772"></a><span class="lineno"> 2772</span>&#160;                {</div>
<div class="line"><a name="l02773"></a><span class="lineno"> 2773</span>&#160;                    begin_iterator.element_pointer = element_pointer;</div>
<div class="line"><a name="l02774"></a><span class="lineno"> 2774</span>&#160;                    begin_iterator.skipfield_pointer = skipfield_pointer;</div>
<div class="line"><a name="l02775"></a><span class="lineno"> 2775</span>&#160;                }</div>
<div class="line"><a name="l02776"></a><span class="lineno"> 2776</span>&#160; </div>
<div class="line"><a name="l02777"></a><span class="lineno"> 2777</span>&#160;                <span class="keywordflow">if</span> (skipblock_size &lt;= size)</div>
<div class="line"><a name="l02778"></a><span class="lineno"> 2778</span>&#160;                {</div>
<div class="line"><a name="l02779"></a><span class="lineno"> 2779</span>&#160;                    groups_with_erasures_list_head-&gt;free_list_head = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(element_pointer)); <span class="comment">// set free list head to previous free list node</span></div>
<div class="line"><a name="l02780"></a><span class="lineno"> 2780</span>&#160;                    fill_skipblock(element, element_pointer, skipfield_pointer, skipblock_size);</div>
<div class="line"><a name="l02781"></a><span class="lineno"> 2781</span>&#160;                    size -= skipblock_size;</div>
<div class="line"><a name="l02782"></a><span class="lineno"> 2782</span>&#160; </div>
<div class="line"><a name="l02783"></a><span class="lineno"> 2783</span>&#160;                    <span class="keywordflow">if</span> (groups_with_erasures_list_head-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. there are more skipblocks to be filled in this group</span></div>
<div class="line"><a name="l02784"></a><span class="lineno"> 2784</span>&#160;                    {</div>
<div class="line"><a name="l02785"></a><span class="lineno"> 2785</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;elements + groups_with_erasures_list_head-&gt;free_list_head) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max(); <span class="comment">// set &#39;next&#39; index of new free list head to &#39;end&#39; (numeric max)</span></div>
<div class="line"><a name="l02786"></a><span class="lineno"> 2786</span>&#160;                    }</div>
<div class="line"><a name="l02787"></a><span class="lineno"> 2787</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02788"></a><span class="lineno"> 2788</span>&#160;                    {</div>
<div class="line"><a name="l02789"></a><span class="lineno"> 2789</span>&#160;                        groups_with_erasures_list_head = groups_with_erasures_list_head-&gt;erasures_list_next_group; <span class="comment">// change groups</span></div>
<div class="line"><a name="l02790"></a><span class="lineno"> 2790</span>&#160;                    }</div>
<div class="line"><a name="l02791"></a><span class="lineno"> 2791</span>&#160; </div>
<div class="line"><a name="l02792"></a><span class="lineno"> 2792</span>&#160;                    <span class="keywordflow">if</span> (size == 0)</div>
<div class="line"><a name="l02793"></a><span class="lineno"> 2793</span>&#160;                    {</div>
<div class="line"><a name="l02794"></a><span class="lineno"> 2794</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02795"></a><span class="lineno"> 2795</span>&#160;                    }</div>
<div class="line"><a name="l02796"></a><span class="lineno"> 2796</span>&#160;                }</div>
<div class="line"><a name="l02797"></a><span class="lineno"> 2797</span>&#160;                <span class="keywordflow">else</span> <span class="comment">// skipblock is larger than remaining number of elements</span></div>
<div class="line"><a name="l02798"></a><span class="lineno"> 2798</span>&#160;                {</div>
<div class="line"><a name="l02799"></a><span class="lineno"> 2799</span>&#160;                    <span class="keyword">const</span> skipfield_type prev_index = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(element_pointer)); <span class="comment">// save before element location is overwritten</span></div>
<div class="line"><a name="l02800"></a><span class="lineno"> 2800</span>&#160;                    fill_skipblock(element, element_pointer, skipfield_pointer, <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(size));</div>
<div class="line"><a name="l02801"></a><span class="lineno"> 2801</span>&#160;                    <span class="keyword">const</span> skipfield_type new_skipblock_size = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(skipblock_size - size);</div>
<div class="line"><a name="l02802"></a><span class="lineno"> 2802</span>&#160; </div>
<div class="line"><a name="l02803"></a><span class="lineno"> 2803</span>&#160;                    <span class="comment">// Update skipfield (earlier nodes already memset&#39;d in fill_skipblock function):</span></div>
<div class="line"><a name="l02804"></a><span class="lineno"> 2804</span>&#160;                    *(skipfield_pointer + size) = new_skipblock_size;</div>
<div class="line"><a name="l02805"></a><span class="lineno"> 2805</span>&#160;                    *(skipfield_pointer + skipblock_size - 1) = new_skipblock_size;</div>
<div class="line"><a name="l02806"></a><span class="lineno"> 2806</span>&#160;                    groups_with_erasures_list_head-&gt;free_list_head = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;free_list_head + size); <span class="comment">// set free list head to new start node</span></div>
<div class="line"><a name="l02807"></a><span class="lineno"> 2807</span>&#160; </div>
<div class="line"><a name="l02808"></a><span class="lineno"> 2808</span>&#160;                    <span class="comment">// Update free list with new head:</span></div>
<div class="line"><a name="l02809"></a><span class="lineno"> 2809</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(element_pointer + size)) = prev_index;</div>
<div class="line"><a name="l02810"></a><span class="lineno"> 2810</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(element_pointer + size) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l02811"></a><span class="lineno"> 2811</span>&#160; </div>
<div class="line"><a name="l02812"></a><span class="lineno"> 2812</span>&#160;                    <span class="keywordflow">if</span> (prev_index != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l02813"></a><span class="lineno"> 2813</span>&#160;                    {</div>
<div class="line"><a name="l02814"></a><span class="lineno"> 2814</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;elements + prev_index) + 1) = groups_with_erasures_list_head-&gt;free_list_head; <span class="comment">// set &#39;next&#39; index of previous skipblock to new start of skipblock</span></div>
<div class="line"><a name="l02815"></a><span class="lineno"> 2815</span>&#160;                    }</div>
<div class="line"><a name="l02816"></a><span class="lineno"> 2816</span>&#160; </div>
<div class="line"><a name="l02817"></a><span class="lineno"> 2817</span>&#160;                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02818"></a><span class="lineno"> 2818</span>&#160;                }</div>
<div class="line"><a name="l02819"></a><span class="lineno"> 2819</span>&#160;            }</div>
<div class="line"><a name="l02820"></a><span class="lineno"> 2820</span>&#160; </div>
<div class="line"><a name="l02821"></a><span class="lineno"> 2821</span>&#160; </div>
<div class="line"><a name="l02822"></a><span class="lineno"> 2822</span>&#160;            <span class="comment">// Use up remaining available element locations in end group:</span></div>
<div class="line"><a name="l02823"></a><span class="lineno"> 2823</span>&#160;            <span class="comment">// This variable is either the remaining capacity of the group or the number of elements yet to be filled, whichever is smaller:</span></div>
<div class="line"><a name="l02824"></a><span class="lineno"> 2824</span>&#160;            <span class="keyword">const</span> skipfield_type group_remainder = (<span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(</div>
<div class="line"><a name="l02825"></a><span class="lineno"> 2825</span>&#160;                <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield) - end_iterator.element_pointer) &gt;= size) ?</div>
<div class="line"><a name="l02826"></a><span class="lineno"> 2826</span>&#160;                <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(size) :</div>
<div class="line"><a name="l02827"></a><span class="lineno"> 2827</span>&#160;                <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield) - end_iterator.element_pointer);</div>
<div class="line"><a name="l02828"></a><span class="lineno"> 2828</span>&#160; </div>
<div class="line"><a name="l02829"></a><span class="lineno"> 2829</span>&#160;            <span class="keywordflow">if</span> (group_remainder != 0)</div>
<div class="line"><a name="l02830"></a><span class="lineno"> 2830</span>&#160;            {</div>
<div class="line"><a name="l02831"></a><span class="lineno"> 2831</span>&#160;                fill(element, group_remainder);</div>
<div class="line"><a name="l02832"></a><span class="lineno"> 2832</span>&#160;                end_iterator.group_pointer-&gt;last_endpoint = end_iterator.element_pointer;</div>
<div class="line"><a name="l02833"></a><span class="lineno"> 2833</span>&#160;                end_iterator.group_pointer-&gt;size = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;size + group_remainder);</div>
<div class="line"><a name="l02834"></a><span class="lineno"> 2834</span>&#160; </div>
<div class="line"><a name="l02835"></a><span class="lineno"> 2835</span>&#160;                <span class="keywordflow">if</span> (size == group_remainder) <span class="comment">// Ie. remaining capacity was &gt;= remaining elements to be filled</span></div>
<div class="line"><a name="l02836"></a><span class="lineno"> 2836</span>&#160;                {</div>
<div class="line"><a name="l02837"></a><span class="lineno"> 2837</span>&#160;                    end_iterator.skipfield_pointer = end_iterator.group_pointer-&gt;skipfield + end_iterator.group_pointer-&gt;size;</div>
<div class="line"><a name="l02838"></a><span class="lineno"> 2838</span>&#160;                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02839"></a><span class="lineno"> 2839</span>&#160;                }</div>
<div class="line"><a name="l02840"></a><span class="lineno"> 2840</span>&#160; </div>
<div class="line"><a name="l02841"></a><span class="lineno"> 2841</span>&#160;                size -= group_remainder;</div>
<div class="line"><a name="l02842"></a><span class="lineno"> 2842</span>&#160;            }</div>
<div class="line"><a name="l02843"></a><span class="lineno"> 2843</span>&#160; </div>
<div class="line"><a name="l02844"></a><span class="lineno"> 2844</span>&#160; </div>
<div class="line"><a name="l02845"></a><span class="lineno"> 2845</span>&#160;            <span class="comment">// Use unused groups:</span></div>
<div class="line"><a name="l02846"></a><span class="lineno"> 2846</span>&#160;            end_iterator.group_pointer-&gt;next_group = unused_groups_head;</div>
<div class="line"><a name="l02847"></a><span class="lineno"> 2847</span>&#160;            fill_unused_groups(size, element, end_iterator.group_pointer-&gt;group_number + 1, end_iterator.group_pointer, unused_groups_head);</div>
<div class="line"><a name="l02848"></a><span class="lineno"> 2848</span>&#160;        }</div>
<div class="line"><a name="l02849"></a><span class="lineno"> 2849</span>&#160; </div>
<div class="line"><a name="l02850"></a><span class="lineno"> 2850</span>&#160; </div>
<div class="line"><a name="l02851"></a><span class="lineno"> 2851</span>&#160; </div>
<div class="line"><a name="l02852"></a><span class="lineno"> 2852</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l02853"></a><span class="lineno"> 2853</span>&#160; </div>
<div class="line"><a name="l02854"></a><span class="lineno"> 2854</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type&gt;</div>
<div class="line"><a name="l02855"></a><span class="lineno"> 2855</span>&#160;        iterator_type range_fill(iterator_type it, <span class="keyword">const</span> skipfield_type size)</div>
<div class="line"><a name="l02856"></a><span class="lineno"> 2856</span>&#160;        {</div>
<div class="line"><a name="l02857"></a><span class="lineno"> 2857</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02858"></a><span class="lineno"> 2858</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02859"></a><span class="lineno"> 2859</span>&#160;            {</div>
<div class="line"><a name="l02860"></a><span class="lineno"> 2860</span>&#160;                <span class="keyword">const</span> aligned_pointer_type fill_end = end_iterator.element_pointer + size;</div>
<div class="line"><a name="l02861"></a><span class="lineno"> 2861</span>&#160; </div>
<div class="line"><a name="l02862"></a><span class="lineno"> 2862</span>&#160;                <span class="keywordflow">do</span></div>
<div class="line"><a name="l02863"></a><span class="lineno"> 2863</span>&#160;                {</div>
<div class="line"><a name="l02864"></a><span class="lineno"> 2864</span>&#160;                    PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer), *it++);</div>
<div class="line"><a name="l02865"></a><span class="lineno"> 2865</span>&#160;                } <span class="keywordflow">while</span> (++end_iterator.element_pointer != fill_end);</div>
<div class="line"><a name="l02866"></a><span class="lineno"> 2866</span>&#160;            }</div>
<div class="line"><a name="l02867"></a><span class="lineno"> 2867</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l02868"></a><span class="lineno"> 2868</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02869"></a><span class="lineno"> 2869</span>&#160;            {</div>
<div class="line"><a name="l02870"></a><span class="lineno"> 2870</span>&#160;                <span class="keyword">const</span> aligned_pointer_type fill_end = end_iterator.element_pointer + size;</div>
<div class="line"><a name="l02871"></a><span class="lineno"> 2871</span>&#160; </div>
<div class="line"><a name="l02872"></a><span class="lineno"> 2872</span>&#160;                <span class="keywordflow">do</span></div>
<div class="line"><a name="l02873"></a><span class="lineno"> 2873</span>&#160;                {</div>
<div class="line"><a name="l02874"></a><span class="lineno"> 2874</span>&#160;                    <span class="keywordflow">try</span></div>
<div class="line"><a name="l02875"></a><span class="lineno"> 2875</span>&#160;                    {</div>
<div class="line"><a name="l02876"></a><span class="lineno"> 2876</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(end_iterator.element_pointer), *it++);</div>
<div class="line"><a name="l02877"></a><span class="lineno"> 2877</span>&#160;                    }</div>
<div class="line"><a name="l02878"></a><span class="lineno"> 2878</span>&#160;                    <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02879"></a><span class="lineno"> 2879</span>&#160;                    {</div>
<div class="line"><a name="l02880"></a><span class="lineno"> 2880</span>&#160;                        recover_from_partial_fill();</div>
<div class="line"><a name="l02881"></a><span class="lineno"> 2881</span>&#160;                        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02882"></a><span class="lineno"> 2882</span>&#160;                    }</div>
<div class="line"><a name="l02883"></a><span class="lineno"> 2883</span>&#160;                } <span class="keywordflow">while</span> (++end_iterator.element_pointer != fill_end);</div>
<div class="line"><a name="l02884"></a><span class="lineno"> 2884</span>&#160;            }</div>
<div class="line"><a name="l02885"></a><span class="lineno"> 2885</span>&#160; </div>
<div class="line"><a name="l02886"></a><span class="lineno"> 2886</span>&#160;            total_size += size;</div>
<div class="line"><a name="l02887"></a><span class="lineno"> 2887</span>&#160;            <span class="keywordflow">return</span> it;</div>
<div class="line"><a name="l02888"></a><span class="lineno"> 2888</span>&#160;        }</div>
<div class="line"><a name="l02889"></a><span class="lineno"> 2889</span>&#160; </div>
<div class="line"><a name="l02890"></a><span class="lineno"> 2890</span>&#160; </div>
<div class="line"><a name="l02891"></a><span class="lineno"> 2891</span>&#160; </div>
<div class="line"><a name="l02892"></a><span class="lineno"> 2892</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type&gt;</div>
<div class="line"><a name="l02893"></a><span class="lineno"> 2893</span>&#160;        iterator_type range_fill_skipblock(iterator_type it, aligned_pointer_type <span class="keyword">const</span> location, skipfield_pointer_type <span class="keyword">const</span> skipfield_pointer, <span class="keyword">const</span> skipfield_type size)</div>
<div class="line"><a name="l02894"></a><span class="lineno"> 2894</span>&#160;        {</div>
<div class="line"><a name="l02895"></a><span class="lineno"> 2895</span>&#160;            <span class="keyword">const</span> aligned_pointer_type fill_end = location + size;</div>
<div class="line"><a name="l02896"></a><span class="lineno"> 2896</span>&#160; </div>
<div class="line"><a name="l02897"></a><span class="lineno"> 2897</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l02898"></a><span class="lineno"> 2898</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_nothrow_copy_constructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l02899"></a><span class="lineno"> 2899</span>&#160;            {</div>
<div class="line"><a name="l02900"></a><span class="lineno"> 2900</span>&#160;                <span class="keywordflow">for</span> (aligned_pointer_type current_location = location; current_location != fill_end; ++current_location)</div>
<div class="line"><a name="l02901"></a><span class="lineno"> 2901</span>&#160;                {</div>
<div class="line"><a name="l02902"></a><span class="lineno"> 2902</span>&#160;                    PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current_location), *it++);</div>
<div class="line"><a name="l02903"></a><span class="lineno"> 2903</span>&#160;                }</div>
<div class="line"><a name="l02904"></a><span class="lineno"> 2904</span>&#160;            }</div>
<div class="line"><a name="l02905"></a><span class="lineno"> 2905</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l02906"></a><span class="lineno"> 2906</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l02907"></a><span class="lineno"> 2907</span>&#160;            {</div>
<div class="line"><a name="l02908"></a><span class="lineno"> 2908</span>&#160;                <span class="keyword">const</span> skipfield_type prev_free_list_node = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(location)); <span class="comment">// in case of exception, grabbing indexes before free_list node is reused</span></div>
<div class="line"><a name="l02909"></a><span class="lineno"> 2909</span>&#160; </div>
<div class="line"><a name="l02910"></a><span class="lineno"> 2910</span>&#160;                <span class="keywordflow">for</span> (aligned_pointer_type current_location = location; current_location != fill_end; ++current_location)</div>
<div class="line"><a name="l02911"></a><span class="lineno"> 2911</span>&#160;                {</div>
<div class="line"><a name="l02912"></a><span class="lineno"> 2912</span>&#160;                    <span class="keywordflow">try</span></div>
<div class="line"><a name="l02913"></a><span class="lineno"> 2913</span>&#160;                    {</div>
<div class="line"><a name="l02914"></a><span class="lineno"> 2914</span>&#160;                        PLF_CONSTRUCT(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current_location), *it++);</div>
<div class="line"><a name="l02915"></a><span class="lineno"> 2915</span>&#160;                    }</div>
<div class="line"><a name="l02916"></a><span class="lineno"> 2916</span>&#160;                    <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l02917"></a><span class="lineno"> 2917</span>&#160;                    {</div>
<div class="line"><a name="l02918"></a><span class="lineno"> 2918</span>&#160;                        recover_from_partial_skipblock_fill(location, current_location, skipfield_pointer, prev_free_list_node);</div>
<div class="line"><a name="l02919"></a><span class="lineno"> 2919</span>&#160;                        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l02920"></a><span class="lineno"> 2920</span>&#160;                    }</div>
<div class="line"><a name="l02921"></a><span class="lineno"> 2921</span>&#160;                }</div>
<div class="line"><a name="l02922"></a><span class="lineno"> 2922</span>&#160;            }</div>
<div class="line"><a name="l02923"></a><span class="lineno"> 2923</span>&#160; </div>
<div class="line"><a name="l02924"></a><span class="lineno"> 2924</span>&#160;            std::memset(skipfield_pointer, 0, size * <span class="keyword">sizeof</span>(skipfield_type)); <span class="comment">// reset skipfield nodes within skipblock to 0</span></div>
<div class="line"><a name="l02925"></a><span class="lineno"> 2925</span>&#160;            groups_with_erasures_list_head-&gt;size = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;size + size);</div>
<div class="line"><a name="l02926"></a><span class="lineno"> 2926</span>&#160;            total_size += size;</div>
<div class="line"><a name="l02927"></a><span class="lineno"> 2927</span>&#160; </div>
<div class="line"><a name="l02928"></a><span class="lineno"> 2928</span>&#160;            <span class="keywordflow">return</span> it;</div>
<div class="line"><a name="l02929"></a><span class="lineno"> 2929</span>&#160;        }</div>
<div class="line"><a name="l02930"></a><span class="lineno"> 2930</span>&#160; </div>
<div class="line"><a name="l02931"></a><span class="lineno"> 2931</span>&#160; </div>
<div class="line"><a name="l02932"></a><span class="lineno"> 2932</span>&#160; </div>
<div class="line"><a name="l02933"></a><span class="lineno"> 2933</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type&gt;</div>
<div class="line"><a name="l02934"></a><span class="lineno"> 2934</span>&#160;        <span class="keywordtype">void</span> range_fill_unused_groups(size_type size, iterator_type it, size_type group_number, group_pointer_type previous_group, <span class="keyword">const</span> group_pointer_type current_group)</div>
<div class="line"><a name="l02935"></a><span class="lineno"> 2935</span>&#160;        {</div>
<div class="line"><a name="l02936"></a><span class="lineno"> 2936</span>&#160;            end_iterator.group_pointer = current_group;</div>
<div class="line"><a name="l02937"></a><span class="lineno"> 2937</span>&#160; </div>
<div class="line"><a name="l02938"></a><span class="lineno"> 2938</span>&#160;            <span class="keywordflow">for</span> (; end_iterator.group_pointer-&gt;capacity &lt; size; end_iterator.group_pointer = end_iterator.group_pointer-&gt;next_group)</div>
<div class="line"><a name="l02939"></a><span class="lineno"> 2939</span>&#160;            {</div>
<div class="line"><a name="l02940"></a><span class="lineno"> 2940</span>&#160;                <span class="keyword">const</span> skipfield_type capacity = end_iterator.group_pointer-&gt;capacity;</div>
<div class="line"><a name="l02941"></a><span class="lineno"> 2941</span>&#160;                end_iterator.group_pointer-&gt;reset(capacity, end_iterator.group_pointer-&gt;next_group, previous_group, group_number++);</div>
<div class="line"><a name="l02942"></a><span class="lineno"> 2942</span>&#160;                previous_group = end_iterator.group_pointer;</div>
<div class="line"><a name="l02943"></a><span class="lineno"> 2943</span>&#160;                size -= <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(capacity);</div>
<div class="line"><a name="l02944"></a><span class="lineno"> 2944</span>&#160;                end_iterator.element_pointer = end_iterator.group_pointer-&gt;elements;</div>
<div class="line"><a name="l02945"></a><span class="lineno"> 2945</span>&#160;                it = range_fill(it, capacity);</div>
<div class="line"><a name="l02946"></a><span class="lineno"> 2946</span>&#160;            }</div>
<div class="line"><a name="l02947"></a><span class="lineno"> 2947</span>&#160; </div>
<div class="line"><a name="l02948"></a><span class="lineno"> 2948</span>&#160;            <span class="comment">// Deal with final group (partial fill)</span></div>
<div class="line"><a name="l02949"></a><span class="lineno"> 2949</span>&#160;            unused_groups_head = end_iterator.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l02950"></a><span class="lineno"> 2950</span>&#160;            end_iterator.group_pointer-&gt;reset(<span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(size), NULL, previous_group, group_number);</div>
<div class="line"><a name="l02951"></a><span class="lineno"> 2951</span>&#160;            end_iterator.element_pointer = end_iterator.group_pointer-&gt;elements;</div>
<div class="line"><a name="l02952"></a><span class="lineno"> 2952</span>&#160;            end_iterator.skipfield_pointer = end_iterator.group_pointer-&gt;skipfield + size;</div>
<div class="line"><a name="l02953"></a><span class="lineno"> 2953</span>&#160;            range_fill(it, <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(size));</div>
<div class="line"><a name="l02954"></a><span class="lineno"> 2954</span>&#160;        }</div>
<div class="line"><a name="l02955"></a><span class="lineno"> 2955</span>&#160; </div>
<div class="line"><a name="l02956"></a><span class="lineno"> 2956</span>&#160; </div>
<div class="line"><a name="l02957"></a><span class="lineno"> 2957</span>&#160; </div>
<div class="line"><a name="l02958"></a><span class="lineno"> 2958</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type&gt;</div>
<div class="line"><a name="l02959"></a><span class="lineno"> 2959</span>&#160;        <span class="keywordtype">void</span> range_insert(iterator_type it, size_type size) <span class="comment">// this is near-identical to the fill insert, with the only alteration being incrementing an iterator for construction, rather than using a const element. And the fill etc function calls are changed to range_fill to match this pattern. comments have been removed, see fill insert for code explanations</span></div>
<div class="line"><a name="l02960"></a><span class="lineno"> 2960</span>&#160;        {</div>
<div class="line"><a name="l02961"></a><span class="lineno"> 2961</span>&#160;            <span class="keywordflow">if</span> (size == 0)</div>
<div class="line"><a name="l02962"></a><span class="lineno"> 2962</span>&#160;            {</div>
<div class="line"><a name="l02963"></a><span class="lineno"> 2963</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02964"></a><span class="lineno"> 2964</span>&#160;            }</div>
<div class="line"><a name="l02965"></a><span class="lineno"> 2965</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (size == 1)</div>
<div class="line"><a name="l02966"></a><span class="lineno"> 2966</span>&#160;            {</div>
<div class="line"><a name="l02967"></a><span class="lineno"> 2967</span>&#160;                insert(*it);</div>
<div class="line"><a name="l02968"></a><span class="lineno"> 2968</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02969"></a><span class="lineno"> 2969</span>&#160;            }</div>
<div class="line"><a name="l02970"></a><span class="lineno"> 2970</span>&#160; </div>
<div class="line"><a name="l02971"></a><span class="lineno"> 2971</span>&#160;            <span class="keywordflow">if</span> (total_size == 0)</div>
<div class="line"><a name="l02972"></a><span class="lineno"> 2972</span>&#160;            {</div>
<div class="line"><a name="l02973"></a><span class="lineno"> 2973</span>&#160;                range_assign(it, size);</div>
<div class="line"><a name="l02974"></a><span class="lineno"> 2974</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02975"></a><span class="lineno"> 2975</span>&#160;            }</div>
<div class="line"><a name="l02976"></a><span class="lineno"> 2976</span>&#160; </div>
<div class="line"><a name="l02977"></a><span class="lineno"> 2977</span>&#160; </div>
<div class="line"><a name="l02978"></a><span class="lineno"> 2978</span>&#160;            reserve(total_size + size);</div>
<div class="line"><a name="l02979"></a><span class="lineno"> 2979</span>&#160; </div>
<div class="line"><a name="l02980"></a><span class="lineno"> 2980</span>&#160;            <span class="keywordflow">while</span> (groups_with_erasures_list_head != NULL)</div>
<div class="line"><a name="l02981"></a><span class="lineno"> 2981</span>&#160;            {</div>
<div class="line"><a name="l02982"></a><span class="lineno"> 2982</span>&#160;                aligned_pointer_type <span class="keyword">const</span> element_pointer = groups_with_erasures_list_head-&gt;elements + groups_with_erasures_list_head-&gt;free_list_head;</div>
<div class="line"><a name="l02983"></a><span class="lineno"> 2983</span>&#160;                skipfield_pointer_type <span class="keyword">const</span> skipfield_pointer = groups_with_erasures_list_head-&gt;skipfield + groups_with_erasures_list_head-&gt;free_list_head;</div>
<div class="line"><a name="l02984"></a><span class="lineno"> 2984</span>&#160;                <span class="keyword">const</span> skipfield_type skipblock_size = *skipfield_pointer;</div>
<div class="line"><a name="l02985"></a><span class="lineno"> 2985</span>&#160; </div>
<div class="line"><a name="l02986"></a><span class="lineno"> 2986</span>&#160;                <span class="keywordflow">if</span> (groups_with_erasures_list_head == begin_iterator.group_pointer &amp;&amp; element_pointer &lt; begin_iterator.element_pointer)</div>
<div class="line"><a name="l02987"></a><span class="lineno"> 2987</span>&#160;                {</div>
<div class="line"><a name="l02988"></a><span class="lineno"> 2988</span>&#160;                    begin_iterator.element_pointer = element_pointer;</div>
<div class="line"><a name="l02989"></a><span class="lineno"> 2989</span>&#160;                    begin_iterator.skipfield_pointer = skipfield_pointer;</div>
<div class="line"><a name="l02990"></a><span class="lineno"> 2990</span>&#160;                }</div>
<div class="line"><a name="l02991"></a><span class="lineno"> 2991</span>&#160; </div>
<div class="line"><a name="l02992"></a><span class="lineno"> 2992</span>&#160;                <span class="keywordflow">if</span> (skipblock_size &lt;= size)</div>
<div class="line"><a name="l02993"></a><span class="lineno"> 2993</span>&#160;                {</div>
<div class="line"><a name="l02994"></a><span class="lineno"> 2994</span>&#160;                    groups_with_erasures_list_head-&gt;free_list_head = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(element_pointer));</div>
<div class="line"><a name="l02995"></a><span class="lineno"> 2995</span>&#160;                    it = range_fill_skipblock(it, element_pointer, skipfield_pointer, skipblock_size);</div>
<div class="line"><a name="l02996"></a><span class="lineno"> 2996</span>&#160;                    size -= skipblock_size;</div>
<div class="line"><a name="l02997"></a><span class="lineno"> 2997</span>&#160; </div>
<div class="line"><a name="l02998"></a><span class="lineno"> 2998</span>&#160;                    <span class="keywordflow">if</span> (groups_with_erasures_list_head-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l02999"></a><span class="lineno"> 2999</span>&#160;                    {</div>
<div class="line"><a name="l03000"></a><span class="lineno"> 3000</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;elements + groups_with_erasures_list_head-&gt;free_list_head) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l03001"></a><span class="lineno"> 3001</span>&#160;                    }</div>
<div class="line"><a name="l03002"></a><span class="lineno"> 3002</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03003"></a><span class="lineno"> 3003</span>&#160;                    {</div>
<div class="line"><a name="l03004"></a><span class="lineno"> 3004</span>&#160;                        groups_with_erasures_list_head = groups_with_erasures_list_head-&gt;erasures_list_next_group;</div>
<div class="line"><a name="l03005"></a><span class="lineno"> 3005</span>&#160;                    }</div>
<div class="line"><a name="l03006"></a><span class="lineno"> 3006</span>&#160; </div>
<div class="line"><a name="l03007"></a><span class="lineno"> 3007</span>&#160;                    <span class="keywordflow">if</span> (size == 0)</div>
<div class="line"><a name="l03008"></a><span class="lineno"> 3008</span>&#160;                    {</div>
<div class="line"><a name="l03009"></a><span class="lineno"> 3009</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l03010"></a><span class="lineno"> 3010</span>&#160;                    }</div>
<div class="line"><a name="l03011"></a><span class="lineno"> 3011</span>&#160;                }</div>
<div class="line"><a name="l03012"></a><span class="lineno"> 3012</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l03013"></a><span class="lineno"> 3013</span>&#160;                {</div>
<div class="line"><a name="l03014"></a><span class="lineno"> 3014</span>&#160;                    <span class="keyword">const</span> skipfield_type prev_index = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(element_pointer));</div>
<div class="line"><a name="l03015"></a><span class="lineno"> 3015</span>&#160;                    it = range_fill_skipblock(it, element_pointer, skipfield_pointer, <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(size));</div>
<div class="line"><a name="l03016"></a><span class="lineno"> 3016</span>&#160;                    <span class="keyword">const</span> skipfield_type new_skipblock_size = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(skipblock_size - size);</div>
<div class="line"><a name="l03017"></a><span class="lineno"> 3017</span>&#160; </div>
<div class="line"><a name="l03018"></a><span class="lineno"> 3018</span>&#160;                    *(skipfield_pointer + size) = new_skipblock_size;</div>
<div class="line"><a name="l03019"></a><span class="lineno"> 3019</span>&#160;                    *(skipfield_pointer + skipblock_size - 1) = new_skipblock_size;</div>
<div class="line"><a name="l03020"></a><span class="lineno"> 3020</span>&#160;                    groups_with_erasures_list_head-&gt;free_list_head = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;free_list_head + size);</div>
<div class="line"><a name="l03021"></a><span class="lineno"> 3021</span>&#160; </div>
<div class="line"><a name="l03022"></a><span class="lineno"> 3022</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(element_pointer + size)) = prev_index;</div>
<div class="line"><a name="l03023"></a><span class="lineno"> 3023</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(element_pointer + size) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l03024"></a><span class="lineno"> 3024</span>&#160; </div>
<div class="line"><a name="l03025"></a><span class="lineno"> 3025</span>&#160;                    <span class="keywordflow">if</span> (prev_index != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03026"></a><span class="lineno"> 3026</span>&#160;                    {</div>
<div class="line"><a name="l03027"></a><span class="lineno"> 3027</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(groups_with_erasures_list_head-&gt;elements + prev_index) + 1) = groups_with_erasures_list_head-&gt;free_list_head;</div>
<div class="line"><a name="l03028"></a><span class="lineno"> 3028</span>&#160;                    }</div>
<div class="line"><a name="l03029"></a><span class="lineno"> 3029</span>&#160; </div>
<div class="line"><a name="l03030"></a><span class="lineno"> 3030</span>&#160;                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l03031"></a><span class="lineno"> 3031</span>&#160;                }</div>
<div class="line"><a name="l03032"></a><span class="lineno"> 3032</span>&#160;            }</div>
<div class="line"><a name="l03033"></a><span class="lineno"> 3033</span>&#160; </div>
<div class="line"><a name="l03034"></a><span class="lineno"> 3034</span>&#160; </div>
<div class="line"><a name="l03035"></a><span class="lineno"> 3035</span>&#160;            <span class="keyword">const</span> skipfield_type group_remainder = (<span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(</div>
<div class="line"><a name="l03036"></a><span class="lineno"> 3036</span>&#160;                <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield) - end_iterator.element_pointer) &gt;= size) ?</div>
<div class="line"><a name="l03037"></a><span class="lineno"> 3037</span>&#160;                <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(size) :</div>
<div class="line"><a name="l03038"></a><span class="lineno"> 3038</span>&#160;                <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield) - end_iterator.element_pointer);</div>
<div class="line"><a name="l03039"></a><span class="lineno"> 3039</span>&#160; </div>
<div class="line"><a name="l03040"></a><span class="lineno"> 3040</span>&#160;            <span class="keywordflow">if</span> (group_remainder != 0)</div>
<div class="line"><a name="l03041"></a><span class="lineno"> 3041</span>&#160;            {</div>
<div class="line"><a name="l03042"></a><span class="lineno"> 3042</span>&#160;                it = range_fill(it, group_remainder);</div>
<div class="line"><a name="l03043"></a><span class="lineno"> 3043</span>&#160;                end_iterator.group_pointer-&gt;last_endpoint = end_iterator.element_pointer;</div>
<div class="line"><a name="l03044"></a><span class="lineno"> 3044</span>&#160;                end_iterator.group_pointer-&gt;size = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;size + group_remainder);</div>
<div class="line"><a name="l03045"></a><span class="lineno"> 3045</span>&#160; </div>
<div class="line"><a name="l03046"></a><span class="lineno"> 3046</span>&#160;                <span class="keywordflow">if</span> (size == group_remainder)</div>
<div class="line"><a name="l03047"></a><span class="lineno"> 3047</span>&#160;                {</div>
<div class="line"><a name="l03048"></a><span class="lineno"> 3048</span>&#160;                    end_iterator.skipfield_pointer = end_iterator.group_pointer-&gt;skipfield + end_iterator.group_pointer-&gt;size;</div>
<div class="line"><a name="l03049"></a><span class="lineno"> 3049</span>&#160;                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l03050"></a><span class="lineno"> 3050</span>&#160;                }</div>
<div class="line"><a name="l03051"></a><span class="lineno"> 3051</span>&#160; </div>
<div class="line"><a name="l03052"></a><span class="lineno"> 3052</span>&#160;                size -= group_remainder;</div>
<div class="line"><a name="l03053"></a><span class="lineno"> 3053</span>&#160;            }</div>
<div class="line"><a name="l03054"></a><span class="lineno"> 3054</span>&#160; </div>
<div class="line"><a name="l03055"></a><span class="lineno"> 3055</span>&#160; </div>
<div class="line"><a name="l03056"></a><span class="lineno"> 3056</span>&#160;            end_iterator.group_pointer-&gt;next_group = unused_groups_head;</div>
<div class="line"><a name="l03057"></a><span class="lineno"> 3057</span>&#160;            range_fill_unused_groups(size, it, end_iterator.group_pointer-&gt;group_number + 1, end_iterator.group_pointer, unused_groups_head);</div>
<div class="line"><a name="l03058"></a><span class="lineno"> 3058</span>&#160;        }</div>
<div class="line"><a name="l03059"></a><span class="lineno"> 3059</span>&#160; </div>
<div class="line"><a name="l03060"></a><span class="lineno"> 3060</span>&#160; </div>
<div class="line"><a name="l03061"></a><span class="lineno"> 3061</span>&#160; </div>
<div class="line"><a name="l03062"></a><span class="lineno"> 3062</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l03063"></a><span class="lineno"> 3063</span>&#160; </div>
<div class="line"><a name="l03064"></a><span class="lineno"> 3064</span>&#160;        <span class="comment">// Range insert:</span></div>
<div class="line"><a name="l03065"></a><span class="lineno"> 3065</span>&#160; </div>
<div class="line"><a name="l03066"></a><span class="lineno"> 3066</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type&gt;</div>
<div class="line"><a name="l03067"></a><span class="lineno"> 3067</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> insert(<span class="keyword">const</span> <span class="keyword">typename</span> plf_enable_if_c&lt;!std::numeric_limits&lt;iterator_type&gt;::is_integer, iterator_type&gt;::type first, <span class="keyword">const</span> iterator_type last)</div>
<div class="line"><a name="l03068"></a><span class="lineno"> 3068</span>&#160;        {</div>
<div class="line"><a name="l03069"></a><span class="lineno"> 3069</span>&#160;            <span class="keyword">using</span> std::distance;</div>
<div class="line"><a name="l03070"></a><span class="lineno"> 3070</span>&#160;            range_insert(first, <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(distance(first, last)));</div>
<div class="line"><a name="l03071"></a><span class="lineno"> 3071</span>&#160;        }</div>
<div class="line"><a name="l03072"></a><span class="lineno"> 3072</span>&#160; </div>
<div class="line"><a name="l03073"></a><span class="lineno"> 3073</span>&#160; </div>
<div class="line"><a name="l03074"></a><span class="lineno"> 3074</span>&#160; </div>
<div class="line"><a name="l03075"></a><span class="lineno"> 3075</span>&#160;        <span class="comment">// Range insert for differing iterator types eg. sentinels:</span></div>
<div class="line"><a name="l03076"></a><span class="lineno"> 3076</span>&#160; </div>
<div class="line"><a name="l03077"></a><span class="lineno"> 3077</span>&#160;<span class="preprocessor">#ifdef PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l03078"></a><span class="lineno"> 3078</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type1, <span class="keyword">class</span> iterator_type2&gt;</div>
<div class="line"><a name="l03079"></a><span class="lineno"> 3079</span>&#160;        requires (!std::same_as&lt;iterator_type1, iterator_type2&gt;&amp;&amp; std::equality_comparable_with&lt;iterator_type1, iterator_type2&gt; &amp;&amp; !std::integral&lt;iterator_type1&gt; &amp;&amp; !std::integral&lt;iterator_type2&gt;)</div>
<div class="line"><a name="l03080"></a><span class="lineno"> 3080</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> insert(<span class="keyword">const</span> iterator_type1 first, <span class="keyword">const</span> iterator_type2 last)</div>
<div class="line"><a name="l03081"></a><span class="lineno"> 3081</span>&#160;        {</div>
<div class="line"><a name="l03082"></a><span class="lineno"> 3082</span>&#160;            size_type distance = 0;</div>
<div class="line"><a name="l03083"></a><span class="lineno"> 3083</span>&#160;            <span class="keywordflow">for</span> (iterator_type1 current = first; current != last; ++current, ++distance) {};</div>
<div class="line"><a name="l03084"></a><span class="lineno"> 3084</span>&#160;            range_insert(first, distance);</div>
<div class="line"><a name="l03085"></a><span class="lineno"> 3085</span>&#160;        }</div>
<div class="line"><a name="l03086"></a><span class="lineno"> 3086</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03087"></a><span class="lineno"> 3087</span>&#160; </div>
<div class="line"><a name="l03088"></a><span class="lineno"> 3088</span>&#160; </div>
<div class="line"><a name="l03089"></a><span class="lineno"> 3089</span>&#160; </div>
<div class="line"><a name="l03090"></a><span class="lineno"> 3090</span>&#160;        <span class="comment">// Range insert, move_iterator overload:</span></div>
<div class="line"><a name="l03091"></a><span class="lineno"> 3091</span>&#160; </div>
<div class="line"><a name="l03092"></a><span class="lineno"> 3092</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l03093"></a><span class="lineno"> 3093</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type&gt;</div>
<div class="line"><a name="l03094"></a><span class="lineno"> 3094</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> insert(<span class="keyword">const</span> std::move_iterator&lt;iterator_type&gt; first, <span class="keyword">const</span> std::move_iterator&lt;iterator_type&gt; last)</div>
<div class="line"><a name="l03095"></a><span class="lineno"> 3095</span>&#160;        {</div>
<div class="line"><a name="l03096"></a><span class="lineno"> 3096</span>&#160;            <span class="keyword">using</span> std::distance;</div>
<div class="line"><a name="l03097"></a><span class="lineno"> 3097</span>&#160;            range_insert(first, <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(distance(first.base(), last.base())));</div>
<div class="line"><a name="l03098"></a><span class="lineno"> 3098</span>&#160;        }</div>
<div class="line"><a name="l03099"></a><span class="lineno"> 3099</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03100"></a><span class="lineno"> 3100</span>&#160; </div>
<div class="line"><a name="l03101"></a><span class="lineno"> 3101</span>&#160; </div>
<div class="line"><a name="l03102"></a><span class="lineno"> 3102</span>&#160; </div>
<div class="line"><a name="l03103"></a><span class="lineno"> 3103</span>&#160;        <span class="comment">// Initializer-list insert</span></div>
<div class="line"><a name="l03104"></a><span class="lineno"> 3104</span>&#160; </div>
<div class="line"><a name="l03105"></a><span class="lineno"> 3105</span>&#160;<span class="preprocessor">#ifdef PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l03106"></a><span class="lineno"> 3106</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> insert(<span class="keyword">const</span> std::initializer_list&lt;element_type&gt;&amp; element_list)</div>
<div class="line"><a name="l03107"></a><span class="lineno"> 3107</span>&#160;        {</div>
<div class="line"><a name="l03108"></a><span class="lineno"> 3108</span>&#160;            range_insert(element_list.begin(), <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(element_list.size()));</div>
<div class="line"><a name="l03109"></a><span class="lineno"> 3109</span>&#160;        }</div>
<div class="line"><a name="l03110"></a><span class="lineno"> 3110</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03111"></a><span class="lineno"> 3111</span>&#160; </div>
<div class="line"><a name="l03112"></a><span class="lineno"> 3112</span>&#160; </div>
<div class="line"><a name="l03113"></a><span class="lineno"> 3113</span>&#160; </div>
<div class="line"><a name="l03114"></a><span class="lineno"> 3114</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l03115"></a><span class="lineno"> 3115</span>&#160; </div>
<div class="line"><a name="l03116"></a><span class="lineno"> 3116</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">void</span> update_subsequent_group_numbers(group_pointer_type current_group) PLF_NOEXCEPT</div>
<div class="line"><a name="l03117"></a><span class="lineno"> 3117</span>&#160;        {</div>
<div class="line"><a name="l03118"></a><span class="lineno"> 3118</span>&#160;            <span class="keywordflow">do</span></div>
<div class="line"><a name="l03119"></a><span class="lineno"> 3119</span>&#160;            {</div>
<div class="line"><a name="l03120"></a><span class="lineno"> 3120</span>&#160;                --(current_group-&gt;group_number);</div>
<div class="line"><a name="l03121"></a><span class="lineno"> 3121</span>&#160;                current_group = current_group-&gt;next_group;</div>
<div class="line"><a name="l03122"></a><span class="lineno"> 3122</span>&#160;            } <span class="keywordflow">while</span> (current_group != NULL);</div>
<div class="line"><a name="l03123"></a><span class="lineno"> 3123</span>&#160;        }</div>
<div class="line"><a name="l03124"></a><span class="lineno"> 3124</span>&#160; </div>
<div class="line"><a name="l03125"></a><span class="lineno"> 3125</span>&#160; </div>
<div class="line"><a name="l03126"></a><span class="lineno"> 3126</span>&#160; </div>
<div class="line"><a name="l03127"></a><span class="lineno"> 3127</span>&#160;        <span class="keywordtype">void</span> remove_from_groups_with_erasures_list(<span class="keyword">const</span> group_pointer_type group_to_remove) PLF_NOEXCEPT</div>
<div class="line"><a name="l03128"></a><span class="lineno"> 3128</span>&#160;        {</div>
<div class="line"><a name="l03129"></a><span class="lineno"> 3129</span>&#160;            <span class="keywordflow">if</span> (group_to_remove == groups_with_erasures_list_head)</div>
<div class="line"><a name="l03130"></a><span class="lineno"> 3130</span>&#160;            {</div>
<div class="line"><a name="l03131"></a><span class="lineno"> 3131</span>&#160;                groups_with_erasures_list_head = groups_with_erasures_list_head-&gt;erasures_list_next_group;</div>
<div class="line"><a name="l03132"></a><span class="lineno"> 3132</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l03133"></a><span class="lineno"> 3133</span>&#160;            }</div>
<div class="line"><a name="l03134"></a><span class="lineno"> 3134</span>&#160; </div>
<div class="line"><a name="l03135"></a><span class="lineno"> 3135</span>&#160;            group_pointer_type previous_group = groups_with_erasures_list_head, current_group = groups_with_erasures_list_head-&gt;erasures_list_next_group;</div>
<div class="line"><a name="l03136"></a><span class="lineno"> 3136</span>&#160; </div>
<div class="line"><a name="l03137"></a><span class="lineno"> 3137</span>&#160;            <span class="keywordflow">while</span> (group_to_remove != current_group)</div>
<div class="line"><a name="l03138"></a><span class="lineno"> 3138</span>&#160;            {</div>
<div class="line"><a name="l03139"></a><span class="lineno"> 3139</span>&#160;                previous_group = current_group;</div>
<div class="line"><a name="l03140"></a><span class="lineno"> 3140</span>&#160;                current_group = current_group-&gt;erasures_list_next_group;</div>
<div class="line"><a name="l03141"></a><span class="lineno"> 3141</span>&#160;            }</div>
<div class="line"><a name="l03142"></a><span class="lineno"> 3142</span>&#160; </div>
<div class="line"><a name="l03143"></a><span class="lineno"> 3143</span>&#160;            previous_group-&gt;erasures_list_next_group = current_group-&gt;erasures_list_next_group;</div>
<div class="line"><a name="l03144"></a><span class="lineno"> 3144</span>&#160;        }</div>
<div class="line"><a name="l03145"></a><span class="lineno"> 3145</span>&#160; </div>
<div class="line"><a name="l03146"></a><span class="lineno"> 3146</span>&#160; </div>
<div class="line"><a name="l03147"></a><span class="lineno"> 3147</span>&#160; </div>
<div class="line"><a name="l03148"></a><span class="lineno"> 3148</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> reset_only_group_left(group_pointer_type <span class="keyword">const</span> group_pointer) PLF_NOEXCEPT</div>
<div class="line"><a name="l03149"></a><span class="lineno"> 3149</span>&#160;        {</div>
<div class="line"><a name="l03150"></a><span class="lineno"> 3150</span>&#160;            groups_with_erasures_list_head = NULL;</div>
<div class="line"><a name="l03151"></a><span class="lineno"> 3151</span>&#160;            group_pointer-&gt;reset(0, NULL, NULL, 0);</div>
<div class="line"><a name="l03152"></a><span class="lineno"> 3152</span>&#160; </div>
<div class="line"><a name="l03153"></a><span class="lineno"> 3153</span>&#160;            <span class="comment">// Reset begin and end iterators:</span></div>
<div class="line"><a name="l03154"></a><span class="lineno"> 3154</span>&#160;            end_iterator.element_pointer = begin_iterator.element_pointer = group_pointer-&gt;last_endpoint;</div>
<div class="line"><a name="l03155"></a><span class="lineno"> 3155</span>&#160;            end_iterator.skipfield_pointer = begin_iterator.skipfield_pointer = group_pointer-&gt;skipfield;</div>
<div class="line"><a name="l03156"></a><span class="lineno"> 3156</span>&#160;        }</div>
<div class="line"><a name="l03157"></a><span class="lineno"> 3157</span>&#160; </div>
<div class="line"><a name="l03158"></a><span class="lineno"> 3158</span>&#160; </div>
<div class="line"><a name="l03159"></a><span class="lineno"> 3159</span>&#160; </div>
<div class="line"><a name="l03160"></a><span class="lineno"> 3160</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">void</span> add_group_to_unused_groups_list(group* <span class="keyword">const</span> group_pointer) PLF_NOEXCEPT</div>
<div class="line"><a name="l03161"></a><span class="lineno"> 3161</span>&#160;        {</div>
<div class="line"><a name="l03162"></a><span class="lineno"> 3162</span>&#160;            group_pointer-&gt;next_group = unused_groups_head;</div>
<div class="line"><a name="l03163"></a><span class="lineno"> 3163</span>&#160;            unused_groups_head = group_pointer;</div>
<div class="line"><a name="l03164"></a><span class="lineno"> 3164</span>&#160;        }</div>
<div class="line"><a name="l03165"></a><span class="lineno"> 3165</span>&#160; </div>
<div class="line"><a name="l03166"></a><span class="lineno"> 3166</span>&#160; </div>
<div class="line"><a name="l03167"></a><span class="lineno"> 3167</span>&#160; </div>
<div class="line"><a name="l03168"></a><span class="lineno"> 3168</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l03169"></a><span class="lineno"> 3169</span>&#160; </div>
<div class="line"><a name="l03170"></a><span class="lineno"> 3170</span>&#160;        <span class="comment">// must return iterator to subsequent non-erased element (or end()), in case the group containing the element which the iterator points to becomes empty after the erasure, and is thereafter removed from the colony chain, making the current iterator invalid and unusable in a ++ operation:</span></div>
<div class="line"><a name="l03171"></a><span class="lineno"> 3171</span>&#160;        iterator erase(<span class="keyword">const</span> const_iterator it) <span class="comment">// if uninitialized/invalid iterator supplied, function could generate an exception</span></div>
<div class="line"><a name="l03172"></a><span class="lineno"> 3172</span>&#160;        {</div>
<div class="line"><a name="l03173"></a><span class="lineno"> 3173</span>&#160;            assert(total_size != 0);</div>
<div class="line"><a name="l03174"></a><span class="lineno"> 3174</span>&#160;            assert(it.group_pointer != NULL); <span class="comment">// ie. not uninitialized iterator</span></div>
<div class="line"><a name="l03175"></a><span class="lineno"> 3175</span>&#160;            assert(it.element_pointer != it.group_pointer-&gt;last_endpoint); <span class="comment">// ie. != end()</span></div>
<div class="line"><a name="l03176"></a><span class="lineno"> 3176</span>&#160;            assert(*(it.skipfield_pointer) == 0); <span class="comment">// ie. element pointed to by iterator has not been erased previously</span></div>
<div class="line"><a name="l03177"></a><span class="lineno"> 3177</span>&#160; </div>
<div class="line"><a name="l03178"></a><span class="lineno"> 3178</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l03179"></a><span class="lineno"> 3179</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_trivially_destructible&lt;element_type&gt;::value) <span class="comment">// This if-statement should be removed by the compiler on resolution of element_type. For some optimizing compilers this step won&#39;t be necessary (for MSVC 2013 it makes a difference)</span></div>
<div class="line"><a name="l03180"></a><span class="lineno"> 3180</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03181"></a><span class="lineno"> 3181</span>&#160;            {</div>
<div class="line"><a name="l03182"></a><span class="lineno"> 3182</span>&#160;                PLF_DESTROY(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(it.element_pointer)); <span class="comment">// Destruct element</span></div>
<div class="line"><a name="l03183"></a><span class="lineno"> 3183</span>&#160;            }</div>
<div class="line"><a name="l03184"></a><span class="lineno"> 3184</span>&#160; </div>
<div class="line"><a name="l03185"></a><span class="lineno"> 3185</span>&#160;            --total_size;</div>
<div class="line"><a name="l03186"></a><span class="lineno"> 3186</span>&#160; </div>
<div class="line"><a name="l03187"></a><span class="lineno"> 3187</span>&#160;            <span class="keywordflow">if</span> (it.group_pointer-&gt;size-- != 1) <span class="comment">// ie. non-empty group at this point in time, don&#39;t consolidate - optimization note: GCC optimizes postfix - 1 comparison better than prefix - 1 comparison in many cases.</span></div>
<div class="line"><a name="l03188"></a><span class="lineno"> 3188</span>&#160;            {</div>
<div class="line"><a name="l03189"></a><span class="lineno"> 3189</span>&#160;                <span class="comment">// Code logic for following section:</span></div>
<div class="line"><a name="l03190"></a><span class="lineno"> 3190</span>&#160;                <span class="comment">// ---------------------------------</span></div>
<div class="line"><a name="l03191"></a><span class="lineno"> 3191</span>&#160;                <span class="comment">// If current skipfield node has no skipped node on either side, continue as usual</span></div>
<div class="line"><a name="l03192"></a><span class="lineno"> 3192</span>&#160;                <span class="comment">// If node only has skipped node on left, set current node and start node of the skipblock to left node value + 1.</span></div>
<div class="line"><a name="l03193"></a><span class="lineno"> 3193</span>&#160;                <span class="comment">// If node only has skipped node on right, make this node the start node of the skipblock and update end node</span></div>
<div class="line"><a name="l03194"></a><span class="lineno"> 3194</span>&#160;                <span class="comment">// If node has skipped nodes on left and right, set start node of left skipblock and end node of right skipblock to the values of the left + right nodes + 1</span></div>
<div class="line"><a name="l03195"></a><span class="lineno"> 3195</span>&#160; </div>
<div class="line"><a name="l03196"></a><span class="lineno"> 3196</span>&#160;                <span class="comment">// Optimization explanation:</span></div>
<div class="line"><a name="l03197"></a><span class="lineno"> 3197</span>&#160;                <span class="comment">// The contextual logic below is the same as that in the insert() functions but in this case the value of the current skipfield node will always be</span></div>
<div class="line"><a name="l03198"></a><span class="lineno"> 3198</span>&#160;                <span class="comment">// zero (since it is not yet erased), meaning no additional manipulations are necessary for the previous skipfield node comparison - we only have to check against zero</span></div>
<div class="line"><a name="l03199"></a><span class="lineno"> 3199</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">char</span> prev_skipfield = *(it.skipfield_pointer - (it.skipfield_pointer != it.group_pointer-&gt;skipfield)) != 0;</div>
<div class="line"><a name="l03200"></a><span class="lineno"> 3200</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">char</span> after_skipfield = *(it.skipfield_pointer + 1) != 0;  <span class="comment">// NOTE: boundary test (checking against end-of-elements) is able to be skipped due to the extra skipfield node (compared to element field) - which is present to enable faster iterator operator ++ operations</span></div>
<div class="line"><a name="l03201"></a><span class="lineno"> 3201</span>&#160;                skipfield_type update_value = 1;</div>
<div class="line"><a name="l03202"></a><span class="lineno"> 3202</span>&#160; </div>
<div class="line"><a name="l03203"></a><span class="lineno"> 3203</span>&#160;                <span class="keywordflow">if</span> (!(prev_skipfield | after_skipfield)) <span class="comment">// no consecutive erased elements</span></div>
<div class="line"><a name="l03204"></a><span class="lineno"> 3204</span>&#160;                {</div>
<div class="line"><a name="l03205"></a><span class="lineno"> 3205</span>&#160;                    *it.skipfield_pointer = 1; <span class="comment">// solo skipped node</span></div>
<div class="line"><a name="l03206"></a><span class="lineno"> 3206</span>&#160;                    <span class="keyword">const</span> skipfield_type index = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(it.element_pointer - it.group_pointer-&gt;elements);</div>
<div class="line"><a name="l03207"></a><span class="lineno"> 3207</span>&#160; </div>
<div class="line"><a name="l03208"></a><span class="lineno"> 3208</span>&#160;                    <span class="keywordflow">if</span> (it.group_pointer-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. if this group already has some erased elements</span></div>
<div class="line"><a name="l03209"></a><span class="lineno"> 3209</span>&#160;                    {</div>
<div class="line"><a name="l03210"></a><span class="lineno"> 3210</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.group_pointer-&gt;elements + it.group_pointer-&gt;free_list_head) + 1) = index; <span class="comment">// set prev free list head&#39;s &#39;next index&#39; number to the index of the current element</span></div>
<div class="line"><a name="l03211"></a><span class="lineno"> 3211</span>&#160;                    }</div>
<div class="line"><a name="l03212"></a><span class="lineno"> 3212</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03213"></a><span class="lineno"> 3213</span>&#160;                    {</div>
<div class="line"><a name="l03214"></a><span class="lineno"> 3214</span>&#160;                        it.group_pointer-&gt;erasures_list_next_group = groups_with_erasures_list_head; <span class="comment">// add it to the groups-with-erasures free list</span></div>
<div class="line"><a name="l03215"></a><span class="lineno"> 3215</span>&#160;                        groups_with_erasures_list_head = it.group_pointer;</div>
<div class="line"><a name="l03216"></a><span class="lineno"> 3216</span>&#160;                    }</div>
<div class="line"><a name="l03217"></a><span class="lineno"> 3217</span>&#160; </div>
<div class="line"><a name="l03218"></a><span class="lineno"> 3218</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.element_pointer)) = it.group_pointer-&gt;free_list_head;</div>
<div class="line"><a name="l03219"></a><span class="lineno"> 3219</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.element_pointer) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l03220"></a><span class="lineno"> 3220</span>&#160;                    it.group_pointer-&gt;free_list_head = index;</div>
<div class="line"><a name="l03221"></a><span class="lineno"> 3221</span>&#160;                }</div>
<div class="line"><a name="l03222"></a><span class="lineno"> 3222</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prev_skipfield &amp; (!after_skipfield)) <span class="comment">// previous erased consecutive elements, none following</span></div>
<div class="line"><a name="l03223"></a><span class="lineno"> 3223</span>&#160;                {</div>
<div class="line"><a name="l03224"></a><span class="lineno"> 3224</span>&#160;                    *(it.skipfield_pointer - *(it.skipfield_pointer - 1)) = *it.skipfield_pointer = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(*(it.skipfield_pointer - 1) + 1);</div>
<div class="line"><a name="l03225"></a><span class="lineno"> 3225</span>&#160;                }</div>
<div class="line"><a name="l03226"></a><span class="lineno"> 3226</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((!prev_skipfield) &amp; after_skipfield) <span class="comment">// following erased consecutive elements, none preceding</span></div>
<div class="line"><a name="l03227"></a><span class="lineno"> 3227</span>&#160;                {</div>
<div class="line"><a name="l03228"></a><span class="lineno"> 3228</span>&#160;                    <span class="keyword">const</span> skipfield_type following_value = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(*(it.skipfield_pointer + 1) + 1);</div>
<div class="line"><a name="l03229"></a><span class="lineno"> 3229</span>&#160;                    *(it.skipfield_pointer + following_value - 1) = *(it.skipfield_pointer) = following_value;</div>
<div class="line"><a name="l03230"></a><span class="lineno"> 3230</span>&#160; </div>
<div class="line"><a name="l03231"></a><span class="lineno"> 3231</span>&#160;                    <span class="keyword">const</span> skipfield_type following_previous = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.element_pointer + 1));</div>
<div class="line"><a name="l03232"></a><span class="lineno"> 3232</span>&#160;                    <span class="keyword">const</span> skipfield_type following_next = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.element_pointer + 1) + 1);</div>
<div class="line"><a name="l03233"></a><span class="lineno"> 3233</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.element_pointer)) = following_previous;</div>
<div class="line"><a name="l03234"></a><span class="lineno"> 3234</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.element_pointer) + 1) = following_next;</div>
<div class="line"><a name="l03235"></a><span class="lineno"> 3235</span>&#160; </div>
<div class="line"><a name="l03236"></a><span class="lineno"> 3236</span>&#160;                    <span class="keyword">const</span> skipfield_type index = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(it.element_pointer - it.group_pointer-&gt;elements);</div>
<div class="line"><a name="l03237"></a><span class="lineno"> 3237</span>&#160; </div>
<div class="line"><a name="l03238"></a><span class="lineno"> 3238</span>&#160;                    <span class="keywordflow">if</span> (following_previous != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03239"></a><span class="lineno"> 3239</span>&#160;                    {</div>
<div class="line"><a name="l03240"></a><span class="lineno"> 3240</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.group_pointer-&gt;elements + following_previous) + 1) = index; <span class="comment">// Set next index of previous free list node to this node&#39;s &#39;next&#39; index</span></div>
<div class="line"><a name="l03241"></a><span class="lineno"> 3241</span>&#160;                    }</div>
<div class="line"><a name="l03242"></a><span class="lineno"> 3242</span>&#160; </div>
<div class="line"><a name="l03243"></a><span class="lineno"> 3243</span>&#160;                    <span class="keywordflow">if</span> (following_next != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03244"></a><span class="lineno"> 3244</span>&#160;                    {</div>
<div class="line"><a name="l03245"></a><span class="lineno"> 3245</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.group_pointer-&gt;elements + following_next)) = index;   <span class="comment">// Set previous index of next free list node to this node&#39;s &#39;previous&#39; index</span></div>
<div class="line"><a name="l03246"></a><span class="lineno"> 3246</span>&#160;                    }</div>
<div class="line"><a name="l03247"></a><span class="lineno"> 3247</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03248"></a><span class="lineno"> 3248</span>&#160;                    {</div>
<div class="line"><a name="l03249"></a><span class="lineno"> 3249</span>&#160;                        it.group_pointer-&gt;free_list_head = index;</div>
<div class="line"><a name="l03250"></a><span class="lineno"> 3250</span>&#160;                    }</div>
<div class="line"><a name="l03251"></a><span class="lineno"> 3251</span>&#160; </div>
<div class="line"><a name="l03252"></a><span class="lineno"> 3252</span>&#160;                    update_value = following_value;</div>
<div class="line"><a name="l03253"></a><span class="lineno"> 3253</span>&#160;                }</div>
<div class="line"><a name="l03254"></a><span class="lineno"> 3254</span>&#160;                <span class="keywordflow">else</span> <span class="comment">// both preceding and following consecutive erased elements - erased element is between two skipblocks</span></div>
<div class="line"><a name="l03255"></a><span class="lineno"> 3255</span>&#160;                {</div>
<div class="line"><a name="l03256"></a><span class="lineno"> 3256</span>&#160;                    <span class="keyword">const</span> skipfield_type preceding_value = *(it.skipfield_pointer - 1);</div>
<div class="line"><a name="l03257"></a><span class="lineno"> 3257</span>&#160;                    <span class="keyword">const</span> skipfield_type following_value = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(*(it.skipfield_pointer + 1) + 1);</div>
<div class="line"><a name="l03258"></a><span class="lineno"> 3258</span>&#160; </div>
<div class="line"><a name="l03259"></a><span class="lineno"> 3259</span>&#160;                    <span class="comment">// Join the skipblocks</span></div>
<div class="line"><a name="l03260"></a><span class="lineno"> 3260</span>&#160;                    *(it.skipfield_pointer - preceding_value) = *(it.skipfield_pointer + following_value - 1) = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(preceding_value + following_value);</div>
<div class="line"><a name="l03261"></a><span class="lineno"> 3261</span>&#160; </div>
<div class="line"><a name="l03262"></a><span class="lineno"> 3262</span>&#160;                    <span class="comment">// Remove the following skipblock&#39;s entry from the free list</span></div>
<div class="line"><a name="l03263"></a><span class="lineno"> 3263</span>&#160;                    <span class="keyword">const</span> skipfield_type following_previous = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.element_pointer + 1));</div>
<div class="line"><a name="l03264"></a><span class="lineno"> 3264</span>&#160;                    <span class="keyword">const</span> skipfield_type following_next = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.element_pointer + 1) + 1);</div>
<div class="line"><a name="l03265"></a><span class="lineno"> 3265</span>&#160; </div>
<div class="line"><a name="l03266"></a><span class="lineno"> 3266</span>&#160;                    <span class="keywordflow">if</span> (following_previous != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03267"></a><span class="lineno"> 3267</span>&#160;                    {</div>
<div class="line"><a name="l03268"></a><span class="lineno"> 3268</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.group_pointer-&gt;elements + following_previous) + 1) = following_next; <span class="comment">// Set next index of previous free list node to this node&#39;s &#39;next&#39; index</span></div>
<div class="line"><a name="l03269"></a><span class="lineno"> 3269</span>&#160;                    }</div>
<div class="line"><a name="l03270"></a><span class="lineno"> 3270</span>&#160; </div>
<div class="line"><a name="l03271"></a><span class="lineno"> 3271</span>&#160;                    <span class="keywordflow">if</span> (following_next != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03272"></a><span class="lineno"> 3272</span>&#160;                    {</div>
<div class="line"><a name="l03273"></a><span class="lineno"> 3273</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(it.group_pointer-&gt;elements + following_next)) = following_previous; <span class="comment">// Set previous index of next free list node to this node&#39;s &#39;previous&#39; index</span></div>
<div class="line"><a name="l03274"></a><span class="lineno"> 3274</span>&#160;                    }</div>
<div class="line"><a name="l03275"></a><span class="lineno"> 3275</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03276"></a><span class="lineno"> 3276</span>&#160;                    {</div>
<div class="line"><a name="l03277"></a><span class="lineno"> 3277</span>&#160;                        it.group_pointer-&gt;free_list_head = following_previous;</div>
<div class="line"><a name="l03278"></a><span class="lineno"> 3278</span>&#160;                    }</div>
<div class="line"><a name="l03279"></a><span class="lineno"> 3279</span>&#160; </div>
<div class="line"><a name="l03280"></a><span class="lineno"> 3280</span>&#160;                    update_value = following_value;</div>
<div class="line"><a name="l03281"></a><span class="lineno"> 3281</span>&#160;                }</div>
<div class="line"><a name="l03282"></a><span class="lineno"> 3282</span>&#160; </div>
<div class="line"><a name="l03283"></a><span class="lineno"> 3283</span>&#160;                iterator return_iterator(it.group_pointer, it.element_pointer + update_value, it.skipfield_pointer + update_value);</div>
<div class="line"><a name="l03284"></a><span class="lineno"> 3284</span>&#160; </div>
<div class="line"><a name="l03285"></a><span class="lineno"> 3285</span>&#160;                <span class="keywordflow">if</span> (return_iterator.element_pointer == it.group_pointer-&gt;last_endpoint &amp;&amp; it.group_pointer-&gt;next_group != NULL)</div>
<div class="line"><a name="l03286"></a><span class="lineno"> 3286</span>&#160;                {</div>
<div class="line"><a name="l03287"></a><span class="lineno"> 3287</span>&#160;                    return_iterator.group_pointer = it.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l03288"></a><span class="lineno"> 3288</span>&#160;                    <span class="keyword">const</span> aligned_pointer_type elements = return_iterator.group_pointer-&gt;elements;</div>
<div class="line"><a name="l03289"></a><span class="lineno"> 3289</span>&#160;                    <span class="keyword">const</span> skipfield_pointer_type skipfield = return_iterator.group_pointer-&gt;skipfield;</div>
<div class="line"><a name="l03290"></a><span class="lineno"> 3290</span>&#160;                    <span class="keyword">const</span> skipfield_type skip = *skipfield;</div>
<div class="line"><a name="l03291"></a><span class="lineno"> 3291</span>&#160;                    return_iterator.element_pointer = elements + skip;</div>
<div class="line"><a name="l03292"></a><span class="lineno"> 3292</span>&#160;                    return_iterator.skipfield_pointer = skipfield + skip;</div>
<div class="line"><a name="l03293"></a><span class="lineno"> 3293</span>&#160;                }</div>
<div class="line"><a name="l03294"></a><span class="lineno"> 3294</span>&#160; </div>
<div class="line"><a name="l03295"></a><span class="lineno"> 3295</span>&#160;                <span class="keywordflow">if</span> (it.element_pointer == begin_iterator.element_pointer) <span class="comment">// If original iterator was first element in colony, update it&#39;s value with the next non-erased element:</span></div>
<div class="line"><a name="l03296"></a><span class="lineno"> 3296</span>&#160;                {</div>
<div class="line"><a name="l03297"></a><span class="lineno"> 3297</span>&#160;                    begin_iterator = return_iterator;</div>
<div class="line"><a name="l03298"></a><span class="lineno"> 3298</span>&#160;                }</div>
<div class="line"><a name="l03299"></a><span class="lineno"> 3299</span>&#160; </div>
<div class="line"><a name="l03300"></a><span class="lineno"> 3300</span>&#160;                <span class="keywordflow">return</span> return_iterator;</div>
<div class="line"><a name="l03301"></a><span class="lineno"> 3301</span>&#160;            }</div>
<div class="line"><a name="l03302"></a><span class="lineno"> 3302</span>&#160; </div>
<div class="line"><a name="l03303"></a><span class="lineno"> 3303</span>&#160;            <span class="comment">// else: group is empty, consolidate groups</span></div>
<div class="line"><a name="l03304"></a><span class="lineno"> 3304</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">bool</span> in_back_block = (it.group_pointer-&gt;next_group == NULL), in_front_block = (it.group_pointer == begin_iterator.group_pointer);</div>
<div class="line"><a name="l03305"></a><span class="lineno"> 3305</span>&#160; </div>
<div class="line"><a name="l03306"></a><span class="lineno"> 3306</span>&#160;            <span class="keywordflow">if</span> (in_back_block &amp; in_front_block) <span class="comment">// ie. only group in colony</span></div>
<div class="line"><a name="l03307"></a><span class="lineno"> 3307</span>&#160;            {</div>
<div class="line"><a name="l03308"></a><span class="lineno"> 3308</span>&#160;                <span class="comment">// Reset skipfield and free list rather than clearing - leads to fewer allocations/deallocations:</span></div>
<div class="line"><a name="l03309"></a><span class="lineno"> 3309</span>&#160;                reset_only_group_left(it.group_pointer);</div>
<div class="line"><a name="l03310"></a><span class="lineno"> 3310</span>&#160;                <span class="keywordflow">return</span> end_iterator;</div>
<div class="line"><a name="l03311"></a><span class="lineno"> 3311</span>&#160;            }</div>
<div class="line"><a name="l03312"></a><span class="lineno"> 3312</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((!in_back_block) &amp; in_front_block) <span class="comment">// ie. Remove first group, change first group to next group</span></div>
<div class="line"><a name="l03313"></a><span class="lineno"> 3313</span>&#160;            {</div>
<div class="line"><a name="l03314"></a><span class="lineno"> 3314</span>&#160;                it.group_pointer-&gt;next_group-&gt;previous_group = NULL; <span class="comment">// Cut off this group from the chain</span></div>
<div class="line"><a name="l03315"></a><span class="lineno"> 3315</span>&#160;                begin_iterator.group_pointer = it.group_pointer-&gt;next_group; <span class="comment">// Make the next group the first group</span></div>
<div class="line"><a name="l03316"></a><span class="lineno"> 3316</span>&#160; </div>
<div class="line"><a name="l03317"></a><span class="lineno"> 3317</span>&#160;                update_subsequent_group_numbers(begin_iterator.group_pointer);</div>
<div class="line"><a name="l03318"></a><span class="lineno"> 3318</span>&#160; </div>
<div class="line"><a name="l03319"></a><span class="lineno"> 3319</span>&#160;                <span class="keywordflow">if</span> (it.group_pointer-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// Erasures present within the group, ie. was part of the linked list of groups with erasures.</span></div>
<div class="line"><a name="l03320"></a><span class="lineno"> 3320</span>&#160;                {</div>
<div class="line"><a name="l03321"></a><span class="lineno"> 3321</span>&#160;                    remove_from_groups_with_erasures_list(it.group_pointer);</div>
<div class="line"><a name="l03322"></a><span class="lineno"> 3322</span>&#160;                }</div>
<div class="line"><a name="l03323"></a><span class="lineno"> 3323</span>&#160; </div>
<div class="line"><a name="l03324"></a><span class="lineno"> 3324</span>&#160;                total_capacity -= it.group_pointer-&gt;capacity;</div>
<div class="line"><a name="l03325"></a><span class="lineno"> 3325</span>&#160;                deallocate_group(it.group_pointer);</div>
<div class="line"><a name="l03326"></a><span class="lineno"> 3326</span>&#160; </div>
<div class="line"><a name="l03327"></a><span class="lineno"> 3327</span>&#160;                <span class="comment">// note: end iterator only needs to be changed if the deleted group was the final group in the chain ie. not in this case</span></div>
<div class="line"><a name="l03328"></a><span class="lineno"> 3328</span>&#160;                begin_iterator.element_pointer = begin_iterator.group_pointer-&gt;elements + *(begin_iterator.group_pointer-&gt;skipfield); <span class="comment">// If the beginning index has been erased (ie. skipfield != 0), skip to next non-erased element</span></div>
<div class="line"><a name="l03329"></a><span class="lineno"> 3329</span>&#160;                begin_iterator.skipfield_pointer = begin_iterator.group_pointer-&gt;skipfield + *(begin_iterator.group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l03330"></a><span class="lineno"> 3330</span>&#160; </div>
<div class="line"><a name="l03331"></a><span class="lineno"> 3331</span>&#160;                <span class="keywordflow">return</span> begin_iterator;</div>
<div class="line"><a name="l03332"></a><span class="lineno"> 3332</span>&#160;            }</div>
<div class="line"><a name="l03333"></a><span class="lineno"> 3333</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(in_back_block | in_front_block)) <span class="comment">// this is a non-first group but not final group in chain: delete the group, then link previous group to the next group in the chain:</span></div>
<div class="line"><a name="l03334"></a><span class="lineno"> 3334</span>&#160;            {</div>
<div class="line"><a name="l03335"></a><span class="lineno"> 3335</span>&#160;                it.group_pointer-&gt;next_group-&gt;previous_group = it.group_pointer-&gt;previous_group;</div>
<div class="line"><a name="l03336"></a><span class="lineno"> 3336</span>&#160;                <span class="keyword">const</span> group_pointer_type return_group = it.group_pointer-&gt;previous_group-&gt;next_group = it.group_pointer-&gt;next_group; <span class="comment">// close the chain, removing this group from it</span></div>
<div class="line"><a name="l03337"></a><span class="lineno"> 3337</span>&#160; </div>
<div class="line"><a name="l03338"></a><span class="lineno"> 3338</span>&#160;                update_subsequent_group_numbers(return_group);</div>
<div class="line"><a name="l03339"></a><span class="lineno"> 3339</span>&#160; </div>
<div class="line"><a name="l03340"></a><span class="lineno"> 3340</span>&#160;                <span class="keywordflow">if</span> (it.group_pointer-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03341"></a><span class="lineno"> 3341</span>&#160;                {</div>
<div class="line"><a name="l03342"></a><span class="lineno"> 3342</span>&#160;                    remove_from_groups_with_erasures_list(it.group_pointer);</div>
<div class="line"><a name="l03343"></a><span class="lineno"> 3343</span>&#160;                }</div>
<div class="line"><a name="l03344"></a><span class="lineno"> 3344</span>&#160; </div>
<div class="line"><a name="l03345"></a><span class="lineno"> 3345</span>&#160;                <span class="keywordflow">if</span> (it.group_pointer-&gt;next_group != end_iterator.group_pointer)</div>
<div class="line"><a name="l03346"></a><span class="lineno"> 3346</span>&#160;                {</div>
<div class="line"><a name="l03347"></a><span class="lineno"> 3347</span>&#160;                    total_capacity -= it.group_pointer-&gt;capacity;</div>
<div class="line"><a name="l03348"></a><span class="lineno"> 3348</span>&#160;                    deallocate_group(it.group_pointer);</div>
<div class="line"><a name="l03349"></a><span class="lineno"> 3349</span>&#160;                }</div>
<div class="line"><a name="l03350"></a><span class="lineno"> 3350</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l03351"></a><span class="lineno"> 3351</span>&#160;                {</div>
<div class="line"><a name="l03352"></a><span class="lineno"> 3352</span>&#160;                    add_group_to_unused_groups_list(it.group_pointer);</div>
<div class="line"><a name="l03353"></a><span class="lineno"> 3353</span>&#160;                }</div>
<div class="line"><a name="l03354"></a><span class="lineno"> 3354</span>&#160; </div>
<div class="line"><a name="l03355"></a><span class="lineno"> 3355</span>&#160;                <span class="comment">// Return next group&#39;s first non-erased element:</span></div>
<div class="line"><a name="l03356"></a><span class="lineno"> 3356</span>&#160;                <span class="keywordflow">return</span> iterator(return_group, return_group-&gt;elements + *(return_group-&gt;skipfield), return_group-&gt;skipfield + *(return_group-&gt;skipfield));</div>
<div class="line"><a name="l03357"></a><span class="lineno"> 3357</span>&#160;            }</div>
<div class="line"><a name="l03358"></a><span class="lineno"> 3358</span>&#160;            <span class="keywordflow">else</span> <span class="comment">// this is a non-first group and the final group in the chain</span></div>
<div class="line"><a name="l03359"></a><span class="lineno"> 3359</span>&#160;            {</div>
<div class="line"><a name="l03360"></a><span class="lineno"> 3360</span>&#160;                <span class="keywordflow">if</span> (it.group_pointer-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03361"></a><span class="lineno"> 3361</span>&#160;                {</div>
<div class="line"><a name="l03362"></a><span class="lineno"> 3362</span>&#160;                    remove_from_groups_with_erasures_list(it.group_pointer);</div>
<div class="line"><a name="l03363"></a><span class="lineno"> 3363</span>&#160;                }</div>
<div class="line"><a name="l03364"></a><span class="lineno"> 3364</span>&#160; </div>
<div class="line"><a name="l03365"></a><span class="lineno"> 3365</span>&#160;                it.group_pointer-&gt;previous_group-&gt;next_group = NULL;</div>
<div class="line"><a name="l03366"></a><span class="lineno"> 3366</span>&#160;                end_iterator.group_pointer = it.group_pointer-&gt;previous_group; <span class="comment">// end iterator needs to be changed as element supplied was the back element of the colony</span></div>
<div class="line"><a name="l03367"></a><span class="lineno"> 3367</span>&#160;                end_iterator.element_pointer = <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l03368"></a><span class="lineno"> 3368</span>&#160;                end_iterator.skipfield_pointer = end_iterator.group_pointer-&gt;skipfield + end_iterator.group_pointer-&gt;capacity;</div>
<div class="line"><a name="l03369"></a><span class="lineno"> 3369</span>&#160; </div>
<div class="line"><a name="l03370"></a><span class="lineno"> 3370</span>&#160;                add_group_to_unused_groups_list(it.group_pointer);</div>
<div class="line"><a name="l03371"></a><span class="lineno"> 3371</span>&#160; </div>
<div class="line"><a name="l03372"></a><span class="lineno"> 3372</span>&#160;                <span class="keywordflow">return</span> end_iterator;</div>
<div class="line"><a name="l03373"></a><span class="lineno"> 3373</span>&#160;            }</div>
<div class="line"><a name="l03374"></a><span class="lineno"> 3374</span>&#160;        }</div>
<div class="line"><a name="l03375"></a><span class="lineno"> 3375</span>&#160; </div>
<div class="line"><a name="l03376"></a><span class="lineno"> 3376</span>&#160; </div>
<div class="line"><a name="l03377"></a><span class="lineno"> 3377</span>&#160; </div>
<div class="line"><a name="l03378"></a><span class="lineno"> 3378</span>&#160;        <span class="comment">// Range erase:</span></div>
<div class="line"><a name="l03379"></a><span class="lineno"> 3379</span>&#160; </div>
<div class="line"><a name="l03380"></a><span class="lineno"> 3380</span>&#160;        iterator erase(<span class="keyword">const</span> const_iterator iterator1, <span class="keyword">const</span> const_iterator iterator2)  <span class="comment">// if uninitialized/invalid iterators supplied, function could generate an exception. If iterator1 &gt; iterator2, behaviour is undefined.</span></div>
<div class="line"><a name="l03381"></a><span class="lineno"> 3381</span>&#160;        {</div>
<div class="line"><a name="l03382"></a><span class="lineno"> 3382</span>&#160;            assert(iterator1 &lt;= iterator2);</div>
<div class="line"><a name="l03383"></a><span class="lineno"> 3383</span>&#160; </div>
<div class="line"><a name="l03384"></a><span class="lineno"> 3384</span>&#160;            const_iterator current = iterator1;</div>
<div class="line"><a name="l03385"></a><span class="lineno"> 3385</span>&#160; </div>
<div class="line"><a name="l03386"></a><span class="lineno"> 3386</span>&#160;            <span class="keywordflow">if</span> (current.group_pointer != iterator2.group_pointer) <span class="comment">// ie. if start and end iterators are in separate groups</span></div>
<div class="line"><a name="l03387"></a><span class="lineno"> 3387</span>&#160;            {</div>
<div class="line"><a name="l03388"></a><span class="lineno"> 3388</span>&#160;                <span class="keywordflow">if</span> (current.element_pointer != current.group_pointer-&gt;elements + *(current.group_pointer-&gt;skipfield)) <span class="comment">// if iterator1 is not the first non-erased element in it&#39;s group - most common case</span></div>
<div class="line"><a name="l03389"></a><span class="lineno"> 3389</span>&#160;                {</div>
<div class="line"><a name="l03390"></a><span class="lineno"> 3390</span>&#160;                    size_type number_of_group_erasures = 0;</div>
<div class="line"><a name="l03391"></a><span class="lineno"> 3391</span>&#160; </div>
<div class="line"><a name="l03392"></a><span class="lineno"> 3392</span>&#160;                    <span class="comment">// Now update skipfield:</span></div>
<div class="line"><a name="l03393"></a><span class="lineno"> 3393</span>&#160;                    <span class="keyword">const</span> aligned_pointer_type end = iterator1.group_pointer-&gt;last_endpoint;</div>
<div class="line"><a name="l03394"></a><span class="lineno"> 3394</span>&#160; </div>
<div class="line"><a name="l03395"></a><span class="lineno"> 3395</span>&#160;                    <span class="comment">// Schema: first erase all non-erased elements until end of group &amp; remove all skipblocks post-iterator1 from the free_list. Then, either update preceding skipblock or create new one:</span></div>
<div class="line"><a name="l03396"></a><span class="lineno"> 3396</span>&#160; </div>
<div class="line"><a name="l03397"></a><span class="lineno"> 3397</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT // if trivially-destructible, and C++11 or higher, and no erasures in group, skip while loop below and just jump straight to the location</span></div>
<div class="line"><a name="l03398"></a><span class="lineno"> 3398</span>&#160;                    <span class="keywordflow">if</span> (std::is_trivially_destructible&lt;element_type&gt;::value &amp;&amp; current.group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03399"></a><span class="lineno"> 3399</span>&#160;                    {</div>
<div class="line"><a name="l03400"></a><span class="lineno"> 3400</span>&#160;                        number_of_group_erasures += <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(end - current.element_pointer);</div>
<div class="line"><a name="l03401"></a><span class="lineno"> 3401</span>&#160;                    }</div>
<div class="line"><a name="l03402"></a><span class="lineno"> 3402</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03403"></a><span class="lineno"> 3403</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03404"></a><span class="lineno"> 3404</span>&#160;                    {</div>
<div class="line"><a name="l03405"></a><span class="lineno"> 3405</span>&#160;                        <span class="keywordflow">while</span> (current.element_pointer != end)</div>
<div class="line"><a name="l03406"></a><span class="lineno"> 3406</span>&#160;                        {</div>
<div class="line"><a name="l03407"></a><span class="lineno"> 3407</span>&#160;                            <span class="keywordflow">if</span> (*current.skipfield_pointer == 0)</div>
<div class="line"><a name="l03408"></a><span class="lineno"> 3408</span>&#160;                            {</div>
<div class="line"><a name="l03409"></a><span class="lineno"> 3409</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l03410"></a><span class="lineno"> 3410</span>&#160;                                <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_trivially_destructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l03411"></a><span class="lineno"> 3411</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03412"></a><span class="lineno"> 3412</span>&#160;                                {</div>
<div class="line"><a name="l03413"></a><span class="lineno"> 3413</span>&#160;                                    PLF_DESTROY(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current.element_pointer)); <span class="comment">// Destruct element</span></div>
<div class="line"><a name="l03414"></a><span class="lineno"> 3414</span>&#160;                                }</div>
<div class="line"><a name="l03415"></a><span class="lineno"> 3415</span>&#160; </div>
<div class="line"><a name="l03416"></a><span class="lineno"> 3416</span>&#160;                                ++number_of_group_erasures;</div>
<div class="line"><a name="l03417"></a><span class="lineno"> 3417</span>&#160;                                ++current.element_pointer;</div>
<div class="line"><a name="l03418"></a><span class="lineno"> 3418</span>&#160;                                ++current.skipfield_pointer;</div>
<div class="line"><a name="l03419"></a><span class="lineno"> 3419</span>&#160;                            }</div>
<div class="line"><a name="l03420"></a><span class="lineno"> 3420</span>&#160;                            <span class="keywordflow">else</span> <span class="comment">// remove skipblock from group:</span></div>
<div class="line"><a name="l03421"></a><span class="lineno"> 3421</span>&#160;                            {</div>
<div class="line"><a name="l03422"></a><span class="lineno"> 3422</span>&#160;                                <span class="keyword">const</span> skipfield_type prev_free_list_index = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.element_pointer));</div>
<div class="line"><a name="l03423"></a><span class="lineno"> 3423</span>&#160;                                <span class="keyword">const</span> skipfield_type next_free_list_index = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.element_pointer) + 1);</div>
<div class="line"><a name="l03424"></a><span class="lineno"> 3424</span>&#160; </div>
<div class="line"><a name="l03425"></a><span class="lineno"> 3425</span>&#160;                                current.element_pointer += *(current.skipfield_pointer);</div>
<div class="line"><a name="l03426"></a><span class="lineno"> 3426</span>&#160;                                current.skipfield_pointer += *(current.skipfield_pointer);</div>
<div class="line"><a name="l03427"></a><span class="lineno"> 3427</span>&#160; </div>
<div class="line"><a name="l03428"></a><span class="lineno"> 3428</span>&#160;                                <span class="keywordflow">if</span> (next_free_list_index == std::numeric_limits&lt;skipfield_type&gt;::max() &amp;&amp; prev_free_list_index == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// if this is the last skipblock in the free list</span></div>
<div class="line"><a name="l03429"></a><span class="lineno"> 3429</span>&#160;                                {</div>
<div class="line"><a name="l03430"></a><span class="lineno"> 3430</span>&#160;                                    remove_from_groups_with_erasures_list(iterator1.group_pointer); <span class="comment">// remove group from list of free-list groups - will be added back in down below, but not worth optimizing for</span></div>
<div class="line"><a name="l03431"></a><span class="lineno"> 3431</span>&#160;                                    iterator1.group_pointer-&gt;free_list_head = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l03432"></a><span class="lineno"> 3432</span>&#160;                                    number_of_group_erasures += <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(end - current.element_pointer);</div>
<div class="line"><a name="l03433"></a><span class="lineno"> 3433</span>&#160; </div>
<div class="line"><a name="l03434"></a><span class="lineno"> 3434</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l03435"></a><span class="lineno"> 3435</span>&#160;                                    <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_trivially_destructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l03436"></a><span class="lineno"> 3436</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03437"></a><span class="lineno"> 3437</span>&#160;                                    {</div>
<div class="line"><a name="l03438"></a><span class="lineno"> 3438</span>&#160;                                        <span class="keywordflow">while</span> (current.element_pointer != end) <span class="comment">// miniloop - avoid checking skipfield for rest of elements in group, as there are no more skipped elements now</span></div>
<div class="line"><a name="l03439"></a><span class="lineno"> 3439</span>&#160;                                        {</div>
<div class="line"><a name="l03440"></a><span class="lineno"> 3440</span>&#160;                                            PLF_DESTROY(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current.element_pointer++)); <span class="comment">// Destruct element</span></div>
<div class="line"><a name="l03441"></a><span class="lineno"> 3441</span>&#160;                                        }</div>
<div class="line"><a name="l03442"></a><span class="lineno"> 3442</span>&#160;                                    }</div>
<div class="line"><a name="l03443"></a><span class="lineno"> 3443</span>&#160; </div>
<div class="line"><a name="l03444"></a><span class="lineno"> 3444</span>&#160;                                    <span class="keywordflow">break</span>; <span class="comment">// end overall while loop</span></div>
<div class="line"><a name="l03445"></a><span class="lineno"> 3445</span>&#160;                                }</div>
<div class="line"><a name="l03446"></a><span class="lineno"> 3446</span>&#160;                                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (next_free_list_index == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// if this is the head of the free list</span></div>
<div class="line"><a name="l03447"></a><span class="lineno"> 3447</span>&#160;                                {</div>
<div class="line"><a name="l03448"></a><span class="lineno"> 3448</span>&#160;                                    current.group_pointer-&gt;free_list_head = prev_free_list_index; <span class="comment">// make free list head equal to next free list node</span></div>
<div class="line"><a name="l03449"></a><span class="lineno"> 3449</span>&#160;                                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.group_pointer-&gt;elements + prev_free_list_index) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l03450"></a><span class="lineno"> 3450</span>&#160;                                }</div>
<div class="line"><a name="l03451"></a><span class="lineno"> 3451</span>&#160;                                <span class="keywordflow">else</span> <span class="comment">// either a tail or middle free list node</span></div>
<div class="line"><a name="l03452"></a><span class="lineno"> 3452</span>&#160;                                {</div>
<div class="line"><a name="l03453"></a><span class="lineno"> 3453</span>&#160;                                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.group_pointer-&gt;elements + next_free_list_index)) = prev_free_list_index;</div>
<div class="line"><a name="l03454"></a><span class="lineno"> 3454</span>&#160; </div>
<div class="line"><a name="l03455"></a><span class="lineno"> 3455</span>&#160;                                    <span class="keywordflow">if</span> (prev_free_list_index != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. not the tail free list node</span></div>
<div class="line"><a name="l03456"></a><span class="lineno"> 3456</span>&#160;                                    {</div>
<div class="line"><a name="l03457"></a><span class="lineno"> 3457</span>&#160;                                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.group_pointer-&gt;elements + prev_free_list_index) + 1) = next_free_list_index;</div>
<div class="line"><a name="l03458"></a><span class="lineno"> 3458</span>&#160;                                    }</div>
<div class="line"><a name="l03459"></a><span class="lineno"> 3459</span>&#160;                                }</div>
<div class="line"><a name="l03460"></a><span class="lineno"> 3460</span>&#160;                            }</div>
<div class="line"><a name="l03461"></a><span class="lineno"> 3461</span>&#160;                        }</div>
<div class="line"><a name="l03462"></a><span class="lineno"> 3462</span>&#160;                    }</div>
<div class="line"><a name="l03463"></a><span class="lineno"> 3463</span>&#160; </div>
<div class="line"><a name="l03464"></a><span class="lineno"> 3464</span>&#160; </div>
<div class="line"><a name="l03465"></a><span class="lineno"> 3465</span>&#160;                    <span class="keyword">const</span> skipfield_type previous_node_value = *(iterator1.skipfield_pointer - 1);</div>
<div class="line"><a name="l03466"></a><span class="lineno"> 3466</span>&#160;                    <span class="keyword">const</span> skipfield_type distance_to_end = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(end - iterator1.element_pointer);</div>
<div class="line"><a name="l03467"></a><span class="lineno"> 3467</span>&#160; </div>
<div class="line"><a name="l03468"></a><span class="lineno"> 3468</span>&#160; </div>
<div class="line"><a name="l03469"></a><span class="lineno"> 3469</span>&#160;                    <span class="keywordflow">if</span> (previous_node_value == 0) <span class="comment">// no previous skipblock</span></div>
<div class="line"><a name="l03470"></a><span class="lineno"> 3470</span>&#160;                    {</div>
<div class="line"><a name="l03471"></a><span class="lineno"> 3471</span>&#160;                        *iterator1.skipfield_pointer = distance_to_end; <span class="comment">// set start node value</span></div>
<div class="line"><a name="l03472"></a><span class="lineno"> 3472</span>&#160;                        *(iterator1.skipfield_pointer + distance_to_end - 1) = distance_to_end; <span class="comment">// set end node value</span></div>
<div class="line"><a name="l03473"></a><span class="lineno"> 3473</span>&#160; </div>
<div class="line"><a name="l03474"></a><span class="lineno"> 3474</span>&#160;                        <span class="keyword">const</span> skipfield_type index = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(iterator1.element_pointer - iterator1.group_pointer-&gt;elements);</div>
<div class="line"><a name="l03475"></a><span class="lineno"> 3475</span>&#160; </div>
<div class="line"><a name="l03476"></a><span class="lineno"> 3476</span>&#160;                        <span class="keywordflow">if</span> (iterator1.group_pointer-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. if this group already has some erased elements</span></div>
<div class="line"><a name="l03477"></a><span class="lineno"> 3477</span>&#160;                        {</div>
<div class="line"><a name="l03478"></a><span class="lineno"> 3478</span>&#160;                            *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(iterator1.group_pointer-&gt;elements + iterator1.group_pointer-&gt;free_list_head) + 1) = index; <span class="comment">// set prev free list head&#39;s &#39;next index&#39; number to the index of the iterator1 element</span></div>
<div class="line"><a name="l03479"></a><span class="lineno"> 3479</span>&#160;                        }</div>
<div class="line"><a name="l03480"></a><span class="lineno"> 3480</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l03481"></a><span class="lineno"> 3481</span>&#160;                        {</div>
<div class="line"><a name="l03482"></a><span class="lineno"> 3482</span>&#160;                            iterator1.group_pointer-&gt;erasures_list_next_group = groups_with_erasures_list_head; <span class="comment">// add it to the groups-with-erasures free list</span></div>
<div class="line"><a name="l03483"></a><span class="lineno"> 3483</span>&#160;                            groups_with_erasures_list_head = iterator1.group_pointer;</div>
<div class="line"><a name="l03484"></a><span class="lineno"> 3484</span>&#160;                        }</div>
<div class="line"><a name="l03485"></a><span class="lineno"> 3485</span>&#160; </div>
<div class="line"><a name="l03486"></a><span class="lineno"> 3486</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(iterator1.element_pointer)) = iterator1.group_pointer-&gt;free_list_head;</div>
<div class="line"><a name="l03487"></a><span class="lineno"> 3487</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(iterator1.element_pointer) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l03488"></a><span class="lineno"> 3488</span>&#160;                        iterator1.group_pointer-&gt;free_list_head = index;</div>
<div class="line"><a name="l03489"></a><span class="lineno"> 3489</span>&#160;                    }</div>
<div class="line"><a name="l03490"></a><span class="lineno"> 3490</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03491"></a><span class="lineno"> 3491</span>&#160;                    { <span class="comment">// update previous skipblock, no need to update free list:</span></div>
<div class="line"><a name="l03492"></a><span class="lineno"> 3492</span>&#160;                        *(iterator1.skipfield_pointer - previous_node_value) = *(iterator1.skipfield_pointer + distance_to_end - 1) = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(previous_node_value + distance_to_end);</div>
<div class="line"><a name="l03493"></a><span class="lineno"> 3493</span>&#160;                    }</div>
<div class="line"><a name="l03494"></a><span class="lineno"> 3494</span>&#160; </div>
<div class="line"><a name="l03495"></a><span class="lineno"> 3495</span>&#160;                    iterator1.group_pointer-&gt;size = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(iterator1.group_pointer-&gt;size - number_of_group_erasures);</div>
<div class="line"><a name="l03496"></a><span class="lineno"> 3496</span>&#160;                    total_size -= number_of_group_erasures;</div>
<div class="line"><a name="l03497"></a><span class="lineno"> 3497</span>&#160; </div>
<div class="line"><a name="l03498"></a><span class="lineno"> 3498</span>&#160;                    current.group_pointer = current.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l03499"></a><span class="lineno"> 3499</span>&#160;                }</div>
<div class="line"><a name="l03500"></a><span class="lineno"> 3500</span>&#160; </div>
<div class="line"><a name="l03501"></a><span class="lineno"> 3501</span>&#160; </div>
<div class="line"><a name="l03502"></a><span class="lineno"> 3502</span>&#160;                <span class="comment">// Intermediate groups:</span></div>
<div class="line"><a name="l03503"></a><span class="lineno"> 3503</span>&#160;                <span class="keyword">const</span> group_pointer_type previous_group = current.group_pointer-&gt;previous_group;</div>
<div class="line"><a name="l03504"></a><span class="lineno"> 3504</span>&#160; </div>
<div class="line"><a name="l03505"></a><span class="lineno"> 3505</span>&#160;                <span class="keywordflow">while</span> (current.group_pointer != iterator2.group_pointer)</div>
<div class="line"><a name="l03506"></a><span class="lineno"> 3506</span>&#160;                {</div>
<div class="line"><a name="l03507"></a><span class="lineno"> 3507</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l03508"></a><span class="lineno"> 3508</span>&#160;                    <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_trivially_destructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l03509"></a><span class="lineno"> 3509</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03510"></a><span class="lineno"> 3510</span>&#160;                    {</div>
<div class="line"><a name="l03511"></a><span class="lineno"> 3511</span>&#160;                        current.element_pointer = current.group_pointer-&gt;elements + *(current.group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l03512"></a><span class="lineno"> 3512</span>&#160;                        current.skipfield_pointer = current.group_pointer-&gt;skipfield + *(current.group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l03513"></a><span class="lineno"> 3513</span>&#160;                        <span class="keyword">const</span> aligned_pointer_type end = current.group_pointer-&gt;last_endpoint;</div>
<div class="line"><a name="l03514"></a><span class="lineno"> 3514</span>&#160; </div>
<div class="line"><a name="l03515"></a><span class="lineno"> 3515</span>&#160;                        <span class="keywordflow">do</span></div>
<div class="line"><a name="l03516"></a><span class="lineno"> 3516</span>&#160;                        {</div>
<div class="line"><a name="l03517"></a><span class="lineno"> 3517</span>&#160;                            PLF_DESTROY(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current.element_pointer)); <span class="comment">// Destruct element</span></div>
<div class="line"><a name="l03518"></a><span class="lineno"> 3518</span>&#160;                            <span class="keyword">const</span> skipfield_type skip = *(++current.skipfield_pointer);</div>
<div class="line"><a name="l03519"></a><span class="lineno"> 3519</span>&#160;                            current.element_pointer += <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(skip) + 1u;</div>
<div class="line"><a name="l03520"></a><span class="lineno"> 3520</span>&#160;                            current.skipfield_pointer += skip;</div>
<div class="line"><a name="l03521"></a><span class="lineno"> 3521</span>&#160;                        } <span class="keywordflow">while</span> (current.element_pointer != end);</div>
<div class="line"><a name="l03522"></a><span class="lineno"> 3522</span>&#160;                    }</div>
<div class="line"><a name="l03523"></a><span class="lineno"> 3523</span>&#160; </div>
<div class="line"><a name="l03524"></a><span class="lineno"> 3524</span>&#160;                    <span class="keywordflow">if</span> (current.group_pointer-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03525"></a><span class="lineno"> 3525</span>&#160;                    {</div>
<div class="line"><a name="l03526"></a><span class="lineno"> 3526</span>&#160;                        remove_from_groups_with_erasures_list(current.group_pointer);</div>
<div class="line"><a name="l03527"></a><span class="lineno"> 3527</span>&#160;                    }</div>
<div class="line"><a name="l03528"></a><span class="lineno"> 3528</span>&#160; </div>
<div class="line"><a name="l03529"></a><span class="lineno"> 3529</span>&#160;                    total_size -= current.group_pointer-&gt;size;</div>
<div class="line"><a name="l03530"></a><span class="lineno"> 3530</span>&#160;                    <span class="keyword">const</span> group_pointer_type current_group = current.group_pointer;</div>
<div class="line"><a name="l03531"></a><span class="lineno"> 3531</span>&#160;                    current.group_pointer = current.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l03532"></a><span class="lineno"> 3532</span>&#160; </div>
<div class="line"><a name="l03533"></a><span class="lineno"> 3533</span>&#160;                    <span class="keywordflow">if</span> (current_group != end_iterator.group_pointer &amp;&amp; current_group-&gt;next_group != end_iterator.group_pointer)</div>
<div class="line"><a name="l03534"></a><span class="lineno"> 3534</span>&#160;                    {</div>
<div class="line"><a name="l03535"></a><span class="lineno"> 3535</span>&#160;                        total_capacity -= current_group-&gt;capacity;</div>
<div class="line"><a name="l03536"></a><span class="lineno"> 3536</span>&#160;                        deallocate_group(current_group);</div>
<div class="line"><a name="l03537"></a><span class="lineno"> 3537</span>&#160;                    }</div>
<div class="line"><a name="l03538"></a><span class="lineno"> 3538</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03539"></a><span class="lineno"> 3539</span>&#160;                    {</div>
<div class="line"><a name="l03540"></a><span class="lineno"> 3540</span>&#160;                        add_group_to_unused_groups_list(current_group);</div>
<div class="line"><a name="l03541"></a><span class="lineno"> 3541</span>&#160;                    }</div>
<div class="line"><a name="l03542"></a><span class="lineno"> 3542</span>&#160;                }</div>
<div class="line"><a name="l03543"></a><span class="lineno"> 3543</span>&#160; </div>
<div class="line"><a name="l03544"></a><span class="lineno"> 3544</span>&#160;                current.element_pointer = current.group_pointer-&gt;elements + *(current.group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l03545"></a><span class="lineno"> 3545</span>&#160;                current.skipfield_pointer = current.group_pointer-&gt;skipfield + *(current.group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l03546"></a><span class="lineno"> 3546</span>&#160;                current.group_pointer-&gt;previous_group = previous_group;</div>
<div class="line"><a name="l03547"></a><span class="lineno"> 3547</span>&#160; </div>
<div class="line"><a name="l03548"></a><span class="lineno"> 3548</span>&#160;                <span class="keywordflow">if</span> (previous_group != NULL)</div>
<div class="line"><a name="l03549"></a><span class="lineno"> 3549</span>&#160;                {</div>
<div class="line"><a name="l03550"></a><span class="lineno"> 3550</span>&#160;                    previous_group-&gt;next_group = current.group_pointer;</div>
<div class="line"><a name="l03551"></a><span class="lineno"> 3551</span>&#160;                }</div>
<div class="line"><a name="l03552"></a><span class="lineno"> 3552</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l03553"></a><span class="lineno"> 3553</span>&#160;                {</div>
<div class="line"><a name="l03554"></a><span class="lineno"> 3554</span>&#160;                    begin_iterator = iterator2; <span class="comment">// This line is included here primarily to avoid a secondary if statement within the if block below - it will not be needed in any other situation</span></div>
<div class="line"><a name="l03555"></a><span class="lineno"> 3555</span>&#160;                }</div>
<div class="line"><a name="l03556"></a><span class="lineno"> 3556</span>&#160;            }</div>
<div class="line"><a name="l03557"></a><span class="lineno"> 3557</span>&#160; </div>
<div class="line"><a name="l03558"></a><span class="lineno"> 3558</span>&#160;            <span class="keywordflow">if</span> (current.element_pointer == iterator2.element_pointer) <span class="comment">// in case iterator2 was at beginning of it&#39;s group - also covers empty range case (first == last)</span></div>
<div class="line"><a name="l03559"></a><span class="lineno"> 3559</span>&#160;            {</div>
<div class="line"><a name="l03560"></a><span class="lineno"> 3560</span>&#160;                <span class="keywordflow">return</span> iterator2;</div>
<div class="line"><a name="l03561"></a><span class="lineno"> 3561</span>&#160;            }</div>
<div class="line"><a name="l03562"></a><span class="lineno"> 3562</span>&#160; </div>
<div class="line"><a name="l03563"></a><span class="lineno"> 3563</span>&#160;            <span class="comment">// Final group:</span></div>
<div class="line"><a name="l03564"></a><span class="lineno"> 3564</span>&#160;            <span class="comment">// Code explanation:</span></div>
<div class="line"><a name="l03565"></a><span class="lineno"> 3565</span>&#160;            <span class="comment">// If not erasing entire final group, 1. Destruct elements (if non-trivial destructor) and add locations to group free list. 2. process skipfield.</span></div>
<div class="line"><a name="l03566"></a><span class="lineno"> 3566</span>&#160;            <span class="comment">// If erasing entire group, 1. Destruct elements (if non-trivial destructor), 2. if no elements left in colony, clear() 3. otherwise reset end_iterator and remove group from groups-with-erasures list (if free list of erasures present)</span></div>
<div class="line"><a name="l03567"></a><span class="lineno"> 3567</span>&#160; </div>
<div class="line"><a name="l03568"></a><span class="lineno"> 3568</span>&#160;            <span class="keywordflow">if</span> (iterator2.element_pointer != end_iterator.element_pointer || current.element_pointer != current.group_pointer-&gt;elements + *(current.group_pointer-&gt;skipfield)) <span class="comment">// ie. not erasing entire group</span></div>
<div class="line"><a name="l03569"></a><span class="lineno"> 3569</span>&#160;            {</div>
<div class="line"><a name="l03570"></a><span class="lineno"> 3570</span>&#160;                size_type number_of_group_erasures = 0;</div>
<div class="line"><a name="l03571"></a><span class="lineno"> 3571</span>&#160;                <span class="comment">// Schema: first erased all non-erased elements until end of group &amp; remove all skipblocks post-iterator2 from the free_list. Then, either update preceding skipblock or create new one:</span></div>
<div class="line"><a name="l03572"></a><span class="lineno"> 3572</span>&#160; </div>
<div class="line"><a name="l03573"></a><span class="lineno"> 3573</span>&#160;                <span class="keyword">const</span> const_iterator current_saved = current;</div>
<div class="line"><a name="l03574"></a><span class="lineno"> 3574</span>&#160; </div>
<div class="line"><a name="l03575"></a><span class="lineno"> 3575</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT // if trivially-destructible, and C++11 or higher, and no erasures in group, skip while loop below and just jump straight to the location</span></div>
<div class="line"><a name="l03576"></a><span class="lineno"> 3576</span>&#160;                <span class="keywordflow">if</span> (std::is_trivially_destructible&lt;element_type&gt;::value &amp;&amp; current.group_pointer-&gt;free_list_head == std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03577"></a><span class="lineno"> 3577</span>&#160;                {</div>
<div class="line"><a name="l03578"></a><span class="lineno"> 3578</span>&#160;                    number_of_group_erasures += <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(iterator2.element_pointer - current.element_pointer);</div>
<div class="line"><a name="l03579"></a><span class="lineno"> 3579</span>&#160;                }</div>
<div class="line"><a name="l03580"></a><span class="lineno"> 3580</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l03581"></a><span class="lineno"> 3581</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03582"></a><span class="lineno"> 3582</span>&#160;                {</div>
<div class="line"><a name="l03583"></a><span class="lineno"> 3583</span>&#160;                    <span class="keywordflow">while</span> (current.element_pointer != iterator2.element_pointer)</div>
<div class="line"><a name="l03584"></a><span class="lineno"> 3584</span>&#160;                    {</div>
<div class="line"><a name="l03585"></a><span class="lineno"> 3585</span>&#160;                        <span class="keywordflow">if</span> (*current.skipfield_pointer == 0)</div>
<div class="line"><a name="l03586"></a><span class="lineno"> 3586</span>&#160;                        {</div>
<div class="line"><a name="l03587"></a><span class="lineno"> 3587</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l03588"></a><span class="lineno"> 3588</span>&#160;                            <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_trivially_destructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l03589"></a><span class="lineno"> 3589</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03590"></a><span class="lineno"> 3590</span>&#160;                            {</div>
<div class="line"><a name="l03591"></a><span class="lineno"> 3591</span>&#160;                                PLF_DESTROY(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current.element_pointer)); <span class="comment">// Destruct element</span></div>
<div class="line"><a name="l03592"></a><span class="lineno"> 3592</span>&#160;                            }</div>
<div class="line"><a name="l03593"></a><span class="lineno"> 3593</span>&#160; </div>
<div class="line"><a name="l03594"></a><span class="lineno"> 3594</span>&#160;                            ++number_of_group_erasures;</div>
<div class="line"><a name="l03595"></a><span class="lineno"> 3595</span>&#160;                            ++current.element_pointer;</div>
<div class="line"><a name="l03596"></a><span class="lineno"> 3596</span>&#160;                            ++current.skipfield_pointer;</div>
<div class="line"><a name="l03597"></a><span class="lineno"> 3597</span>&#160;                        }</div>
<div class="line"><a name="l03598"></a><span class="lineno"> 3598</span>&#160;                        <span class="keywordflow">else</span> <span class="comment">// remove skipblock from group:</span></div>
<div class="line"><a name="l03599"></a><span class="lineno"> 3599</span>&#160;                        {</div>
<div class="line"><a name="l03600"></a><span class="lineno"> 3600</span>&#160;                            <span class="keyword">const</span> skipfield_type prev_free_list_index = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.element_pointer));</div>
<div class="line"><a name="l03601"></a><span class="lineno"> 3601</span>&#160;                            <span class="keyword">const</span> skipfield_type next_free_list_index = *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.element_pointer) + 1);</div>
<div class="line"><a name="l03602"></a><span class="lineno"> 3602</span>&#160; </div>
<div class="line"><a name="l03603"></a><span class="lineno"> 3603</span>&#160;                            current.element_pointer += *(current.skipfield_pointer);</div>
<div class="line"><a name="l03604"></a><span class="lineno"> 3604</span>&#160;                            current.skipfield_pointer += *(current.skipfield_pointer);</div>
<div class="line"><a name="l03605"></a><span class="lineno"> 3605</span>&#160; </div>
<div class="line"><a name="l03606"></a><span class="lineno"> 3606</span>&#160;                            <span class="keywordflow">if</span> (next_free_list_index == std::numeric_limits&lt;skipfield_type&gt;::max() &amp;&amp; prev_free_list_index == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// if this is the last skipblock in the free list</span></div>
<div class="line"><a name="l03607"></a><span class="lineno"> 3607</span>&#160;                            {</div>
<div class="line"><a name="l03608"></a><span class="lineno"> 3608</span>&#160;                                remove_from_groups_with_erasures_list(iterator2.group_pointer); <span class="comment">// remove group from list of free-list groups - will be added back in down below, but not worth optimizing for</span></div>
<div class="line"><a name="l03609"></a><span class="lineno"> 3609</span>&#160;                                iterator2.group_pointer-&gt;free_list_head = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l03610"></a><span class="lineno"> 3610</span>&#160;                                number_of_group_erasures += <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(iterator2.element_pointer - current.element_pointer);</div>
<div class="line"><a name="l03611"></a><span class="lineno"> 3611</span>&#160; </div>
<div class="line"><a name="l03612"></a><span class="lineno"> 3612</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l03613"></a><span class="lineno"> 3613</span>&#160;                                <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_trivially_destructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l03614"></a><span class="lineno"> 3614</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03615"></a><span class="lineno"> 3615</span>&#160;                                {</div>
<div class="line"><a name="l03616"></a><span class="lineno"> 3616</span>&#160;                                    <span class="keywordflow">while</span> (current.element_pointer != iterator2.element_pointer)</div>
<div class="line"><a name="l03617"></a><span class="lineno"> 3617</span>&#160;                                    {</div>
<div class="line"><a name="l03618"></a><span class="lineno"> 3618</span>&#160;                                        PLF_DESTROY(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current.element_pointer++)); <span class="comment">// Destruct element</span></div>
<div class="line"><a name="l03619"></a><span class="lineno"> 3619</span>&#160;                                    }</div>
<div class="line"><a name="l03620"></a><span class="lineno"> 3620</span>&#160;                                }</div>
<div class="line"><a name="l03621"></a><span class="lineno"> 3621</span>&#160; </div>
<div class="line"><a name="l03622"></a><span class="lineno"> 3622</span>&#160;                                <span class="keywordflow">break</span>; <span class="comment">// end overall while loop</span></div>
<div class="line"><a name="l03623"></a><span class="lineno"> 3623</span>&#160;                            }</div>
<div class="line"><a name="l03624"></a><span class="lineno"> 3624</span>&#160;                            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (next_free_list_index == std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// if this is the head of the free list</span></div>
<div class="line"><a name="l03625"></a><span class="lineno"> 3625</span>&#160;                            {</div>
<div class="line"><a name="l03626"></a><span class="lineno"> 3626</span>&#160;                                current.group_pointer-&gt;free_list_head = prev_free_list_index;</div>
<div class="line"><a name="l03627"></a><span class="lineno"> 3627</span>&#160;                                *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.group_pointer-&gt;elements + prev_free_list_index) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l03628"></a><span class="lineno"> 3628</span>&#160;                            }</div>
<div class="line"><a name="l03629"></a><span class="lineno"> 3629</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l03630"></a><span class="lineno"> 3630</span>&#160;                            {</div>
<div class="line"><a name="l03631"></a><span class="lineno"> 3631</span>&#160;                                *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.group_pointer-&gt;elements + next_free_list_index)) = prev_free_list_index;</div>
<div class="line"><a name="l03632"></a><span class="lineno"> 3632</span>&#160; </div>
<div class="line"><a name="l03633"></a><span class="lineno"> 3633</span>&#160;                                <span class="keywordflow">if</span> (prev_free_list_index != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. not the tail free list node</span></div>
<div class="line"><a name="l03634"></a><span class="lineno"> 3634</span>&#160;                                {</div>
<div class="line"><a name="l03635"></a><span class="lineno"> 3635</span>&#160;                                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current.group_pointer-&gt;elements + prev_free_list_index) + 1) = next_free_list_index;</div>
<div class="line"><a name="l03636"></a><span class="lineno"> 3636</span>&#160;                                }</div>
<div class="line"><a name="l03637"></a><span class="lineno"> 3637</span>&#160;                            }</div>
<div class="line"><a name="l03638"></a><span class="lineno"> 3638</span>&#160;                        }</div>
<div class="line"><a name="l03639"></a><span class="lineno"> 3639</span>&#160;                    }</div>
<div class="line"><a name="l03640"></a><span class="lineno"> 3640</span>&#160;                }</div>
<div class="line"><a name="l03641"></a><span class="lineno"> 3641</span>&#160; </div>
<div class="line"><a name="l03642"></a><span class="lineno"> 3642</span>&#160; </div>
<div class="line"><a name="l03643"></a><span class="lineno"> 3643</span>&#160;                <span class="keyword">const</span> skipfield_type distance_to_iterator2 = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(iterator2.element_pointer - current_saved.element_pointer);</div>
<div class="line"><a name="l03644"></a><span class="lineno"> 3644</span>&#160;                <span class="keyword">const</span> skipfield_type index = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(current_saved.element_pointer - iterator2.group_pointer-&gt;elements);</div>
<div class="line"><a name="l03645"></a><span class="lineno"> 3645</span>&#160; </div>
<div class="line"><a name="l03646"></a><span class="lineno"> 3646</span>&#160; </div>
<div class="line"><a name="l03647"></a><span class="lineno"> 3647</span>&#160;                <span class="keywordflow">if</span> (index == 0 || *(current_saved.skipfield_pointer - 1) == 0) <span class="comment">// element is either at start of group or previous skipfield node is 0</span></div>
<div class="line"><a name="l03648"></a><span class="lineno"> 3648</span>&#160;                {</div>
<div class="line"><a name="l03649"></a><span class="lineno"> 3649</span>&#160;                    *(current_saved.skipfield_pointer) = distance_to_iterator2;</div>
<div class="line"><a name="l03650"></a><span class="lineno"> 3650</span>&#160;                    *(iterator2.skipfield_pointer - 1) = distance_to_iterator2;</div>
<div class="line"><a name="l03651"></a><span class="lineno"> 3651</span>&#160; </div>
<div class="line"><a name="l03652"></a><span class="lineno"> 3652</span>&#160;                    <span class="keywordflow">if</span> (iterator2.group_pointer-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. if this group already has some erased elements</span></div>
<div class="line"><a name="l03653"></a><span class="lineno"> 3653</span>&#160;                    {</div>
<div class="line"><a name="l03654"></a><span class="lineno"> 3654</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(iterator2.group_pointer-&gt;elements + iterator2.group_pointer-&gt;free_list_head) + 1) = index;</div>
<div class="line"><a name="l03655"></a><span class="lineno"> 3655</span>&#160;                    }</div>
<div class="line"><a name="l03656"></a><span class="lineno"> 3656</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03657"></a><span class="lineno"> 3657</span>&#160;                    {</div>
<div class="line"><a name="l03658"></a><span class="lineno"> 3658</span>&#160;                        iterator2.group_pointer-&gt;erasures_list_next_group = groups_with_erasures_list_head; <span class="comment">// add it to the groups-with-erasures free list</span></div>
<div class="line"><a name="l03659"></a><span class="lineno"> 3659</span>&#160;                        groups_with_erasures_list_head = iterator2.group_pointer;</div>
<div class="line"><a name="l03660"></a><span class="lineno"> 3660</span>&#160;                    }</div>
<div class="line"><a name="l03661"></a><span class="lineno"> 3661</span>&#160; </div>
<div class="line"><a name="l03662"></a><span class="lineno"> 3662</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current_saved.element_pointer)) = iterator2.group_pointer-&gt;free_list_head;</div>
<div class="line"><a name="l03663"></a><span class="lineno"> 3663</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(current_saved.element_pointer) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l03664"></a><span class="lineno"> 3664</span>&#160;                    iterator2.group_pointer-&gt;free_list_head = index;</div>
<div class="line"><a name="l03665"></a><span class="lineno"> 3665</span>&#160;                }</div>
<div class="line"><a name="l03666"></a><span class="lineno"> 3666</span>&#160;                <span class="keywordflow">else</span> <span class="comment">// If iterator 1 &amp; 2 are in same group, but iterator 1 was not at start of group, and previous skipfield node is an end node in a skipblock:</span></div>
<div class="line"><a name="l03667"></a><span class="lineno"> 3667</span>&#160;                {</div>
<div class="line"><a name="l03668"></a><span class="lineno"> 3668</span>&#160;                    <span class="comment">// Just update existing skipblock, no need to create new free list node:</span></div>
<div class="line"><a name="l03669"></a><span class="lineno"> 3669</span>&#160;                    <span class="keyword">const</span> skipfield_type prev_node_value = *(current_saved.skipfield_pointer - 1);</div>
<div class="line"><a name="l03670"></a><span class="lineno"> 3670</span>&#160;                    *(current_saved.skipfield_pointer - prev_node_value) = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(prev_node_value + distance_to_iterator2);</div>
<div class="line"><a name="l03671"></a><span class="lineno"> 3671</span>&#160;                    *(iterator2.skipfield_pointer - 1) = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(prev_node_value + distance_to_iterator2);</div>
<div class="line"><a name="l03672"></a><span class="lineno"> 3672</span>&#160;                }</div>
<div class="line"><a name="l03673"></a><span class="lineno"> 3673</span>&#160; </div>
<div class="line"><a name="l03674"></a><span class="lineno"> 3674</span>&#160; </div>
<div class="line"><a name="l03675"></a><span class="lineno"> 3675</span>&#160;                <span class="keywordflow">if</span> (iterator1.element_pointer == begin_iterator.element_pointer)</div>
<div class="line"><a name="l03676"></a><span class="lineno"> 3676</span>&#160;                {</div>
<div class="line"><a name="l03677"></a><span class="lineno"> 3677</span>&#160;                    begin_iterator = iterator2;</div>
<div class="line"><a name="l03678"></a><span class="lineno"> 3678</span>&#160;                }</div>
<div class="line"><a name="l03679"></a><span class="lineno"> 3679</span>&#160; </div>
<div class="line"><a name="l03680"></a><span class="lineno"> 3680</span>&#160;                iterator2.group_pointer-&gt;size = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(iterator2.group_pointer-&gt;size - number_of_group_erasures);</div>
<div class="line"><a name="l03681"></a><span class="lineno"> 3681</span>&#160;                total_size -= number_of_group_erasures;</div>
<div class="line"><a name="l03682"></a><span class="lineno"> 3682</span>&#160;            }</div>
<div class="line"><a name="l03683"></a><span class="lineno"> 3683</span>&#160;            <span class="keywordflow">else</span> <span class="comment">// ie. full group erasure</span></div>
<div class="line"><a name="l03684"></a><span class="lineno"> 3684</span>&#160;            {</div>
<div class="line"><a name="l03685"></a><span class="lineno"> 3685</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l03686"></a><span class="lineno"> 3686</span>&#160;                <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_trivially_destructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l03687"></a><span class="lineno"> 3687</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03688"></a><span class="lineno"> 3688</span>&#160;                {</div>
<div class="line"><a name="l03689"></a><span class="lineno"> 3689</span>&#160;                    <span class="keywordflow">while</span> (current.element_pointer != iterator2.element_pointer)</div>
<div class="line"><a name="l03690"></a><span class="lineno"> 3690</span>&#160;                    {</div>
<div class="line"><a name="l03691"></a><span class="lineno"> 3691</span>&#160;                        PLF_DESTROY(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current.element_pointer));</div>
<div class="line"><a name="l03692"></a><span class="lineno"> 3692</span>&#160;                        ++current.skipfield_pointer;</div>
<div class="line"><a name="l03693"></a><span class="lineno"> 3693</span>&#160;                        current.element_pointer += <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(*current.skipfield_pointer) + 1u;</div>
<div class="line"><a name="l03694"></a><span class="lineno"> 3694</span>&#160;                        current.skipfield_pointer += *current.skipfield_pointer;</div>
<div class="line"><a name="l03695"></a><span class="lineno"> 3695</span>&#160;                    }</div>
<div class="line"><a name="l03696"></a><span class="lineno"> 3696</span>&#160;                }</div>
<div class="line"><a name="l03697"></a><span class="lineno"> 3697</span>&#160; </div>
<div class="line"><a name="l03698"></a><span class="lineno"> 3698</span>&#160; </div>
<div class="line"><a name="l03699"></a><span class="lineno"> 3699</span>&#160;                <span class="keywordflow">if</span> ((total_size -= current.group_pointer-&gt;size) != 0) <span class="comment">// ie. either previous_group != NULL or next_group != NULL</span></div>
<div class="line"><a name="l03700"></a><span class="lineno"> 3700</span>&#160;                {</div>
<div class="line"><a name="l03701"></a><span class="lineno"> 3701</span>&#160;                    <span class="keywordflow">if</span> (current.group_pointer-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max())</div>
<div class="line"><a name="l03702"></a><span class="lineno"> 3702</span>&#160;                    {</div>
<div class="line"><a name="l03703"></a><span class="lineno"> 3703</span>&#160;                        remove_from_groups_with_erasures_list(current.group_pointer);</div>
<div class="line"><a name="l03704"></a><span class="lineno"> 3704</span>&#160;                    }</div>
<div class="line"><a name="l03705"></a><span class="lineno"> 3705</span>&#160; </div>
<div class="line"><a name="l03706"></a><span class="lineno"> 3706</span>&#160;                    current.group_pointer-&gt;previous_group-&gt;next_group = current.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l03707"></a><span class="lineno"> 3707</span>&#160; </div>
<div class="line"><a name="l03708"></a><span class="lineno"> 3708</span>&#160;                    <span class="keywordflow">if</span> (current.group_pointer == end_iterator.group_pointer)</div>
<div class="line"><a name="l03709"></a><span class="lineno"> 3709</span>&#160;                    {</div>
<div class="line"><a name="l03710"></a><span class="lineno"> 3710</span>&#160;                        end_iterator.group_pointer = current.group_pointer-&gt;previous_group;</div>
<div class="line"><a name="l03711"></a><span class="lineno"> 3711</span>&#160;                        end_iterator.element_pointer = end_iterator.group_pointer-&gt;last_endpoint;</div>
<div class="line"><a name="l03712"></a><span class="lineno"> 3712</span>&#160;                        end_iterator.skipfield_pointer = end_iterator.group_pointer-&gt;skipfield + end_iterator.group_pointer-&gt;capacity;</div>
<div class="line"><a name="l03713"></a><span class="lineno"> 3713</span>&#160;                        add_group_to_unused_groups_list(current.group_pointer);</div>
<div class="line"><a name="l03714"></a><span class="lineno"> 3714</span>&#160;                        <span class="keywordflow">return</span> end_iterator;</div>
<div class="line"><a name="l03715"></a><span class="lineno"> 3715</span>&#160;                    }</div>
<div class="line"><a name="l03716"></a><span class="lineno"> 3716</span>&#160;                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (current.group_pointer == begin_iterator.group_pointer)</div>
<div class="line"><a name="l03717"></a><span class="lineno"> 3717</span>&#160;                    {</div>
<div class="line"><a name="l03718"></a><span class="lineno"> 3718</span>&#160;                        begin_iterator.group_pointer = current.group_pointer-&gt;next_group;</div>
<div class="line"><a name="l03719"></a><span class="lineno"> 3719</span>&#160;                        <span class="keyword">const</span> skipfield_type skip = *(begin_iterator.group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l03720"></a><span class="lineno"> 3720</span>&#160;                        begin_iterator.element_pointer = begin_iterator.group_pointer-&gt;elements + skip;</div>
<div class="line"><a name="l03721"></a><span class="lineno"> 3721</span>&#160;                        begin_iterator.skipfield_pointer = begin_iterator.group_pointer-&gt;skipfield + skip;</div>
<div class="line"><a name="l03722"></a><span class="lineno"> 3722</span>&#160;                    }</div>
<div class="line"><a name="l03723"></a><span class="lineno"> 3723</span>&#160; </div>
<div class="line"><a name="l03724"></a><span class="lineno"> 3724</span>&#160;                    <span class="keywordflow">if</span> (current.group_pointer-&gt;next_group != end_iterator.group_pointer)</div>
<div class="line"><a name="l03725"></a><span class="lineno"> 3725</span>&#160;                    {</div>
<div class="line"><a name="l03726"></a><span class="lineno"> 3726</span>&#160;                        total_capacity -= current.group_pointer-&gt;capacity;</div>
<div class="line"><a name="l03727"></a><span class="lineno"> 3727</span>&#160;                    }</div>
<div class="line"><a name="l03728"></a><span class="lineno"> 3728</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03729"></a><span class="lineno"> 3729</span>&#160;                    {</div>
<div class="line"><a name="l03730"></a><span class="lineno"> 3730</span>&#160;                        add_group_to_unused_groups_list(current.group_pointer);</div>
<div class="line"><a name="l03731"></a><span class="lineno"> 3731</span>&#160;                        <span class="keywordflow">return</span> iterator2;</div>
<div class="line"><a name="l03732"></a><span class="lineno"> 3732</span>&#160;                    }</div>
<div class="line"><a name="l03733"></a><span class="lineno"> 3733</span>&#160;                }</div>
<div class="line"><a name="l03734"></a><span class="lineno"> 3734</span>&#160;                <span class="keywordflow">else</span> <span class="comment">// ie. colony is now empty</span></div>
<div class="line"><a name="l03735"></a><span class="lineno"> 3735</span>&#160;                {</div>
<div class="line"><a name="l03736"></a><span class="lineno"> 3736</span>&#160;                    <span class="comment">// Reset skipfield and free list rather than clearing - leads to fewer allocations/deallocations:</span></div>
<div class="line"><a name="l03737"></a><span class="lineno"> 3737</span>&#160;                    reset_only_group_left(current.group_pointer);</div>
<div class="line"><a name="l03738"></a><span class="lineno"> 3738</span>&#160;                    <span class="keywordflow">return</span> end_iterator;</div>
<div class="line"><a name="l03739"></a><span class="lineno"> 3739</span>&#160;                }</div>
<div class="line"><a name="l03740"></a><span class="lineno"> 3740</span>&#160; </div>
<div class="line"><a name="l03741"></a><span class="lineno"> 3741</span>&#160;                deallocate_group(current.group_pointer);</div>
<div class="line"><a name="l03742"></a><span class="lineno"> 3742</span>&#160;            }</div>
<div class="line"><a name="l03743"></a><span class="lineno"> 3743</span>&#160; </div>
<div class="line"><a name="l03744"></a><span class="lineno"> 3744</span>&#160;            <span class="keywordflow">return</span> iterator2;</div>
<div class="line"><a name="l03745"></a><span class="lineno"> 3745</span>&#160;        }</div>
<div class="line"><a name="l03746"></a><span class="lineno"> 3746</span>&#160; </div>
<div class="line"><a name="l03747"></a><span class="lineno"> 3747</span>&#160; </div>
<div class="line"><a name="l03748"></a><span class="lineno"> 3748</span>&#160; </div>
<div class="line"><a name="l03749"></a><span class="lineno"> 3749</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l03750"></a><span class="lineno"> 3750</span>&#160; </div>
<div class="line"><a name="l03751"></a><span class="lineno"> 3751</span>&#160;        <span class="keywordtype">void</span> prepare_groups_for_assign(<span class="keyword">const</span> size_type size)</div>
<div class="line"><a name="l03752"></a><span class="lineno"> 3752</span>&#160;        {</div>
<div class="line"><a name="l03753"></a><span class="lineno"> 3753</span>&#160;            <span class="comment">// Destroy all elements if non-trivial:</span></div>
<div class="line"><a name="l03754"></a><span class="lineno"> 3754</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l03755"></a><span class="lineno"> 3755</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(!std::is_trivially_destructible&lt;element_type&gt;::value)</div>
<div class="line"><a name="l03756"></a><span class="lineno"> 3756</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03757"></a><span class="lineno"> 3757</span>&#160;            {</div>
<div class="line"><a name="l03758"></a><span class="lineno"> 3758</span>&#160;                <span class="keywordflow">for</span> (iterator current = begin_iterator; current != end_iterator; ++current)</div>
<div class="line"><a name="l03759"></a><span class="lineno"> 3759</span>&#160;                {</div>
<div class="line"><a name="l03760"></a><span class="lineno"> 3760</span>&#160;                    PLF_DESTROY(allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>(current.element_pointer));</div>
<div class="line"><a name="l03761"></a><span class="lineno"> 3761</span>&#160;                }</div>
<div class="line"><a name="l03762"></a><span class="lineno"> 3762</span>&#160;            }</div>
<div class="line"><a name="l03763"></a><span class="lineno"> 3763</span>&#160; </div>
<div class="line"><a name="l03764"></a><span class="lineno"> 3764</span>&#160;            <span class="keywordflow">if</span> (size &lt; total_capacity &amp;&amp; (total_capacity - size) &gt;= tuple_allocator_pair.min_group_capacity)</div>
<div class="line"><a name="l03765"></a><span class="lineno"> 3765</span>&#160;            {</div>
<div class="line"><a name="l03766"></a><span class="lineno"> 3766</span>&#160;                size_type difference = total_capacity - size;</div>
<div class="line"><a name="l03767"></a><span class="lineno"> 3767</span>&#160;                end_iterator.group_pointer-&gt;next_group = unused_groups_head;</div>
<div class="line"><a name="l03768"></a><span class="lineno"> 3768</span>&#160; </div>
<div class="line"><a name="l03769"></a><span class="lineno"> 3769</span>&#160;                <span class="comment">// Remove surplus groups which&#39;re under the difference limit:</span></div>
<div class="line"><a name="l03770"></a><span class="lineno"> 3770</span>&#160;                group_pointer_type current_group = begin_iterator.group_pointer, previous_group = NULL;</div>
<div class="line"><a name="l03771"></a><span class="lineno"> 3771</span>&#160; </div>
<div class="line"><a name="l03772"></a><span class="lineno"> 3772</span>&#160;                <span class="keywordflow">do</span></div>
<div class="line"><a name="l03773"></a><span class="lineno"> 3773</span>&#160;                {</div>
<div class="line"><a name="l03774"></a><span class="lineno"> 3774</span>&#160;                    <span class="keyword">const</span> group_pointer_type next_group = current_group-&gt;next_group;</div>
<div class="line"><a name="l03775"></a><span class="lineno"> 3775</span>&#160; </div>
<div class="line"><a name="l03776"></a><span class="lineno"> 3776</span>&#160;                    <span class="keywordflow">if</span> (current_group-&gt;capacity &lt;= difference)</div>
<div class="line"><a name="l03777"></a><span class="lineno"> 3777</span>&#160;                    { <span class="comment">// Remove group:</span></div>
<div class="line"><a name="l03778"></a><span class="lineno"> 3778</span>&#160;                        difference -= current_group-&gt;capacity;</div>
<div class="line"><a name="l03779"></a><span class="lineno"> 3779</span>&#160;                        total_capacity -= current_group-&gt;capacity;</div>
<div class="line"><a name="l03780"></a><span class="lineno"> 3780</span>&#160;                        deallocate_group(current_group);</div>
<div class="line"><a name="l03781"></a><span class="lineno"> 3781</span>&#160; </div>
<div class="line"><a name="l03782"></a><span class="lineno"> 3782</span>&#160;                        <span class="keywordflow">if</span> (current_group == begin_iterator.group_pointer)</div>
<div class="line"><a name="l03783"></a><span class="lineno"> 3783</span>&#160;                        {</div>
<div class="line"><a name="l03784"></a><span class="lineno"> 3784</span>&#160;                            begin_iterator.group_pointer = next_group;</div>
<div class="line"><a name="l03785"></a><span class="lineno"> 3785</span>&#160;                        }</div>
<div class="line"><a name="l03786"></a><span class="lineno"> 3786</span>&#160;                    }</div>
<div class="line"><a name="l03787"></a><span class="lineno"> 3787</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l03788"></a><span class="lineno"> 3788</span>&#160;                    {</div>
<div class="line"><a name="l03789"></a><span class="lineno"> 3789</span>&#160;                        <span class="keywordflow">if</span> (previous_group != NULL)</div>
<div class="line"><a name="l03790"></a><span class="lineno"> 3790</span>&#160;                        {</div>
<div class="line"><a name="l03791"></a><span class="lineno"> 3791</span>&#160;                            previous_group-&gt;next_group = current_group;</div>
<div class="line"><a name="l03792"></a><span class="lineno"> 3792</span>&#160;                        }</div>
<div class="line"><a name="l03793"></a><span class="lineno"> 3793</span>&#160; </div>
<div class="line"><a name="l03794"></a><span class="lineno"> 3794</span>&#160;                        previous_group = current_group;</div>
<div class="line"><a name="l03795"></a><span class="lineno"> 3795</span>&#160;                    }</div>
<div class="line"><a name="l03796"></a><span class="lineno"> 3796</span>&#160; </div>
<div class="line"><a name="l03797"></a><span class="lineno"> 3797</span>&#160;                    current_group = next_group;</div>
<div class="line"><a name="l03798"></a><span class="lineno"> 3798</span>&#160;                } <span class="keywordflow">while</span> (current_group != NULL);</div>
<div class="line"><a name="l03799"></a><span class="lineno"> 3799</span>&#160; </div>
<div class="line"><a name="l03800"></a><span class="lineno"> 3800</span>&#160;                previous_group-&gt;next_group = NULL;</div>
<div class="line"><a name="l03801"></a><span class="lineno"> 3801</span>&#160;            }</div>
<div class="line"><a name="l03802"></a><span class="lineno"> 3802</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l03803"></a><span class="lineno"> 3803</span>&#160;            {</div>
<div class="line"><a name="l03804"></a><span class="lineno"> 3804</span>&#160;                <span class="keywordflow">if</span> (size &gt; total_capacity)</div>
<div class="line"><a name="l03805"></a><span class="lineno"> 3805</span>&#160;                {</div>
<div class="line"><a name="l03806"></a><span class="lineno"> 3806</span>&#160;                    reserve(size);</div>
<div class="line"><a name="l03807"></a><span class="lineno"> 3807</span>&#160;                }</div>
<div class="line"><a name="l03808"></a><span class="lineno"> 3808</span>&#160; </div>
<div class="line"><a name="l03809"></a><span class="lineno"> 3809</span>&#160;                <span class="comment">// Join all unused_groups to main chain:</span></div>
<div class="line"><a name="l03810"></a><span class="lineno"> 3810</span>&#160;                end_iterator.group_pointer-&gt;next_group = unused_groups_head;</div>
<div class="line"><a name="l03811"></a><span class="lineno"> 3811</span>&#160;            }</div>
<div class="line"><a name="l03812"></a><span class="lineno"> 3812</span>&#160; </div>
<div class="line"><a name="l03813"></a><span class="lineno"> 3813</span>&#160;            begin_iterator.element_pointer = begin_iterator.group_pointer-&gt;elements;</div>
<div class="line"><a name="l03814"></a><span class="lineno"> 3814</span>&#160;            begin_iterator.skipfield_pointer = begin_iterator.group_pointer-&gt;skipfield;</div>
<div class="line"><a name="l03815"></a><span class="lineno"> 3815</span>&#160;            groups_with_erasures_list_head = NULL;</div>
<div class="line"><a name="l03816"></a><span class="lineno"> 3816</span>&#160;            total_size = 0;</div>
<div class="line"><a name="l03817"></a><span class="lineno"> 3817</span>&#160;        }</div>
<div class="line"><a name="l03818"></a><span class="lineno"> 3818</span>&#160; </div>
<div class="line"><a name="l03819"></a><span class="lineno"> 3819</span>&#160; </div>
<div class="line"><a name="l03820"></a><span class="lineno"> 3820</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l03821"></a><span class="lineno"> 3821</span>&#160; </div>
<div class="line"><a name="l03822"></a><span class="lineno"> 3822</span>&#160; </div>
<div class="line"><a name="l03823"></a><span class="lineno"> 3823</span>&#160;        <span class="comment">// Fill assign:</span></div>
<div class="line"><a name="l03824"></a><span class="lineno"> 3824</span>&#160; </div>
<div class="line"><a name="l03825"></a><span class="lineno"> 3825</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> assign(<span class="keyword">const</span> size_type size, <span class="keyword">const</span> element_type&amp; element)</div>
<div class="line"><a name="l03826"></a><span class="lineno"> 3826</span>&#160;        {</div>
<div class="line"><a name="l03827"></a><span class="lineno"> 3827</span>&#160;            <span class="keywordflow">if</span> (size == 0)</div>
<div class="line"><a name="l03828"></a><span class="lineno"> 3828</span>&#160;            {</div>
<div class="line"><a name="l03829"></a><span class="lineno"> 3829</span>&#160;                clear();</div>
<div class="line"><a name="l03830"></a><span class="lineno"> 3830</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l03831"></a><span class="lineno"> 3831</span>&#160;            }</div>
<div class="line"><a name="l03832"></a><span class="lineno"> 3832</span>&#160; </div>
<div class="line"><a name="l03833"></a><span class="lineno"> 3833</span>&#160;            prepare_groups_for_assign(size);</div>
<div class="line"><a name="l03834"></a><span class="lineno"> 3834</span>&#160;            fill_unused_groups(size, element, 0, NULL, begin_iterator.group_pointer);</div>
<div class="line"><a name="l03835"></a><span class="lineno"> 3835</span>&#160;        }</div>
<div class="line"><a name="l03836"></a><span class="lineno"> 3836</span>&#160; </div>
<div class="line"><a name="l03837"></a><span class="lineno"> 3837</span>&#160; </div>
<div class="line"><a name="l03838"></a><span class="lineno"> 3838</span>&#160; </div>
<div class="line"><a name="l03839"></a><span class="lineno"> 3839</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l03840"></a><span class="lineno"> 3840</span>&#160; </div>
<div class="line"><a name="l03841"></a><span class="lineno"> 3841</span>&#160;        <span class="comment">// Range assign core:</span></div>
<div class="line"><a name="l03842"></a><span class="lineno"> 3842</span>&#160; </div>
<div class="line"><a name="l03843"></a><span class="lineno"> 3843</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type&gt;</div>
<div class="line"><a name="l03844"></a><span class="lineno"> 3844</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> range_assign(<span class="keyword">const</span> iterator_type it, <span class="keyword">const</span> size_type size)</div>
<div class="line"><a name="l03845"></a><span class="lineno"> 3845</span>&#160;        {</div>
<div class="line"><a name="l03846"></a><span class="lineno"> 3846</span>&#160;            <span class="keywordflow">if</span> (size == 0)</div>
<div class="line"><a name="l03847"></a><span class="lineno"> 3847</span>&#160;            {</div>
<div class="line"><a name="l03848"></a><span class="lineno"> 3848</span>&#160;                clear();</div>
<div class="line"><a name="l03849"></a><span class="lineno"> 3849</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l03850"></a><span class="lineno"> 3850</span>&#160;            }</div>
<div class="line"><a name="l03851"></a><span class="lineno"> 3851</span>&#160; </div>
<div class="line"><a name="l03852"></a><span class="lineno"> 3852</span>&#160;            prepare_groups_for_assign(size);</div>
<div class="line"><a name="l03853"></a><span class="lineno"> 3853</span>&#160;            range_fill_unused_groups(size, it, 0, NULL, begin_iterator.group_pointer);</div>
<div class="line"><a name="l03854"></a><span class="lineno"> 3854</span>&#160;        }</div>
<div class="line"><a name="l03855"></a><span class="lineno"> 3855</span>&#160; </div>
<div class="line"><a name="l03856"></a><span class="lineno"> 3856</span>&#160; </div>
<div class="line"><a name="l03857"></a><span class="lineno"> 3857</span>&#160; </div>
<div class="line"><a name="l03858"></a><span class="lineno"> 3858</span>&#160; </div>
<div class="line"><a name="l03859"></a><span class="lineno"> 3859</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l03860"></a><span class="lineno"> 3860</span>&#160; </div>
<div class="line"><a name="l03861"></a><span class="lineno"> 3861</span>&#160;        <span class="comment">// Range assign:</span></div>
<div class="line"><a name="l03862"></a><span class="lineno"> 3862</span>&#160; </div>
<div class="line"><a name="l03863"></a><span class="lineno"> 3863</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type&gt;</div>
<div class="line"><a name="l03864"></a><span class="lineno"> 3864</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> assign(<span class="keyword">const</span> <span class="keyword">typename</span> plf_enable_if_c&lt;!std::numeric_limits&lt;iterator_type&gt;::is_integer, iterator_type&gt;::type first, <span class="keyword">const</span> iterator_type last)</div>
<div class="line"><a name="l03865"></a><span class="lineno"> 3865</span>&#160;        {</div>
<div class="line"><a name="l03866"></a><span class="lineno"> 3866</span>&#160;            <span class="keyword">using</span> std::distance;</div>
<div class="line"><a name="l03867"></a><span class="lineno"> 3867</span>&#160;            range_assign(first, <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(distance(first, last)));</div>
<div class="line"><a name="l03868"></a><span class="lineno"> 3868</span>&#160;        }</div>
<div class="line"><a name="l03869"></a><span class="lineno"> 3869</span>&#160; </div>
<div class="line"><a name="l03870"></a><span class="lineno"> 3870</span>&#160; </div>
<div class="line"><a name="l03871"></a><span class="lineno"> 3871</span>&#160; </div>
<div class="line"><a name="l03872"></a><span class="lineno"> 3872</span>&#160;        <span class="comment">// Range insert for differing iterator types eg. sentinels:</span></div>
<div class="line"><a name="l03873"></a><span class="lineno"> 3873</span>&#160; </div>
<div class="line"><a name="l03874"></a><span class="lineno"> 3874</span>&#160;<span class="preprocessor">#ifdef PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l03875"></a><span class="lineno"> 3875</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type1, <span class="keyword">class</span> iterator_type2&gt;</div>
<div class="line"><a name="l03876"></a><span class="lineno"> 3876</span>&#160;        requires (!std::same_as&lt;iterator_type1, iterator_type2&gt;&amp;&amp; std::equality_comparable_with&lt;iterator_type1, iterator_type2&gt; &amp;&amp; !std::integral&lt;iterator_type1&gt; &amp;&amp; !std::integral&lt;iterator_type2&gt;)</div>
<div class="line"><a name="l03877"></a><span class="lineno"> 3877</span>&#160;            <span class="keyword">inline</span> <span class="keywordtype">void</span> assign(<span class="keyword">const</span> iterator_type1 first, <span class="keyword">const</span> iterator_type2 last)</div>
<div class="line"><a name="l03878"></a><span class="lineno"> 3878</span>&#160;        {</div>
<div class="line"><a name="l03879"></a><span class="lineno"> 3879</span>&#160;            size_type distance = 0;</div>
<div class="line"><a name="l03880"></a><span class="lineno"> 3880</span>&#160;            <span class="keywordflow">for</span> (iterator_type1 current = first; current != last; ++current, ++distance) {};</div>
<div class="line"><a name="l03881"></a><span class="lineno"> 3881</span>&#160;            range_assign(first, distance);</div>
<div class="line"><a name="l03882"></a><span class="lineno"> 3882</span>&#160;        }</div>
<div class="line"><a name="l03883"></a><span class="lineno"> 3883</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03884"></a><span class="lineno"> 3884</span>&#160; </div>
<div class="line"><a name="l03885"></a><span class="lineno"> 3885</span>&#160; </div>
<div class="line"><a name="l03886"></a><span class="lineno"> 3886</span>&#160; </div>
<div class="line"><a name="l03887"></a><span class="lineno"> 3887</span>&#160;        <span class="comment">// Range assign, move_iterator overload:</span></div>
<div class="line"><a name="l03888"></a><span class="lineno"> 3888</span>&#160; </div>
<div class="line"><a name="l03889"></a><span class="lineno"> 3889</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l03890"></a><span class="lineno"> 3890</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> iterator_type&gt;</div>
<div class="line"><a name="l03891"></a><span class="lineno"> 3891</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> assign(<span class="keyword">const</span> std::move_iterator&lt;iterator_type&gt; first, <span class="keyword">const</span> std::move_iterator&lt;iterator_type&gt; last)</div>
<div class="line"><a name="l03892"></a><span class="lineno"> 3892</span>&#160;        {</div>
<div class="line"><a name="l03893"></a><span class="lineno"> 3893</span>&#160;            <span class="keyword">using</span> std::distance;</div>
<div class="line"><a name="l03894"></a><span class="lineno"> 3894</span>&#160;            range_assign(first, <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(distance(first.base(), last.base())));</div>
<div class="line"><a name="l03895"></a><span class="lineno"> 3895</span>&#160;        }</div>
<div class="line"><a name="l03896"></a><span class="lineno"> 3896</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03897"></a><span class="lineno"> 3897</span>&#160; </div>
<div class="line"><a name="l03898"></a><span class="lineno"> 3898</span>&#160; </div>
<div class="line"><a name="l03899"></a><span class="lineno"> 3899</span>&#160; </div>
<div class="line"><a name="l03900"></a><span class="lineno"> 3900</span>&#160;        <span class="comment">// Initializer-list assign:</span></div>
<div class="line"><a name="l03901"></a><span class="lineno"> 3901</span>&#160; </div>
<div class="line"><a name="l03902"></a><span class="lineno"> 3902</span>&#160;<span class="preprocessor">#ifdef PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l03903"></a><span class="lineno"> 3903</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> assign(<span class="keyword">const</span> std::initializer_list&lt;element_type&gt;&amp; element_list)</div>
<div class="line"><a name="l03904"></a><span class="lineno"> 3904</span>&#160;        {</div>
<div class="line"><a name="l03905"></a><span class="lineno"> 3905</span>&#160;            range_assign(element_list.begin(), <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(element_list.size()));</div>
<div class="line"><a name="l03906"></a><span class="lineno"> 3906</span>&#160;        }</div>
<div class="line"><a name="l03907"></a><span class="lineno"> 3907</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03908"></a><span class="lineno"> 3908</span>&#160; </div>
<div class="line"><a name="l03909"></a><span class="lineno"> 3909</span>&#160; </div>
<div class="line"><a name="l03910"></a><span class="lineno"> 3910</span>&#160; </div>
<div class="line"><a name="l03911"></a><span class="lineno"> 3911</span>&#160; </div>
<div class="line"><a name="l03912"></a><span class="lineno"> 3912</span>&#160;<span class="preprocessor">#ifdef PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l03913"></a><span class="lineno"> 3913</span>&#160;        [[nodiscard]]</div>
<div class="line"><a name="l03914"></a><span class="lineno"> 3914</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03915"></a><span class="lineno"> 3915</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">bool</span> empty() const PLF_NOEXCEPT</div>
<div class="line"><a name="l03916"></a><span class="lineno"> 3916</span>&#160;        {</div>
<div class="line"><a name="l03917"></a><span class="lineno"> 3917</span>&#160;            <span class="keywordflow">return</span> total_size == 0;</div>
<div class="line"><a name="l03918"></a><span class="lineno"> 3918</span>&#160;        }</div>
<div class="line"><a name="l03919"></a><span class="lineno"> 3919</span>&#160; </div>
<div class="line"><a name="l03920"></a><span class="lineno"> 3920</span>&#160; </div>
<div class="line"><a name="l03921"></a><span class="lineno"> 3921</span>&#160; </div>
<div class="line"><a name="l03922"></a><span class="lineno"> 3922</span>&#160;        <span class="keyword">inline</span> size_type size() const PLF_NOEXCEPT</div>
<div class="line"><a name="l03923"></a><span class="lineno"> 3923</span>&#160;        {</div>
<div class="line"><a name="l03924"></a><span class="lineno"> 3924</span>&#160;            <span class="keywordflow">return</span> total_size;</div>
<div class="line"><a name="l03925"></a><span class="lineno"> 3925</span>&#160;        }</div>
<div class="line"><a name="l03926"></a><span class="lineno"> 3926</span>&#160; </div>
<div class="line"><a name="l03927"></a><span class="lineno"> 3927</span>&#160; </div>
<div class="line"><a name="l03928"></a><span class="lineno"> 3928</span>&#160; </div>
<div class="line"><a name="l03929"></a><span class="lineno"> 3929</span>&#160;<span class="preprocessor">#ifdef PLF_COLONY_TEST_DEBUG // used for debugging during internal testing only:</span></div>
<div class="line"><a name="l03930"></a><span class="lineno"> 3930</span>&#160;        size_type group_size_sum() const PLF_NOEXCEPT</div>
<div class="line"><a name="l03931"></a><span class="lineno"> 3931</span>&#160;        {</div>
<div class="line"><a name="l03932"></a><span class="lineno"> 3932</span>&#160;            size_type temp = 0;</div>
<div class="line"><a name="l03933"></a><span class="lineno"> 3933</span>&#160; </div>
<div class="line"><a name="l03934"></a><span class="lineno"> 3934</span>&#160;            <span class="keywordflow">for</span> (group_pointer_type current = begin_iterator.group_pointer; current != NULL; current = current-&gt;next_group)</div>
<div class="line"><a name="l03935"></a><span class="lineno"> 3935</span>&#160;            {</div>
<div class="line"><a name="l03936"></a><span class="lineno"> 3936</span>&#160;                temp += current-&gt;size;</div>
<div class="line"><a name="l03937"></a><span class="lineno"> 3937</span>&#160;            }</div>
<div class="line"><a name="l03938"></a><span class="lineno"> 3938</span>&#160; </div>
<div class="line"><a name="l03939"></a><span class="lineno"> 3939</span>&#160;            <span class="keywordflow">return</span> temp;</div>
<div class="line"><a name="l03940"></a><span class="lineno"> 3940</span>&#160;        }</div>
<div class="line"><a name="l03941"></a><span class="lineno"> 3941</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03942"></a><span class="lineno"> 3942</span>&#160; </div>
<div class="line"><a name="l03943"></a><span class="lineno"> 3943</span>&#160; </div>
<div class="line"><a name="l03944"></a><span class="lineno"> 3944</span>&#160; </div>
<div class="line"><a name="l03945"></a><span class="lineno"> 3945</span>&#160;        <span class="keyword">inline</span> size_type max_size() const PLF_NOEXCEPT</div>
<div class="line"><a name="l03946"></a><span class="lineno"> 3946</span>&#160;        {</div>
<div class="line"><a name="l03947"></a><span class="lineno"> 3947</span>&#160;<span class="preprocessor">#ifdef PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l03948"></a><span class="lineno"> 3948</span>&#160;            <span class="keywordflow">return</span> std::allocator_traits&lt;allocator_type&gt;::max_size(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l03949"></a><span class="lineno"> 3949</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l03950"></a><span class="lineno"> 3950</span>&#160;            <span class="keywordflow">return</span> allocator_type::max_size();</div>
<div class="line"><a name="l03951"></a><span class="lineno"> 3951</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03952"></a><span class="lineno"> 3952</span>&#160;        }</div>
<div class="line"><a name="l03953"></a><span class="lineno"> 3953</span>&#160; </div>
<div class="line"><a name="l03954"></a><span class="lineno"> 3954</span>&#160; </div>
<div class="line"><a name="l03955"></a><span class="lineno"> 3955</span>&#160; </div>
<div class="line"><a name="l03956"></a><span class="lineno"> 3956</span>&#160;        <span class="keyword">inline</span> size_type capacity() const PLF_NOEXCEPT</div>
<div class="line"><a name="l03957"></a><span class="lineno"> 3957</span>&#160;        {</div>
<div class="line"><a name="l03958"></a><span class="lineno"> 3958</span>&#160;            <span class="keywordflow">return</span> total_capacity;</div>
<div class="line"><a name="l03959"></a><span class="lineno"> 3959</span>&#160;        }</div>
<div class="line"><a name="l03960"></a><span class="lineno"> 3960</span>&#160; </div>
<div class="line"><a name="l03961"></a><span class="lineno"> 3961</span>&#160; </div>
<div class="line"><a name="l03962"></a><span class="lineno"> 3962</span>&#160; </div>
<div class="line"><a name="l03963"></a><span class="lineno"> 3963</span>&#160;        <span class="keyword">inline</span> size_type memory() const PLF_NOEXCEPT</div>
<div class="line"><a name="l03964"></a><span class="lineno"> 3964</span>&#160;        {</div>
<div class="line"><a name="l03965"></a><span class="lineno"> 3965</span>&#160;            size_type memory_use = <span class="keyword">sizeof</span>(*this); <span class="comment">// sizeof colony basic structure</span></div>
<div class="line"><a name="l03966"></a><span class="lineno"> 3966</span>&#160;            end_iterator.group_pointer-&gt;next_group = unused_groups_head; <span class="comment">// temporarily link the main groups and unused groups (reserved groups) in order to only have one loop below instead of several</span></div>
<div class="line"><a name="l03967"></a><span class="lineno"> 3967</span>&#160; </div>
<div class="line"><a name="l03968"></a><span class="lineno"> 3968</span>&#160;            <span class="keywordflow">for</span> (group_pointer_type current = begin_iterator.group_pointer; current != NULL; current = current-&gt;next_group)</div>
<div class="line"><a name="l03969"></a><span class="lineno"> 3969</span>&#160;            {</div>
<div class="line"><a name="l03970"></a><span class="lineno"> 3970</span>&#160;                memory_use += <span class="keyword">sizeof</span>(group) + (PLF_GROUP_ALIGNED_BLOCK_SIZE(current-&gt;capacity) * <span class="keyword">sizeof</span>(aligned_allocation_struct)); <span class="comment">// add memory block sizes and the size of the group structs themselves. The original calculation, including divisor, is necessary in order to correctly round up the number of allocations</span></div>
<div class="line"><a name="l03971"></a><span class="lineno"> 3971</span>&#160;            }</div>
<div class="line"><a name="l03972"></a><span class="lineno"> 3972</span>&#160; </div>
<div class="line"><a name="l03973"></a><span class="lineno"> 3973</span>&#160;            end_iterator.group_pointer-&gt;next_group = NULL; <span class="comment">// unlink main groups and unused groups</span></div>
<div class="line"><a name="l03974"></a><span class="lineno"> 3974</span>&#160;            <span class="keywordflow">return</span> memory_use;</div>
<div class="line"><a name="l03975"></a><span class="lineno"> 3975</span>&#160;        }</div>
<div class="line"><a name="l03976"></a><span class="lineno"> 3976</span>&#160; </div>
<div class="line"><a name="l03977"></a><span class="lineno"> 3977</span>&#160; </div>
<div class="line"><a name="l03978"></a><span class="lineno"> 3978</span>&#160; </div>
<div class="line"><a name="l03979"></a><span class="lineno"> 3979</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l03980"></a><span class="lineno"> 3980</span>&#160; </div>
<div class="line"><a name="l03981"></a><span class="lineno"> 3981</span>&#160;        <span class="comment">// get all elements contiguous in memory and shrink to fit, remove erasures and erasure free lists. Invalidates all iterators and pointers to elements.</span></div>
<div class="line"><a name="l03982"></a><span class="lineno"> 3982</span>&#160;        <span class="keywordtype">void</span> consolidate()</div>
<div class="line"><a name="l03983"></a><span class="lineno"> 3983</span>&#160;        {</div>
<div class="line"><a name="l03984"></a><span class="lineno"> 3984</span>&#160;<span class="preprocessor">#if defined(PLF_MOVE_SEMANTICS_SUPPORT) &amp;&amp; defined(PLF_TYPE_TRAITS_SUPPORT)</span></div>
<div class="line"><a name="l03985"></a><span class="lineno"> 3985</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_move_constructible&lt;element_type&gt;::value &amp;&amp; std::is_move_assignable&lt;element_type&gt;::value)</div>
<div class="line"><a name="l03986"></a><span class="lineno"> 3986</span>&#160;            {</div>
<div class="line"><a name="l03987"></a><span class="lineno"> 3987</span>&#160;                colony temp(<a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a>(tuple_allocator_pair.min_group_capacity, group_allocator_pair.max_group_capacity));</div>
<div class="line"><a name="l03988"></a><span class="lineno"> 3988</span>&#160;                temp.range_assign(std::make_move_iterator(begin_iterator), total_size);</div>
<div class="line"><a name="l03989"></a><span class="lineno"> 3989</span>&#160;                *<span class="keyword">this</span> = std::move(temp); <span class="comment">// Avoid generating 2nd temporary</span></div>
<div class="line"><a name="l03990"></a><span class="lineno"> 3990</span>&#160;            }</div>
<div class="line"><a name="l03991"></a><span class="lineno"> 3991</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l03992"></a><span class="lineno"> 3992</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03993"></a><span class="lineno"> 3993</span>&#160;            {</div>
<div class="line"><a name="l03994"></a><span class="lineno"> 3994</span>&#160;                colony temp(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l03995"></a><span class="lineno"> 3995</span>&#160;                swap(temp);</div>
<div class="line"><a name="l03996"></a><span class="lineno"> 3996</span>&#160;            }</div>
<div class="line"><a name="l03997"></a><span class="lineno"> 3997</span>&#160;        }</div>
<div class="line"><a name="l03998"></a><span class="lineno"> 3998</span>&#160; </div>
<div class="line"><a name="l03999"></a><span class="lineno"> 3999</span>&#160; </div>
<div class="line"><a name="l04000"></a><span class="lineno"> 4000</span>&#160; </div>
<div class="line"><a name="l04001"></a><span class="lineno"> 4001</span>&#160; </div>
<div class="line"><a name="l04002"></a><span class="lineno"> 4002</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l04003"></a><span class="lineno"> 4003</span>&#160; </div>
<div class="line"><a name="l04004"></a><span class="lineno"> 4004</span>&#160; </div>
<div class="line"><a name="l04005"></a><span class="lineno"> 4005</span>&#160;        <span class="keywordtype">void</span> reshape(<span class="keyword">const</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> capacities)</div>
<div class="line"><a name="l04006"></a><span class="lineno"> 4006</span>&#160;        {</div>
<div class="line"><a name="l04007"></a><span class="lineno"> 4007</span>&#160;            check_capacities_conformance(capacities);</div>
<div class="line"><a name="l04008"></a><span class="lineno"> 4008</span>&#160;            tuple_allocator_pair.min_group_capacity = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(capacities.min);</div>
<div class="line"><a name="l04009"></a><span class="lineno"> 4009</span>&#160;            group_allocator_pair.max_group_capacity = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(capacities.max);</div>
<div class="line"><a name="l04010"></a><span class="lineno"> 4010</span>&#160; </div>
<div class="line"><a name="l04011"></a><span class="lineno"> 4011</span>&#160;            <span class="comment">// Need to check all group sizes here, because splice might append smaller blocks to the end of a larger block:</span></div>
<div class="line"><a name="l04012"></a><span class="lineno"> 4012</span>&#160;            <span class="keywordflow">for</span> (group_pointer_type current = begin_iterator.group_pointer; current != end_iterator.group_pointer; current = current-&gt;next_group)</div>
<div class="line"><a name="l04013"></a><span class="lineno"> 4013</span>&#160;            {</div>
<div class="line"><a name="l04014"></a><span class="lineno"> 4014</span>&#160;                <span class="keywordflow">if</span> (current-&gt;capacity &lt; tuple_allocator_pair.min_group_capacity || current-&gt;capacity &gt; group_allocator_pair.max_group_capacity)</div>
<div class="line"><a name="l04015"></a><span class="lineno"> 4015</span>&#160;                {</div>
<div class="line"><a name="l04016"></a><span class="lineno"> 4016</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT // If type is non-copyable/movable, cannot be consolidated, throw exception:</span></div>
<div class="line"><a name="l04017"></a><span class="lineno"> 4017</span>&#160;                    <span class="keywordflow">if</span> PLF_CONSTEXPR(!(std::is_copy_constructible&lt;element_type&gt;::value || std::is_move_constructible&lt;element_type&gt;::value))</div>
<div class="line"><a name="l04018"></a><span class="lineno"> 4018</span>&#160;                    {</div>
<div class="line"><a name="l04019"></a><span class="lineno"> 4019</span>&#160;                        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l04020"></a><span class="lineno"> 4020</span>&#160;                    }</div>
<div class="line"><a name="l04021"></a><span class="lineno"> 4021</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l04022"></a><span class="lineno"> 4022</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04023"></a><span class="lineno"> 4023</span>&#160;                    {</div>
<div class="line"><a name="l04024"></a><span class="lineno"> 4024</span>&#160;                        consolidate();</div>
<div class="line"><a name="l04025"></a><span class="lineno"> 4025</span>&#160;                    }</div>
<div class="line"><a name="l04026"></a><span class="lineno"> 4026</span>&#160; </div>
<div class="line"><a name="l04027"></a><span class="lineno"> 4027</span>&#160;                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l04028"></a><span class="lineno"> 4028</span>&#160;                }</div>
<div class="line"><a name="l04029"></a><span class="lineno"> 4029</span>&#160;            }</div>
<div class="line"><a name="l04030"></a><span class="lineno"> 4030</span>&#160;        }</div>
<div class="line"><a name="l04031"></a><span class="lineno"> 4031</span>&#160; </div>
<div class="line"><a name="l04032"></a><span class="lineno"> 4032</span>&#160; </div>
<div class="line"><a name="l04033"></a><span class="lineno"> 4033</span>&#160; </div>
<div class="line"><a name="l04034"></a><span class="lineno"> 4034</span>&#160;        <span class="keyword">inline</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a> block_limits() const PLF_NOEXCEPT</div>
<div class="line"><a name="l04035"></a><span class="lineno"> 4035</span>&#160;        {</div>
<div class="line"><a name="l04036"></a><span class="lineno"> 4036</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="structplf_1_1colony__limits.html">plf::colony_limits</a>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(tuple_allocator_pair.min_group_capacity), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(group_allocator_pair.max_group_capacity));</div>
<div class="line"><a name="l04037"></a><span class="lineno"> 4037</span>&#160;        }</div>
<div class="line"><a name="l04038"></a><span class="lineno"> 4038</span>&#160; </div>
<div class="line"><a name="l04039"></a><span class="lineno"> 4039</span>&#160; </div>
<div class="line"><a name="l04040"></a><span class="lineno"> 4040</span>&#160; </div>
<div class="line"><a name="l04041"></a><span class="lineno"> 4041</span>&#160;        <span class="keyword">inline</span> PLF_FORCE_INLINE <span class="keywordtype">void</span> clear() PLF_NOEXCEPT</div>
<div class="line"><a name="l04042"></a><span class="lineno"> 4042</span>&#160;        {</div>
<div class="line"><a name="l04043"></a><span class="lineno"> 4043</span>&#160;            destroy_all_data();</div>
<div class="line"><a name="l04044"></a><span class="lineno"> 4044</span>&#160;            blank();</div>
<div class="line"><a name="l04045"></a><span class="lineno"> 4045</span>&#160;        }</div>
<div class="line"><a name="l04046"></a><span class="lineno"> 4046</span>&#160; </div>
<div class="line"><a name="l04047"></a><span class="lineno"> 4047</span>&#160; </div>
<div class="line"><a name="l04048"></a><span class="lineno"> 4048</span>&#160; </div>
<div class="line"><a name="l04049"></a><span class="lineno"> 4049</span>&#160;        <span class="keyword">inline</span> colony&amp; operator = (<span class="keyword">const</span> colony&amp; source)</div>
<div class="line"><a name="l04050"></a><span class="lineno"> 4050</span>&#160;        {</div>
<div class="line"><a name="l04051"></a><span class="lineno"> 4051</span>&#160;            assert(&amp;source != <span class="keyword">this</span>);</div>
<div class="line"><a name="l04052"></a><span class="lineno"> 4052</span>&#160;            range_assign(source.begin_iterator, source.total_size);</div>
<div class="line"><a name="l04053"></a><span class="lineno"> 4053</span>&#160;            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l04054"></a><span class="lineno"> 4054</span>&#160;        }</div>
<div class="line"><a name="l04055"></a><span class="lineno"> 4055</span>&#160; </div>
<div class="line"><a name="l04056"></a><span class="lineno"> 4056</span>&#160; </div>
<div class="line"><a name="l04057"></a><span class="lineno"> 4057</span>&#160; </div>
<div class="line"><a name="l04058"></a><span class="lineno"> 4058</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l04059"></a><span class="lineno"> 4059</span>&#160;        <span class="comment">// Move assignment</span></div>
<div class="line"><a name="l04060"></a><span class="lineno"> 4060</span>&#160;        colony&amp; operator = (colony&amp;&amp; source) PLF_NOEXCEPT_MOVE_ASSIGN(allocator_type)</div>
<div class="line"><a name="l04061"></a><span class="lineno"> 4061</span>&#160;        {</div>
<div class="line"><a name="l04062"></a><span class="lineno"> 4062</span>&#160;            assert(&amp;source != <span class="keyword">this</span>);</div>
<div class="line"><a name="l04063"></a><span class="lineno"> 4063</span>&#160;            destroy_all_data();</div>
<div class="line"><a name="l04064"></a><span class="lineno"> 4064</span>&#160; </div>
<div class="line"><a name="l04065"></a><span class="lineno"> 4065</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l04066"></a><span class="lineno"> 4066</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_trivial&lt;group_pointer_type&gt;::value &amp;&amp; std::is_trivial&lt;aligned_pointer_type&gt;::value &amp;&amp; std::is_trivial&lt;skipfield_pointer_type&gt;::value)</div>
<div class="line"><a name="l04067"></a><span class="lineno"> 4067</span>&#160;            {</div>
<div class="line"><a name="l04068"></a><span class="lineno"> 4068</span>&#160;                std::memcpy(<span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>), &amp;source, <span class="keyword">sizeof</span>(colony));</div>
<div class="line"><a name="l04069"></a><span class="lineno"> 4069</span>&#160;            }</div>
<div class="line"><a name="l04070"></a><span class="lineno"> 4070</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l04071"></a><span class="lineno"> 4071</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04072"></a><span class="lineno"> 4072</span>&#160;            {</div>
<div class="line"><a name="l04073"></a><span class="lineno"> 4073</span>&#160;                end_iterator = std::move(source.end_iterator);</div>
<div class="line"><a name="l04074"></a><span class="lineno"> 4074</span>&#160;                begin_iterator = std::move(source.begin_iterator);</div>
<div class="line"><a name="l04075"></a><span class="lineno"> 4075</span>&#160;                groups_with_erasures_list_head = std::move(source.groups_with_erasures_list_head);</div>
<div class="line"><a name="l04076"></a><span class="lineno"> 4076</span>&#160;                unused_groups_head = std::move(source.unused_groups_head);</div>
<div class="line"><a name="l04077"></a><span class="lineno"> 4077</span>&#160;                total_size = source.total_size;</div>
<div class="line"><a name="l04078"></a><span class="lineno"> 4078</span>&#160;                total_capacity = source.total_capacity;</div>
<div class="line"><a name="l04079"></a><span class="lineno"> 4079</span>&#160;                tuple_allocator_pair.min_group_capacity = source.tuple_allocator_pair.min_group_capacity;</div>
<div class="line"><a name="l04080"></a><span class="lineno"> 4080</span>&#160;                group_allocator_pair.max_group_capacity = source.group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l04081"></a><span class="lineno"> 4081</span>&#160;            }</div>
<div class="line"><a name="l04082"></a><span class="lineno"> 4082</span>&#160; </div>
<div class="line"><a name="l04083"></a><span class="lineno"> 4083</span>&#160;            source.blank();</div>
<div class="line"><a name="l04084"></a><span class="lineno"> 4084</span>&#160;            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l04085"></a><span class="lineno"> 4085</span>&#160;        }</div>
<div class="line"><a name="l04086"></a><span class="lineno"> 4086</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04087"></a><span class="lineno"> 4087</span>&#160; </div>
<div class="line"><a name="l04088"></a><span class="lineno"> 4088</span>&#160; </div>
<div class="line"><a name="l04089"></a><span class="lineno"> 4089</span>&#160; </div>
<div class="line"><a name="l04090"></a><span class="lineno"> 4090</span>&#160;<span class="preprocessor">#ifdef PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l04091"></a><span class="lineno"> 4091</span>&#160;        <span class="keyword">inline</span> colony&amp; operator = (<span class="keyword">const</span> std::initializer_list&lt;element_type&gt;&amp; element_list)</div>
<div class="line"><a name="l04092"></a><span class="lineno"> 4092</span>&#160;        {</div>
<div class="line"><a name="l04093"></a><span class="lineno"> 4093</span>&#160;            range_assign(element_list.begin(), <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(element_list.size()));</div>
<div class="line"><a name="l04094"></a><span class="lineno"> 4094</span>&#160;            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l04095"></a><span class="lineno"> 4095</span>&#160;        }</div>
<div class="line"><a name="l04096"></a><span class="lineno"> 4096</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04097"></a><span class="lineno"> 4097</span>&#160; </div>
<div class="line"><a name="l04098"></a><span class="lineno"> 4098</span>&#160; </div>
<div class="line"><a name="l04099"></a><span class="lineno"> 4099</span>&#160; </div>
<div class="line"><a name="l04100"></a><span class="lineno"> 4100</span>&#160;        <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> colony&amp; lh, <span class="keyword">const</span> colony&amp; rh)</div>
<div class="line"><a name="l04101"></a><span class="lineno"> 4101</span>&#160;        {</div>
<div class="line"><a name="l04102"></a><span class="lineno"> 4102</span>&#160;            <span class="keywordflow">if</span> (lh.total_size != rh.total_size)</div>
<div class="line"><a name="l04103"></a><span class="lineno"> 4103</span>&#160;            {</div>
<div class="line"><a name="l04104"></a><span class="lineno"> 4104</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l04105"></a><span class="lineno"> 4105</span>&#160;            }</div>
<div class="line"><a name="l04106"></a><span class="lineno"> 4106</span>&#160; </div>
<div class="line"><a name="l04107"></a><span class="lineno"> 4107</span>&#160;            <span class="keywordflow">for</span> (const_iterator lh_iterator = lh.begin_iterator, rh_iterator = rh.begin_iterator; lh_iterator != lh.end_iterator; ++lh_iterator, ++rh_iterator)</div>
<div class="line"><a name="l04108"></a><span class="lineno"> 4108</span>&#160;            {</div>
<div class="line"><a name="l04109"></a><span class="lineno"> 4109</span>&#160;                <span class="keywordflow">if</span> (*lh_iterator != *rh_iterator)</div>
<div class="line"><a name="l04110"></a><span class="lineno"> 4110</span>&#160;                {</div>
<div class="line"><a name="l04111"></a><span class="lineno"> 4111</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l04112"></a><span class="lineno"> 4112</span>&#160;                }</div>
<div class="line"><a name="l04113"></a><span class="lineno"> 4113</span>&#160;            }</div>
<div class="line"><a name="l04114"></a><span class="lineno"> 4114</span>&#160; </div>
<div class="line"><a name="l04115"></a><span class="lineno"> 4115</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l04116"></a><span class="lineno"> 4116</span>&#160;        }</div>
<div class="line"><a name="l04117"></a><span class="lineno"> 4117</span>&#160; </div>
<div class="line"><a name="l04118"></a><span class="lineno"> 4118</span>&#160; </div>
<div class="line"><a name="l04119"></a><span class="lineno"> 4119</span>&#160; </div>
<div class="line"><a name="l04120"></a><span class="lineno"> 4120</span>&#160;        <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> colony&amp; lh, <span class="keyword">const</span> colony&amp; rh)</div>
<div class="line"><a name="l04121"></a><span class="lineno"> 4121</span>&#160;        {</div>
<div class="line"><a name="l04122"></a><span class="lineno"> 4122</span>&#160;            <span class="keywordflow">return</span> !(lh == rh);</div>
<div class="line"><a name="l04123"></a><span class="lineno"> 4123</span>&#160;        }</div>
<div class="line"><a name="l04124"></a><span class="lineno"> 4124</span>&#160; </div>
<div class="line"><a name="l04125"></a><span class="lineno"> 4125</span>&#160; </div>
<div class="line"><a name="l04126"></a><span class="lineno"> 4126</span>&#160; </div>
<div class="line"><a name="l04127"></a><span class="lineno"> 4127</span>&#160;        <span class="keywordtype">void</span> shrink_to_fit()</div>
<div class="line"><a name="l04128"></a><span class="lineno"> 4128</span>&#160;        {</div>
<div class="line"><a name="l04129"></a><span class="lineno"> 4129</span>&#160;            <span class="keywordflow">if</span> (total_size == total_capacity)</div>
<div class="line"><a name="l04130"></a><span class="lineno"> 4130</span>&#160;            {</div>
<div class="line"><a name="l04131"></a><span class="lineno"> 4131</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l04132"></a><span class="lineno"> 4132</span>&#160;            }</div>
<div class="line"><a name="l04133"></a><span class="lineno"> 4133</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (total_size == 0)</div>
<div class="line"><a name="l04134"></a><span class="lineno"> 4134</span>&#160;            {</div>
<div class="line"><a name="l04135"></a><span class="lineno"> 4135</span>&#160;                clear();</div>
<div class="line"><a name="l04136"></a><span class="lineno"> 4136</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l04137"></a><span class="lineno"> 4137</span>&#160;            }</div>
<div class="line"><a name="l04138"></a><span class="lineno"> 4138</span>&#160; </div>
<div class="line"><a name="l04139"></a><span class="lineno"> 4139</span>&#160;            consolidate();</div>
<div class="line"><a name="l04140"></a><span class="lineno"> 4140</span>&#160;        }</div>
<div class="line"><a name="l04141"></a><span class="lineno"> 4141</span>&#160; </div>
<div class="line"><a name="l04142"></a><span class="lineno"> 4142</span>&#160; </div>
<div class="line"><a name="l04143"></a><span class="lineno"> 4143</span>&#160; </div>
<div class="line"><a name="l04144"></a><span class="lineno"> 4144</span>&#160;        <span class="keywordtype">void</span> trim() PLF_NOEXCEPT</div>
<div class="line"><a name="l04145"></a><span class="lineno"> 4145</span>&#160;        {</div>
<div class="line"><a name="l04146"></a><span class="lineno"> 4146</span>&#160;            <span class="keywordflow">while</span> (unused_groups_head != NULL)</div>
<div class="line"><a name="l04147"></a><span class="lineno"> 4147</span>&#160;            {</div>
<div class="line"><a name="l04148"></a><span class="lineno"> 4148</span>&#160;                total_capacity -= unused_groups_head-&gt;capacity;</div>
<div class="line"><a name="l04149"></a><span class="lineno"> 4149</span>&#160;                <span class="keyword">const</span> group_pointer_type next_group = unused_groups_head-&gt;next_group;</div>
<div class="line"><a name="l04150"></a><span class="lineno"> 4150</span>&#160;                deallocate_group(unused_groups_head);</div>
<div class="line"><a name="l04151"></a><span class="lineno"> 4151</span>&#160;                unused_groups_head = next_group;</div>
<div class="line"><a name="l04152"></a><span class="lineno"> 4152</span>&#160;            }</div>
<div class="line"><a name="l04153"></a><span class="lineno"> 4153</span>&#160;        }</div>
<div class="line"><a name="l04154"></a><span class="lineno"> 4154</span>&#160; </div>
<div class="line"><a name="l04155"></a><span class="lineno"> 4155</span>&#160; </div>
<div class="line"><a name="l04156"></a><span class="lineno"> 4156</span>&#160; </div>
<div class="line"><a name="l04157"></a><span class="lineno"> 4157</span>&#160;        <span class="keywordtype">void</span> reserve(size_type new_capacity)</div>
<div class="line"><a name="l04158"></a><span class="lineno"> 4158</span>&#160;        {</div>
<div class="line"><a name="l04159"></a><span class="lineno"> 4159</span>&#160;            <span class="keywordflow">if</span> (new_capacity == 0 || new_capacity &lt;= total_capacity) <span class="comment">// We already have enough space allocated</span></div>
<div class="line"><a name="l04160"></a><span class="lineno"> 4160</span>&#160;            {</div>
<div class="line"><a name="l04161"></a><span class="lineno"> 4161</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l04162"></a><span class="lineno"> 4162</span>&#160;            }</div>
<div class="line"><a name="l04163"></a><span class="lineno"> 4163</span>&#160; </div>
<div class="line"><a name="l04164"></a><span class="lineno"> 4164</span>&#160;            <span class="keywordflow">if</span> (new_capacity &gt; max_size())</div>
<div class="line"><a name="l04165"></a><span class="lineno"> 4165</span>&#160;            {</div>
<div class="line"><a name="l04166"></a><span class="lineno"> 4166</span>&#160;                <span class="keywordflow">throw</span> std::length_error(<span class="stringliteral">&quot;Capacity requested via reserve() greater than max_size()&quot;</span>);</div>
<div class="line"><a name="l04167"></a><span class="lineno"> 4167</span>&#160;            }</div>
<div class="line"><a name="l04168"></a><span class="lineno"> 4168</span>&#160; </div>
<div class="line"><a name="l04169"></a><span class="lineno"> 4169</span>&#160;            new_capacity -= total_capacity;</div>
<div class="line"><a name="l04170"></a><span class="lineno"> 4170</span>&#160; </div>
<div class="line"><a name="l04171"></a><span class="lineno"> 4171</span>&#160;            size_type number_of_max_groups = new_capacity / group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l04172"></a><span class="lineno"> 4172</span>&#160;            skipfield_type remainder = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(new_capacity - (number_of_max_groups * group_allocator_pair.max_group_capacity));</div>
<div class="line"><a name="l04173"></a><span class="lineno"> 4173</span>&#160; </div>
<div class="line"><a name="l04174"></a><span class="lineno"> 4174</span>&#160; </div>
<div class="line"><a name="l04175"></a><span class="lineno"> 4175</span>&#160;            <span class="keywordflow">if</span> (remainder == 0)</div>
<div class="line"><a name="l04176"></a><span class="lineno"> 4176</span>&#160;            {</div>
<div class="line"><a name="l04177"></a><span class="lineno"> 4177</span>&#160;                remainder = group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l04178"></a><span class="lineno"> 4178</span>&#160;                --number_of_max_groups;</div>
<div class="line"><a name="l04179"></a><span class="lineno"> 4179</span>&#160;            }</div>
<div class="line"><a name="l04180"></a><span class="lineno"> 4180</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (remainder &lt; tuple_allocator_pair.min_group_capacity)</div>
<div class="line"><a name="l04181"></a><span class="lineno"> 4181</span>&#160;            {</div>
<div class="line"><a name="l04182"></a><span class="lineno"> 4182</span>&#160;                remainder = tuple_allocator_pair.min_group_capacity;</div>
<div class="line"><a name="l04183"></a><span class="lineno"> 4183</span>&#160;            }</div>
<div class="line"><a name="l04184"></a><span class="lineno"> 4184</span>&#160; </div>
<div class="line"><a name="l04185"></a><span class="lineno"> 4185</span>&#160; </div>
<div class="line"><a name="l04186"></a><span class="lineno"> 4186</span>&#160;            group_pointer_type current_group, first_unused_group;</div>
<div class="line"><a name="l04187"></a><span class="lineno"> 4187</span>&#160; </div>
<div class="line"><a name="l04188"></a><span class="lineno"> 4188</span>&#160;            <span class="keywordflow">if</span> (begin_iterator.group_pointer == NULL) <span class="comment">// Most common scenario - empty colony</span></div>
<div class="line"><a name="l04189"></a><span class="lineno"> 4189</span>&#160;            {</div>
<div class="line"><a name="l04190"></a><span class="lineno"> 4190</span>&#160;                initialize(remainder);</div>
<div class="line"><a name="l04191"></a><span class="lineno"> 4191</span>&#160;                begin_iterator.group_pointer-&gt;last_endpoint = begin_iterator.group_pointer-&gt;elements; <span class="comment">// last_endpoint initially == elements + 1 via default constructor</span></div>
<div class="line"><a name="l04192"></a><span class="lineno"> 4192</span>&#160;                begin_iterator.group_pointer-&gt;size = 0; <span class="comment">// 1 by default</span></div>
<div class="line"><a name="l04193"></a><span class="lineno"> 4193</span>&#160; </div>
<div class="line"><a name="l04194"></a><span class="lineno"> 4194</span>&#160;                <span class="keywordflow">if</span> (number_of_max_groups == 0)</div>
<div class="line"><a name="l04195"></a><span class="lineno"> 4195</span>&#160;                {</div>
<div class="line"><a name="l04196"></a><span class="lineno"> 4196</span>&#160;                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l04197"></a><span class="lineno"> 4197</span>&#160;                }</div>
<div class="line"><a name="l04198"></a><span class="lineno"> 4198</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l04199"></a><span class="lineno"> 4199</span>&#160;                {</div>
<div class="line"><a name="l04200"></a><span class="lineno"> 4200</span>&#160;                    first_unused_group = current_group = allocate_new_group(group_allocator_pair.max_group_capacity, begin_iterator.group_pointer);</div>
<div class="line"><a name="l04201"></a><span class="lineno"> 4201</span>&#160;                    total_capacity += group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l04202"></a><span class="lineno"> 4202</span>&#160;                    --number_of_max_groups;</div>
<div class="line"><a name="l04203"></a><span class="lineno"> 4203</span>&#160;                }</div>
<div class="line"><a name="l04204"></a><span class="lineno"> 4204</span>&#160;            }</div>
<div class="line"><a name="l04205"></a><span class="lineno"> 4205</span>&#160;            <span class="keywordflow">else</span> <span class="comment">// Non-empty colony, add first group:</span></div>
<div class="line"><a name="l04206"></a><span class="lineno"> 4206</span>&#160;            {</div>
<div class="line"><a name="l04207"></a><span class="lineno"> 4207</span>&#160;                first_unused_group = current_group = allocate_new_group(remainder, end_iterator.group_pointer);</div>
<div class="line"><a name="l04208"></a><span class="lineno"> 4208</span>&#160;                total_capacity += remainder;</div>
<div class="line"><a name="l04209"></a><span class="lineno"> 4209</span>&#160;            }</div>
<div class="line"><a name="l04210"></a><span class="lineno"> 4210</span>&#160; </div>
<div class="line"><a name="l04211"></a><span class="lineno"> 4211</span>&#160; </div>
<div class="line"><a name="l04212"></a><span class="lineno"> 4212</span>&#160;            <span class="keywordflow">while</span> (number_of_max_groups != 0)</div>
<div class="line"><a name="l04213"></a><span class="lineno"> 4213</span>&#160;            {</div>
<div class="line"><a name="l04214"></a><span class="lineno"> 4214</span>&#160;                <span class="keywordflow">try</span></div>
<div class="line"><a name="l04215"></a><span class="lineno"> 4215</span>&#160;                {</div>
<div class="line"><a name="l04216"></a><span class="lineno"> 4216</span>&#160;                    current_group-&gt;next_group = allocate_new_group(group_allocator_pair.max_group_capacity, current_group);</div>
<div class="line"><a name="l04217"></a><span class="lineno"> 4217</span>&#160;                }</div>
<div class="line"><a name="l04218"></a><span class="lineno"> 4218</span>&#160;                <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l04219"></a><span class="lineno"> 4219</span>&#160;                {</div>
<div class="line"><a name="l04220"></a><span class="lineno"> 4220</span>&#160;                    deallocate_group(current_group-&gt;next_group);</div>
<div class="line"><a name="l04221"></a><span class="lineno"> 4221</span>&#160;                    current_group-&gt;next_group = unused_groups_head;</div>
<div class="line"><a name="l04222"></a><span class="lineno"> 4222</span>&#160;                    unused_groups_head = first_unused_group;</div>
<div class="line"><a name="l04223"></a><span class="lineno"> 4223</span>&#160;                    <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l04224"></a><span class="lineno"> 4224</span>&#160;                }</div>
<div class="line"><a name="l04225"></a><span class="lineno"> 4225</span>&#160; </div>
<div class="line"><a name="l04226"></a><span class="lineno"> 4226</span>&#160;                current_group = current_group-&gt;next_group;</div>
<div class="line"><a name="l04227"></a><span class="lineno"> 4227</span>&#160;                total_capacity += group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l04228"></a><span class="lineno"> 4228</span>&#160;                --number_of_max_groups;</div>
<div class="line"><a name="l04229"></a><span class="lineno"> 4229</span>&#160;            }</div>
<div class="line"><a name="l04230"></a><span class="lineno"> 4230</span>&#160; </div>
<div class="line"><a name="l04231"></a><span class="lineno"> 4231</span>&#160;            current_group-&gt;next_group = unused_groups_head;</div>
<div class="line"><a name="l04232"></a><span class="lineno"> 4232</span>&#160;            unused_groups_head = first_unused_group;</div>
<div class="line"><a name="l04233"></a><span class="lineno"> 4233</span>&#160;        }</div>
<div class="line"><a name="l04234"></a><span class="lineno"> 4234</span>&#160; </div>
<div class="line"><a name="l04235"></a><span class="lineno"> 4235</span>&#160; </div>
<div class="line"><a name="l04236"></a><span class="lineno"> 4236</span>&#160; </div>
<div class="line"><a name="l04237"></a><span class="lineno"> 4237</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l04238"></a><span class="lineno"> 4238</span>&#160; </div>
<div class="line"><a name="l04239"></a><span class="lineno"> 4239</span>&#160;        <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is_const&gt;</div>
<div class="line"><a name="l04240"></a><span class="lineno"> 4240</span>&#160;        colony_iterator&lt;is_const&gt; get_it(<span class="keyword">const</span> pointer element_pointer) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l04241"></a><span class="lineno"> 4241</span>&#160;        {</div>
<div class="line"><a name="l04242"></a><span class="lineno"> 4242</span>&#160;            <span class="keyword">typedef</span> colony_iterator&lt;is_const&gt; iterator_type;</div>
<div class="line"><a name="l04243"></a><span class="lineno"> 4243</span>&#160; </div>
<div class="line"><a name="l04244"></a><span class="lineno"> 4244</span>&#160;            <span class="keywordflow">if</span> (total_size != 0) <span class="comment">// Necessary here to prevent a pointer matching to an empty colony with one memory block retained with the skipfield wiped (see erase())</span></div>
<div class="line"><a name="l04245"></a><span class="lineno"> 4245</span>&#160;            {</div>
<div class="line"><a name="l04246"></a><span class="lineno"> 4246</span>&#160;                <span class="comment">// Start with last group first, as will be the largest group in most cases:</span></div>
<div class="line"><a name="l04247"></a><span class="lineno"> 4247</span>&#160;                <span class="keywordflow">for</span> (group_pointer_type current_group = end_iterator.group_pointer; current_group != NULL; current_group = current_group-&gt;previous_group)</div>
<div class="line"><a name="l04248"></a><span class="lineno"> 4248</span>&#160;                {</div>
<div class="line"><a name="l04249"></a><span class="lineno"> 4249</span>&#160;                    <span class="keywordflow">if</span> (<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(element_pointer) &gt;= current_group-&gt;elements &amp;&amp; <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(element_pointer) &lt; <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(current_group-&gt;skipfield))</div>
<div class="line"><a name="l04250"></a><span class="lineno"> 4250</span>&#160;                    {</div>
<div class="line"><a name="l04251"></a><span class="lineno"> 4251</span>&#160;                        <span class="keyword">const</span> skipfield_pointer_type skipfield_pointer = current_group-&gt;skipfield + (<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(element_pointer) - current_group-&gt;elements);</div>
<div class="line"><a name="l04252"></a><span class="lineno"> 4252</span>&#160;                        <span class="keywordflow">return</span> (*skipfield_pointer == 0) ? iterator_type(current_group, <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(element_pointer), skipfield_pointer) : static_cast&lt;iterator_type&gt;(end_iterator); <span class="comment">// If element has been erased, return end()</span></div>
<div class="line"><a name="l04253"></a><span class="lineno"> 4253</span>&#160;                    }</div>
<div class="line"><a name="l04254"></a><span class="lineno"> 4254</span>&#160;                }</div>
<div class="line"><a name="l04255"></a><span class="lineno"> 4255</span>&#160;            }</div>
<div class="line"><a name="l04256"></a><span class="lineno"> 4256</span>&#160; </div>
<div class="line"><a name="l04257"></a><span class="lineno"> 4257</span>&#160;            <span class="keywordflow">return</span> end_iterator;</div>
<div class="line"><a name="l04258"></a><span class="lineno"> 4258</span>&#160;        }</div>
<div class="line"><a name="l04259"></a><span class="lineno"> 4259</span>&#160; </div>
<div class="line"><a name="l04260"></a><span class="lineno"> 4260</span>&#160; </div>
<div class="line"><a name="l04261"></a><span class="lineno"> 4261</span>&#160; </div>
<div class="line"><a name="l04262"></a><span class="lineno"> 4262</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l04263"></a><span class="lineno"> 4263</span>&#160; </div>
<div class="line"><a name="l04264"></a><span class="lineno"> 4264</span>&#160;        <span class="keyword">inline</span> iterator get_iterator(<span class="keyword">const</span> pointer element_pointer) PLF_NOEXCEPT</div>
<div class="line"><a name="l04265"></a><span class="lineno"> 4265</span>&#160;        {</div>
<div class="line"><a name="l04266"></a><span class="lineno"> 4266</span>&#160;            <span class="keywordflow">return</span> get_it&lt;false&gt;(element_pointer);</div>
<div class="line"><a name="l04267"></a><span class="lineno"> 4267</span>&#160;        }</div>
<div class="line"><a name="l04268"></a><span class="lineno"> 4268</span>&#160; </div>
<div class="line"><a name="l04269"></a><span class="lineno"> 4269</span>&#160; </div>
<div class="line"><a name="l04270"></a><span class="lineno"> 4270</span>&#160; </div>
<div class="line"><a name="l04271"></a><span class="lineno"> 4271</span>&#160;        <span class="keyword">inline</span> const_iterator get_iterator(<span class="keyword">const</span> const_pointer element_pointer) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l04272"></a><span class="lineno"> 4272</span>&#160;        {</div>
<div class="line"><a name="l04273"></a><span class="lineno"> 4273</span>&#160;            <span class="keywordflow">return</span> get_it&lt;true&gt;(<span class="keyword">const_cast&lt;</span>pointer<span class="keyword">&gt;</span>(element_pointer));</div>
<div class="line"><a name="l04274"></a><span class="lineno"> 4274</span>&#160;        }</div>
<div class="line"><a name="l04275"></a><span class="lineno"> 4275</span>&#160; </div>
<div class="line"><a name="l04276"></a><span class="lineno"> 4276</span>&#160; </div>
<div class="line"><a name="l04277"></a><span class="lineno"> 4277</span>&#160; </div>
<div class="line"><a name="l04278"></a><span class="lineno"> 4278</span>&#160;        <span class="keyword">inline</span> allocator_type get_allocator() const PLF_NOEXCEPT</div>
<div class="line"><a name="l04279"></a><span class="lineno"> 4279</span>&#160;        {</div>
<div class="line"><a name="l04280"></a><span class="lineno"> 4280</span>&#160;            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l04281"></a><span class="lineno"> 4281</span>&#160;        }</div>
<div class="line"><a name="l04282"></a><span class="lineno"> 4282</span>&#160; </div>
<div class="line"><a name="l04283"></a><span class="lineno"> 4283</span>&#160; </div>
<div class="line"><a name="l04284"></a><span class="lineno"> 4284</span>&#160; </div>
<div class="line"><a name="l04285"></a><span class="lineno"> 4285</span>&#160;        <span class="keywordtype">void</span> splice(colony&amp; source)</div>
<div class="line"><a name="l04286"></a><span class="lineno"> 4286</span>&#160;        {</div>
<div class="line"><a name="l04287"></a><span class="lineno"> 4287</span>&#160;            <span class="comment">// Process: if there are unused memory spaces at the end of the current back group of the chain, convert them</span></div>
<div class="line"><a name="l04288"></a><span class="lineno"> 4288</span>&#160;            <span class="comment">// to skipped elements and add the locations to the group&#39;s free list.</span></div>
<div class="line"><a name="l04289"></a><span class="lineno"> 4289</span>&#160;            <span class="comment">// Then link the destination&#39;s groups to the source&#39;s groups and nullify the source.</span></div>
<div class="line"><a name="l04290"></a><span class="lineno"> 4290</span>&#160;            <span class="comment">// If the source has more unused memory spaces in the back group than the destination, swap them before processing to reduce the number of locations added to a free list and also subsequent jumps during iteration.</span></div>
<div class="line"><a name="l04291"></a><span class="lineno"> 4291</span>&#160; </div>
<div class="line"><a name="l04292"></a><span class="lineno"> 4292</span>&#160;            assert(&amp;source != <span class="keyword">this</span>);</div>
<div class="line"><a name="l04293"></a><span class="lineno"> 4293</span>&#160; </div>
<div class="line"><a name="l04294"></a><span class="lineno"> 4294</span>&#160;            <span class="keywordflow">if</span> (source.total_size == 0)</div>
<div class="line"><a name="l04295"></a><span class="lineno"> 4295</span>&#160;            {</div>
<div class="line"><a name="l04296"></a><span class="lineno"> 4296</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l04297"></a><span class="lineno"> 4297</span>&#160;            }</div>
<div class="line"><a name="l04298"></a><span class="lineno"> 4298</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (total_size == 0)</div>
<div class="line"><a name="l04299"></a><span class="lineno"> 4299</span>&#160;            {</div>
<div class="line"><a name="l04300"></a><span class="lineno"> 4300</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l04301"></a><span class="lineno"> 4301</span>&#160;                * <span class="keyword">this</span> = std::move(source);</div>
<div class="line"><a name="l04302"></a><span class="lineno"> 4302</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l04303"></a><span class="lineno"> 4303</span>&#160;                clear();</div>
<div class="line"><a name="l04304"></a><span class="lineno"> 4304</span>&#160;                swap(source);</div>
<div class="line"><a name="l04305"></a><span class="lineno"> 4305</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04306"></a><span class="lineno"> 4306</span>&#160; </div>
<div class="line"><a name="l04307"></a><span class="lineno"> 4307</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l04308"></a><span class="lineno"> 4308</span>&#160;            }</div>
<div class="line"><a name="l04309"></a><span class="lineno"> 4309</span>&#160; </div>
<div class="line"><a name="l04310"></a><span class="lineno"> 4310</span>&#160;            <span class="comment">// If there&#39;s more unused element locations in back memory block of destination than in back memory block of source, swap with source to reduce number of skipped elements during iteration, and reduce size of free-list:</span></div>
<div class="line"><a name="l04311"></a><span class="lineno"> 4311</span>&#160;            <span class="keywordflow">if</span> ((<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield) - end_iterator.element_pointer) &gt; (<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(source.end_iterator.group_pointer-&gt;skipfield) - source.end_iterator.element_pointer))</div>
<div class="line"><a name="l04312"></a><span class="lineno"> 4312</span>&#160;            {</div>
<div class="line"><a name="l04313"></a><span class="lineno"> 4313</span>&#160;                swap(source);</div>
<div class="line"><a name="l04314"></a><span class="lineno"> 4314</span>&#160;            }</div>
<div class="line"><a name="l04315"></a><span class="lineno"> 4315</span>&#160; </div>
<div class="line"><a name="l04316"></a><span class="lineno"> 4316</span>&#160; </div>
<div class="line"><a name="l04317"></a><span class="lineno"> 4317</span>&#160;            <span class="comment">// Throw if incompatible group capacity found:</span></div>
<div class="line"><a name="l04318"></a><span class="lineno"> 4318</span>&#160;            <span class="keywordflow">if</span> (source.tuple_allocator_pair.min_group_capacity &lt; tuple_allocator_pair.min_group_capacity || source.group_allocator_pair.max_group_capacity &gt; group_allocator_pair.max_group_capacity)</div>
<div class="line"><a name="l04319"></a><span class="lineno"> 4319</span>&#160;            {</div>
<div class="line"><a name="l04320"></a><span class="lineno"> 4320</span>&#160;                <span class="keywordflow">for</span> (group_pointer_type current_group = source.begin_iterator.group_pointer; current_group != NULL; current_group = current_group-&gt;next_group)</div>
<div class="line"><a name="l04321"></a><span class="lineno"> 4321</span>&#160;                {</div>
<div class="line"><a name="l04322"></a><span class="lineno"> 4322</span>&#160;                    <span class="keywordflow">if</span> (current_group-&gt;capacity &lt; tuple_allocator_pair.min_group_capacity || current_group-&gt;capacity &gt; group_allocator_pair.max_group_capacity)</div>
<div class="line"><a name="l04323"></a><span class="lineno"> 4323</span>&#160;                    {</div>
<div class="line"><a name="l04324"></a><span class="lineno"> 4324</span>&#160;                        <span class="keywordflow">throw</span> std::length_error(<span class="stringliteral">&quot;A source memory block capacity is outside of the destination&#39;s minimum or maximum memory block capacity limits - please change either the source or the destination&#39;s min/max block capacity limits using reshape() before calling splice() in this case&quot;</span>);</div>
<div class="line"><a name="l04325"></a><span class="lineno"> 4325</span>&#160;                    }</div>
<div class="line"><a name="l04326"></a><span class="lineno"> 4326</span>&#160;                }</div>
<div class="line"><a name="l04327"></a><span class="lineno"> 4327</span>&#160;            }</div>
<div class="line"><a name="l04328"></a><span class="lineno"> 4328</span>&#160; </div>
<div class="line"><a name="l04329"></a><span class="lineno"> 4329</span>&#160; </div>
<div class="line"><a name="l04330"></a><span class="lineno"> 4330</span>&#160;            <span class="comment">// Add source list of groups-with-erasures to destination list of groups-with-erasures:</span></div>
<div class="line"><a name="l04331"></a><span class="lineno"> 4331</span>&#160;            <span class="keywordflow">if</span> (source.groups_with_erasures_list_head != NULL)</div>
<div class="line"><a name="l04332"></a><span class="lineno"> 4332</span>&#160;            {</div>
<div class="line"><a name="l04333"></a><span class="lineno"> 4333</span>&#160;                <span class="keywordflow">if</span> (groups_with_erasures_list_head != NULL)</div>
<div class="line"><a name="l04334"></a><span class="lineno"> 4334</span>&#160;                {</div>
<div class="line"><a name="l04335"></a><span class="lineno"> 4335</span>&#160;                    group_pointer_type tail_group = groups_with_erasures_list_head;</div>
<div class="line"><a name="l04336"></a><span class="lineno"> 4336</span>&#160; </div>
<div class="line"><a name="l04337"></a><span class="lineno"> 4337</span>&#160;                    <span class="keywordflow">while</span> (tail_group-&gt;erasures_list_next_group != NULL)</div>
<div class="line"><a name="l04338"></a><span class="lineno"> 4338</span>&#160;                    {</div>
<div class="line"><a name="l04339"></a><span class="lineno"> 4339</span>&#160;                        tail_group = tail_group-&gt;erasures_list_next_group;</div>
<div class="line"><a name="l04340"></a><span class="lineno"> 4340</span>&#160;                    }</div>
<div class="line"><a name="l04341"></a><span class="lineno"> 4341</span>&#160; </div>
<div class="line"><a name="l04342"></a><span class="lineno"> 4342</span>&#160;                    tail_group-&gt;erasures_list_next_group = source.groups_with_erasures_list_head;</div>
<div class="line"><a name="l04343"></a><span class="lineno"> 4343</span>&#160;                }</div>
<div class="line"><a name="l04344"></a><span class="lineno"> 4344</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l04345"></a><span class="lineno"> 4345</span>&#160;                {</div>
<div class="line"><a name="l04346"></a><span class="lineno"> 4346</span>&#160;                    groups_with_erasures_list_head = source.groups_with_erasures_list_head;</div>
<div class="line"><a name="l04347"></a><span class="lineno"> 4347</span>&#160;                }</div>
<div class="line"><a name="l04348"></a><span class="lineno"> 4348</span>&#160;            }</div>
<div class="line"><a name="l04349"></a><span class="lineno"> 4349</span>&#160; </div>
<div class="line"><a name="l04350"></a><span class="lineno"> 4350</span>&#160; </div>
<div class="line"><a name="l04351"></a><span class="lineno"> 4351</span>&#160;            <span class="keyword">const</span> skipfield_type distance_to_end = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield) - end_iterator.element_pointer);</div>
<div class="line"><a name="l04352"></a><span class="lineno"> 4352</span>&#160; </div>
<div class="line"><a name="l04353"></a><span class="lineno"> 4353</span>&#160;            <span class="keywordflow">if</span> (distance_to_end != 0) <span class="comment">// 0 == edge case</span></div>
<div class="line"><a name="l04354"></a><span class="lineno"> 4354</span>&#160;            {    <span class="comment">// Mark unused element memory locations from back group as skipped/erased:</span></div>
<div class="line"><a name="l04355"></a><span class="lineno"> 4355</span>&#160; </div>
<div class="line"><a name="l04356"></a><span class="lineno"> 4356</span>&#160;                <span class="comment">// Update skipfield:</span></div>
<div class="line"><a name="l04357"></a><span class="lineno"> 4357</span>&#160;                <span class="keyword">const</span> skipfield_type previous_node_value = *(end_iterator.skipfield_pointer - 1);</div>
<div class="line"><a name="l04358"></a><span class="lineno"> 4358</span>&#160;                end_iterator.group_pointer-&gt;last_endpoint = <span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;skipfield);</div>
<div class="line"><a name="l04359"></a><span class="lineno"> 4359</span>&#160; </div>
<div class="line"><a name="l04360"></a><span class="lineno"> 4360</span>&#160;                <span class="keywordflow">if</span> (previous_node_value == 0) <span class="comment">// no previous skipblock</span></div>
<div class="line"><a name="l04361"></a><span class="lineno"> 4361</span>&#160;                {</div>
<div class="line"><a name="l04362"></a><span class="lineno"> 4362</span>&#160;                    *end_iterator.skipfield_pointer = distance_to_end;</div>
<div class="line"><a name="l04363"></a><span class="lineno"> 4363</span>&#160;                    *(end_iterator.skipfield_pointer + distance_to_end - 1) = distance_to_end;</div>
<div class="line"><a name="l04364"></a><span class="lineno"> 4364</span>&#160; </div>
<div class="line"><a name="l04365"></a><span class="lineno"> 4365</span>&#160;                    <span class="keyword">const</span> skipfield_type index = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(end_iterator.element_pointer - end_iterator.group_pointer-&gt;elements);</div>
<div class="line"><a name="l04366"></a><span class="lineno"> 4366</span>&#160; </div>
<div class="line"><a name="l04367"></a><span class="lineno"> 4367</span>&#160;                    <span class="keywordflow">if</span> (end_iterator.group_pointer-&gt;free_list_head != std::numeric_limits&lt;skipfield_type&gt;::max()) <span class="comment">// ie. if this group already has some erased elements</span></div>
<div class="line"><a name="l04368"></a><span class="lineno"> 4368</span>&#160;                    {</div>
<div class="line"><a name="l04369"></a><span class="lineno"> 4369</span>&#160;                        *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;elements + end_iterator.group_pointer-&gt;free_list_head) + 1) = index; <span class="comment">// set prev free list head&#39;s &#39;next index&#39; number to the index of the current element</span></div>
<div class="line"><a name="l04370"></a><span class="lineno"> 4370</span>&#160;                    }</div>
<div class="line"><a name="l04371"></a><span class="lineno"> 4371</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l04372"></a><span class="lineno"> 4372</span>&#160;                    {</div>
<div class="line"><a name="l04373"></a><span class="lineno"> 4373</span>&#160;                        end_iterator.group_pointer-&gt;erasures_list_next_group = groups_with_erasures_list_head; <span class="comment">// add it to the groups-with-erasures free list</span></div>
<div class="line"><a name="l04374"></a><span class="lineno"> 4374</span>&#160;                        groups_with_erasures_list_head = end_iterator.group_pointer;</div>
<div class="line"><a name="l04375"></a><span class="lineno"> 4375</span>&#160;                    }</div>
<div class="line"><a name="l04376"></a><span class="lineno"> 4376</span>&#160; </div>
<div class="line"><a name="l04377"></a><span class="lineno"> 4377</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(end_iterator.element_pointer)) = end_iterator.group_pointer-&gt;free_list_head;</div>
<div class="line"><a name="l04378"></a><span class="lineno"> 4378</span>&#160;                    *(<span class="keyword">reinterpret_cast&lt;</span>skipfield_pointer_type<span class="keyword">&gt;</span>(end_iterator.element_pointer) + 1) = std::numeric_limits&lt;skipfield_type&gt;::max();</div>
<div class="line"><a name="l04379"></a><span class="lineno"> 4379</span>&#160;                    end_iterator.group_pointer-&gt;free_list_head = index;</div>
<div class="line"><a name="l04380"></a><span class="lineno"> 4380</span>&#160;                }</div>
<div class="line"><a name="l04381"></a><span class="lineno"> 4381</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l04382"></a><span class="lineno"> 4382</span>&#160;                { <span class="comment">// update previous skipblock, no need to update free list:</span></div>
<div class="line"><a name="l04383"></a><span class="lineno"> 4383</span>&#160;                    *(end_iterator.skipfield_pointer - previous_node_value) = *(end_iterator.skipfield_pointer + distance_to_end - 1) = <span class="keyword">static_cast&lt;</span>skipfield_type<span class="keyword">&gt;</span>(previous_node_value + distance_to_end);</div>
<div class="line"><a name="l04384"></a><span class="lineno"> 4384</span>&#160;                }</div>
<div class="line"><a name="l04385"></a><span class="lineno"> 4385</span>&#160;            }</div>
<div class="line"><a name="l04386"></a><span class="lineno"> 4386</span>&#160; </div>
<div class="line"><a name="l04387"></a><span class="lineno"> 4387</span>&#160; </div>
<div class="line"><a name="l04388"></a><span class="lineno"> 4388</span>&#160;            <span class="comment">// Update subsequent group numbers:</span></div>
<div class="line"><a name="l04389"></a><span class="lineno"> 4389</span>&#160;            group_pointer_type current_group = source.begin_iterator.group_pointer;</div>
<div class="line"><a name="l04390"></a><span class="lineno"> 4390</span>&#160;            size_type current_group_number = end_iterator.group_pointer-&gt;group_number;</div>
<div class="line"><a name="l04391"></a><span class="lineno"> 4391</span>&#160; </div>
<div class="line"><a name="l04392"></a><span class="lineno"> 4392</span>&#160;            <span class="keywordflow">do</span></div>
<div class="line"><a name="l04393"></a><span class="lineno"> 4393</span>&#160;            {</div>
<div class="line"><a name="l04394"></a><span class="lineno"> 4394</span>&#160;                current_group-&gt;group_number = ++current_group_number;</div>
<div class="line"><a name="l04395"></a><span class="lineno"> 4395</span>&#160;                current_group = current_group-&gt;next_group;</div>
<div class="line"><a name="l04396"></a><span class="lineno"> 4396</span>&#160;            } <span class="keywordflow">while</span> (current_group != NULL);</div>
<div class="line"><a name="l04397"></a><span class="lineno"> 4397</span>&#160; </div>
<div class="line"><a name="l04398"></a><span class="lineno"> 4398</span>&#160; </div>
<div class="line"><a name="l04399"></a><span class="lineno"> 4399</span>&#160;            <span class="comment">// Join the destination and source group chains:</span></div>
<div class="line"><a name="l04400"></a><span class="lineno"> 4400</span>&#160;            end_iterator.group_pointer-&gt;next_group = source.begin_iterator.group_pointer;</div>
<div class="line"><a name="l04401"></a><span class="lineno"> 4401</span>&#160;            source.begin_iterator.group_pointer-&gt;previous_group = end_iterator.group_pointer;</div>
<div class="line"><a name="l04402"></a><span class="lineno"> 4402</span>&#160;            end_iterator = source.end_iterator;</div>
<div class="line"><a name="l04403"></a><span class="lineno"> 4403</span>&#160;            total_size += source.total_size;</div>
<div class="line"><a name="l04404"></a><span class="lineno"> 4404</span>&#160;            total_capacity += source.total_capacity;</div>
<div class="line"><a name="l04405"></a><span class="lineno"> 4405</span>&#160; </div>
<div class="line"><a name="l04406"></a><span class="lineno"> 4406</span>&#160;            <span class="comment">// Remove source unused groups:</span></div>
<div class="line"><a name="l04407"></a><span class="lineno"> 4407</span>&#160;            source.trim();</div>
<div class="line"><a name="l04408"></a><span class="lineno"> 4408</span>&#160;            source.blank();</div>
<div class="line"><a name="l04409"></a><span class="lineno"> 4409</span>&#160;        }</div>
<div class="line"><a name="l04410"></a><span class="lineno"> 4410</span>&#160; </div>
<div class="line"><a name="l04411"></a><span class="lineno"> 4411</span>&#160; </div>
<div class="line"><a name="l04412"></a><span class="lineno"> 4412</span>&#160; </div>
<div class="line"><a name="l04413"></a><span class="lineno"> 4413</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l04414"></a><span class="lineno"> 4414</span>&#160; </div>
<div class="line"><a name="l04415"></a><span class="lineno"> 4415</span>&#160;        <span class="keyword">struct </span>less</div>
<div class="line"><a name="l04416"></a><span class="lineno"> 4416</span>&#160;        {</div>
<div class="line"><a name="l04417"></a><span class="lineno"> 4417</span>&#160;            <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> element_type&amp; a, <span class="keyword">const</span> element_type&amp; b) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l04418"></a><span class="lineno"> 4418</span>&#160;            {</div>
<div class="line"><a name="l04419"></a><span class="lineno"> 4419</span>&#160;                <span class="keywordflow">return</span> a &lt; b;</div>
<div class="line"><a name="l04420"></a><span class="lineno"> 4420</span>&#160;            }</div>
<div class="line"><a name="l04421"></a><span class="lineno"> 4421</span>&#160;        };</div>
<div class="line"><a name="l04422"></a><span class="lineno"> 4422</span>&#160; </div>
<div class="line"><a name="l04423"></a><span class="lineno"> 4423</span>&#160; </div>
<div class="line"><a name="l04424"></a><span class="lineno"> 4424</span>&#160; </div>
<div class="line"><a name="l04425"></a><span class="lineno"> 4425</span>&#160;        <span class="keyword">struct </span>item_index_tuple</div>
<div class="line"><a name="l04426"></a><span class="lineno"> 4426</span>&#160;        {</div>
<div class="line"><a name="l04427"></a><span class="lineno"> 4427</span>&#160;            pointer original_location;</div>
<div class="line"><a name="l04428"></a><span class="lineno"> 4428</span>&#160;            size_type original_index;</div>
<div class="line"><a name="l04429"></a><span class="lineno"> 4429</span>&#160; </div>
<div class="line"><a name="l04430"></a><span class="lineno"> 4430</span>&#160;            item_index_tuple(<span class="keyword">const</span> pointer _item, <span class="keyword">const</span> size_type _index) PLF_NOEXCEPT:</div>
<div class="line"><a name="l04431"></a><span class="lineno"> 4431</span>&#160;            original_location(_item),</div>
<div class="line"><a name="l04432"></a><span class="lineno"> 4432</span>&#160;                original_index(_index)</div>
<div class="line"><a name="l04433"></a><span class="lineno"> 4433</span>&#160;            {}</div>
<div class="line"><a name="l04434"></a><span class="lineno"> 4434</span>&#160;        };</div>
<div class="line"><a name="l04435"></a><span class="lineno"> 4435</span>&#160; </div>
<div class="line"><a name="l04436"></a><span class="lineno"> 4436</span>&#160; </div>
<div class="line"><a name="l04437"></a><span class="lineno"> 4437</span>&#160; </div>
<div class="line"><a name="l04438"></a><span class="lineno"> 4438</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> comparison_function&gt;</div>
<div class="line"><a name="l04439"></a><span class="lineno"> 4439</span>&#160;        <span class="keyword">struct </span>sort_dereferencer</div>
<div class="line"><a name="l04440"></a><span class="lineno"> 4440</span>&#160;        {</div>
<div class="line"><a name="l04441"></a><span class="lineno"> 4441</span>&#160;            comparison_function stored_instance;</div>
<div class="line"><a name="l04442"></a><span class="lineno"> 4442</span>&#160; </div>
<div class="line"><a name="l04443"></a><span class="lineno"> 4443</span>&#160;            <span class="keyword">explicit</span> sort_dereferencer(<span class="keyword">const</span> comparison_function&amp; function_instance) :</div>
<div class="line"><a name="l04444"></a><span class="lineno"> 4444</span>&#160;                stored_instance(function_instance)</div>
<div class="line"><a name="l04445"></a><span class="lineno"> 4445</span>&#160;            {}</div>
<div class="line"><a name="l04446"></a><span class="lineno"> 4446</span>&#160; </div>
<div class="line"><a name="l04447"></a><span class="lineno"> 4447</span>&#160;            <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> item_index_tuple first, <span class="keyword">const</span> item_index_tuple second)</div>
<div class="line"><a name="l04448"></a><span class="lineno"> 4448</span>&#160;            {</div>
<div class="line"><a name="l04449"></a><span class="lineno"> 4449</span>&#160;                <span class="keywordflow">return</span> stored_instance(*(first.original_location), *(second.original_location));</div>
<div class="line"><a name="l04450"></a><span class="lineno"> 4450</span>&#160;            }</div>
<div class="line"><a name="l04451"></a><span class="lineno"> 4451</span>&#160;        };</div>
<div class="line"><a name="l04452"></a><span class="lineno"> 4452</span>&#160; </div>
<div class="line"><a name="l04453"></a><span class="lineno"> 4453</span>&#160; </div>
<div class="line"><a name="l04454"></a><span class="lineno"> 4454</span>&#160; </div>
<div class="line"><a name="l04455"></a><span class="lineno"> 4455</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l04456"></a><span class="lineno"> 4456</span>&#160; </div>
<div class="line"><a name="l04457"></a><span class="lineno"> 4457</span>&#160; </div>
<div class="line"><a name="l04458"></a><span class="lineno"> 4458</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> comparison_function&gt;</div>
<div class="line"><a name="l04459"></a><span class="lineno"> 4459</span>&#160;        <span class="keywordtype">void</span> sort(comparison_function compare)</div>
<div class="line"><a name="l04460"></a><span class="lineno"> 4460</span>&#160;        {</div>
<div class="line"><a name="l04461"></a><span class="lineno"> 4461</span>&#160;            <span class="keywordflow">if</span> (total_size &lt; 2)</div>
<div class="line"><a name="l04462"></a><span class="lineno"> 4462</span>&#160;            {</div>
<div class="line"><a name="l04463"></a><span class="lineno"> 4463</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l04464"></a><span class="lineno"> 4464</span>&#160;            }</div>
<div class="line"><a name="l04465"></a><span class="lineno"> 4465</span>&#160; </div>
<div class="line"><a name="l04466"></a><span class="lineno"> 4466</span>&#160;            tuple_pointer_type <span class="keyword">const</span> sort_array = PLF_ALLOCATE(tuple_allocator_type, tuple_allocator_pair, total_size, NULL);</div>
<div class="line"><a name="l04467"></a><span class="lineno"> 4467</span>&#160;            tuple_pointer_type tuple_pointer = sort_array;</div>
<div class="line"><a name="l04468"></a><span class="lineno"> 4468</span>&#160; </div>
<div class="line"><a name="l04469"></a><span class="lineno"> 4469</span>&#160;            <span class="comment">// Construct pointers to all elements in the sequence:</span></div>
<div class="line"><a name="l04470"></a><span class="lineno"> 4470</span>&#160;            size_type index = 0;</div>
<div class="line"><a name="l04471"></a><span class="lineno"> 4471</span>&#160; </div>
<div class="line"><a name="l04472"></a><span class="lineno"> 4472</span>&#160;            <span class="keywordflow">for</span> (iterator current_element = begin_iterator; current_element != end_iterator; ++current_element, ++tuple_pointer, ++index)</div>
<div class="line"><a name="l04473"></a><span class="lineno"> 4473</span>&#160;            {</div>
<div class="line"><a name="l04474"></a><span class="lineno"> 4474</span>&#160;<span class="preprocessor">#ifdef PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l04475"></a><span class="lineno"> 4475</span>&#160;                PLF_CONSTRUCT(tuple_allocator_type, tuple_allocator_pair, tuple_pointer, &amp;*current_element, index);</div>
<div class="line"><a name="l04476"></a><span class="lineno"> 4476</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l04477"></a><span class="lineno"> 4477</span>&#160;                PLF_CONSTRUCT(tuple_allocator_type, tuple_allocator_pair, tuple_pointer, item_index_tuple(&amp;*current_element, index));</div>
<div class="line"><a name="l04478"></a><span class="lineno"> 4478</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04479"></a><span class="lineno"> 4479</span>&#160;            }</div>
<div class="line"><a name="l04480"></a><span class="lineno"> 4480</span>&#160; </div>
<div class="line"><a name="l04481"></a><span class="lineno"> 4481</span>&#160;            <span class="comment">// Now, sort the pointers by the values they point to (std::sort is default sort function if the macro below is not defined):</span></div>
<div class="line"><a name="l04482"></a><span class="lineno"> 4482</span>&#160;<span class="preprocessor">#ifndef PLF_SORT_FUNCTION</span></div>
<div class="line"><a name="l04483"></a><span class="lineno"> 4483</span>&#160;            std::sort(sort_array, sort_array + total_size, sort_dereferencer&lt;comparison_function&gt;(compare));</div>
<div class="line"><a name="l04484"></a><span class="lineno"> 4484</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l04485"></a><span class="lineno"> 4485</span>&#160;            PLF_SORT_FUNCTION(sort_array, sort_array + total_size, sort_dereferencer&lt;comparison_function&gt;(compare));</div>
<div class="line"><a name="l04486"></a><span class="lineno"> 4486</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04487"></a><span class="lineno"> 4487</span>&#160; </div>
<div class="line"><a name="l04488"></a><span class="lineno"> 4488</span>&#160;            <span class="comment">// Sort the actual elements via the tuple array:</span></div>
<div class="line"><a name="l04489"></a><span class="lineno"> 4489</span>&#160;            index = 0;</div>
<div class="line"><a name="l04490"></a><span class="lineno"> 4490</span>&#160; </div>
<div class="line"><a name="l04491"></a><span class="lineno"> 4491</span>&#160;            <span class="keywordflow">for</span> (tuple_pointer_type current_tuple = sort_array; current_tuple != tuple_pointer; ++current_tuple, ++index)</div>
<div class="line"><a name="l04492"></a><span class="lineno"> 4492</span>&#160;            {</div>
<div class="line"><a name="l04493"></a><span class="lineno"> 4493</span>&#160;                <span class="keywordflow">if</span> (current_tuple-&gt;original_index != index)</div>
<div class="line"><a name="l04494"></a><span class="lineno"> 4494</span>&#160;                {</div>
<div class="line"><a name="l04495"></a><span class="lineno"> 4495</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l04496"></a><span class="lineno"> 4496</span>&#160;                    element_type end_value = std::move(*(current_tuple-&gt;original_location));</div>
<div class="line"><a name="l04497"></a><span class="lineno"> 4497</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l04498"></a><span class="lineno"> 4498</span>&#160;                    element_type end_value = *(current_tuple-&gt;original_location);</div>
<div class="line"><a name="l04499"></a><span class="lineno"> 4499</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04500"></a><span class="lineno"> 4500</span>&#160; </div>
<div class="line"><a name="l04501"></a><span class="lineno"> 4501</span>&#160;                    size_type destination_index = index;</div>
<div class="line"><a name="l04502"></a><span class="lineno"> 4502</span>&#160;                    size_type source_index = current_tuple-&gt;original_index;</div>
<div class="line"><a name="l04503"></a><span class="lineno"> 4503</span>&#160; </div>
<div class="line"><a name="l04504"></a><span class="lineno"> 4504</span>&#160;                    <span class="keywordflow">do</span></div>
<div class="line"><a name="l04505"></a><span class="lineno"> 4505</span>&#160;                    {</div>
<div class="line"><a name="l04506"></a><span class="lineno"> 4506</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l04507"></a><span class="lineno"> 4507</span>&#160;                        * (sort_array[destination_index].original_location) = std::move(*(sort_array[source_index].original_location));</div>
<div class="line"><a name="l04508"></a><span class="lineno"> 4508</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l04509"></a><span class="lineno"> 4509</span>&#160;                        * (sort_array[destination_index].original_location) = *(sort_array[source_index].original_location);</div>
<div class="line"><a name="l04510"></a><span class="lineno"> 4510</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04511"></a><span class="lineno"> 4511</span>&#160; </div>
<div class="line"><a name="l04512"></a><span class="lineno"> 4512</span>&#160;                        destination_index = source_index;</div>
<div class="line"><a name="l04513"></a><span class="lineno"> 4513</span>&#160;                        source_index = sort_array[destination_index].original_index;</div>
<div class="line"><a name="l04514"></a><span class="lineno"> 4514</span>&#160;                        sort_array[destination_index].original_index = destination_index;</div>
<div class="line"><a name="l04515"></a><span class="lineno"> 4515</span>&#160;                    } <span class="keywordflow">while</span> (source_index != index);</div>
<div class="line"><a name="l04516"></a><span class="lineno"> 4516</span>&#160; </div>
<div class="line"><a name="l04517"></a><span class="lineno"> 4517</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l04518"></a><span class="lineno"> 4518</span>&#160;                    * (sort_array[destination_index].original_location) = std::move(end_value);</div>
<div class="line"><a name="l04519"></a><span class="lineno"> 4519</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l04520"></a><span class="lineno"> 4520</span>&#160;                    * (sort_array[destination_index].original_location) = end_value;</div>
<div class="line"><a name="l04521"></a><span class="lineno"> 4521</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04522"></a><span class="lineno"> 4522</span>&#160;                }</div>
<div class="line"><a name="l04523"></a><span class="lineno"> 4523</span>&#160;            }</div>
<div class="line"><a name="l04524"></a><span class="lineno"> 4524</span>&#160; </div>
<div class="line"><a name="l04525"></a><span class="lineno"> 4525</span>&#160;            PLF_DEALLOCATE(tuple_allocator_type, tuple_allocator_pair, sort_array, total_size);</div>
<div class="line"><a name="l04526"></a><span class="lineno"> 4526</span>&#160;        }</div>
<div class="line"><a name="l04527"></a><span class="lineno"> 4527</span>&#160; </div>
<div class="line"><a name="l04528"></a><span class="lineno"> 4528</span>&#160; </div>
<div class="line"><a name="l04529"></a><span class="lineno"> 4529</span>&#160; </div>
<div class="line"><a name="l04530"></a><span class="lineno"> 4530</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> sort()</div>
<div class="line"><a name="l04531"></a><span class="lineno"> 4531</span>&#160;        {</div>
<div class="line"><a name="l04532"></a><span class="lineno"> 4532</span>&#160;            sort(less());</div>
<div class="line"><a name="l04533"></a><span class="lineno"> 4533</span>&#160;        }</div>
<div class="line"><a name="l04534"></a><span class="lineno"> 4534</span>&#160; </div>
<div class="line"><a name="l04535"></a><span class="lineno"> 4535</span>&#160; </div>
<div class="line"><a name="l04536"></a><span class="lineno"> 4536</span>&#160; </div>
<div class="line"><a name="l04537"></a><span class="lineno"><a class="line" href="structplf_1_1colony_1_1colony__data.html"> 4537</a></span>&#160;        <span class="keyword">struct </span><a class="code" href="structplf_1_1colony_1_1colony__data.html">colony_data</a> : <span class="keyword">public</span> uchar_allocator_type</div>
<div class="line"><a name="l04538"></a><span class="lineno"> 4538</span>&#160;        {</div>
<div class="line"><a name="l04539"></a><span class="lineno"> 4539</span>&#160;            aligned_pointer_type* <span class="keyword">const</span> block_pointers;             <span class="comment">// array of pointers to element memory blocks</span></div>
<div class="line"><a name="l04540"></a><span class="lineno"> 4540</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** <span class="keyword">const</span> bitfield_pointers;                <span class="comment">// array of pointers to bitfields in the form of unsigned char arrays representing whether an element is erased or not (0 for erased).</span></div>
<div class="line"><a name="l04541"></a><span class="lineno"> 4541</span>&#160;            <span class="keywordtype">size_t</span>* <span class="keyword">const</span> block_capacities;                             <span class="comment">// array of the number of elements in each memory block</span></div>
<div class="line"><a name="l04542"></a><span class="lineno"> 4542</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_blocks;                              <span class="comment">// size of each of the arrays above</span></div>
<div class="line"><a name="l04543"></a><span class="lineno"> 4543</span>&#160; </div>
<div class="line"><a name="l04544"></a><span class="lineno"> 4544</span>&#160; </div>
<div class="line"><a name="l04545"></a><span class="lineno"> 4545</span>&#160;            <a class="code" href="structplf_1_1colony_1_1colony__data.html">colony_data</a>(<span class="keyword">const</span> size_type size) :</div>
<div class="line"><a name="l04546"></a><span class="lineno"> 4546</span>&#160;                block_pointers(<span class="keyword">reinterpret_cast&lt;</span>aligned_pointer_type*<span class="keyword">&gt;</span>(PLF_ALLOCATE(uchar_allocator_type, *<span class="keyword">this</span>, size * <span class="keyword">sizeof</span>(aligned_pointer_type), NULL))),</div>
<div class="line"><a name="l04547"></a><span class="lineno"> 4547</span>&#160;                bitfield_pointers(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>**<span class="keyword">&gt;</span>(PLF_ALLOCATE(uchar_allocator_type, *<span class="keyword">this</span>, size * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*), NULL))),</div>
<div class="line"><a name="l04548"></a><span class="lineno"> 4548</span>&#160;                block_capacities(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">size_t</span>*<span class="keyword">&gt;</span>(PLF_ALLOCATE(uchar_allocator_type, *<span class="keyword">this</span>, size * <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), NULL))),</div>
<div class="line"><a name="l04549"></a><span class="lineno"> 4549</span>&#160;                number_of_blocks(size)</div>
<div class="line"><a name="l04550"></a><span class="lineno"> 4550</span>&#160;            {}</div>
<div class="line"><a name="l04551"></a><span class="lineno"> 4551</span>&#160; </div>
<div class="line"><a name="l04552"></a><span class="lineno"> 4552</span>&#160; </div>
<div class="line"><a name="l04553"></a><span class="lineno"> 4553</span>&#160;            ~<a class="code" href="structplf_1_1colony_1_1colony__data.html">colony_data</a>()</div>
<div class="line"><a name="l04554"></a><span class="lineno"> 4554</span>&#160;            {</div>
<div class="line"><a name="l04555"></a><span class="lineno"> 4555</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> index = 0; index != number_of_blocks; ++index)</div>
<div class="line"><a name="l04556"></a><span class="lineno"> 4556</span>&#160;                {</div>
<div class="line"><a name="l04557"></a><span class="lineno"> 4557</span>&#160;                    PLF_DEALLOCATE(uchar_allocator_type, *<span class="keyword">this</span>, bitfield_pointers[index], (block_capacities[index] + 7) / 8);</div>
<div class="line"><a name="l04558"></a><span class="lineno"> 4558</span>&#160;                }</div>
<div class="line"><a name="l04559"></a><span class="lineno"> 4559</span>&#160; </div>
<div class="line"><a name="l04560"></a><span class="lineno"> 4560</span>&#160;                PLF_DEALLOCATE(uchar_allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(block_pointers), number_of_blocks * <span class="keyword">sizeof</span>(aligned_pointer_type));</div>
<div class="line"><a name="l04561"></a><span class="lineno"> 4561</span>&#160;                PLF_DEALLOCATE(uchar_allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(bitfield_pointers), number_of_blocks * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*));</div>
<div class="line"><a name="l04562"></a><span class="lineno"> 4562</span>&#160;                PLF_DEALLOCATE(uchar_allocator_type, *<span class="keyword">this</span>, <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(block_capacities), number_of_blocks * <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>));</div>
<div class="line"><a name="l04563"></a><span class="lineno"> 4563</span>&#160;            }</div>
<div class="line"><a name="l04564"></a><span class="lineno"> 4564</span>&#160;        };</div>
<div class="line"><a name="l04565"></a><span class="lineno"> 4565</span>&#160; </div>
<div class="line"><a name="l04566"></a><span class="lineno"> 4566</span>&#160; </div>
<div class="line"><a name="l04567"></a><span class="lineno"> 4567</span>&#160;        <span class="keyword">typedef</span> <a class="code" href="structplf_1_1colony_1_1colony__data.html">colony_data</a> <a class="code" href="structplf_1_1colony_1_1colony__data.html">hive_data</a>;</div>
<div class="line"><a name="l04568"></a><span class="lineno"> 4568</span>&#160; </div>
<div class="line"><a name="l04569"></a><span class="lineno"> 4569</span>&#160; </div>
<div class="line"><a name="l04570"></a><span class="lineno"> 4570</span>&#160; </div>
<div class="line"><a name="l04571"></a><span class="lineno"> 4571</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l04572"></a><span class="lineno"> 4572</span>&#160; </div>
<div class="line"><a name="l04573"></a><span class="lineno"> 4573</span>&#160;        <span class="keywordtype">void</span> setup_data_cell(<a class="code" href="structplf_1_1colony_1_1colony__data.html">colony_data</a>* data, <span class="keyword">const</span> group_pointer_type current_group, <span class="keyword">const</span> <span class="keywordtype">size_t</span> capacity, <span class="keyword">const</span> <span class="keywordtype">size_t</span> group_number)</div>
<div class="line"><a name="l04574"></a><span class="lineno"> 4574</span>&#160;        {</div>
<div class="line"><a name="l04575"></a><span class="lineno"> 4575</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> bitfield_capacity = (capacity + 7) / 8; <span class="comment">// round up</span></div>
<div class="line"><a name="l04576"></a><span class="lineno"> 4576</span>&#160; </div>
<div class="line"><a name="l04577"></a><span class="lineno"> 4577</span>&#160;            data-&gt;block_pointers[group_number] = current_group-&gt;elements;</div>
<div class="line"><a name="l04578"></a><span class="lineno"> 4578</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bitfield_location = data-&gt;bitfield_pointers[group_number] = PLF_ALLOCATE(uchar_allocator_type, (*data), bitfield_capacity, NULL);</div>
<div class="line"><a name="l04579"></a><span class="lineno"> 4579</span>&#160;            data-&gt;block_capacities[group_number] = capacity;</div>
<div class="line"><a name="l04580"></a><span class="lineno"> 4580</span>&#160;            std::memset(bitfield_location, 0, bitfield_capacity);</div>
<div class="line"><a name="l04581"></a><span class="lineno"> 4581</span>&#160; </div>
<div class="line"><a name="l04582"></a><span class="lineno"> 4582</span>&#160;            skipfield_pointer_type skipfield_pointer = current_group-&gt;skipfield;</div>
<div class="line"><a name="l04583"></a><span class="lineno"> 4583</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* end = bitfield_location + bitfield_capacity;</div>
<div class="line"><a name="l04584"></a><span class="lineno"> 4584</span>&#160; </div>
<div class="line"><a name="l04585"></a><span class="lineno"> 4585</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> index = 0; bitfield_location != end; ++bitfield_location)</div>
<div class="line"><a name="l04586"></a><span class="lineno"> 4586</span>&#160;            {</div>
<div class="line"><a name="l04587"></a><span class="lineno"> 4587</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> offset = 0; offset != 8 &amp;&amp; index != capacity; ++index, ++offset, ++skipfield_pointer)</div>
<div class="line"><a name="l04588"></a><span class="lineno"> 4588</span>&#160;                {</div>
<div class="line"><a name="l04589"></a><span class="lineno"> 4589</span>&#160;                    *bitfield_location |= <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(!*skipfield_pointer) &lt;&lt; offset);</div>
<div class="line"><a name="l04590"></a><span class="lineno"> 4590</span>&#160;                }</div>
<div class="line"><a name="l04591"></a><span class="lineno"> 4591</span>&#160;            }</div>
<div class="line"><a name="l04592"></a><span class="lineno"> 4592</span>&#160;        }</div>
<div class="line"><a name="l04593"></a><span class="lineno"> 4593</span>&#160; </div>
<div class="line"><a name="l04594"></a><span class="lineno"> 4594</span>&#160; </div>
<div class="line"><a name="l04595"></a><span class="lineno"> 4595</span>&#160; </div>
<div class="line"><a name="l04596"></a><span class="lineno"> 4596</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l04597"></a><span class="lineno"> 4597</span>&#160; </div>
<div class="line"><a name="l04598"></a><span class="lineno"> 4598</span>&#160;        colony_data* data()</div>
<div class="line"><a name="l04599"></a><span class="lineno"> 4599</span>&#160;        {</div>
<div class="line"><a name="l04600"></a><span class="lineno"> 4600</span>&#160;            colony_data* data = <span class="keyword">new</span> colony_data(end_iterator.group_pointer-&gt;group_number + 1);</div>
<div class="line"><a name="l04601"></a><span class="lineno"> 4601</span>&#160;            <span class="keywordtype">size_t</span> group_number = 0;</div>
<div class="line"><a name="l04602"></a><span class="lineno"> 4602</span>&#160; </div>
<div class="line"><a name="l04603"></a><span class="lineno"> 4603</span>&#160;            <span class="keywordflow">for</span> (group_pointer_type current_group = begin_iterator.group_pointer; current_group != end_iterator.group_pointer; current_group = current_group-&gt;next_group, ++group_number)</div>
<div class="line"><a name="l04604"></a><span class="lineno"> 4604</span>&#160;            {</div>
<div class="line"><a name="l04605"></a><span class="lineno"> 4605</span>&#160;                setup_data_cell(data, current_group, current_group-&gt;capacity, group_number);</div>
<div class="line"><a name="l04606"></a><span class="lineno"> 4606</span>&#160;            }</div>
<div class="line"><a name="l04607"></a><span class="lineno"> 4607</span>&#160; </div>
<div class="line"><a name="l04608"></a><span class="lineno"> 4608</span>&#160;            <span class="comment">// Special case for end group:</span></div>
<div class="line"><a name="l04609"></a><span class="lineno"> 4609</span>&#160;            setup_data_cell(data, end_iterator.group_pointer, <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end_iterator.group_pointer-&gt;last_endpoint - end_iterator.group_pointer-&gt;elements), group_number);</div>
<div class="line"><a name="l04610"></a><span class="lineno"> 4610</span>&#160; </div>
<div class="line"><a name="l04611"></a><span class="lineno"> 4611</span>&#160;            <span class="keywordflow">return</span> data;</div>
<div class="line"><a name="l04612"></a><span class="lineno"> 4612</span>&#160;        }</div>
<div class="line"><a name="l04613"></a><span class="lineno"> 4613</span>&#160; </div>
<div class="line"><a name="l04614"></a><span class="lineno"> 4614</span>&#160; </div>
<div class="line"><a name="l04615"></a><span class="lineno"> 4615</span>&#160; </div>
<div class="line"><a name="l04616"></a><span class="lineno"> 4616</span>&#160; </div>
<div class="line"><a name="l04617"></a><span class="lineno"> 4617</span>&#160;        <span class="keywordtype">void</span> swap(colony&amp; source) PLF_NOEXCEPT_SWAP(allocator_type)</div>
<div class="line"><a name="l04618"></a><span class="lineno"> 4618</span>&#160;        {</div>
<div class="line"><a name="l04619"></a><span class="lineno"> 4619</span>&#160;            assert(&amp;source != <span class="keyword">this</span>);</div>
<div class="line"><a name="l04620"></a><span class="lineno"> 4620</span>&#160; </div>
<div class="line"><a name="l04621"></a><span class="lineno"> 4621</span>&#160;<span class="preprocessor">#ifdef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l04622"></a><span class="lineno"> 4622</span>&#160;            <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_trivial&lt;group_pointer_type&gt;::value &amp;&amp; std::is_trivial&lt;aligned_pointer_type&gt;::value &amp;&amp; std::is_trivial&lt;skipfield_pointer_type&gt;::value) <span class="comment">// if all pointer types are trivial we can just copy using memcpy - avoids constructors/destructors etc and is faster</span></div>
<div class="line"><a name="l04623"></a><span class="lineno"> 4623</span>&#160;            {</div>
<div class="line"><a name="l04624"></a><span class="lineno"> 4624</span>&#160;                <span class="keywordtype">char</span> temp[<span class="keyword">sizeof</span>(colony)];</div>
<div class="line"><a name="l04625"></a><span class="lineno"> 4625</span>&#160;                std::memcpy(&amp;temp, <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>), <span class="keyword">sizeof</span>(colony));</div>
<div class="line"><a name="l04626"></a><span class="lineno"> 4626</span>&#160;                std::memcpy(<span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>), <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(&amp;source), <span class="keyword">sizeof</span>(colony));</div>
<div class="line"><a name="l04627"></a><span class="lineno"> 4627</span>&#160;                std::memcpy(<span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(&amp;source), &amp;temp, <span class="keyword">sizeof</span>(colony));</div>
<div class="line"><a name="l04628"></a><span class="lineno"> 4628</span>&#160;            }</div>
<div class="line"><a name="l04629"></a><span class="lineno"> 4629</span>&#160;<span class="preprocessor">#ifdef PLF_MOVE_SEMANTICS_SUPPORT // Moving is probably going to be more efficient than copying, particularly if pointer types are non-trivial:</span></div>
<div class="line"><a name="l04630"></a><span class="lineno"> 4630</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> PLF_CONSTEXPR(std::is_move_assignable&lt;group_pointer_type&gt;::value &amp;&amp; std::is_move_assignable&lt;aligned_pointer_type&gt;::value &amp;&amp; std::is_move_assignable&lt;skipfield_pointer_type&gt;::value &amp;&amp; std::is_move_constructible&lt;group_pointer_type&gt;::value &amp;&amp; std::is_move_constructible&lt;aligned_pointer_type&gt;::value &amp;&amp; std::is_move_constructible&lt;skipfield_pointer_type&gt;::value)</div>
<div class="line"><a name="l04631"></a><span class="lineno"> 4631</span>&#160;            {</div>
<div class="line"><a name="l04632"></a><span class="lineno"> 4632</span>&#160;                colony temp(std::move(source));</div>
<div class="line"><a name="l04633"></a><span class="lineno"> 4633</span>&#160;                source = std::move(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l04634"></a><span class="lineno"> 4634</span>&#160;                *<span class="keyword">this</span> = std::move(temp);</div>
<div class="line"><a name="l04635"></a><span class="lineno"> 4635</span>&#160;            }</div>
<div class="line"><a name="l04636"></a><span class="lineno"> 4636</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04637"></a><span class="lineno"> 4637</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l04638"></a><span class="lineno"> 4638</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04639"></a><span class="lineno"> 4639</span>&#160;            {</div>
<div class="line"><a name="l04640"></a><span class="lineno"> 4640</span>&#160;                <span class="keyword">const</span> iterator                  swap_end_iterator = end_iterator, swap_begin_iterator = begin_iterator;</div>
<div class="line"><a name="l04641"></a><span class="lineno"> 4641</span>&#160;                <span class="keyword">const</span> group_pointer_type        swap_groups_with_erasures_list_head = groups_with_erasures_list_head, swap_unused_groups_head = unused_groups_head;</div>
<div class="line"><a name="l04642"></a><span class="lineno"> 4642</span>&#160;                <span class="keyword">const</span> size_type                 swap_total_size = total_size, swap_total_capacity = total_capacity;</div>
<div class="line"><a name="l04643"></a><span class="lineno"> 4643</span>&#160;                <span class="keyword">const</span> skipfield_type            swap_min_group_capacity = tuple_allocator_pair.min_group_capacity, swap_max_group_capacity = group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l04644"></a><span class="lineno"> 4644</span>&#160; </div>
<div class="line"><a name="l04645"></a><span class="lineno"> 4645</span>&#160;                end_iterator = source.end_iterator;</div>
<div class="line"><a name="l04646"></a><span class="lineno"> 4646</span>&#160;                begin_iterator = source.begin_iterator;</div>
<div class="line"><a name="l04647"></a><span class="lineno"> 4647</span>&#160;                groups_with_erasures_list_head = source.groups_with_erasures_list_head;</div>
<div class="line"><a name="l04648"></a><span class="lineno"> 4648</span>&#160;                unused_groups_head = source.unused_groups_head;</div>
<div class="line"><a name="l04649"></a><span class="lineno"> 4649</span>&#160;                total_size = source.total_size;</div>
<div class="line"><a name="l04650"></a><span class="lineno"> 4650</span>&#160;                total_capacity = source.total_capacity;</div>
<div class="line"><a name="l04651"></a><span class="lineno"> 4651</span>&#160;                tuple_allocator_pair.min_group_capacity = source.tuple_allocator_pair.min_group_capacity;</div>
<div class="line"><a name="l04652"></a><span class="lineno"> 4652</span>&#160;                group_allocator_pair.max_group_capacity = source.group_allocator_pair.max_group_capacity;</div>
<div class="line"><a name="l04653"></a><span class="lineno"> 4653</span>&#160; </div>
<div class="line"><a name="l04654"></a><span class="lineno"> 4654</span>&#160;                source.end_iterator = swap_end_iterator;</div>
<div class="line"><a name="l04655"></a><span class="lineno"> 4655</span>&#160;                source.begin_iterator = swap_begin_iterator;</div>
<div class="line"><a name="l04656"></a><span class="lineno"> 4656</span>&#160;                source.groups_with_erasures_list_head = swap_groups_with_erasures_list_head;</div>
<div class="line"><a name="l04657"></a><span class="lineno"> 4657</span>&#160;                source.unused_groups_head = swap_unused_groups_head;</div>
<div class="line"><a name="l04658"></a><span class="lineno"> 4658</span>&#160;                source.total_size = swap_total_size;</div>
<div class="line"><a name="l04659"></a><span class="lineno"> 4659</span>&#160;                source.total_capacity = swap_total_capacity;</div>
<div class="line"><a name="l04660"></a><span class="lineno"> 4660</span>&#160;                source.tuple_allocator_pair.min_group_capacity = swap_min_group_capacity;</div>
<div class="line"><a name="l04661"></a><span class="lineno"> 4661</span>&#160;                source.group_allocator_pair.max_group_capacity = swap_max_group_capacity;</div>
<div class="line"><a name="l04662"></a><span class="lineno"> 4662</span>&#160;            }</div>
<div class="line"><a name="l04663"></a><span class="lineno"> 4663</span>&#160;        }</div>
<div class="line"><a name="l04664"></a><span class="lineno"> 4664</span>&#160; </div>
<div class="line"><a name="l04665"></a><span class="lineno"> 4665</span>&#160;    }; <span class="comment">// colony</span></div>
<div class="line"><a name="l04666"></a><span class="lineno"> 4666</span>&#160; </div>
<div class="line"><a name="l04667"></a><span class="lineno"> 4667</span>&#160; </div>
<div class="line"><a name="l04668"></a><span class="lineno"> 4668</span>&#160; </div>
<div class="line"><a name="l04669"></a><span class="lineno"> 4669</span>&#160;    <span class="comment">// Set up hive as alias of colony:</span></div>
<div class="line"><a name="l04670"></a><span class="lineno"> 4670</span>&#160;<span class="preprocessor">#if defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L</span></div>
<div class="line"><a name="l04671"></a><span class="lineno"> 4671</span>&#160;    <span class="keyword">typedef</span> colony_limits hive_limits;</div>
<div class="line"><a name="l04672"></a><span class="lineno"> 4672</span>&#160;    <span class="keyword">typedef</span> colony_priority hive_priority;</div>
<div class="line"><a name="l04673"></a><span class="lineno"> 4673</span>&#160; </div>
<div class="line"><a name="l04674"></a><span class="lineno"> 4674</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> element_type, <span class="keyword">class</span> allocator_type = std::allocator&lt;element_type&gt;, plf::hive_priority priority = plf::performance&gt;</div>
<div class="line"><a name="l04675"></a><span class="lineno"> 4675</span>&#160;    <span class="keyword">using</span> hive = <a class="code" href="classplf_1_1colony.html">plf::colony&lt;element_type, allocator_type, priority&gt;</a>;</div>
<div class="line"><a name="l04676"></a><span class="lineno"> 4676</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l04677"></a><span class="lineno"> 4677</span>&#160; </div>
<div class="line"><a name="l04678"></a><span class="lineno"> 4678</span>&#160; </div>
<div class="line"><a name="l04679"></a><span class="lineno"> 4679</span>&#160; </div>
<div class="line"><a name="l04680"></a><span class="lineno"> 4680</span>&#160;    <span class="comment">// Used by std::erase_if() overload below:</span></div>
<div class="line"><a name="l04681"></a><span class="lineno"> 4681</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span> element_type&gt;</div>
<div class="line"><a name="l04682"></a><span class="lineno"><a class="line" href="structplf_1_1colony__eq__to.html"> 4682</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structplf_1_1colony__eq__to.html">colony_eq_to</a></div>
<div class="line"><a name="l04683"></a><span class="lineno"> 4683</span>&#160;    {</div>
<div class="line"><a name="l04684"></a><span class="lineno"> 4684</span>&#160;        <span class="keyword">const</span> element_type value;</div>
<div class="line"><a name="l04685"></a><span class="lineno"> 4685</span>&#160; </div>
<div class="line"><a name="l04686"></a><span class="lineno"> 4686</span>&#160;        <span class="keyword">explicit</span> <a class="code" href="structplf_1_1colony__eq__to.html">colony_eq_to</a>(<span class="keyword">const</span> element_type store_value) : <span class="comment">/* may not be noexcept as the element may allocate and therefore potentially throw when copied */</span></div>
<div class="line"><a name="l04687"></a><span class="lineno"> 4687</span>&#160;            value(store_value)</div>
<div class="line"><a name="l04688"></a><span class="lineno"> 4688</span>&#160;        {}</div>
<div class="line"><a name="l04689"></a><span class="lineno"> 4689</span>&#160; </div>
<div class="line"><a name="l04690"></a><span class="lineno"> 4690</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> element_type compare_value) <span class="keyword">const</span> PLF_NOEXCEPT</div>
<div class="line"><a name="l04691"></a><span class="lineno"> 4691</span>&#160;        {</div>
<div class="line"><a name="l04692"></a><span class="lineno"> 4692</span>&#160;            <span class="keywordflow">return</span> value == compare_value;</div>
<div class="line"><a name="l04693"></a><span class="lineno"> 4693</span>&#160;        }</div>
<div class="line"><a name="l04694"></a><span class="lineno"> 4694</span>&#160;    };</div>
<div class="line"><a name="l04695"></a><span class="lineno"> 4695</span>&#160; </div>
<div class="line"><a name="l04696"></a><span class="lineno"> 4696</span>&#160; </div>
<div class="line"><a name="l04697"></a><span class="lineno"> 4697</span>&#160;} <span class="comment">// plf namespace</span></div>
<div class="line"><a name="l04698"></a><span class="lineno"> 4698</span>&#160; </div>
<div class="line"><a name="l04699"></a><span class="lineno"> 4699</span>&#160; </div>
<div class="line"><a name="l04700"></a><span class="lineno"> 4700</span>&#160; </div>
<div class="line"><a name="l04701"></a><span class="lineno"> 4701</span>&#160; </div>
<div class="line"><a name="l04702"></a><span class="lineno"> 4702</span>&#160;<span class="keyword">namespace </span>std</div>
<div class="line"><a name="l04703"></a><span class="lineno"> 4703</span>&#160;{</div>
<div class="line"><a name="l04704"></a><span class="lineno"> 4704</span>&#160; </div>
<div class="line"><a name="l04705"></a><span class="lineno"> 4705</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> element_type, <span class="keyword">class</span> allocator_type, plf::colony_priority priority&gt;</div>
<div class="line"><a name="l04706"></a><span class="lineno"> 4706</span>&#160;    <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(<a class="code" href="classplf_1_1colony.html">plf::colony&lt;element_type, allocator_type, priority&gt;</a>&amp; a, <a class="code" href="classplf_1_1colony.html">plf::colony&lt;element_type, allocator_type, priority&gt;</a>&amp; b) PLF_NOEXCEPT_SWAP(allocator_type)</div>
<div class="line"><a name="l04707"></a><span class="lineno"> 4707</span>&#160;    {</div>
<div class="line"><a name="l04708"></a><span class="lineno"> 4708</span>&#160;        a.swap(b);</div>
<div class="line"><a name="l04709"></a><span class="lineno"> 4709</span>&#160;    }</div>
<div class="line"><a name="l04710"></a><span class="lineno"> 4710</span>&#160; </div>
<div class="line"><a name="l04711"></a><span class="lineno"> 4711</span>&#160; </div>
<div class="line"><a name="l04712"></a><span class="lineno"> 4712</span>&#160; </div>
<div class="line"><a name="l04713"></a><span class="lineno"> 4713</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> element_type, <span class="keyword">class</span> allocator_type, plf::colony_priority priority, <span class="keyword">class</span> predicate_function&gt;</div>
<div class="line"><a name="l04714"></a><span class="lineno"> 4714</span>&#160;    <span class="keyword">typename</span> plf::colony&lt;element_type, allocator_type, priority&gt;::size_type erase_if(<a class="code" href="classplf_1_1colony.html">plf::colony&lt;element_type, allocator_type, priority&gt;</a>&amp; container, predicate_function predicate)</div>
<div class="line"><a name="l04715"></a><span class="lineno"> 4715</span>&#160;    {</div>
<div class="line"><a name="l04716"></a><span class="lineno"> 4716</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classplf_1_1colony.html">plf::colony&lt;element_type, allocator_type, priority&gt;</a> colony;</div>
<div class="line"><a name="l04717"></a><span class="lineno"> 4717</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> colony::const_iterator const_iterator;</div>
<div class="line"><a name="l04718"></a><span class="lineno"> 4718</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> colony::size_type          size_type;</div>
<div class="line"><a name="l04719"></a><span class="lineno"> 4719</span>&#160;        size_type count = 0;</div>
<div class="line"><a name="l04720"></a><span class="lineno"> 4720</span>&#160; </div>
<div class="line"><a name="l04721"></a><span class="lineno"> 4721</span>&#160;        <span class="keywordflow">for</span> (const_iterator current = container.begin(), end = container.end(); current != end;)</div>
<div class="line"><a name="l04722"></a><span class="lineno"> 4722</span>&#160;        {</div>
<div class="line"><a name="l04723"></a><span class="lineno"> 4723</span>&#160;            <span class="keywordflow">if</span> (predicate(*current))</div>
<div class="line"><a name="l04724"></a><span class="lineno"> 4724</span>&#160;            {</div>
<div class="line"><a name="l04725"></a><span class="lineno"> 4725</span>&#160;                <span class="keyword">const</span> size_type original_count = ++count;</div>
<div class="line"><a name="l04726"></a><span class="lineno"> 4726</span>&#160;                const_iterator last(++const_iterator(current));</div>
<div class="line"><a name="l04727"></a><span class="lineno"> 4727</span>&#160; </div>
<div class="line"><a name="l04728"></a><span class="lineno"> 4728</span>&#160;                <span class="keywordflow">while</span> (last != end &amp;&amp; predicate(*last))</div>
<div class="line"><a name="l04729"></a><span class="lineno"> 4729</span>&#160;                {</div>
<div class="line"><a name="l04730"></a><span class="lineno"> 4730</span>&#160;                    ++last;</div>
<div class="line"><a name="l04731"></a><span class="lineno"> 4731</span>&#160;                    ++count;</div>
<div class="line"><a name="l04732"></a><span class="lineno"> 4732</span>&#160;                }</div>
<div class="line"><a name="l04733"></a><span class="lineno"> 4733</span>&#160; </div>
<div class="line"><a name="l04734"></a><span class="lineno"> 4734</span>&#160;                <span class="keywordflow">if</span> (count != original_count)</div>
<div class="line"><a name="l04735"></a><span class="lineno"> 4735</span>&#160;                {</div>
<div class="line"><a name="l04736"></a><span class="lineno"> 4736</span>&#160;                    current = container.erase(current, last);</div>
<div class="line"><a name="l04737"></a><span class="lineno"> 4737</span>&#160;                }</div>
<div class="line"><a name="l04738"></a><span class="lineno"> 4738</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l04739"></a><span class="lineno"> 4739</span>&#160;                {</div>
<div class="line"><a name="l04740"></a><span class="lineno"> 4740</span>&#160;                    current = container.erase(current);</div>
<div class="line"><a name="l04741"></a><span class="lineno"> 4741</span>&#160;                }</div>
<div class="line"><a name="l04742"></a><span class="lineno"> 4742</span>&#160; </div>
<div class="line"><a name="l04743"></a><span class="lineno"> 4743</span>&#160;                end = container.end();</div>
<div class="line"><a name="l04744"></a><span class="lineno"> 4744</span>&#160;            }</div>
<div class="line"><a name="l04745"></a><span class="lineno"> 4745</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l04746"></a><span class="lineno"> 4746</span>&#160;            {</div>
<div class="line"><a name="l04747"></a><span class="lineno"> 4747</span>&#160;                ++current;</div>
<div class="line"><a name="l04748"></a><span class="lineno"> 4748</span>&#160;            }</div>
<div class="line"><a name="l04749"></a><span class="lineno"> 4749</span>&#160;        }</div>
<div class="line"><a name="l04750"></a><span class="lineno"> 4750</span>&#160; </div>
<div class="line"><a name="l04751"></a><span class="lineno"> 4751</span>&#160;        <span class="keywordflow">return</span> count;</div>
<div class="line"><a name="l04752"></a><span class="lineno"> 4752</span>&#160;    }</div>
<div class="line"><a name="l04753"></a><span class="lineno"> 4753</span>&#160; </div>
<div class="line"><a name="l04754"></a><span class="lineno"> 4754</span>&#160; </div>
<div class="line"><a name="l04755"></a><span class="lineno"> 4755</span>&#160; </div>
<div class="line"><a name="l04756"></a><span class="lineno"> 4756</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> element_type, <span class="keyword">class</span> allocator_type, plf::colony_priority priority&gt;</div>
<div class="line"><a name="l04757"></a><span class="lineno"> 4757</span>&#160;    <span class="keyword">inline</span> <span class="keyword">typename</span> plf::colony&lt;element_type, allocator_type, priority&gt;::size_type erase(<a class="code" href="classplf_1_1colony.html">plf::colony&lt;element_type, allocator_type, priority&gt;</a>&amp; container, <span class="keyword">const</span> element_type&amp; value)</div>
<div class="line"><a name="l04758"></a><span class="lineno"> 4758</span>&#160;    {</div>
<div class="line"><a name="l04759"></a><span class="lineno"> 4759</span>&#160;        <span class="keywordflow">return</span> erase_if(container, <a class="code" href="structplf_1_1colony__eq__to.html">plf::colony_eq_to&lt;element_type&gt;</a>(value));</div>
<div class="line"><a name="l04760"></a><span class="lineno"> 4760</span>&#160;    }</div>
<div class="line"><a name="l04761"></a><span class="lineno"> 4761</span>&#160;}</div>
<div class="line"><a name="l04762"></a><span class="lineno"> 4762</span>&#160; </div>
<div class="line"><a name="l04763"></a><span class="lineno"> 4763</span>&#160; </div>
<div class="line"><a name="l04764"></a><span class="lineno"> 4764</span>&#160;<span class="preprocessor">#undef PLF_MIN_BLOCK_CAPACITY</span></div>
<div class="line"><a name="l04765"></a><span class="lineno"> 4765</span>&#160;<span class="preprocessor">#undef PLF_GROUP_ALIGNED_BLOCK_SIZE</span></div>
<div class="line"><a name="l04766"></a><span class="lineno"> 4766</span>&#160; </div>
<div class="line"><a name="l04767"></a><span class="lineno"> 4767</span>&#160;<span class="preprocessor">#undef PLF_FORCE_INLINE</span></div>
<div class="line"><a name="l04768"></a><span class="lineno"> 4768</span>&#160;<span class="preprocessor">#undef PLF_ALIGNMENT_SUPPORT</span></div>
<div class="line"><a name="l04769"></a><span class="lineno"> 4769</span>&#160;<span class="preprocessor">#undef PLF_INITIALIZER_LIST_SUPPORT</span></div>
<div class="line"><a name="l04770"></a><span class="lineno"> 4770</span>&#160;<span class="preprocessor">#undef PLF_TYPE_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l04771"></a><span class="lineno"> 4771</span>&#160;<span class="preprocessor">#undef PLF_ALLOCATOR_TRAITS_SUPPORT</span></div>
<div class="line"><a name="l04772"></a><span class="lineno"> 4772</span>&#160;<span class="preprocessor">#undef PLF_VARIADICS_SUPPORT</span></div>
<div class="line"><a name="l04773"></a><span class="lineno"> 4773</span>&#160;<span class="preprocessor">#undef PLF_MOVE_SEMANTICS_SUPPORT</span></div>
<div class="line"><a name="l04774"></a><span class="lineno"> 4774</span>&#160;<span class="preprocessor">#undef PLF_NOEXCEPT</span></div>
<div class="line"><a name="l04775"></a><span class="lineno"> 4775</span>&#160;<span class="preprocessor">#undef PLF_NOEXCEPT_SWAP</span></div>
<div class="line"><a name="l04776"></a><span class="lineno"> 4776</span>&#160;<span class="preprocessor">#undef PLF_NOEXCEPT_MOVE_ASSIGN</span></div>
<div class="line"><a name="l04777"></a><span class="lineno"> 4777</span>&#160;<span class="preprocessor">#undef PLF_CONSTEXPR</span></div>
<div class="line"><a name="l04778"></a><span class="lineno"> 4778</span>&#160;<span class="preprocessor">#undef PLF_CPP20_SUPPORT</span></div>
<div class="line"><a name="l04779"></a><span class="lineno"> 4779</span>&#160;<span class="preprocessor">#undef PLF_STATIC_ASSERT</span></div>
<div class="line"><a name="l04780"></a><span class="lineno"> 4780</span>&#160; </div>
<div class="line"><a name="l04781"></a><span class="lineno"> 4781</span>&#160;<span class="preprocessor">#undef PLF_CONSTRUCT</span></div>
<div class="line"><a name="l04782"></a><span class="lineno"> 4782</span>&#160;<span class="preprocessor">#undef PLF_DESTROY</span></div>
<div class="line"><a name="l04783"></a><span class="lineno"> 4783</span>&#160;<span class="preprocessor">#undef PLF_ALLOCATE</span></div>
<div class="line"><a name="l04784"></a><span class="lineno"> 4784</span>&#160;<span class="preprocessor">#undef PLF_DEALLOCATE</span></div>
<div class="line"><a name="l04785"></a><span class="lineno"> 4785</span>&#160; </div>
<div class="line"><a name="l04786"></a><span class="lineno"> 4786</span>&#160;<span class="preprocessor">#endif // PLF_COLONY_H</span></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassplf_1_1colony_1_1colony__reverse__iterator_html"><div class="ttname"><a href="classplf_1_1colony_1_1colony__reverse__iterator.html">plf::colony::colony_reverse_iterator</a></div><div class="ttdef"><b>Definition:</b> plf_colony.hpp:1104</div></div>
<div class="ttc" id="astructplf_1_1colony_1_1colony__data_html"><div class="ttname"><a href="structplf_1_1colony_1_1colony__data.html">plf::colony::colony_data</a></div><div class="ttdef"><b>Definition:</b> plf_colony.hpp:4538</div></div>
<div class="ttc" id="astructplf_1_1colony__limits_html"><div class="ttname"><a href="structplf_1_1colony__limits.html">plf::colony_limits</a></div><div class="ttdef"><b>Definition:</b> plf_colony.hpp:249</div></div>
<div class="ttc" id="aclassplf_1_1colony_1_1colony__iterator_html"><div class="ttname"><a href="classplf_1_1colony_1_1colony__iterator.html">plf::colony::colony_iterator</a></div><div class="ttdef"><b>Definition:</b> plf_colony.hpp:464</div></div>
<div class="ttc" id="astructplf_1_1colony__eq__to_html"><div class="ttname"><a href="structplf_1_1colony__eq__to.html">plf::colony_eq_to</a></div><div class="ttdef"><b>Definition:</b> plf_colony.hpp:4683</div></div>
<div class="ttc" id="aclassplf_1_1colony_html"><div class="ttname"><a href="classplf_1_1colony.html">plf::colony</a></div><div class="ttdef"><b>Definition:</b> plf_colony.hpp:260</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>plf_colony.hpp</b></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
