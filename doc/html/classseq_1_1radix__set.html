<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEQ library: seq::radix_set&lt; Key, ExtractKey, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SEQ library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Original STL like containers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classseq_1_1radix__set.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseq_1_1radix__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">seq::radix_set&lt; Key, ExtractKey, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::set.  
 <a href="classseq_1_1radix__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="radix__map_8hpp_source.html">radix_map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access const iterator class.  <a href="structseq_1_1radix__set_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a357542fc4beded531ea2684de6425398"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a> = <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="separator:a357542fc4beded531ea2684de6425398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281374cd8906c351929324604119eb6e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a281374cd8906c351929324604119eb6e">key_type</a> = Key</td></tr>
<tr class="separator:a281374cd8906c351929324604119eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1490b99f1452ae21f78b89ac47ccfc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> = Key</td></tr>
<tr class="separator:a5b1490b99f1452ae21f78b89ac47ccfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f85c4f0f04599e167ae1ce95132c17e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a3f85c4f0f04599e167ae1ce95132c17e">difference_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#a3f85c4f0f04599e167ae1ce95132c17e">difference_type</a></td></tr>
<tr class="separator:a3f85c4f0f04599e167ae1ce95132c17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3755d1dd705b7e0ec30f29431bc59f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a></td></tr>
<tr class="separator:ad3755d1dd705b7e0ec30f29431bc59f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2d649a3d782580e0b51385e0ee6f3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a1f2d649a3d782580e0b51385e0ee6f3b">key_extract</a> = ExtractKey</td></tr>
<tr class="separator:a1f2d649a3d782580e0b51385e0ee6f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09869745be8f4ff05fdd21634c65a46"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#af09869745be8f4ff05fdd21634c65a46">allocator_type</a> = Allocator</td></tr>
<tr class="separator:af09869745be8f4ff05fdd21634c65a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe5be916b8d86205bf87b147684ef82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#acbe5be916b8d86205bf87b147684ef82">reference</a> = Key &amp;</td></tr>
<tr class="separator:acbe5be916b8d86205bf87b147684ef82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfeb4f57a3e600c9bd60dcb3d781178"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#abdfeb4f57a3e600c9bd60dcb3d781178">const_reference</a> = const Key &amp;</td></tr>
<tr class="separator:abdfeb4f57a3e600c9bd60dcb3d781178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14654bbd5e485908c505623cd936ca8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#aa14654bbd5e485908c505623cd936ca8">pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#aa14654bbd5e485908c505623cd936ca8">pointer</a></td></tr>
<tr class="separator:aa14654bbd5e485908c505623cd936ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c37637462e65d8983e5fc8be2f0efe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a23c37637462e65d8983e5fc8be2f0efe">const_pointer</a> = typename std::allocator_traits&lt; Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#a23c37637462e65d8983e5fc8be2f0efe">const_pointer</a></td></tr>
<tr class="separator:a23c37637462e65d8983e5fc8be2f0efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1df97d61e9e30381d709b036895acb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#aa1df97d61e9e30381d709b036895acb3">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a> &gt;</td></tr>
<tr class="separator:aa1df97d61e9e30381d709b036895acb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b809cc9832a4ff8d26e392fa998d4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:ad8b809cc9832a4ff8d26e392fa998d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0da186362b40325a87eb800d9808c47e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a0da186362b40325a87eb800d9808c47e">radix_set</a> ()</td></tr>
<tr class="memdesc:a0da186362b40325a87eb800d9808c47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classseq_1_1radix__set.html#a0da186362b40325a87eb800d9808c47e">More...</a><br /></td></tr>
<tr class="separator:a0da186362b40325a87eb800d9808c47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c863ee2efc6ebd247566b7fcf2be817"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a7c863ee2efc6ebd247566b7fcf2be817">radix_set</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a7c863ee2efc6ebd247566b7fcf2be817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from allocator object.  <a href="classseq_1_1radix__set.html#a7c863ee2efc6ebd247566b7fcf2be817">More...</a><br /></td></tr>
<tr class="separator:a7c863ee2efc6ebd247566b7fcf2be817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478e9c120d98a3c2245f586ae439219d"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a478e9c120d98a3c2245f586ae439219d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a478e9c120d98a3c2245f586ae439219d">radix_set</a> (InputIt first, InputIt last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a478e9c120d98a3c2245f586ae439219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1radix__set.html#a478e9c120d98a3c2245f586ae439219d">More...</a><br /></td></tr>
<tr class="separator:a478e9c120d98a3c2245f586ae439219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa119d7f73f14cc0ae347e953e7e00df1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#aa119d7f73f14cc0ae347e953e7e00df1">radix_set</a> (const <a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;other)</td></tr>
<tr class="memdesc:aa119d7f73f14cc0ae347e953e7e00df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1radix__set.html#aa119d7f73f14cc0ae347e953e7e00df1">More...</a><br /></td></tr>
<tr class="separator:aa119d7f73f14cc0ae347e953e7e00df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0042f93293d4ea7614f23cfe34c8fdcb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a0042f93293d4ea7614f23cfe34c8fdcb">radix_set</a> (const <a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a0042f93293d4ea7614f23cfe34c8fdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classseq_1_1radix__set.html#a0042f93293d4ea7614f23cfe34c8fdcb">More...</a><br /></td></tr>
<tr class="separator:a0042f93293d4ea7614f23cfe34c8fdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb2d4c6490fc415698155b9f4287a31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a1bb2d4c6490fc415698155b9f4287a31">radix_set</a> (<a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a1bb2d4c6490fc415698155b9f4287a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="classseq_1_1radix__set.html#a1bb2d4c6490fc415698155b9f4287a31">More...</a><br /></td></tr>
<tr class="separator:a1bb2d4c6490fc415698155b9f4287a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa344f22a14f3a0415e6b2034c032f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a1ffa344f22a14f3a0415e6b2034c032f">radix_set</a> (<a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a1ffa344f22a14f3a0415e6b2034c032f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="classseq_1_1radix__set.html#a1ffa344f22a14f3a0415e6b2034c032f">More...</a><br /></td></tr>
<tr class="separator:a1ffa344f22a14f3a0415e6b2034c032f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38901562f28648af8391b98de31c780d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a38901562f28648af8391b98de31c780d">radix_set</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &gt; init, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a38901562f28648af8391b98de31c780d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1radix__set.html#a38901562f28648af8391b98de31c780d">More...</a><br /></td></tr>
<tr class="separator:a38901562f28648af8391b98de31c780d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d19b3489a6fe850ea97b1170780e50"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ad5d19b3489a6fe850ea97b1170780e50">operator=</a> (<a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;</td></tr>
<tr class="memdesc:ad5d19b3489a6fe850ea97b1170780e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classseq_1_1radix__set.html#ad5d19b3489a6fe850ea97b1170780e50">More...</a><br /></td></tr>
<tr class="separator:ad5d19b3489a6fe850ea97b1170780e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3163f422b3d04cdf07a58cccbe635c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a1e3163f422b3d04cdf07a58cccbe635c">operator=</a> (const <a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;other) -&gt; <a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;</td></tr>
<tr class="memdesc:a1e3163f422b3d04cdf07a58cccbe635c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator.  <a href="classseq_1_1radix__set.html#a1e3163f422b3d04cdf07a58cccbe635c">More...</a><br /></td></tr>
<tr class="separator:a1e3163f422b3d04cdf07a58cccbe635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2f792f0821b86c42b62f695ad438bb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a6e2f792f0821b86c42b62f695ad438bb">operator=</a> (const std::initializer_list&lt; <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &gt; &amp;init) -&gt; <a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;</td></tr>
<tr class="memdesc:a6e2f792f0821b86c42b62f695ad438bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign initializer-list.  <a href="classseq_1_1radix__set.html#a6e2f792f0821b86c42b62f695ad438bb">More...</a><br /></td></tr>
<tr class="separator:a6e2f792f0821b86c42b62f695ad438bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266b2942a94145e8fdac5523b5aa0a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a266b2942a94145e8fdac5523b5aa0a99">get_allocator</a> () const noexcept -&gt; const Allocator &amp;</td></tr>
<tr class="memdesc:a266b2942a94145e8fdac5523b5aa0a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns container's allocator.  <a href="classseq_1_1radix__set.html#a266b2942a94145e8fdac5523b5aa0a99">More...</a><br /></td></tr>
<tr class="separator:a266b2942a94145e8fdac5523b5aa0a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d39ea1d47a63473f2cd5dad477228cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a6d39ea1d47a63473f2cd5dad477228cb">get_allocator</a> () noexcept -&gt; Allocator &amp;</td></tr>
<tr class="separator:a6d39ea1d47a63473f2cd5dad477228cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d7914a9c95158f0d91a2738551bd74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a82d7914a9c95158f0d91a2738551bd74">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a82d7914a9c95158f0d91a2738551bd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if container is empty, false otherwise.  <a href="classseq_1_1radix__set.html#a82d7914a9c95158f0d91a2738551bd74">More...</a><br /></td></tr>
<tr class="separator:a82d7914a9c95158f0d91a2738551bd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6773cd2c1b6c2001289055e8b540661b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a6773cd2c1b6c2001289055e8b540661b">size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a></td></tr>
<tr class="memdesc:a6773cd2c1b6c2001289055e8b540661b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size.  <a href="classseq_1_1radix__set.html#a6773cd2c1b6c2001289055e8b540661b">More...</a><br /></td></tr>
<tr class="separator:a6773cd2c1b6c2001289055e8b540661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc8966556e933f631acfc543272b05c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a4bc8966556e933f631acfc543272b05c">max_size</a> () const noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a></td></tr>
<tr class="memdesc:a4bc8966556e933f631acfc543272b05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container maximum size.  <a href="classseq_1_1radix__set.html#a4bc8966556e933f631acfc543272b05c">More...</a><br /></td></tr>
<tr class="separator:a4bc8966556e933f631acfc543272b05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bb70c33d472b7dad4700f565bfa1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ae1bb70c33d472b7dad4700f565bfa1fb">clear</a> () noexcept</td></tr>
<tr class="memdesc:ae1bb70c33d472b7dad4700f565bfa1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container.  <a href="classseq_1_1radix__set.html#ae1bb70c33d472b7dad4700f565bfa1fb">More...</a><br /></td></tr>
<tr class="separator:ae1bb70c33d472b7dad4700f565bfa1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432cf07350077bab004445cb02225515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a432cf07350077bab004445cb02225515">swap</a> (<a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a432cf07350077bab004445cb02225515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this container's content with another. Iterators to both containers remain valid, including end iterators.  <a href="classseq_1_1radix__set.html#a432cf07350077bab004445cb02225515">More...</a><br /></td></tr>
<tr class="separator:a432cf07350077bab004445cb02225515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7018cae97e47121116f0730e79dc7f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ad7018cae97e47121116f0730e79dc7f0">reserve</a> (size_t)</td></tr>
<tr class="separator:ad7018cae97e47121116f0730e79dc7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ab9b9ef290f3be417a6067d8185d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a87ab9b9ef290f3be417a6067d8185d26">shrink_to_fit</a> ()</td></tr>
<tr class="separator:a87ab9b9ef290f3be417a6067d8185d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe893a04f37c3a492d5d442882c3161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a0fe893a04f37c3a492d5d442882c3161">insert</a> (const <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a0fe893a04f37c3a492d5d442882c3161"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1radix__set.html#a0fe893a04f37c3a492d5d442882c3161">More...</a><br /></td></tr>
<tr class="separator:a0fe893a04f37c3a492d5d442882c3161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae70bccb32b586cff5738690ce6e572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#acae70bccb32b586cff5738690ce6e572">insert</a> (<a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &amp;&amp;value) -&gt; std::pair&lt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:acae70bccb32b586cff5738690ce6e572"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::insert.  <a href="classseq_1_1radix__set.html#acae70bccb32b586cff5738690ce6e572">More...</a><br /></td></tr>
<tr class="separator:acae70bccb32b586cff5738690ce6e572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a81f82620ef45cbdf871974e34bbfc5"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a7a81f82620ef45cbdf871974e34bbfc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a7a81f82620ef45cbdf871974e34bbfc5">emplace</a> (Args &amp;&amp;... args) -&gt; std::pair&lt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:a7a81f82620ef45cbdf871974e34bbfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See std::set::emplace().  <a href="classseq_1_1radix__set.html#a7a81f82620ef45cbdf871974e34bbfc5">More...</a><br /></td></tr>
<tr class="separator:a7a81f82620ef45cbdf871974e34bbfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e152806b39e09d5b30d89c1ea33a3f0"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a0e152806b39e09d5b30d89c1ea33a3f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a0e152806b39e09d5b30d89c1ea33a3f0">emplace_hint</a> (<a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> hint, Args &amp;&amp;... args) -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a></td></tr>
<tr class="memdesc:a0e152806b39e09d5b30d89c1ea33a3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::emplace_hint.  <a href="classseq_1_1radix__set.html#a0e152806b39e09d5b30d89c1ea33a3f0">More...</a><br /></td></tr>
<tr class="separator:a0e152806b39e09d5b30d89c1ea33a3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01790959e150b602ec2e130fe392e515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a01790959e150b602ec2e130fe392e515">insert</a> (<a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> hint, const <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &amp;value) -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a></td></tr>
<tr class="memdesc:a01790959e150b602ec2e130fe392e515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1radix__set.html#a01790959e150b602ec2e130fe392e515">More...</a><br /></td></tr>
<tr class="separator:a01790959e150b602ec2e130fe392e515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42caa2c075432f13b74c6b3d738e02c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a42caa2c075432f13b74c6b3d738e02c4">insert</a> (<a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> hint, <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a></td></tr>
<tr class="memdesc:a42caa2c075432f13b74c6b3d738e02c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::set::insert()  <a href="classseq_1_1radix__set.html#a42caa2c075432f13b74c6b3d738e02c4">More...</a><br /></td></tr>
<tr class="separator:a42caa2c075432f13b74c6b3d738e02c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbf4da089845fde9a9393dd843cb198"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a3fbf4da089845fde9a9393dd843cb198"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a3fbf4da089845fde9a9393dd843cb198">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a3fbf4da089845fde9a9393dd843cb198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector.">tiered_vector</a>, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one.  <a href="classseq_1_1radix__set.html#a3fbf4da089845fde9a9393dd843cb198">More...</a><br /></td></tr>
<tr class="separator:a3fbf4da089845fde9a9393dd843cb198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463600164441345c9aabdcd7b6ecbb8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a463600164441345c9aabdcd7b6ecbb8a">insert</a> (std::initializer_list&lt; <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:a463600164441345c9aabdcd7b6ecbb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true.  <a href="classseq_1_1radix__set.html#a463600164441345c9aabdcd7b6ecbb8a">More...</a><br /></td></tr>
<tr class="separator:a463600164441345c9aabdcd7b6ecbb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4237f935aa1912cc7d029d51246c50f4"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a4237f935aa1912cc7d029d51246c50f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a4237f935aa1912cc7d029d51246c50f4">assign</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:a4237f935aa1912cc7d029d51246c50f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the content of the range [first, last) to this container, discarding previous values.  <a href="classseq_1_1radix__set.html#a4237f935aa1912cc7d029d51246c50f4">More...</a><br /></td></tr>
<tr class="separator:a4237f935aa1912cc7d029d51246c50f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7724d032e8e6e1dcc9e594bf2cbdea72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a7724d032e8e6e1dcc9e594bf2cbdea72">erase</a> (<a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> <a class="el" href="namespaceseq.html#ab534e8a0f6ac376f61e976fe7cd65457">pos</a>) -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a></td></tr>
<tr class="memdesc:a7724d032e8e6e1dcc9e594bf2cbdea72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at given location.  <a href="classseq_1_1radix__set.html#a7724d032e8e6e1dcc9e594bf2cbdea72">More...</a><br /></td></tr>
<tr class="separator:a7724d032e8e6e1dcc9e594bf2cbdea72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96298fa479b68f6864526097b01f25b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a96298fa479b68f6864526097b01f25b6">erase</a> (<a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> last) -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a></td></tr>
<tr class="memdesc:a96298fa479b68f6864526097b01f25b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the range [first, last)  <a href="classseq_1_1radix__set.html#a96298fa479b68f6864526097b01f25b6">More...</a><br /></td></tr>
<tr class="separator:a96298fa479b68f6864526097b01f25b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d8be17a800c4902ae898c5c7f3ebf"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:ab71d8be17a800c4902ae898c5c7f3ebf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ab71d8be17a800c4902ae898c5c7f3ebf">erase</a> (const K &amp;key) -&gt; <a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a></td></tr>
<tr class="memdesc:ab71d8be17a800c4902ae898c5c7f3ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with key that compares equivalent to the value key.  <a href="classseq_1_1radix__set.html#ab71d8be17a800c4902ae898c5c7f3ebf">More...</a><br /></td></tr>
<tr class="separator:ab71d8be17a800c4902ae898c5c7f3ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6374ea8fdd020e048fa3956c700762c6"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:a6374ea8fdd020e048fa3956c700762c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a6374ea8fdd020e048fa3956c700762c6">find</a> (const K &amp;key) const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:a6374ea8fdd020e048fa3956c700762c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value key.  <a href="classseq_1_1radix__set.html#a6374ea8fdd020e048fa3956c700762c6">More...</a><br /></td></tr>
<tr class="separator:a6374ea8fdd020e048fa3956c700762c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e315b3938fd500001e415656c2c4e1"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:ab1e315b3938fd500001e415656c2c4e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ab1e315b3938fd500001e415656c2c4e1">lower_bound</a> (const K &amp;key) const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:ab1e315b3938fd500001e415656c2c4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key.  <a href="classseq_1_1radix__set.html#ab1e315b3938fd500001e415656c2c4e1">More...</a><br /></td></tr>
<tr class="separator:ab1e315b3938fd500001e415656c2c4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fa9bbb4a20b1f1f32ee3fafb0a14a9"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:a98fa9bbb4a20b1f1f32ee3fafb0a14a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a98fa9bbb4a20b1f1f32ee3fafb0a14a9">upper_bound</a> (const K &amp;key) const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:a98fa9bbb4a20b1f1f32ee3fafb0a14a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value key.  <a href="classseq_1_1radix__set.html#a98fa9bbb4a20b1f1f32ee3fafb0a14a9">More...</a><br /></td></tr>
<tr class="separator:a98fa9bbb4a20b1f1f32ee3fafb0a14a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0c1eb60e45ce20fb469f9aafa85beb"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:abb0c1eb60e45ce20fb469f9aafa85beb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#abb0c1eb60e45ce20fb469f9aafa85beb">contains</a> (const K &amp;key) const -&gt; bool</td></tr>
<tr class="memdesc:abb0c1eb60e45ce20fb469f9aafa85beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value key.  <a href="classseq_1_1radix__set.html#abb0c1eb60e45ce20fb469f9aafa85beb">More...</a><br /></td></tr>
<tr class="separator:abb0c1eb60e45ce20fb469f9aafa85beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178f66e947b9ff5b01212989c6705297"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:a178f66e947b9ff5b01212989c6705297"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a178f66e947b9ff5b01212989c6705297">count</a> (const K &amp;key) const -&gt; <a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a></td></tr>
<tr class="memdesc:a178f66e947b9ff5b01212989c6705297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key key (either 1 or 0 for <a class="el" href="classseq_1_1radix__set.html" title="Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::set.">radix_set</a> and <a class="el" href="classseq_1_1radix__map.html" title="Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::map.">radix_map</a>).  <a href="classseq_1_1radix__set.html#a178f66e947b9ff5b01212989c6705297">More...</a><br /></td></tr>
<tr class="separator:a178f66e947b9ff5b01212989c6705297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547f59c223a73387d02931de73327c5b"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:a547f59c223a73387d02931de73327c5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a547f59c223a73387d02931de73327c5b">equal_range</a> (const K &amp;key) const -&gt; std::pair&lt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>, <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a> &gt;</td></tr>
<tr class="memdesc:a547f59c223a73387d02931de73327c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1radix__set.html#ab1e315b3938fd500001e415656c2c4e1" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1radix__set.html#a98fa9bbb4a20b1f1f32ee3fafb0a14a9" title="Returns an iterator pointing to the first element that compares greater to the value key.">upper_bound()</a>.  <a href="classseq_1_1radix__set.html#a547f59c223a73387d02931de73327c5b">More...</a><br /></td></tr>
<tr class="separator:a547f59c223a73387d02931de73327c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab964b02af1ed1caa66c3aa5b3f1f1784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ab964b02af1ed1caa66c3aa5b3f1f1784">merge</a> (<a class="el" href="classseq_1_1radix__set.html">radix_set</a> &amp;source)</td></tr>
<tr class="separator:ab964b02af1ed1caa66c3aa5b3f1f1784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8bc9335818b8875278e28c62c582e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a9c8bc9335818b8875278e28c62c582e6">begin</a> () noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a></td></tr>
<tr class="memdesc:a9c8bc9335818b8875278e28c62c582e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1radix__set.html#a9c8bc9335818b8875278e28c62c582e6">More...</a><br /></td></tr>
<tr class="separator:a9c8bc9335818b8875278e28c62c582e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757f8b2568334de62ca9b32a755d5f46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a757f8b2568334de62ca9b32a755d5f46">begin</a> () const noexcept -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:a757f8b2568334de62ca9b32a755d5f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1radix__set.html#a757f8b2568334de62ca9b32a755d5f46">More...</a><br /></td></tr>
<tr class="separator:a757f8b2568334de62ca9b32a755d5f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2ff6b9eab6b7296e7d30fd630efb46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a9d2ff6b9eab6b7296e7d30fd630efb46">cbegin</a> () const noexcept -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:a9d2ff6b9eab6b7296e7d30fd630efb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classseq_1_1radix__set.html#a9d2ff6b9eab6b7296e7d30fd630efb46">More...</a><br /></td></tr>
<tr class="separator:a9d2ff6b9eab6b7296e7d30fd630efb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a4dc26ffb7635fdbca22af809b31af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ae3a4dc26ffb7635fdbca22af809b31af">end</a> () noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a></td></tr>
<tr class="memdesc:ae3a4dc26ffb7635fdbca22af809b31af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1radix__set.html#ae3a4dc26ffb7635fdbca22af809b31af">More...</a><br /></td></tr>
<tr class="separator:ae3a4dc26ffb7635fdbca22af809b31af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbc0a2e0f40393ef92c829bb6d114a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a3fbc0a2e0f40393ef92c829bb6d114a5">end</a> () const noexcept -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:a3fbc0a2e0f40393ef92c829bb6d114a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1radix__set.html#a3fbc0a2e0f40393ef92c829bb6d114a5">More...</a><br /></td></tr>
<tr class="separator:a3fbc0a2e0f40393ef92c829bb6d114a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ebb8ff49703b66be87576d45662f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a01ebb8ff49703b66be87576d45662f4c">cend</a> () const noexcept -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:a01ebb8ff49703b66be87576d45662f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classseq_1_1radix__set.html#a01ebb8ff49703b66be87576d45662f4c">More...</a><br /></td></tr>
<tr class="separator:a01ebb8ff49703b66be87576d45662f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade52356498023d36bf43dd999a3865ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#ade52356498023d36bf43dd999a3865ea">rbegin</a> () noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#aa1df97d61e9e30381d709b036895acb3">reverse_iterator</a></td></tr>
<tr class="memdesc:ade52356498023d36bf43dd999a3865ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1radix__set.html#ade52356498023d36bf43dd999a3865ea">More...</a><br /></td></tr>
<tr class="separator:ade52356498023d36bf43dd999a3865ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b5e6e7e7e93861869612c1ddfc0a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a579b5e6e7e7e93861869612c1ddfc0a2">rbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a579b5e6e7e7e93861869612c1ddfc0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1radix__set.html#a579b5e6e7e7e93861869612c1ddfc0a2">More...</a><br /></td></tr>
<tr class="separator:a579b5e6e7e7e93861869612c1ddfc0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed44b40a0698644cf7920c24abecf136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#aed44b40a0698644cf7920c24abecf136">rend</a> () noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#aa1df97d61e9e30381d709b036895acb3">reverse_iterator</a></td></tr>
<tr class="memdesc:aed44b40a0698644cf7920c24abecf136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1radix__set.html#aed44b40a0698644cf7920c24abecf136">More...</a><br /></td></tr>
<tr class="separator:aed44b40a0698644cf7920c24abecf136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c7d935a808dc3d50763c70a44b32d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a09c7d935a808dc3d50763c70a44b32d0">rend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a09c7d935a808dc3d50763c70a44b32d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1radix__set.html#a09c7d935a808dc3d50763c70a44b32d0">More...</a><br /></td></tr>
<tr class="separator:a09c7d935a808dc3d50763c70a44b32d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfb024b6e5427af94d0759bcd37bb2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a3cfb024b6e5427af94d0759bcd37bb2d">crbegin</a> () const noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a3cfb024b6e5427af94d0759bcd37bb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed list.  <a href="classseq_1_1radix__set.html#a3cfb024b6e5427af94d0759bcd37bb2d">More...</a><br /></td></tr>
<tr class="separator:a3cfb024b6e5427af94d0759bcd37bb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e541273d093acf89d0f3cc70840cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseq_1_1radix__set.html#a340e541273d093acf89d0f3cc70840cf">crend</a> () const noexcept -&gt; <a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a340e541273d093acf89d0f3cc70840cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed list.  <a href="classseq_1_1radix__set.html#a340e541273d093acf89d0f3cc70840cf">More...</a><br /></td></tr>
<tr class="separator:a340e541273d093acf89d0f3cc70840cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class ExtractKey = default_key&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;&gt;<br />
class seq::radix_set&lt; Key, ExtractKey, Allocator &gt;</h3>

<p>Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::set. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>key type </td></tr>
    <tr><td class="paramname">ExtractKey</td><td>Functor extracting a suitable key for the radix tree </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af09869745be8f4ff05fdd21634c65a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09869745be8f4ff05fdd21634c65a46">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#af09869745be8f4ff05fdd21634c65a46">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23c37637462e65d8983e5fc8be2f0efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c37637462e65d8983e5fc8be2f0efe">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#a23c37637462e65d8983e5fc8be2f0efe">const_pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1radix__set.html#a23c37637462e65d8983e5fc8be2f0efe">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdfeb4f57a3e600c9bd60dcb3d781178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfeb4f57a3e600c9bd60dcb3d781178">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#abdfeb4f57a3e600c9bd60dcb3d781178">const_reference</a> =  const Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8b809cc9832a4ff8d26e392fa998d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b809cc9832a4ff8d26e392fa998d4a">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f85c4f0f04599e167ae1ce95132c17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f85c4f0f04599e167ae1ce95132c17e">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#a3f85c4f0f04599e167ae1ce95132c17e">difference_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1radix__set.html#a3f85c4f0f04599e167ae1ce95132c17e">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a357542fc4beded531ea2684de6425398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357542fc4beded531ea2684de6425398">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a> =  <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f2d649a3d782580e0b51385e0ee6f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2d649a3d782580e0b51385e0ee6f3b">&#9670;&nbsp;</a></span>key_extract</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#a1f2d649a3d782580e0b51385e0ee6f3b">key_extract</a> =  ExtractKey</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a281374cd8906c351929324604119eb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281374cd8906c351929324604119eb6e">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#a281374cd8906c351929324604119eb6e">key_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa14654bbd5e485908c505623cd936ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14654bbd5e485908c505623cd936ca8">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#aa14654bbd5e485908c505623cd936ca8">pointer</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1radix__set.html#aa14654bbd5e485908c505623cd936ca8">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbe5be916b8d86205bf87b147684ef82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe5be916b8d86205bf87b147684ef82">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#acbe5be916b8d86205bf87b147684ef82">reference</a> =  Key&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1df97d61e9e30381d709b036895acb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1df97d61e9e30381d709b036895acb3">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#aa1df97d61e9e30381d709b036895acb3">reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3755d1dd705b7e0ec30f29431bc59f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3755d1dd705b7e0ec30f29431bc59f4">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a> =  typename std::allocator_traits&lt;Allocator&gt;::<a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b1490b99f1452ae21f78b89ac47ccfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1490b99f1452ae21f78b89ac47ccfc">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0da186362b40325a87eb800d9808c47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da186362b40325a87eb800d9808c47e">&#9670;&nbsp;</a></span>radix_set() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html">radix_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a7c863ee2efc6ebd247566b7fcf2be817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c863ee2efc6ebd247566b7fcf2be817">&#9670;&nbsp;</a></span>radix_set() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html">radix_set</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from allocator object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a478e9c120d98a3c2245f586ae439219d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478e9c120d98a3c2245f586ae439219d">&#9670;&nbsp;</a></span>radix_set() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html">radix_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Range constructor. Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa119d7f73f14cc0ae347e953e7e00df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa119d7f73f14cc0ae347e953e7e00df1">&#9670;&nbsp;</a></span>radix_set() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html">radix_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0042f93293d4ea7614f23cfe34c8fdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0042f93293d4ea7614f23cfe34c8fdcb">&#9670;&nbsp;</a></span>radix_set() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html">radix_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb2d4c6490fc415698155b9f4287a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb2d4c6490fc415698155b9f4287a31">&#9670;&nbsp;</a></span>radix_set() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html">radix_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ffa344f22a14f3a0415e6b2034c032f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffa344f22a14f3a0415e6b2034c032f">&#9670;&nbsp;</a></span>radix_set() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html">radix_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38901562f28648af8391b98de31c780d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38901562f28648af8391b98de31c780d">&#9670;&nbsp;</a></span>radix_set() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::<a class="el" href="classseq_1_1radix__set.html">radix_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer-list constructor. Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">comp</td><td>comparison function object to use for all comparisons of keys </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4237f935aa1912cc7d029d51246c50f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4237f935aa1912cc7d029d51246c50f4">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the content of the range [first, last) to this container, discarding previous values. </p>

</div>
</div>
<a id="a757f8b2568334de62ca9b32a755d5f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757f8b2568334de62ca9b32a755d5f46">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="a9c8bc9335818b8875278e28c62c582e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8bc9335818b8875278e28c62c582e6">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="a9d2ff6b9eab6b7296e7d30fd630efb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2ff6b9eab6b7296e7d30fd630efb46">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>

</div>
</div>
<a id="a01ebb8ff49703b66be87576d45662f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ebb8ff49703b66be87576d45662f4c">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="ae1bb70c33d472b7dad4700f565bfa1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bb70c33d472b7dad4700f565bfa1fb">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the container. </p>

</div>
</div>
<a id="abb0c1eb60e45ce20fb469f9aafa85beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0c1eb60e45ce20fb469f9aafa85beb">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; bool  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key that compares equivalent to the value key. </p>

</div>
</div>
<a id="a178f66e947b9ff5b01212989c6705297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178f66e947b9ff5b01212989c6705297">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key key (either 1 or 0 for <a class="el" href="classseq_1_1radix__set.html" title="Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::set.">radix_set</a> and <a class="el" href="classseq_1_1radix__map.html" title="Radix based sorted container using Variable Arity Radix Tree (VART). Same interface as std::map.">radix_map</a>). </p>

</div>
</div>
<a id="a3cfb024b6e5427af94d0759bcd37bb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfb024b6e5427af94d0759bcd37bb2d">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a340e541273d093acf89d0f3cc70840cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340e541273d093acf89d0f3cc70840cf">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="a7a81f82620ef45cbdf871974e34bbfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a81f82620ef45cbdf871974e34bbfc5">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>, bool&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::emplace(). </p>

</div>
</div>
<a id="a0e152806b39e09d5b30d89c1ea33a3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e152806b39e09d5b30d89c1ea33a3f0">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::emplace_hint. </p>

</div>
</div>
<a id="a82d7914a9c95158f0d91a2738551bd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d7914a9c95158f0d91a2738551bd74">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if container is empty, false otherwise. </p>

</div>
</div>
<a id="a3fbc0a2e0f40393ef92c829bb6d114a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbc0a2e0f40393ef92c829bb6d114a5">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="ae3a4dc26ffb7635fdbca22af809b31af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a4dc26ffb7635fdbca22af809b31af">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>

</div>
</div>
<a id="a547f59c223a73387d02931de73327c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547f59c223a73387d02931de73327c5b">&#9670;&nbsp;</a></span>equal_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; std::pair&lt;<a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>, <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>&gt;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classseq_1_1radix__set.html#ab1e315b3938fd500001e415656c2c4e1" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="classseq_1_1radix__set.html#a98fa9bbb4a20b1f1f32ee3fafb0a14a9" title="Returns an iterator pointing to the first element that compares greater to the value key.">upper_bound()</a>. </p>

</div>
</div>
<a id="ab71d8be17a800c4902ae898c5c7f3ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71d8be17a800c4902ae898c5c7f3ebf">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with key that compares equivalent to the value key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value of the elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>

</div>
</div>
<a id="a96298fa479b68f6864526097b01f25b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96298fa479b68f6864526097b01f25b6">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements in the range [first, last) </p>

</div>
</div>
<a id="a7724d032e8e6e1dcc9e594bf2cbdea72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7724d032e8e6e1dcc9e594bf2cbdea72">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element at given location. </p>

</div>
</div>
<a id="a6374ea8fdd020e048fa3956c700762c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6374ea8fdd020e048fa3956c700762c6">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found element, or end iterator </dd></dl>

</div>
</div>
<a id="a266b2942a94145e8fdac5523b5aa0a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266b2942a94145e8fdac5523b5aa0a99">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const Allocator &amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns container's allocator. </p>

</div>
</div>
<a id="a6d39ea1d47a63473f2cd5dad477228cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d39ea1d47a63473f2cd5dad477228cb">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; Allocator&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fe893a04f37c3a492d5d442882c3161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe893a04f37c3a492d5d442882c3161">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>, bool&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::insert. </p>

</div>
</div>
<a id="a01790959e150b602ec2e130fe392e515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01790959e150b602ec2e130fe392e515">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::insert() </p>

</div>
</div>
<a id="a42caa2c075432f13b74c6b3d738e02c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42caa2c075432f13b74c6b3d738e02c4">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::set::insert() </p>

</div>
</div>
<a id="a3fbf4da089845fde9a9393dd843cb198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbf4da089845fde9a9393dd843cb198">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. This function will insert the new elements at the end of the underlying <a class="el" href="classseq_1_1tiered__vector.html" title="seq::tiered_vector is a std::deque like container implemented as a tiered-vector.">tiered_vector</a>, sort them, inplace merge the old and new key, and remove potential duplicates. If the number of elements in the range [first, last) is roughly equal or greater than the container's size, this function is much faster than inserting elements one by one. </p>

</div>
</div>
<a id="a463600164441345c9aabdcd7b6ecbb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463600164441345c9aabdcd7b6ecbb8a">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted, except if template parameter Stable is true. </p>

</div>
</div>
<a id="acae70bccb32b586cff5738690ce6e572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae70bccb32b586cff5738690ce6e572">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classseq_1_1radix__set.html#a357542fc4beded531ea2684de6425398">iterator</a>, bool&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See std::set::insert. </p>

</div>
</div>
<a id="ab1e315b3938fd500001e415656c2c4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e315b3938fd500001e415656c2c4e1">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value key. </p>

</div>
</div>
<a id="a4bc8966556e933f631acfc543272b05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc8966556e933f631acfc543272b05c">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container maximum size. </p>

</div>
</div>
<a id="ab964b02af1ed1caa66c3aa5b3f1f1784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab964b02af1ed1caa66c3aa5b3f1f1784">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e3163f422b3d04cdf07a58cccbe635c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3163f422b3d04cdf07a58cccbe635c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this container </dd></dl>

</div>
</div>
<a id="a6e2f792f0821b86c42b62f695ad438bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2f792f0821b86c42b62f695ad438bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classseq_1_1radix__set.html#a5b1490b99f1452ae21f78b89ac47ccfc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&amp;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign initializer-list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this container </dd></dl>

</div>
</div>
<a id="ad5d19b3489a6fe850ea97b1170780e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d19b3489a6fe850ea97b1170780e50">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1radix__set.html">radix_set</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this container </dd></dl>

</div>
</div>
<a id="a579b5e6e7e7e93861869612c1ddfc0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579b5e6e7e7e93861869612c1ddfc0a2">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="ade52356498023d36bf43dd999a3865ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade52356498023d36bf43dd999a3865ea">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1radix__set.html#aa1df97d61e9e30381d709b036895acb3">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed list. </p>

</div>
</div>
<a id="a09c7d935a808dc3d50763c70a44b32d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c7d935a808dc3d50763c70a44b32d0">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1radix__set.html#ad8b809cc9832a4ff8d26e392fa998d4a">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="aed44b40a0698644cf7920c24abecf136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed44b40a0698644cf7920c24abecf136">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classseq_1_1radix__set.html#aa1df97d61e9e30381d709b036895acb3">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed list. </p>

</div>
</div>
<a id="ad7018cae97e47121116f0730e79dc7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7018cae97e47121116f0730e79dc7f0">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87ab9b9ef290f3be417a6067d8185d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ab9b9ef290f3be417a6067d8185d26">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6773cd2c1b6c2001289055e8b540661b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6773cd2c1b6c2001289055e8b540661b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classseq_1_1radix__set.html#ad3755d1dd705b7e0ec30f29431bc59f4">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size. </p>

</div>
</div>
<a id="a432cf07350077bab004445cb02225515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432cf07350077bab004445cb02225515">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> void <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseq_1_1radix__set.html">radix_set</a>&lt; Key, ExtractKey, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap this container's content with another. Iterators to both containers remain valid, including end iterators. </p>

</div>
</div>
<a id="a98fa9bbb4a20b1f1f32ee3fafb0a14a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fa9bbb4a20b1f1f32ee3fafb0a14a9">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class ExtractKey  = default_key&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bits.html#ga68ad5ff4a759a2a341569a42f9ba2e44">SEQ_ALWAYS_INLINE</a> auto <a class="el" href="classseq_1_1radix__set.html">seq::radix_set</a>&lt; Key, ExtractKey, Allocator &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structseq_1_1radix__set_1_1const__iterator.html">const_iterator</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares greater to the value key. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seq/<a class="el" href="radix__map_8hpp_source.html">radix_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceseq.html">seq</a></li><li class="navelem"><a class="el" href="classseq_1_1radix__set.html">radix_set</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
